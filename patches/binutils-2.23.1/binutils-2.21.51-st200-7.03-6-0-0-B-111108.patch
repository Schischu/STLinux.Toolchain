diff -r -N -u binutils-2.21.51/bfd/archures.c binutils/bfd/archures.c
--- binutils-2.21.51/bfd/archures.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/bfd/archures.c	2011-07-06 12:44:26.137253000 +0100
@@ -434,6 +434,12 @@
 .#define bfd_mach_z80            3 {* With ixl, ixh, iyl, and iyh.  *}
 .#define bfd_mach_z80full        7 {* All undocumented instructions.  *}
 .#define bfd_mach_r800           11 {* R800: successor with multiplication.  *}
+.  bfd_arch_lx,        {* STMicroelectronics ST200 *}
+.#define bfd_mach_st210                0
+.#define bfd_mach_st220                1
+.#define bfd_mach_st230                2
+.#define bfd_mach_st231                3
+.#define bfd_mach_st240                4
 .  bfd_arch_lm32,      {* Lattice Mico32 *}
 .#define bfd_mach_lm32      1
 .  bfd_arch_microblaze,{* Xilinx MicroBlaze. *}
@@ -546,6 +552,7 @@
 extern const bfd_arch_info_type bfd_xc16x_arch;
 extern const bfd_arch_info_type bfd_z80_arch;
 extern const bfd_arch_info_type bfd_z8k_arch;
+extern const bfd_arch_info_type bfd_lx_arch;
 
 static const bfd_arch_info_type * const bfd_archures_list[] =
   {
@@ -620,6 +627,7 @@
     &bfd_xc16x_arch,
     &bfd_z80_arch,
     &bfd_z8k_arch,
+    &bfd_lx_arch,
 #endif
   0
 };
diff -r -N -u binutils-2.21.51/bfd/bfd-in2.h binutils/bfd/bfd-in2.h
--- binutils-2.21.51/bfd/bfd-in2.h	2011-06-14 09:27:52.000000000 +0100
+++ binutils/bfd/bfd-in2.h	2011-07-06 12:44:26.137253000 +0100
@@ -1,4 +1,4 @@
-/* DO NOT EDIT!  -*- buffer-read-only: t -*-  This file is automatically 
+/* DO NOT EDIT!  This file is automatically 
    generated from "bfd-in.h", "init.c", "opncls.c", "libbfd.c", 
    "bfdio.c", "bfdwin.c", "section.c", "archures.c", "reloc.c", 
    "syms.c", "bfd.c", "archive.c", "corefile.c", "targets.c", "format.c", 
@@ -1548,6 +1548,11 @@
 #define BFD_COM_SECTION_NAME "*COM*"
 #define BFD_IND_SECTION_NAME "*IND*"
 
+#ifdef IPA_LINK
+#define BFD_WHD_SECTION_NAME "*WHD*"
+#define BFD_WHT_SECTION_NAME "*WHT*"
+#endif
+
 /* The absolute section.  */
 extern asection bfd_abs_section;
 #define bfd_abs_section_ptr ((asection *) &bfd_abs_section)
@@ -1570,6 +1575,17 @@
   || ((SEC) == bfd_com_section_ptr)            \
   || ((SEC) == bfd_ind_section_ptr))
 
+#ifdef IPA_LINK
+/* Pointer to the dummy whirl data section */
+extern asection bfd_whirl_data_section;
+#define bfd_whirl_data_section_ptr ((asection *) &bfd_whirl_data_section)
+#define bfd_is_whirl_data_section(sec) ((sec) == bfd_whirl_data_section_ptr)
+/* Pointer to the dummy whirl text section */
+extern asection bfd_whirl_text_section;
+#define bfd_whirl_text_section_ptr ((asection *) &bfd_whirl_text_section)
+#define bfd_is_whirl_text_section(sec) ((sec) == bfd_whirl_text_section_ptr)
+#endif
+
 /* Macros to handle insertion and deletion of a bfd's sections.  These
    only handle the list pointers, ie. do not adjust section_count,
    target_index etc.  */
@@ -2132,6 +2148,12 @@
 #define bfd_mach_r800           11 /* R800: successor with multiplication.  */
   bfd_arch_lm32,      /* Lattice Mico32 */
 #define bfd_mach_lm32      1
+  bfd_arch_lx,         /* STMicroelectronics ST200 */
+#define bfd_mach_st210         0
+#define bfd_mach_st220         1
+#define bfd_mach_st230         2
+#define bfd_mach_st231         3
+#define bfd_mach_st240         4
   bfd_arch_microblaze,/* Xilinx MicroBlaze. */
   bfd_arch_last
   };
@@ -3077,6 +3099,46 @@
 It generally does map to one of the other relocation types.  */
   BFD_RELOC_CTOR,
 
+/* LX relocations  */
+  BFD_RELOC_LX_16,
+  BFD_RELOC_LX_32 ,
+  BFD_RELOC_LX_32_PCREL,
+  BFD_RELOC_LX_23_PCREL,
+  BFD_RELOC_LX_HI23,
+  BFD_RELOC_LX_LO9,
+  BFD_RELOC_LX_GPREL_HI23,
+  BFD_RELOC_LX_GPREL_LO9,
+  BFD_RELOC_LX_REL32,
+  BFD_RELOC_LX_GOTOFF_HI23,
+  BFD_RELOC_LX_GOTOFF_LO9,
+  BFD_RELOC_LX_GOTOFFX_HI23,
+  BFD_RELOC_LX_GOTOFFX_LO9,
+  BFD_RELOC_LX_LTV32,
+  BFD_RELOC_LX_SEGREL32,
+  BFD_RELOC_LX_FPTR32,
+  BFD_RELOC_LX_PLTOFF_HI23,
+  BFD_RELOC_LX_PLTOFF_LO9,
+  BFD_RELOC_LX_GOTOFF_FPTR_HI23,
+  BFD_RELOC_LX_GOTOFF_FPTR_LO9,
+  BFD_RELOC_LX_IPLT,
+  BFD_RELOC_LX_NEG_GPREL_HI23,
+  BFD_RELOC_LX_NEG_GPREL_LO9,
+  BFD_RELOC_LX_COPY,
+  BFD_RELOC_LX_JMP_SLOT,
+  BFD_RELOC_LX_TPREL_HI23,
+  BFD_RELOC_LX_TPREL_LO9,
+  BFD_RELOC_LX_TPREL32,
+  BFD_RELOC_LX_GOTOFF_TPREL_HI23,
+  BFD_RELOC_LX_GOTOFF_TPREL_LO9,
+  BFD_RELOC_LX_GOTOFF_DTPLDM_HI23,
+  BFD_RELOC_LX_GOTOFF_DTPLDM_LO9,
+  BFD_RELOC_LX_DTPREL_HI23,
+  BFD_RELOC_LX_DTPREL_LO9,
+  BFD_RELOC_LX_DTPMOD32,
+  BFD_RELOC_LX_DTPREL32,
+  BFD_RELOC_LX_GOTOFF_DTPNDX_HI23,
+  BFD_RELOC_LX_GOTOFF_DTPNDX_LO9,
+
 /* ARM 26 bit pc-relative branch.  The lowest two bits must be zero and are
 not stored in the instruction.  */
   BFD_RELOC_ARM_PCREL_BRANCH,
diff -r -N -u binutils-2.21.51/bfd/config.bfd binutils/bfd/config.bfd
--- binutils-2.21.51/bfd/config.bfd	2011-06-14 09:27:52.000000000 +0100
+++ binutils/bfd/config.bfd	2011-07-06 12:44:26.137253000 +0100
@@ -85,6 +85,7 @@
 i[3-7]86)	 targ_archs=bfd_i386_arch ;;
 i370)		 targ_archs=bfd_i370_arch ;;
 lm32)	         targ_archs=bfd_lm32_arch ;;
+lx*)             targ_archs=bfd_lx_arch ;;
 m6811*|m68hc11*) targ_archs="bfd_m68hc11_arch bfd_m68hc12_arch" ;;
 m6812*|m68hc12*) targ_archs="bfd_m68hc12_arch bfd_m68hc11_arch" ;;
 m68*)		 targ_archs=bfd_m68k_arch ;;
@@ -98,6 +99,7 @@
 rs6000)		 targ_archs="bfd_rs6000_arch bfd_powerpc_arch" ;;
 s390*)		 targ_archs=bfd_s390_arch ;;
 sh*)		 targ_archs=bfd_sh_arch ;;
+st2[2-4][0-9]*)  targ_archs=bfd_lx_arch ;;
 sparc*)		 targ_archs=bfd_sparc_arch ;;
 spu*)            targ_archs=bfd_spu_arch ;;
 v850*)		 targ_archs=bfd_v850_arch ;;
@@ -1458,6 +1460,21 @@
     want64=true
     ;;
 
+  st2[2-4][0-9]-*-linux-gnu*)
+    targ_defvec=bfd_elf32_littlelx_linux_vec
+    targ_selvecs=bfd_elf32_lx_linux_vec
+    ;;
+
+  lx-*-elf*)
+    targ_defvec=bfd_elf32_lx_vec
+    targ_selvecs=bfd_elf32_littlelx_vec
+    ;;  
+
+  lx-*-linux-gnu*)
+    targ_defvec=bfd_elf32_littlelx_linux_vec
+    targ_selvecs=bfd_elf32_lx_linux_vec
+    ;;
+
 #if HAVE_host_aout_vec
   tahoe-*-*)
     targ_defvec=host_aout_vec
diff -r -N -u binutils-2.21.51/bfd/configure binutils/bfd/configure
--- binutils-2.21.51/bfd/configure	2011-06-14 09:27:52.000000000 +0100
+++ binutils/bfd/configure	2011-07-06 12:44:26.137253000 +0100
@@ -12894,7 +12894,7 @@
 
 done
 
-for ac_header in fcntl.h sys/file.h sys/time.h sys/stat.h
+for ac_header in fcntl.h sys/file.h sys/time.h sys/stat.h libintl.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
@@ -15147,6 +15147,8 @@
 elf="elf.lo elflink.lo elf-attrs.lo elf-strtab.lo
      elf-eh-frame.lo dwarf1.lo"
 
+ipa="ipa_bfd.lo"
+
 for vec in $selvecs
 do
     target_size=32
@@ -15229,6 +15231,10 @@
                                 tb="$tb elf32-arm.lo elf32.lo elf-vxworks.lo $elf" ;;
     bfd_elf32_littlearm_vec)	tb="$tb elf32-arm.lo elf32.lo elf-vxworks.lo $elf" ;;
     bfd_elf32_littlemips_vec) 	tb="$tb elf32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo" ;;
+    bfd_elf32_lx_vec)           tb="$tb elf32-lx.lo elf32.lo $elf $ipa" ;;
+    bfd_elf32_littlelx_vec)     tb="$tb elf32-lx.lo elf32.lo $elf $ipa" ;;
+    bfd_elf32_lx_linux_vec)    tb="$tb elf32-lx-linux.lo elf32.lo $elf $ipa" ;;
+    bfd_elf32_littlelx_linux_vec) tb="$tb elf32-lx-linux.lo elf32.lo $elf $ipa" ;;
     bfd_elf32_littlemips_vxworks_vec)
 			 	tb="$tb elf32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo" ;;
     bfd_elf32_m32c_vec)         tb="$tb elf32-m32c.lo elf32.lo $elf" ;;
diff -r -N -u binutils-2.21.51/bfd/configure.in binutils/bfd/configure.in
--- binutils-2.21.51/bfd/configure.in	2011-06-14 09:27:52.000000000 +0100
+++ binutils/bfd/configure.in	2011-07-06 12:44:26.137253000 +0100
@@ -186,7 +186,7 @@
 BFD_CC_FOR_BUILD
 
 AC_CHECK_HEADERS(alloca.h stddef.h string.h strings.h stdlib.h time.h unistd.h)
-AC_CHECK_HEADERS(fcntl.h sys/file.h sys/time.h sys/stat.h)
+AC_CHECK_HEADERS(fcntl.h sys/file.h sys/time.h sys/stat.h libintl.h)
 GCC_HEADER_STDINT(bfd_stdint.h)
 AC_HEADER_TIME
 AC_HEADER_DIRENT
@@ -646,6 +646,8 @@
 elf="elf.lo elflink.lo elf-attrs.lo elf-strtab.lo
      elf-eh-frame.lo dwarf1.lo"
 
+ipa="ipa_bfd.lo"
+
 for vec in $selvecs
 do
     target_size=32
@@ -728,6 +730,10 @@
                                 tb="$tb elf32-arm.lo elf32.lo elf-vxworks.lo $elf" ;;
     bfd_elf32_littlearm_vec)	tb="$tb elf32-arm.lo elf32.lo elf-vxworks.lo $elf" ;;
     bfd_elf32_littlemips_vec) 	tb="$tb elf32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo" ;;
+    bfd_elf32_lx_vec)           tb="$tb elf32-lx.lo elf32.lo $elf $ipa" ;;  
+    bfd_elf32_littlelx_vec)     tb="$tb elf32-lx.lo elf32.lo $elf $ipa" ;;
+    bfd_elf32_lx_linux_vec)    tb="$tb elf32-lx-linux.lo elf32.lo $elf $ipa" ;;
+    bfd_elf32_littlelx_linux_vec) tb="$tb elf32-lx-linux.lo elf32.lo $elf $ipa" ;;
     bfd_elf32_littlemips_vxworks_vec)
 			 	tb="$tb elf32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo" ;;
     bfd_elf32_m32c_vec)         tb="$tb elf32-m32c.lo elf32.lo $elf" ;;
diff -r -N -u binutils-2.21.51/bfd/cpu-lx.c binutils/bfd/cpu-lx.c
--- binutils-2.21.51/bfd/cpu-lx.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils/bfd/cpu-lx.c	2007-02-27 15:35:58.519433000 +0000
@@ -0,0 +1,59 @@
+/**
+*** (c) Copyright Hewlett-Packard Company 1999-2003
+**/
+
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
+
+/**
+*** static char sccs_id[] = "@(#)cpu-lx.c	1.1 05/07/98 18:43:24";
+**/
+
+/* BFD support for the HP Lisard architecture.
+   Copyright 1992 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+#include "symcat.h"
+
+
+#define N(number, print, default, next)  \
+{  32, 32, 8, bfd_arch_lx, number, "lx/st200", print, 3, default, bfd_default_compatible, bfd_default_scan, next }
+
+#define ST220_NEXT  &arch_info_struct[0]
+#define ST230_NEXT  &arch_info_struct[1]
+#define ST231_NEXT  &arch_info_struct[2]
+#define ST240_NEXT  &arch_info_struct[3]
+
+static const bfd_arch_info_type arch_info_struct[] =
+{
+  N (bfd_mach_st220,      "st220",   FALSE, ST230_NEXT),
+  N (bfd_mach_st230,      "st230",   FALSE, ST231_NEXT),
+  N (bfd_mach_st231,      "st231",   FALSE, ST240_NEXT),
+  N (bfd_mach_st240,      "st240",   FALSE, NULL)
+};
+
+const bfd_arch_info_type bfd_lx_arch =
+      N (0, "st200", TRUE, ST220_NEXT);
+
+
+
diff -r -N -u binutils-2.21.51/bfd/elf32-lx.c binutils/bfd/elf32-lx.c
--- binutils-2.21.51/bfd/elf32-lx.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils/bfd/elf32-lx.c	2011-11-08 16:34:51.378162000 +0000
@@ -0,0 +1,7764 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+*/
+
+/**
+*** (c) Copyright Hewlett-Packard Company 1999-2003
+**/
+
+
+/**
+*** static char sccs_id[] = "@(#)elf32-lx.c	1.7 02/11/00 21:26:39";
+**/
+
+/* Generic support for 32-bit ELF
+   Copyright 1993 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libiberty.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf32-lx.h"
+
+#define MAX_FWD_BRANCH_OFFSET (((1 << 22) - 1) << 2)
+#define MAX_BWD_BRANCH_OFFSET (-((1 << 22) << 2))
+#define NOP_BUNDLE ((bfd_vma)0x80000000)
+#define NOP_NOP_BUNDLE ((bfd_vma)0xb1000001)
+
+/* This does not include any relocations, but should be good enough
+   for GDB to read the file.  */
+
+typedef struct bfd_hash_entry *(*new_hash_entry_func)
+  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
+
+/* In dynamically (linker-) created sections, we generally need to keep track
+   of the place a symbol or expression got allocated to. This is done via hash
+   tables that store entries of the following type.  */
+
+struct elf_lx_dyn_sym_info
+{
+  /* The addend for which this entry is relevant.  */
+  bfd_vma addend;
+
+  /* Next addend in the list.  */
+  struct elf_lx_dyn_sym_info *next;
+
+  bfd_vma got_offset;
+  bfd_vma fptr_offset;
+  bfd_vma pltoff_offset;
+  bfd_vma plt_offset;
+  bfd_vma plt2_offset;
+  bfd_vma tprel_offset;
+  bfd_vma dtpndx_offset;
+  bfd_vma dtpldm_offset;
+
+  /* The symbol table entry, if any, that this was derived from.  */
+  struct elf_link_hash_entry *h;
+
+  /* Used to count non-got, non-plt relocations for delayed sizing
+     of relocation sections.  */
+  struct elf_lx_dyn_reloc_entry
+  {
+    struct elf_lx_dyn_reloc_entry *next;
+
+    /* The section that is the target of the relocation. */
+    asection *sec;
+
+    /* The section that should contain the dynamic relocation. */
+    asection *srel;
+
+    /* The type of the dynamic relocation. */ 
+    int type;
+
+    /* Repeat count. */
+    int count;
+  } *reloc_entries;
+
+  /* True when the section contents have been updated.  */
+  unsigned got_done : 1;
+  unsigned fptr_done : 1;
+  unsigned pltoff_done : 1;
+  unsigned tprel_done : 1;
+  unsigned dtpldm_done : 1;
+  unsigned dtpndx_done : 1;
+
+  /* True for the different kinds of linker data we want created.  */
+  unsigned want_fptr : 1;
+  unsigned want_ltoff_fptr : 1;
+  unsigned want_plt : 1;
+  unsigned want_plt2 : 1;
+  unsigned want_pltoff : 1;
+
+  unsigned want_tprel;
+  unsigned want_dtpndx;
+  unsigned want_dtpldm;
+
+  /* Count of the number of references to the got entry for this.
+     Zero if there are none. */
+  long int want_got;
+};
+
+struct elf_lx_local_hash_entry
+{
+  struct bfd_hash_entry root;
+  struct elf_lx_dyn_sym_info *info;
+
+  /* True if this hash entry's addends was translated for
+     SHF_MERGE optimization.  */
+  unsigned sec_merge_done : 1;
+};
+
+struct elf_lx_local_hash_table
+{
+  struct bfd_hash_table root;
+  /* No additional fields for now.  */
+};
+
+struct elf_lx_link_hash_entry
+{
+  struct elf_link_hash_entry root;
+  /* A pointer to the most recently used stub hash entry against this
+     symbol. */
+  struct elf_lx_stub_hash_entry *stub_cache;
+  struct elf_lx_dyn_sym_info *info;
+  /* Non-zero means allocate that many bytes of .dynbss. */
+  bfd_vma dynbss_size;
+  /* True when space has been allocated in dynbss section. */
+  bfd_boolean dynbss_allocated;
+  /* True when space has been allocated for relocation in .rel.dynbss section. */
+  bfd_boolean rel_dynbss_allocated;
+};
+
+struct elf_lx_link_hash_table
+{
+  /* The main hash table */
+  struct elf_link_hash_table root;
+
+  /* The stub hash table.  */
+  struct bfd_hash_table stub_hash_table;
+
+  /* Linker stub bfd.  */
+  bfd *stub_bfd;
+
+  /* Linker call-backs.  */
+  asection * (*add_stub_section) PARAMS ((const char *, asection *));
+  void (*layout_sections_again) PARAMS ((void));
+
+  /* Array to keep track of which stub sections have been created, and
+     information on stub grouping.  */
+  struct map_stub {
+    /* This is the section to which stubs in the group will be
+       attached.  */
+    asection *link_sec;
+    /* The stub section.  */
+    asection *stub_sec;
+  } *stub_group;
+
+  /* Number of stubs against global syms.  */
+  unsigned long stub_globals;
+
+  /* Count of stubs for non-global symbols created so far. */
+  unsigned long local_stub_count;
+
+  /* Assorted information used by elf_lx_size_stubs.  */
+  unsigned int bfd_count;
+  int top_index;
+  asection **input_list;
+
+  asection *got_sec;		/* the linkage table section (or NULL) */
+  asection *rel_got_sec;	/* dynamic relocation section for same */
+  asection *fptr_sec;		/* function descriptor table (or NULL) */
+  asection *plt_sec;		/* the primary plt section (or NULL) */
+  asection *pltoff_sec;		/* PIC ABI: private descriptors for plt (or NULL) */
+                                /* Embedded ABI: gotplt function pointers */
+  asection *rel_pltoff_sec;	/* dynamic relocation section for same */
+  asection *dynbss_sec;         /* dynbss section (or NULL) */
+  asection *rel_dynbss_sec;     /* dynamic relocation section for same */
+  bfd_size_type minplt_entries;	/* number of minplt entries */
+  unsigned reltext : 1;		/* are there relocs against readonly sections? */
+  unsigned self_dtpldm_done : 1;/* has self DTPLDM entry been finished? */
+  unsigned transform_to_absolute : 1; /* transform GP-relative insts to absolute? */
+  bfd_vma self_dtpldm_offset;   /* got offset to self DTPLDM entry */
+
+  bfd *got_bfd;                 /* The bfd that owns the .got section */
+
+  /* rel_hash information for the GOT static relocations. */
+  struct elf_link_hash_entry **got_rel_hash;
+
+  struct elf_lx_local_hash_table loc_hash_table;
+};
+
+/*
+ * Ordered table of sections that have a lma != vma.
+ * This table is created when section compression is performed 
+ * called by objcopy, using the secinit information.
+ * This table is used in a second pass of objcopy to compact the
+ * sections in the lma taking into account the space freed by
+ * the section compression. In this second pass, the sections lma 
+ * and sections size are updated in the ELF headers.
+ * initial_lma and compress_lma may be different if a previous section
+ * (in lma order) has been compressed.
+ * initial_size and compress_size may be the same for sections described
+ * in the secinit table for a COPY and not a COMPRESS action.
+ */
+struct elf_lx_cpt {
+    unsigned int secinit_index;	/* Index of corresponding entry in secinit table */
+    char *sec_name;		/* section name */
+    bfd_vma initial_lma;	/* section lma before compression */
+    bfd_vma compress_lma;	/* section lma after compression */
+    bfd_size_type initial_size;	/* section size before copmpression */
+    bfd_size_type compress_size;/* section size after copmpression */
+};
+struct elf_lx_cpt *elf_lx_cpt_tab_ = NULL;
+struct elf_lx_cpt **elf_lx_cpt_tab = NULL;
+/* Number of entries actually in the table */
+unsigned int elf_lx_cpt_tab_nb;
+#define DEBUG_COMPRESSION 1
+
+#define elf_lx_hash_table(p) \
+  ((struct elf_lx_link_hash_table *) ((p)->hash))
+
+#define lx_stub_hash_lookup(table, string, create, copy) \
+  ((struct elf_lx_stub_hash_entry *) \
+   bfd_hash_lookup ((table), (string), (create), (copy)))
+
+static bfd_boolean elf_lx_relocate_section (
+                 bfd *output_bfd, struct bfd_link_info *info, bfd *input_bfd, 
+                 asection *input_section, bfd_byte *contents, 
+                 Elf_Internal_Rela *relocs, Elf_Internal_Sym *local_syms, 
+                 asection **local_sections);
+static bfd_boolean lx_elf_set_mach_from_flags PARAMS ((bfd *));
+static bfd_boolean lx_mach_has_interlocks PARAMS ((bfd *));
+static bfd_boolean lx_mach_has_st240_encodings PARAMS ((bfd *));
+#if 0 /* SC: currently unused, so ifdef out to avoid warnings */
+static bfd_boolean lx_elf_set_flags_from_mach PARAMS ((bfd *));
+#endif
+static bfd_boolean lx_elf_merge_private_bfd_data PARAMS ((bfd *, bfd *));
+static bfd_boolean lx_elf_print_private_bfd_data PARAMS ((bfd *, PTR));
+static bfd_boolean lx_elf_set_private_flags PARAMS ((bfd *, flagword));
+static bfd_boolean lx_elf_copy_private_flags PARAMS ((bfd *, bfd *));
+static bfd_boolean lx_elf_is_local_label_name PARAMS((bfd *, const char *));
+
+static reloc_howto_type *bfd_elf32_bfd_reloc_name_lookup
+  PARAMS ((bfd *abfd ATTRIBUTE_UNUSED, const char *r_name));
+static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
+  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
+static bfd_boolean abi_uses_reloc_p PARAMS ((bfd_boolean, unsigned int));
+static void lx_info_to_howto_rel PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
+static void lx_info_to_howto  PARAMS((bfd *, 
+				      arelent *, Elf_Internal_Rela *));
+static bfd_boolean pic_abi_p PARAMS((bfd *));
+static bfd_boolean reloc_matching_pair PARAMS((bfd *, Elf_Internal_Rela *,
+                                           bfd_vma,
+					   Elf_Internal_Rela *, bfd_byte *));
+static bfd_boolean elf32_lx_relax_got_load PARAMS((bfd *, struct bfd_link_info *,
+					       bfd_byte *, Elf_Internal_Rela *,
+					       unsigned int,
+					       struct elf_link_hash_entry *,
+					       Elf_Internal_Rela *,
+					       Elf_Internal_Rela *,
+					       bfd_boolean *, bfd_boolean *));
+static bfd_boolean elf_lx_relax_section PARAMS((bfd *, asection *,
+					    struct bfd_link_info *, bfd_boolean *));
+static bfd_boolean elf_lx_dynamic_symbol_p PARAMS((struct elf_link_hash_entry *,
+					       struct bfd_link_info *));
+static bfd_boolean main_program_weak_def_p PARAMS((struct elf_link_hash_entry *,
+					       struct bfd_link_info *));
+static bfd_boolean elf_lx_local_hash_table_init
+  PARAMS((struct elf_lx_local_hash_table *, bfd *, new_hash_entry_func));
+static struct bfd_hash_entry *elf_lx_new_loc_hash_entry
+  PARAMS((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
+static struct bfd_hash_entry *elf_lx_new_elf_hash_entry
+  PARAMS((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
+static struct bfd_hash_entry *stub_hash_newfunc
+  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
+static void transfer_relocs PARAMS((struct elf_lx_dyn_sym_info *,
+				    struct elf_lx_dyn_sym_info *));
+static void elf_lx_hash_copy_indirect (struct bfd_link_info *info,
+				       struct elf_link_hash_entry *,
+				       struct elf_link_hash_entry *);
+static void elf_lx_hash_hide_symbol PARAMS((struct bfd_link_info *,
+					    struct elf_link_hash_entry *,
+					    bfd_boolean));
+static struct bfd_link_hash_table *elf_lx_hash_table_create PARAMS((bfd *));
+static void elf_lx_hash_table_free
+  PARAMS ((struct bfd_link_hash_table *));
+static struct elf_lx_local_hash_entry *elf_lx_local_hash_lookup
+  PARAMS((struct elf_lx_local_hash_table *, const char *, bfd_boolean, bfd_boolean));
+static bfd_boolean elf_lx_global_dyn_sym_thunk
+  PARAMS((struct bfd_hash_entry *, PTR));
+static bfd_boolean elf_lx_local_dyn_sym_thunk PARAMS((struct bfd_hash_entry *,
+						  PTR));
+static void elf_lx_dyn_sym_traverse
+  PARAMS((struct elf_lx_link_hash_table *,
+	  bfd_boolean (*func) (struct elf_lx_dyn_sym_info *, PTR),
+	  PTR));
+static bfd_boolean elf_lx_create_dynamic_sections
+  PARAMS((bfd *, struct bfd_link_info *));
+static struct elf_lx_local_hash_entry *get_local_sym_hash
+  PARAMS((struct elf_lx_link_hash_table *, bfd *, const Elf_Internal_Rela *,
+	  bfd_boolean));
+static struct elf_lx_dyn_sym_info *get_dyn_sym_info
+  PARAMS((struct elf_lx_link_hash_table *, struct elf_link_hash_entry *,
+	  bfd *, const Elf_Internal_Rela *, bfd_boolean));
+static asection *get_got PARAMS((bfd *, struct bfd_link_info *,
+				 struct elf_lx_link_hash_table *));
+static asection *get_fptr PARAMS((bfd *, struct bfd_link_info *,
+				  struct elf_lx_link_hash_table *));
+static asection *get_pltoff PARAMS((bfd *, struct bfd_link_info *,
+				    struct elf_lx_link_hash_table *));
+static asection *get_reloc_section
+  PARAMS((bfd *, struct elf_lx_link_hash_table *, asection *, bfd_boolean));
+static bfd_boolean count_dyn_reloc
+  PARAMS((bfd *, struct elf_lx_dyn_sym_info *, asection *, asection *, int));
+static bfd_boolean elf_lx_check_relocs
+  PARAMS((bfd *, struct bfd_link_info *, asection *,
+	  const Elf_Internal_Rela *));
+static bfd_boolean allocate_global_data_got
+  PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static bfd_boolean allocate_global_fptr_got
+  PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static bfd_boolean allocate_local_got PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static long global_sym_index PARAMS((struct elf_link_hash_entry *));
+static bfd_boolean allocate_fptr PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static bfd_boolean allocate_plt_entries
+  PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static bfd_boolean allocate_plt2_entries
+  PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static bfd_boolean allocate_pltoff_entries
+  PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static bfd_boolean allocate_dynrel_entries
+  PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static bfd_boolean elf_lx_adjust_dynamic_symbol
+  PARAMS((struct bfd_link_info *, struct elf_link_hash_entry *));
+static void group_sections
+  PARAMS ((struct elf_lx_link_hash_table *, bfd_size_type, bfd_boolean));
+static enum elf_lx_stub_type lx_type_of_stub
+  PARAMS ((bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *,
+	   bfd_vma));
+static char *lx_stub_name
+  PARAMS ((const asection *, const asection *,
+	   const struct elf_lx_link_hash_entry *,
+	   const Elf_Internal_Rela *));
+static struct elf_lx_stub_hash_entry *lx_get_stub_entry
+  PARAMS ((const asection *, const asection *,
+	   struct elf_link_hash_entry *,
+	   const Elf_Internal_Rela *,
+	   struct elf_lx_link_hash_table *));
+static struct elf_lx_stub_hash_entry *lx_add_stub
+  PARAMS ((const char *, asection *, struct elf_lx_link_hash_table *));
+static bfd_boolean lx_size_one_stub
+  PARAMS ((struct bfd_hash_entry *, PTR));
+static bfd_boolean lx_build_one_stub
+  PARAMS ((struct bfd_hash_entry *, PTR));
+static bfd_boolean elf_lx_size_dynamic_sections
+  PARAMS((bfd *, struct bfd_link_info *));
+static void elf_lx_install_dyn_reloc
+  PARAMS((bfd *, struct bfd_link_info *, asection *, asection *, bfd_vma,
+	  unsigned int, long, bfd_vma, bfd_boolean *));
+static bfd_vma set_got_entry
+  PARAMS((bfd *, struct bfd_link_info *, struct elf_lx_dyn_sym_info *,
+	  long, bfd_vma, bfd_vma, unsigned int));
+static bfd_vma set_fptr_entry
+  PARAMS((bfd *, struct bfd_link_info *, struct elf_lx_dyn_sym_info *,
+	  bfd_vma));
+static bfd_vma set_pltoff_entry
+  PARAMS((bfd *, struct bfd_link_info *, struct elf_lx_dyn_sym_info *,
+	  bfd_vma, bfd_boolean));
+static bfd_vma elf_lx_tprel_base
+  PARAMS ((struct bfd_link_info *info));
+static bfd_vma elf_lx_dtprel_base
+  PARAMS ((struct bfd_link_info *info));
+static bfd_boolean elf_lx_relocate_section
+  PARAMS((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
+	  Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
+static bfd_boolean elf_lx_output_arch_local_syms(
+  bfd *output_bfd,
+  struct bfd_link_info *info,
+  void *finfo, bfd_boolean (*func) (void *, const char *,
+				    Elf_Internal_Sym *,
+				    asection *,
+				    struct elf_link_hash_entry *));
+static bfd_boolean elf_lx_finish_dynamic_symbol
+  PARAMS((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
+	  Elf_Internal_Sym *));
+static bfd_boolean elf_lx_finish_dynamic_sections
+  PARAMS((bfd *, struct bfd_link_info *info));
+static bfd_boolean lx_elf_set_private_flags PARAMS((bfd *, flagword));
+static enum elf_reloc_type_class elf_lx_reloc_type_class
+  PARAMS((const Elf_Internal_Rela *rela));
+static void elf_lx_merge_symbol_attribute (struct elf_link_hash_entry *h,
+					   const Elf_Internal_Sym *isym,
+					   bfd_boolean definition,
+					   bfd_boolean dynamic);
+
+int elf_lx_get_compact_info (bfd *abfd, sec_ptr sec,
+			     bfd_vma *initial_lma, bfd_vma *compress_lma,
+			     bfd_size_type *initial_size, 
+			     bfd_size_type *compress_size);
+int elf_lx_sort_sections_by_lma (const void *arg1, const void *arg2);
+void elf_lx_dump_secinit_table(bfd *abfd, FILE *writer);
+static unsigned int elf_lx_action_discarded (asection *sec);
+
+static const char *lx_elf_print_symbol_all
+  PARAMS ((bfd *, PTR, asymbol *));
+
+bfd_reloc_status_type _bfd_final_link_relocate (reloc_howto_type *howto,
+						bfd *input_bfd,
+						asection *input_section,
+						bfd_byte *contents,
+						bfd_vma address,
+						bfd_vma value,
+						bfd_vma addend);
+
+static reloc_howto_type elf32_lx_howto_table[] =
+{
+  HOWTO (R_LX_NONE,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_LX_NONE",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Simple 16 bit relocation -- for data */
+
+  HOWTO (R_LX_16,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_LX_16",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Simple 32 bit relocation -- for data */
+
+  HOWTO (R_LX_32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_LX_32",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /*  32 bit pcrel relocation -- for data */
+
+  HOWTO (R_LX_32_PCREL,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_LX_32_PCREL",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 TRUE), 		/* pcrel_offset */
+
+  /* A PC Relative 24-bit relocation, shifted by 2  */
+  /* right container                                */
+
+  HOWTO (R_LX_23_PCREL, 	/* type */
+	 2,	                /* rightshift */
+	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
+	 23,	                /* bitsize */
+	 TRUE,	                /* pc_relative */
+	 0,	                /* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_23_PCREL",	/* name */
+	 FALSE,	                /* partial_inplace */
+	 0x0,		        /* src_mask */
+	 0x7fffff,   		/* dst_mask */
+	 TRUE), 		/* pcrel_offset */
+
+    /* A HI part of a 32 bit absolute relocation */
+
+  HOWTO (R_LX_HI23,		/* type */
+	 9,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_LX_HI23",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a 32 immediate */
+
+  HOWTO (R_LX_LO9,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_LX_LO9",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a GP-relative reference */
+
+  HOWTO (R_LX_GPREL_HI23,       /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GPREL_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a GP-relative reference */
+
+  HOWTO (R_LX_GPREL_LO9,        /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GPREL_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit relative to load address */
+
+  HOWTO (R_LX_REL32,            /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    	       	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_REL32",	        /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a reference to a global offset table entry */
+
+  HOWTO (R_LX_GOTOFF_HI23,      /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a reference to a global offset table entry */
+
+  HOWTO (R_LX_GOTOFF_LO9,       /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of an optimizable reference to a global offset table entry */
+
+  HOWTO (R_LX_GOTOFFX_HI23,     /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFFX_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of an optimizable reference to a global offset table entry */
+
+  HOWTO (R_LX_GOTOFFX_LO9,      /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFFX_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit relocation for data, resolves to link-time value */
+
+  HOWTO (R_LX_LTV32,            /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_LTV32",	        /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit segment-relative relocation for data */
+
+  HOWTO (R_LX_SEGREL32,         /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_SEGREL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit relocation to obtain official function pointer */
+
+  HOWTO (R_LX_FPTR32,           /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_FPTR32",	        /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a reference to a local function descriptor in the GOT */
+
+  HOWTO (R_LX_PLTOFF_HI23,      /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_PLTOFF_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a reference to a local function descriptor in the GOT */
+
+  HOWTO (R_LX_PLTOFF_LO9,       /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_PLTOFF_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a reference to a GOT entry that points to an official
+     function descriptor */
+
+  HOWTO (R_LX_GOTOFF_FPTR_HI23, /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_FPTR_HI23", /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a reference to a GOT entry that points to an official
+     function descriptor */
+
+  HOWTO (R_LX_GOTOFF_FPTR_LO9,  /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_FPTR_LO9", /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit relocation to obtain official function pointer */
+
+  HOWTO (R_LX_IPLT,             /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_IPLT",	        /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a GP-relative reference */
+
+  HOWTO (R_LX_NEG_GPREL_HI23,   /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_NEG_GPREL_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a GP-relative reference */
+
+  HOWTO (R_LX_NEG_GPREL_LO9,    /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_NEG_GPREL_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* copy initialized data to bss */
+
+  HOWTO (R_LX_COPY,             /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    	        /* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_COPY",	        /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit relocation to obtain function pointer */
+
+  HOWTO (R_LX_JMP_SLOT,         /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_JMP_SLOT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a TP-relative reference */
+
+  HOWTO (R_LX_TPREL_HI23,       /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_TPREL_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a TP-relative reference */
+
+  HOWTO (R_LX_TPREL_LO9,        /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_TPREL_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit TP-relative reference */
+
+  HOWTO (R_LX_TPREL32,          /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    	       	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_TPREL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a reference to a global offset table entry containing a TP-relative offset */
+
+  HOWTO (R_LX_GOTOFF_TPREL_HI23,/* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_TPREL_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a reference to a global offset table entry containing a TP-relative offset */
+
+  HOWTO (R_LX_GOTOFF_TPREL_LO9, /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_TPREL_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a reference to a global offset table entry containing a ti_index */
+
+  HOWTO (R_LX_GOTOFF_DTPLDM_HI23,      /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_DTPLDM_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a reference to a global offset table entry containing a ti_index */
+
+  HOWTO (R_LX_GOTOFF_DTPLDM_LO9,/* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_DTPLDM_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of offset from start of TLS block */
+
+  HOWTO (R_LX_DTPREL_HI23,      /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_DTPREL_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of offset from start of TLS block */
+
+  HOWTO (R_LX_DTPREL_LO9,       /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_DTPREL_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit TLS dynamic module ID */
+
+  HOWTO (R_LX_DTPMOD32,         /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    	       	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_DTPMOD32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit offset from start of TLS block */
+
+  HOWTO (R_LX_DTPREL32,         /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    	       	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_DTPREL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a reference to a global offset table entry containing a ti_index */
+
+  HOWTO (R_LX_GOTOFF_DTPNDX_HI23,      /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_DTPNDX_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a reference to a global offset table entry containing a ti_index */
+
+  HOWTO (R_LX_GOTOFF_DTPNDX_LO9,       /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_DTPNDX_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE)		        /* pcrel_offset */
+
+};
+
+struct lx_reloc_map
+{
+   bfd_reloc_code_real_type bfd_reloc_val;
+  unsigned char elf_reloc_val;
+  bfd_boolean used_in_embedded_abi;
+  bfd_boolean used_in_pic_abi;
+};
+
+static const struct lx_reloc_map lx_reloc_map[] =
+{
+  { BFD_RELOC_NONE,                  R_LX_NONE,               TRUE,  TRUE  },
+  { BFD_RELOC_16,                    R_LX_16,                 TRUE,  TRUE  },
+  { BFD_RELOC_32,                    R_LX_32,                 TRUE,  TRUE  },
+  { BFD_RELOC_32_PCREL,              R_LX_32_PCREL,           TRUE,  TRUE  },
+  { BFD_RELOC_LX_23_PCREL,           R_LX_23_PCREL,           TRUE,  TRUE  },
+  { BFD_RELOC_LX_HI23,               R_LX_HI23,               TRUE,  FALSE },
+  { BFD_RELOC_LX_LO9,                R_LX_LO9,                TRUE,  FALSE },
+  { BFD_RELOC_LX_GPREL_HI23,         R_LX_GPREL_HI23,         TRUE,  TRUE  },
+  { BFD_RELOC_LX_GPREL_LO9,          R_LX_GPREL_LO9,          TRUE,  TRUE  },
+  { BFD_RELOC_LX_REL32,              R_LX_REL32,              TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_HI23,        R_LX_GOTOFF_HI23,        TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_LO9,         R_LX_GOTOFF_LO9,         TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFFX_HI23,       R_LX_GOTOFFX_HI23,       TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFFX_LO9,        R_LX_GOTOFFX_LO9,        TRUE,  TRUE  },
+  { BFD_RELOC_LX_LTV32,              R_LX_LTV32,              TRUE,  TRUE  },
+  { BFD_RELOC_LX_SEGREL32,           R_LX_SEGREL32,           TRUE,  TRUE  },
+  { BFD_RELOC_LX_FPTR32,             R_LX_FPTR32,             FALSE, TRUE  },
+  { BFD_RELOC_LX_PLTOFF_HI23,        R_LX_PLTOFF_HI23,        FALSE, TRUE  },
+  { BFD_RELOC_LX_PLTOFF_LO9,         R_LX_PLTOFF_LO9,         FALSE, TRUE  },
+  { BFD_RELOC_LX_GOTOFF_FPTR_HI23,   R_LX_GOTOFF_FPTR_HI23,   FALSE, TRUE  },
+  { BFD_RELOC_LX_GOTOFF_FPTR_LO9,    R_LX_GOTOFF_FPTR_LO9,    FALSE, TRUE  },
+  { BFD_RELOC_LX_IPLT,               R_LX_IPLT,               FALSE, TRUE  },
+  { BFD_RELOC_LX_NEG_GPREL_HI23,     R_LX_NEG_GPREL_HI23,     TRUE,  TRUE  },
+  { BFD_RELOC_LX_NEG_GPREL_LO9,      R_LX_NEG_GPREL_LO9,      TRUE,  TRUE  },
+  { BFD_RELOC_LX_COPY,               R_LX_COPY,               TRUE,  FALSE },
+  { BFD_RELOC_LX_JMP_SLOT,           R_LX_JMP_SLOT,           TRUE,  FALSE },
+  { BFD_RELOC_LX_TPREL_HI23,         R_LX_TPREL_HI23,         TRUE,  TRUE  },
+  { BFD_RELOC_LX_TPREL_LO9,          R_LX_TPREL_LO9,          TRUE,  TRUE  },
+  { BFD_RELOC_LX_TPREL32,            R_LX_TPREL32,            TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_TPREL_HI23,  R_LX_GOTOFF_TPREL_HI23,  TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_TPREL_LO9,   R_LX_GOTOFF_TPREL_LO9,   TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_DTPLDM_HI23, R_LX_GOTOFF_DTPLDM_HI23, TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_DTPLDM_LO9,  R_LX_GOTOFF_DTPLDM_LO9,  TRUE,  TRUE  },
+  { BFD_RELOC_LX_DTPREL_HI23,        R_LX_DTPREL_HI23,        TRUE,  TRUE  },
+  { BFD_RELOC_LX_DTPREL_LO9,         R_LX_DTPREL_LO9,         TRUE,  TRUE  },
+  { BFD_RELOC_LX_DTPMOD32,           R_LX_DTPMOD32,           TRUE,  TRUE  },
+  { BFD_RELOC_LX_DTPREL32,           R_LX_DTPREL32,           TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_DTPNDX_HI23, R_LX_GOTOFF_DTPNDX_HI23, TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_DTPNDX_LO9,  R_LX_GOTOFF_DTPNDX_LO9,  TRUE,  TRUE  }
+};
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+				 const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0;
+       i < (sizeof (elf32_lx_howto_table)
+	    / sizeof (elf32_lx_howto_table[0]));
+       i++)
+    if (elf32_lx_howto_table[i].name != NULL
+	&& strcasecmp (elf32_lx_howto_table[i].name, r_name) == 0)
+      return &elf32_lx_howto_table[i];
+
+  return NULL;
+}
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_type_lookup(abfd, code)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     bfd_reloc_code_real_type code;
+{
+  unsigned int i;
+
+  for (i = 0; i < sizeof(lx_reloc_map) / sizeof (struct lx_reloc_map); i++)
+    {
+      if (lx_reloc_map[i].bfd_reloc_val == code)
+	return &elf32_lx_howto_table[lx_reloc_map[i].elf_reloc_val];
+    }
+  return NULL;
+}
+
+static bfd_boolean
+abi_uses_reloc_p (is_pic_abi, r_type)
+     bfd_boolean is_pic_abi;
+     unsigned int r_type;
+{
+  unsigned int i;
+  for (i = 0; i < sizeof(lx_reloc_map) / sizeof (struct lx_reloc_map); i++)
+    {
+      if (lx_reloc_map[i].elf_reloc_val == r_type)
+	return is_pic_abi ? lx_reloc_map[i].used_in_pic_abi
+	  : lx_reloc_map[i].used_in_embedded_abi;
+    }
+  return FALSE;
+}
+
+/* Set the howto pointer for an LX ELF reloc. */
+
+static void lx_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED, 
+				  arelent *cache_ptr, Elf_Internal_Rela *dst)
+{
+  unsigned r_type;
+  
+  r_type = ELF32_R_TYPE(dst->r_info);
+  BFD_ASSERT (r_type < (unsigned int) R_LX_max);
+  cache_ptr->howto = &elf32_lx_howto_table[r_type];
+}
+
+static void lx_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, 
+			      arelent *cache_ptr, Elf_Internal_Rela *dst)
+{
+  lx_info_to_howto_rel(abfd, cache_ptr, dst);
+
+  /* If we ever need to do any extra processing with dst->r_addend
+     (the field omitted in an Elf_Internal_Rel) we can do it here.  */
+}
+
+/* The name of the dynamic interpreter.  This is put in the .interp
+   section.  */
+
+#define ELF_DYNAMIC_INTERPRETER "/lib/ld-linux.so.2"
+
+#define L_RELOCATABLE 0
+
+#define INSN_IS_IMML_P(I)          (((I) & 0x7f800000) == 0x15000000)
+#define INSN_IS_IMMR_P(I)          (((I) & 0x7f800000) == 0x15800000)
+#define INSN_IS_ADDI_R16_P(I)      (((I) & 0x7fe00fc0) == 0x08000400)
+#define INSN_IS_CALL_P(I)          (((I) & 0x7f800000) == 0x30000000)
+#define INSN_IS_LDW_OR_LDWD_P(B,I) (lx_mach_has_st240_encodings (B) \
+                                    ? (((I) & 0x7fe00000) == 0x21000000) \
+                                    : (((I) & 0x7f600000) == 0x20000000))
+#define INSN_IS_BUNDLE_END_P(I)    (((I) & 0x80000000) == 0x80000000)
+#define LDW_TO_ADD(I)              (((I) & ~0x7fe00000) | 0x08000000)
+
+static struct elf_link_hash_entry *
+symbol_for_relax (bfd *abfd,
+		  unsigned long r_symndx)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry *h;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+
+  if (r_symndx < symtab_hdr->sh_info)
+    h = NULL;
+  else
+    {
+      h = elf_sym_hashes (abfd)[r_symndx - symtab_hdr->sh_info];
+      BFD_ASSERT (h != NULL);
+      while (h->root.type == bfd_link_hash_indirect
+	     || h->root.type == bfd_link_hash_warning)
+	h = (struct elf_link_hash_entry *)h->root.u.i.link;
+    }
+  return h;
+}
+
+static bfd_boolean
+reloc_matching_pair (abfd, rel1, rel1_addend, rel2, contents)
+     bfd *abfd;
+     Elf_Internal_Rela *rel1;
+     bfd_vma rel1_addend;
+     Elf_Internal_Rela *rel2;
+     bfd_byte *contents;
+{
+  unsigned int rel1_r_type = ELF32_R_TYPE (rel1->r_info);
+  unsigned int rel2_r_type = ELF32_R_TYPE (rel2->r_info);
+  bfd_vma rel2_addend = rel2->r_addend;
+
+  /* Ensure high reloc. is in rel1 and low reloc is in rel2. */
+  if (rel1_r_type == R_LX_GPREL_LO9
+      || rel1_r_type == R_LX_GOTOFF_LO9
+      || rel1_r_type == R_LX_GOTOFFX_LO9
+      || rel1_r_type == R_LX_GOTOFF_TPREL_LO9
+      || rel1_r_type == R_LX_GOTOFF_DTPLDM_LO9
+      || rel1_r_type == R_LX_GOTOFF_DTPNDX_LO9)
+    {
+      unsigned int temp_r_type;
+      Elf_Internal_Rela *temp_reloc;
+
+      temp_r_type = rel1_r_type; rel1_r_type = rel2_r_type; rel2_r_type = temp_r_type;
+      temp_reloc = rel1; rel1 = rel2; rel2 = temp_reloc;
+    }
+  if (ELF32_R_SYM (rel1->r_info) == ELF32_R_SYM (rel2->r_info)
+      && rel1_addend == rel2_addend
+      && ((rel1_r_type == R_LX_GPREL_HI23 && rel2_r_type == R_LX_GPREL_LO9)
+	  || (rel1_r_type == R_LX_GOTOFF_HI23 && rel2_r_type == R_LX_GOTOFF_LO9)
+	  || (rel1_r_type == R_LX_GOTOFFX_HI23 && rel2_r_type == R_LX_GOTOFFX_LO9)
+	  || (rel1_r_type == R_LX_GOTOFF_TPREL_HI23
+	      && rel2_r_type == R_LX_GOTOFF_TPREL_LO9)
+	  || (rel1_r_type == R_LX_GOTOFF_DTPLDM_HI23
+	      && rel2_r_type == R_LX_GOTOFF_DTPLDM_LO9)
+	  || (rel1_r_type == R_LX_GOTOFF_DTPNDX_HI23
+	      && rel2_r_type == R_LX_GOTOFF_DTPNDX_LO9)))
+    {
+      bfd_vma insn = bfd_get_32 (abfd, contents + rel1->r_offset);
+
+      if (INSN_IS_IMML_P(insn)
+	  && rel1->r_offset == rel2->r_offset + 4)
+	return TRUE;
+      else if (INSN_IS_IMMR_P(insn)
+	       && rel1->r_offset + 4 == rel2->r_offset)
+	return TRUE;
+    }
+  return FALSE;
+}
+
+static bfd_boolean elf32_lx_relax_got_load (abfd, link_info, contents, irel, r_type, h,
+					irelocs, irelend,
+					changed_contents, changed_relocs)
+     bfd *abfd;
+     struct bfd_link_info *link_info;
+     bfd_byte *contents;
+     Elf_Internal_Rela *irel;
+     unsigned int r_type;
+     struct elf_link_hash_entry *h;
+     Elf_Internal_Rela *irelocs ATTRIBUTE_UNUSED;
+     Elf_Internal_Rela *irelend;
+     bfd_boolean *changed_contents;
+     bfd_boolean *changed_relocs;
+{
+  struct elf_lx_dyn_sym_info *dyn_i;
+  struct elf_lx_link_hash_table *lx_info;
+
+  if (! elf_lx_dynamic_symbol_p (h, link_info)
+      && irel < (irelend - 1)
+      && reloc_matching_pair (abfd, irel, irel->r_addend, irel + 1, contents))
+    {
+      Elf_Internal_Rela *low_rel;
+      Elf_Internal_Rela *high_rel;
+      bfd_vma insn;
+
+      if (r_type == R_LX_GOTOFF_LO9)
+	{
+	  low_rel = irel;
+	  high_rel = irel + 1;
+	}
+      else
+	{
+	  low_rel = irel + 1;
+	  high_rel = irel;
+	  r_type = ELF32_R_TYPE (low_rel->r_info);
+	}
+
+      insn = bfd_get_32 (abfd, contents + low_rel->r_offset);
+
+      if (r_type == R_LX_GOTOFF_LO9 && 
+	  INSN_IS_LDW_OR_LDWD_P(abfd, insn))
+	{ /* R_LX_GOTOFF_LO9 with an ldw or ldw.d,
+	     R_LX_GOTOFF_HI23 with imml or immr.
+	     Make the transformation. */
+	  /* Instruction is ldw or ldw.d, convert to add. */
+	  insn = LDW_TO_ADD (insn);
+	  bfd_put_32 (abfd, insn, contents + low_rel->r_offset);
+	  *changed_contents = TRUE;
+#if 0
+	  (*_bfd_error_handler)
+	    (_("%s: information: converting @gotoff to @gprel for %s"),
+	     bfd_get_filename (abfd),
+	     (h != NULL) ? h->root.root.string : "local symbol");
+#endif
+	  /* Change relocation to GPREL. */
+	  low_rel->r_info = ELF32_R_INFO (ELF32_R_SYM (low_rel->r_info), R_LX_GPREL_LO9);
+	  high_rel->r_info = ELF32_R_INFO (ELF32_R_SYM (high_rel->r_info),
+							R_LX_GPREL_HI23);
+	  *changed_relocs = TRUE;
+	  lx_info = elf_lx_hash_table (link_info);
+	  dyn_i = get_dyn_sym_info (lx_info, h, abfd, irel, FALSE);
+	  BFD_ASSERT (dyn_i != NULL);
+	  BFD_ASSERT (dyn_i->want_got > 1);
+
+	  dyn_i->want_got -= 2;
+	}
+    }
+  return TRUE;
+}
+
+static bfd_boolean
+elf_lx_relax_section (abfd, sec, link_info, again)
+     bfd *abfd;
+     asection *sec;
+     struct bfd_link_info *link_info;
+     bfd_boolean *again;
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Rela *internal_relocs;
+  Elf_Internal_Rela *irel, *irelend;
+  bfd_byte *contents = NULL;
+  struct elf_link_hash_entry *h;
+  bfd_boolean changed_contents = FALSE;
+  bfd_boolean changed_relocs = FALSE;
+
+  /* We are not currently changing any sizes, so only one pass.  */
+  *again = FALSE;
+
+  if (link_info->relocatable
+      || (sec->flags & SEC_RELOC) == 0
+      || sec->reloc_count == 0)
+    return TRUE;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+
+  internal_relocs = (_bfd_elf_link_read_relocs
+		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
+		      link_info->keep_memory));
+  if (internal_relocs == NULL)
+    return FALSE;
+
+  irelend = internal_relocs + sec->reloc_count;
+  for (irel = internal_relocs; irel < irelend; irel++)
+    {
+      unsigned int  r_type = ELF32_R_TYPE (irel->r_info);
+      unsigned long r_symndx = ELF32_R_SYM (irel->r_info);
+
+      h = symbol_for_relax (abfd, r_symndx);
+
+      switch (r_type)
+	{
+	default:
+	  break;
+	case R_LX_GOTOFF_HI23:
+	case R_LX_GOTOFF_LO9:
+	  /* We do not fetch contents until we know we need them, because
+	     if we cache the contents of an eh_frame section, it will not
+	     be handled correctly in elf-eh-frame (that file can increase the
+             size of the eh_frame section, but the cached contents are not
+             reallocated to the increased size). */
+	  if (contents == NULL)
+	    {
+	      if (elf_section_data (sec)->this_hdr.contents != NULL)
+		contents = elf_section_data (sec)->this_hdr.contents;
+	      else
+		{
+		  if (!bfd_malloc_and_get_section (abfd, sec, &contents))
+		    goto error_return;
+		}
+	    }
+	  if (!elf32_lx_relax_got_load (abfd, link_info, contents, irel,
+					r_type, h, internal_relocs, irelend,
+					&changed_contents,
+					&changed_relocs))
+	    goto error_return;
+	  break;
+	}
+    }
+
+  if (contents != NULL
+      && elf_section_data (sec)->this_hdr.contents != contents)
+    {
+      if (!changed_contents && !link_info->keep_memory)
+	free (contents);
+      else
+	{
+	  /* Cache the section contents for elf_link_input_bfd. */
+	  elf_section_data (sec)->this_hdr.contents = contents;
+	}
+    }
+
+  if (elf_section_data (sec)->relocs != internal_relocs)
+    {
+      if (!changed_relocs)
+	free (internal_relocs);
+      else
+	elf_section_data (sec)->relocs = internal_relocs;
+    }
+
+  return TRUE;
+
+ error_return:
+  if (contents != NULL
+      && elf_section_data (sec)->this_hdr.contents != contents)
+    free (contents);
+  if (internal_relocs != NULL
+      && elf_section_data (sec)->relocs != internal_relocs)
+    free (internal_relocs);
+  return FALSE;
+}
+
+enum stub_insn_type
+  {
+    CODE_TYPE,
+    IMM9_TYPE,
+    IMM23_TYPE
+  };
+
+enum stub_reloc_type
+  {
+    STUB_RELOC_NONE = 0,
+    STUB_RELOC_ABS,
+    STUB_RELOC_PIC,
+    STUB_RELOC_PCREL,
+    STUB_RELOC_GPREL,
+  };
+
+typedef struct
+{
+  bfd_vma opcode;
+  enum stub_insn_type type;
+  enum stub_reloc_type reloc_type;
+  int r_type;
+  int reloc_addend;
+  int patch_based_reg;
+}  insn_sequence;
+
+/* Insn with no relocation.  */
+#define INSN(X)           {(X), CODE_TYPE,  STUB_RELOC_NONE, R_LX_NONE, 0, 0}
+/* Insn with LO9 and HI23 relocations on absolute values.  */
+#define IMM9_INSN(X)      {(X), IMM9_TYPE,  STUB_RELOC_ABS, R_LX_LO9, 0, 0}
+#define IMM23_INSN(X)          {(X), IMM23_TYPE, STUB_RELOC_ABS, R_LX_HI23, 0, 0}
+/* Insn with LO9 and HI23 relocations on PC-relative values. Y is an addend value.  */
+#define IMM9_PIC_INSN(X, Y)  {(X), IMM9_TYPE,  STUB_RELOC_PIC, R_LX_LO9, (Y), 0}
+#define IMM23_PIC_INSN(X, Y) {(X), IMM23_TYPE, STUB_RELOC_PIC, R_LX_HI23, (Y), 0}
+/* Insn with 23_PCREL relocation. Y is an addend value.  */
+#define IMM23_PCREL_INSN(X, Y) {(X), IMM23_TYPE, STUB_RELOC_PCREL, R_LX_23_PCREL, (Y), 0}
+/* Insn with LO9 and HI23 relocations on GP-relative values. Y is an addend value.
+   Z is the base register to patch in embedded ABI shared mode.  */
+#define IMM9_GPREL_INSN(X, Y, Z)  {(X), IMM9_TYPE,  STUB_RELOC_GPREL, R_LX_LO9, (Y), (Z)}
+#define IMM23_GPREL_INSN(X, Y, Z) {(X), IMM23_TYPE, STUB_RELOC_GPREL, R_LX_HI23, (Y), (Z)}
+
+/* The size in bytes of an entry in the procedure linkage table.  */
+
+#define PLT_HEADER_SIZE     32
+#define PLT_MIN_ENTRY_SIZE  16
+#define PLT_FULL_ENTRY_SIZE 32
+#define PLT_FULL_ENTRY_SIZE_PIC_ABI 40
+#define PLT_RESERVED_WORDS   3
+
+/* PLT templates for PIC ABI */
+
+static const insn_sequence pic_abi_plt_header_pre_st240[PLT_HEADER_SIZE / 4] =
+  {
+    /* ldw $r0.63=4[$r0.8]    */ INSN(0x20004FC8),
+    /* mov $r0.11=$r0.63   ;; */ INSN(0x8000BFC0),
+    /* ldw $r0.10=0[$r0.8] ;; */ INSN(0xA0000288),
+    /* ldw $r0.14=8[$r0.8] ;; */ INSN(0xA0008388),
+    /* nop                 ;; */ INSN(NOP_BUNDLE),
+    /* goto $r0.63            */ INSN(0x31800000),
+    /* mov $r0.63=$r0.11   ;; */ INSN(0x8003F2C0),
+    /* nop                 ;; */ INSN(NOP_BUNDLE),
+  };
+
+static const insn_sequence pic_abi_plt_header_st240[PLT_HEADER_SIZE / 4] =
+  {
+    /* ldw $r0.63=4[$r0.8]    */ INSN(0x21004FC8),
+    /* mov $r0.11=$r0.63   ;; */ INSN(0x8000BFC0),
+    /* ldw $r0.10=0[$r0.8] ;; */ INSN(0xA1000288),
+    /* ldw $r0.14=8[$r0.8] ;; */ INSN(0xA1008388),
+    /* goto $r0.63            */ INSN(0x31800000),
+    /* mov $r0.63=$r0.11   ;; */ INSN(0x8003F2C0),
+    /* nop                 ;; */ INSN(NOP_BUNDLE),
+    /* nop                 ;; */ INSN(NOP_BUNDLE),
+  };
+
+static const insn_sequence plt_min_entry[PLT_MIN_ENTRY_SIZE / 4] =
+  {
+    /* goto .PLT0             */ IMM23_PCREL_INSN(0x31000000, 0),
+    /* mov $r0.9=0 	      */ IMM9_INSN(0x08000240),
+    /* imml 0              ;; */ IMM23_INSN(0x95000000),
+    /* nop                 ;; */ INSN(NOP_BUNDLE)
+  };
+
+static const insn_sequence pic_abi_plt_full_entry_pre_st240[PLT_FULL_ENTRY_SIZE_PIC_ABI / 4] =
+  {
+    /* immr 0                 */ IMM23_GPREL_INSN(0x15800000, 0, 0),
+    /* ldw $r0.63=0[$r0.14]   */ IMM9_GPREL_INSN(0x20000FCE, 0, 0),
+    /* mov $r0.9=$r0.63    ;; */ INSN(0x80009FC0),
+    /* mov $r0.8=$r0.14    ;; */ INSN(0x80008380),
+    /* immr 0                 */ IMM23_GPREL_INSN(0x15800000, 4, 0),
+    /* ldw $r0.14=0[$r0.14];; */ IMM9_GPREL_INSN(0xa000038E, 4, 0),
+    /* nop                 ;; */ INSN(NOP_BUNDLE),
+    /* goto $r0.63            */ INSN(0x31800000),
+    /* mov $r0.63=$r0.9    ;; */ INSN(0x8003F240),
+    /* nop                 ;; */ INSN(NOP_BUNDLE)
+  };
+
+static const insn_sequence pic_abi_plt_full_entry_st240[PLT_FULL_ENTRY_SIZE_PIC_ABI / 4] =
+  {
+    /* immr 0                 */ IMM23_GPREL_INSN(0x15800000, 0, 0),
+    /* ldw $r0.63=0[$r0.14]   */ IMM9_GPREL_INSN(0x21000FCE, 0, 0),
+    /* mov $r0.9=$r0.63    ;; */ INSN(0x80009FC0),
+    /* mov $r0.8=$r0.14    ;; */ INSN(0x80008380),
+    /* immr 0                 */ IMM23_GPREL_INSN(0x15800000, 4, 0),
+    /* ldw $r0.14=0[$r0.14];; */ IMM9_GPREL_INSN(0xa100038E, 4, 0),
+    /* goto $r0.63            */ INSN(0x31800000),
+    /* mov $r0.63=$r0.9    ;; */ INSN(0x8003F240),
+    /* nop                 ;; */ INSN(NOP_BUNDLE),
+    /* nop                 ;; */ INSN(NOP_BUNDLE)
+  };
+
+/* PLT templates for embedded ABI */
+
+static const insn_sequence embedded_abi_plt_header_pre_st240[PLT_HEADER_SIZE / 4] =
+  {
+    /* ldw $r0.63=4[$r0.14]   */ INSN(0x20004FCE),
+    /* mov $r0.11=$r0.63   ;; */ INSN(0x8000BFC0),
+    /* ldw $r0.10=0[$r0.14];; */ INSN(0xA000028E),
+    /* goto 1              ;; */ INSN(NOP_NOP_BUNDLE),
+    /* goto $r0.63            */ INSN(0x31800000),
+    /* mov $r0.63=$r0.11   ;; */ INSN(0x8003F2C0),
+    /* nop                 ;; */ INSN(NOP_BUNDLE),
+    /* nop                 ;; */ INSN(NOP_BUNDLE)
+  };
+
+static const insn_sequence embedded_abi_plt_header_st240[PLT_HEADER_SIZE / 4] =
+  {
+    /* ldw $r0.63=4[$r0.14]   */ INSN(0x21004FCE),
+    /* mov $r0.11=$r0.63   ;; */ INSN(0x8000BFC0),
+    /* ldw $r0.10=0[$r0.14];; */ INSN(0xA100028E),
+    /* goto $r0.63            */ INSN(0x31800000),
+    /* mov $r0.63=$r0.11   ;; */ INSN(0x8003F2C0),
+    /* nop                 ;; */ INSN(NOP_BUNDLE),
+    /* nop                 ;; */ INSN(NOP_BUNDLE),
+    /* nop                 ;; */ INSN(NOP_BUNDLE)
+  };
+
+static const insn_sequence embedded_abi_absolute_plt_header_pre_st240[PLT_HEADER_SIZE / 4] =
+  {
+    /* immr 0                 */ IMM23_GPREL_INSN(0x15800000, 4, 0), // ??
+    /* ldw $r0.63=0[$r0.0]    */ IMM9_GPREL_INSN(0x20000FC0, 4 , 0), // ??
+    /* mov $r0.11=$r0.63   ;; */ INSN(0x8000BFC0),
+    /* ldw $r0.10=0[$r0.0]    */ IMM9_GPREL_INSN(0x20000280, 0, 0), // ??
+    /* imml 0              ;; */ IMM23_GPREL_INSN(0x95000000, 0, 0), // ??
+    /* goto 1              ;; */ INSN(NOP_NOP_BUNDLE),
+    /* goto $r0.63            */ INSN(0x31800000),
+    /* mov $r0.63=$r0.11   ;; */ INSN(0x8003F2C0),
+  };
+
+static const insn_sequence embedded_abi_absolute_plt_header_st240[PLT_HEADER_SIZE / 4] =
+  {
+    /* immr 0                 */ IMM23_GPREL_INSN(0x15800000, 4, 0), // ??
+    /* ldw $r0.63=0[$r0.0]    */ IMM9_GPREL_INSN(0x21000FC0, 4, 0), // ??
+    /* mov $r0.11=$r0.63   ;; */ INSN(0x8000BFC0),
+    /* ldw $r0.10=0[$r0.0]    */ IMM9_GPREL_INSN(0x21000280, 0, 0), // ??
+    /* imml 0              ;; */ IMM23_GPREL_INSN(0x95000000, 0, 0), // ??
+    /* goto $r0.63            */ INSN(0x31800000),
+    /* mov $r0.63=$r0.11   ;; */ INSN(0x8003F2C0),
+    /* nop                 ;; */ INSN(NOP_BUNDLE)
+  };
+
+/* We use the same plt_min_entry for PIC ABI and embedded ABI,
+   PIC and absolute. */
+
+/* We use the same plt_full_entry template for embedded ABI PIC and
+   absolute, but adjust the base register in one instruction. */
+
+static const insn_sequence embedded_abi_plt_full_entry_pre_st240[PLT_FULL_ENTRY_SIZE / 4] =
+  {
+    /* immr 0                 */ IMM23_GPREL_INSN(0x15800000, 0, 0), // GOT
+    /* Adjust the base register on the next instruction:
+       For PIC, use $r0.14, for absolute use $r0.0. */
+    /* ldw $r0.63=0[$r0.0]    */ IMM9_GPREL_INSN(0x20000FC0, 0, 14), // GOT
+    /* mov $r0.9=$r0.63    ;; */ INSN(0x80009FC0),
+    /* goto 1              ;; */ INSN(NOP_NOP_BUNDLE),
+    /* nop                 ;; */ INSN(NOP_BUNDLE),
+    /* goto $r0.63            */ INSN(0x31800000),
+    /* mov $r0.63=$r0.9    ;; */ INSN(0x8003F240),
+    /* nop                 ;; */ INSN(NOP_BUNDLE)
+  };
+
+static const insn_sequence embedded_abi_plt_full_entry_st240[PLT_FULL_ENTRY_SIZE / 4] =
+  {
+    /* immr 0                 */ IMM23_GPREL_INSN(0x15800000, 0, 0), // GOT
+    /* Adjust the base register on the next instruction:
+       For PIC, use $r0.14, for absolute use $r0.0. */
+    /* ldw $r0.63=0[$r0.0]    */ IMM9_GPREL_INSN(0x21000FC0, 0, 14), // GOT
+    /* mov $r0.9=$r0.63    ;; */ INSN(0x80009FC0),
+    /* goto $r0.63            */ INSN(0x31800000),
+    /* mov $r0.63=$r0.9    ;; */ INSN(0x8003F240),
+    /* nop                 ;; */ INSN(NOP_BUNDLE),
+    /* nop                 ;; */ INSN(NOP_BUNDLE),
+    /* nop                 ;; */ INSN(NOP_BUNDLE)
+  };
+
+static const insn_sequence abs_long_branch_stub[] =
+  {
+    /* immr 0                 */ IMM23_INSN(0x15800000),
+    /* movi $r63=0            */ IMM9_INSN(0x08000fc0),
+    /* mov $r9=$r63        ;; */ INSN(0x80009fc0),
+    /* goto 1              ;; */ INSN(NOP_NOP_BUNDLE),
+    /* goto $r63              */ INSN(0x31800000),
+    /* mov $r63=$r9        ;; */ INSN(0x8003f240)
+  };
+
+static const insn_sequence pic_long_branch_stub_pre_st240[] =
+  {
+    /* call $r63=8            */ INSN(0x30000002),
+    /* mov $r9=$r63        ;; */ INSN(0x80009fc0),
+    /* immr 0                 */ IMM23_PIC_INSN(0x15800000, 0),
+    /* add $r63=$r63,0     ;; */ IMM9_PIC_INSN(0x88000fff, 0),
+    /* goto 1              ;; */ INSN(NOP_NOP_BUNDLE),
+    /* goto $r63              */ INSN(0x31800000),
+    /* mov $r63=$r9        ;; */ INSN(0x8003f240)
+  };
+
+static const insn_sequence pic_long_branch_stub_st240[] =
+  {
+    /* immr 0                 */ IMM23_PIC_INSN(0x15800000, 0),
+    /* addpc $r9 = 0       ;; */ IMM9_PIC_INSN(0x89000240, 0),
+    /* mov $r63 = $r9         */ INSN(0x0003f240),
+    /* mov $r9 = $r63      ;; */ INSN(0x80009fc0),
+    /* goto $r63              */ INSN(0x31800000),
+    /* mov $r63 = $r9      ;; */ INSN(0x8003f240)
+  };
+
+/* Section name for stubs is the associated section name plus this
+   string.  */
+#define STUB_SUFFIX ".stub"
+
+enum elf_lx_stub_type {
+  lx_stub_none,
+  lx_stub_abs_long_branch,
+  lx_stub_pic_long_branch_pre_st240,
+  lx_stub_pic_long_branch_st240
+};
+
+struct elf_lx_stub_hash_entry {
+
+  /* Base hash table entry structure.  */
+  struct bfd_hash_entry root;
+
+  /* The stub section.  */
+  asection *stub_sec;
+
+  /* Offset within stub_sec of the beginning of this stub.  */
+  bfd_vma stub_offset;
+
+  /* Given the symbol's value and its section we can determine its final
+     value when building the stubs (so the stub knows where to jump).  */
+  bfd_vma target_value;
+  asection *target_section;
+
+  /* The stub type.  */
+  enum elf_lx_stub_type stub_type;
+  /* Its encoding size in bytes.  */
+  int stub_size;
+  /* Its template.  */
+  const insn_sequence *stub_template;
+  /* The size of the template (number of entries).  */
+  int stub_template_size;
+
+  /* The symbol table entry, if any, that this was derived from.  */
+  struct elf_lx_link_hash_entry *h;
+
+  /* A symbol labelling the stub.  Only created if needed. */
+  struct elf_lx_link_hash_entry *sh;
+
+  /* Where this stub is being called from, or, in the case of combined
+     stub sections, the first input section in the group.  */
+  asection *id_sec;
+};
+
+/* Are we using the PIC ABI or the embedded ABI? */
+
+static bfd_boolean
+pic_abi_p (abfd)
+     bfd *abfd;
+{
+  flagword flags;
+
+  flags = lx_elf_get_private_flags (abfd);
+  return (flags & ELF_LX_ABI_MASK) == ELF_LX_ABI_PIC;
+}
+
+/* Should we do dynamic things to this symbol?  */
+
+static bfd_boolean
+elf_lx_dynamic_symbol_p (h, info)
+     struct elf_link_hash_entry *h;
+     struct bfd_link_info *info;
+{
+  return _bfd_elf_dynamic_symbol_p (h, info, 1);
+}
+
+static bfd_boolean
+main_program_weak_def_p (h, info)
+     struct elf_link_hash_entry *h;
+     struct bfd_link_info *info;
+{
+  if (h != NULL
+      && info->executable)
+    {
+
+      while (h->root.type == bfd_link_hash_indirect
+	     || h->root.type == bfd_link_hash_warning)
+	h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+      if (h->root.type == bfd_link_hash_defweak
+	  && h->def_regular)
+	return TRUE;
+    }
+
+  return FALSE;
+}
+
+static bfd_boolean
+non_preemptible_def_p (struct elf_link_hash_entry *h,
+		       struct bfd_link_info *info)
+{
+  if (!h)
+    /* Local symbols are non-preemptible. */
+    return TRUE;
+  
+  while (h->root.type == bfd_link_hash_indirect
+	 || h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  /* Symbols with restricted visibility are non-preemptible. */
+  switch (ELF_ST_VISIBILITY (h->other))
+    {
+    case STV_INTERNAL:
+    case STV_HIDDEN:
+      return TRUE;
+    case STV_PROTECTED:
+     /* Unfortunately, STV_PROTECTED symbols defined in a shared
+	library can be prempted, but STV_PROTECTED symbols defined
+	in a main program cannot be preempted. */
+      return (h->def_regular
+	      ? TRUE
+	      : FALSE);
+    }
+
+  /* Symbol with a regular, non-weak definition in a main
+     program is non-preemptible. */
+  /* Care: common symbols can have neither ELF_LINK_HASH_DEF_REGULAR
+     or ELF_LINK_HASH_DEF_DYNAMIC.  Also, symbols can have both
+     ELF_LINK_HASH_DEF_REGULAR and ELF_LINK_HASH_DEF_DYNAMIC. */
+  if ((h->def_regular
+       || ! h->def_dynamic)
+      && ! main_program_weak_def_p (h, info))
+    return TRUE;
+
+  return FALSE;
+}
+
+
+static bfd_boolean
+elf_lx_local_hash_table_init (ht, abfd, new)
+     struct elf_lx_local_hash_table *ht;
+     bfd *abfd ATTRIBUTE_UNUSED;
+     new_hash_entry_func new;
+{
+  memset (ht, 0, sizeof (*ht));
+  return bfd_hash_table_init (&ht->root, new, sizeof(struct elf_lx_local_hash_entry));
+}
+
+static struct bfd_hash_entry*
+elf_lx_new_loc_hash_entry (entry, table, string)
+     struct bfd_hash_entry *entry;
+     struct bfd_hash_table *table;
+     const char *string;
+{
+  struct elf_lx_local_hash_entry *ret;
+  ret = (struct elf_lx_local_hash_entry *) entry;
+
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (!ret)
+    ret = bfd_hash_allocate (table, sizeof (*ret));
+
+  if (!ret)
+    return 0;
+
+  /* Initialize our local data.  All zeros, and definitely easier
+     than setting a handful of bit fields.  */
+  memset (ret, 0, sizeof (*ret));
+
+  /* Call the allocation method of the superclass.  */
+  ret = ((struct elf_lx_local_hash_entry *)
+	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
+
+  return (struct bfd_hash_entry *) ret;
+}
+
+static struct bfd_hash_entry*
+elf_lx_new_elf_hash_entry (entry, table, string)
+     struct bfd_hash_entry *entry;
+     struct bfd_hash_table *table;
+     const char *string;
+{
+  struct elf_lx_link_hash_entry *ret;
+  ret = (struct elf_lx_link_hash_entry *) entry;
+
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (!ret)
+    ret = bfd_hash_allocate (table, sizeof (*ret));
+
+  if (!ret)
+    return 0;
+
+  /* Initialize our local data.  All zeros, and definitely easier
+     than setting a handful of bit fields.  */
+  memset (ret, 0, sizeof (*ret));
+
+  /* Call the allocation method of the superclass.  */
+  ret = ((struct elf_lx_link_hash_entry *)
+	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
+				     table, string));
+  if (ret != NULL)
+    ret->stub_cache = NULL;
+
+  return (struct bfd_hash_entry *) ret;
+}
+
+/* Initialize an entry in the stub hash table.  */
+
+static struct bfd_hash_entry *
+stub_hash_newfunc (entry, table, string)
+     struct bfd_hash_entry *entry;
+     struct bfd_hash_table *table;
+     const char *string;
+{
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (entry == NULL)
+    {
+      entry = bfd_hash_allocate (table,
+				 sizeof (struct elf_lx_stub_hash_entry));
+      if (entry == NULL)
+	return entry;
+    }
+
+  /* Call the allocation method of the superclass.  */
+  entry = bfd_hash_newfunc (entry, table, string);
+  if (entry != NULL)
+    {
+      struct elf_lx_stub_hash_entry *eh;
+
+      /* Initialize the local fields.  */
+      eh = (struct elf_lx_stub_hash_entry *) entry;
+      eh->stub_sec = NULL;
+      eh->stub_offset = 0;
+      eh->target_value = 0;
+      eh->target_section = NULL;
+      eh->stub_type = lx_stub_none;
+      eh->h = NULL;
+      eh->sh = NULL;
+      eh->id_sec = NULL;
+    }
+
+  return entry;
+}
+
+static void
+transfer_relocs (dst, src)
+     struct elf_lx_dyn_sym_info *dst;
+     struct elf_lx_dyn_sym_info *src;
+{
+  struct elf_lx_dyn_reloc_entry **pp;
+  struct elf_lx_dyn_reloc_entry *p;
+
+  /* Note the strange way the relocs are transferred:
+     for items that are on both src and dst lists,
+     we update the count on the dst list and remove the item
+     from the src list.
+     for items that are only on the src list, leave them there.
+     After walking the whole src list, append the whole dst
+     list to the src list, then move the src list to the dst.
+  */
+  for (pp = &src->reloc_entries; (p = *pp) != NULL; )
+    {
+      struct elf_lx_dyn_reloc_entry *q;
+
+      for (q = dst->reloc_entries; q != NULL; q = q->next)
+	{
+	  if (p->sec == q->sec
+	      && p->srel == q->srel
+	      && p->type == q->type)
+	    {
+	      q->count += p->count;
+	      /* Remove this item from src list. */
+	      *pp = p->next;
+	      break;
+	    }
+	}
+      if (q == NULL)
+	pp = &p->next;
+    }
+  *pp = dst->reloc_entries;
+  dst->reloc_entries = src->reloc_entries;
+  src->reloc_entries = NULL;
+}
+
+static void
+elf_lx_hash_copy_indirect (struct bfd_link_info *info,
+			   struct elf_link_hash_entry *xdir,
+			   struct elf_link_hash_entry *xind)
+{
+  struct elf_lx_link_hash_entry *dir, *ind;
+
+  dir = (struct elf_lx_link_hash_entry *) xdir;
+  ind = (struct elf_lx_link_hash_entry *) xind;
+
+#if 0
+  printf ("copy_indirect (%s) %s (%p) => %s (%p)\n",
+	  (xind->root.type == bfd_link_hash_indirect
+	   ? "indirect"
+	   : "weak to strong"),
+	  xind->root.root.string, xind,
+	  xdir->root.root.string, xdir);
+#endif
+
+  if (ind->root.root.type == bfd_link_hash_indirect)
+    {
+      struct elf_lx_dyn_sym_info *dyn_i;
+
+      if (dir->info == NULL)
+	{
+	  dir->info = ind->info;
+	  ind->info = NULL;
+	  /* Fix up the dyn_sym_info pointers to the global symbol.  */
+	  for (dyn_i = dir->info; dyn_i; dyn_i = dyn_i->next)
+	    dyn_i->h = &dir->root;
+	}
+      BFD_ASSERT (ind->info == NULL);
+      dir->dynbss_size = ind->dynbss_size;
+      ind->dynbss_size = 0;
+      dir->dynbss_allocated = ind->dynbss_allocated;
+      ind->dynbss_allocated = FALSE;
+      dir->rel_dynbss_allocated = ind->rel_dynbss_allocated;
+      ind->rel_dynbss_allocated = FALSE;
+    }
+  else
+    {
+      /* We are copying a weak definition to a strong
+	 definition.  Transfer the relocs over, but otherwise
+	 leave the info lists intact.
+      */
+      if (ind->info != NULL)
+	{
+	  struct elf_lx_dyn_sym_info *p;
+	  struct elf_lx_dyn_sym_info *q;
+	  struct elf_lx_dyn_sym_info *prevq;
+
+	  /* Transfer the ind relocs to the dir list. */
+	  if (dir->info != NULL
+	      && xind->root.type == bfd_link_hash_indirect)
+	    abort ();
+
+	  for (p = ind->info; p != NULL; p = p->next)
+	    {
+	      for (prevq = NULL, q = dir->info;
+		   q != NULL;
+		   prevq = q, q = q->next)
+		if (q->addend == p->addend)
+		  break;
+	      if (q == NULL)
+		{
+		  /* This addend not found on the direct list.
+		     Create it, and append it to the direct list.
+		  */
+
+		  /* Memory leak: I would like to use bfd_zalloc here,
+		     but I do not have a bfd available. */
+		  q = (struct elf_lx_dyn_sym_info *)
+		    bfd_malloc ((bfd_size_type) sizeof *q);
+		  memset (q, 0, (bfd_size_type) sizeof *q);
+		  q->h = &dir->root;
+		  q->reloc_entries = NULL;
+		  q->next = NULL;
+		  if (prevq == NULL)
+		    dir->info = q;
+		  else
+		    prevq->next = q;
+		}
+	      transfer_relocs (q, p);
+	    }
+	}
+    }
+
+#if 0
+  {
+    struct elf_lx_dyn_sym_info *p;
+    printf ("  info list: ");
+    for (p = dir->info; p; p = p->next)
+      printf ("{ %p, %ld } ", p->h, (long)p->addend);
+    printf ("\n");
+  }
+#endif
+  _bfd_elf_link_hash_copy_indirect (info, xdir, xind);
+
+}
+
+static void
+elf_lx_hash_hide_symbol (info, xh, force_local)
+     struct bfd_link_info *info;
+     struct elf_link_hash_entry *xh;
+     bfd_boolean force_local;
+{
+  struct elf_lx_link_hash_entry *h;
+  struct elf_lx_dyn_sym_info *dyn_i;
+
+  h = (struct elf_lx_link_hash_entry *)xh;
+
+  _bfd_elf_link_hash_hide_symbol (info, &h->root, force_local);
+
+  for (dyn_i = h->info; dyn_i; dyn_i = dyn_i->next)
+    dyn_i->want_plt2 = 0;
+}
+
+/* Create the derived linker hash table.  The lx ELF port uses this
+   derived hash table to keep information specific to the lx ElF
+   linker (without using static variables).  */
+
+static struct bfd_link_hash_table*
+elf_lx_hash_table_create (abfd)
+     bfd *abfd;
+{
+  struct elf_lx_link_hash_table *ret;
+
+  ret = bfd_zalloc (abfd, (bfd_size_type) sizeof (*ret));
+  if (!ret)
+    return 0;
+  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
+				      elf_lx_new_elf_hash_entry,
+				      sizeof (struct elf_lx_link_hash_entry),
+				      GENERIC_ELF_DATA))
+    {
+      bfd_release (abfd, ret);
+      return 0;
+    }
+
+  if (!elf_lx_local_hash_table_init (&ret->loc_hash_table, abfd,
+				     elf_lx_new_loc_hash_entry))
+    return 0;
+
+  if (!bfd_hash_table_init (&ret->stub_hash_table, stub_hash_newfunc,
+			    sizeof (struct elf_lx_stub_hash_entry)))
+    return 0;
+
+  return &ret->root.root;
+}
+
+/* Free the derived linker hash table.  */
+
+static void
+elf_lx_hash_table_free (hash)
+     struct bfd_link_hash_table *hash;
+{
+  struct elf_lx_link_hash_table *ret
+    = (struct elf_lx_link_hash_table *) hash;
+
+  bfd_hash_table_free (&ret->stub_hash_table);
+  _bfd_generic_link_hash_table_free (hash);
+}
+
+/* Look up an entry in an lx ELF linker hash table.  */
+
+static INLINE struct elf_lx_local_hash_entry *
+elf_lx_local_hash_lookup(table, string, create, copy)
+     struct elf_lx_local_hash_table *table;
+     const char *string;
+     bfd_boolean create, copy;
+{
+  return ((struct elf_lx_local_hash_entry *)
+	  bfd_hash_lookup (&table->root, string, create, copy));
+}
+
+/* Traverse both local and global hash tables.  */
+
+struct elf_lx_dyn_sym_traverse_data
+{
+  bfd_boolean (*func) PARAMS ((struct elf_lx_dyn_sym_info *, PTR));
+  PTR data;
+};
+
+static bfd_boolean
+elf_lx_global_dyn_sym_thunk (xentry, xdata)
+     struct bfd_hash_entry *xentry;
+     PTR xdata;
+{
+  struct elf_lx_link_hash_entry *entry
+    = (struct elf_lx_link_hash_entry *) xentry;
+  struct elf_lx_dyn_sym_traverse_data *data
+    = (struct elf_lx_dyn_sym_traverse_data *) xdata;
+  struct elf_lx_dyn_sym_info *dyn_i;
+
+  if (entry->root.root.type == bfd_link_hash_warning)
+    entry = (struct elf_lx_link_hash_entry *) entry->root.root.u.i.link;
+
+  for (dyn_i = entry->info; dyn_i; dyn_i = dyn_i->next)
+    if (! (*data->func) (dyn_i, data->data))
+      return FALSE;
+  return TRUE;
+}
+
+static bfd_boolean
+elf_lx_local_dyn_sym_thunk (xentry, xdata)
+     struct bfd_hash_entry *xentry;
+     PTR xdata;
+{
+  struct elf_lx_local_hash_entry *entry
+    = (struct elf_lx_local_hash_entry *) xentry;
+  struct elf_lx_dyn_sym_traverse_data *data
+    = (struct elf_lx_dyn_sym_traverse_data *) xdata;
+  struct elf_lx_dyn_sym_info *dyn_i;
+
+  for (dyn_i = entry->info; dyn_i; dyn_i = dyn_i->next)
+    if (! (*data->func) (dyn_i, data->data))
+      return FALSE;
+  return TRUE;
+}
+
+static void
+elf_lx_dyn_sym_traverse (lx_info, func, data)
+     struct elf_lx_link_hash_table *lx_info;
+     bfd_boolean (*func) PARAMS ((struct elf_lx_dyn_sym_info *, PTR));
+     PTR data;
+{
+  struct elf_lx_dyn_sym_traverse_data xdata;
+
+  xdata.func = func;
+  xdata.data = data;
+
+  elf_link_hash_traverse (&lx_info->root,
+			  elf_lx_global_dyn_sym_thunk, &xdata);
+  bfd_hash_traverse (&lx_info->loc_hash_table.root,
+		     elf_lx_local_dyn_sym_thunk, &xdata);
+}
+
+
+static bfd_boolean
+elf_lx_create_dynamic_sections (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  struct elf_lx_link_hash_table *lx_info;
+  asection *s;
+
+  if (! _bfd_elf_create_dynamic_sections (abfd, info))
+    return FALSE;
+
+  lx_info = elf_lx_hash_table (info);
+
+  lx_info->plt_sec = bfd_get_section_by_name (abfd, ".plt");
+  if (lx_info->got_sec == NULL)
+    {
+      lx_info->got_sec = bfd_get_section_by_name (abfd, ".got");
+      lx_info->got_bfd = abfd;
+    }
+
+  if (!get_pltoff (abfd, info, lx_info))
+    return FALSE;
+
+  if (pic_abi_p (abfd))
+    {
+      s = bfd_make_section_with_flags (abfd, ".rela.lx.pltoff",
+				       (SEC_ALLOC | SEC_LOAD
+					| SEC_HAS_CONTENTS
+					| SEC_IN_MEMORY
+					| SEC_LINKER_CREATED
+					| SEC_READONLY));
+      if (s == NULL
+	  || !bfd_set_section_alignment (abfd, s, 2))
+	return FALSE;
+      lx_info->rel_pltoff_sec = s;
+    }
+  else
+    lx_info->rel_pltoff_sec = bfd_get_section_by_name (abfd, ".rela.plt");
+
+  s = bfd_make_section_anyway_with_flags (abfd, ".rela.got",
+				   (SEC_ALLOC | SEC_LOAD
+				    | SEC_HAS_CONTENTS
+				    | SEC_IN_MEMORY
+				    | SEC_LINKER_CREATED
+				    | SEC_READONLY));
+  if (s == NULL
+      || !bfd_set_section_alignment (abfd, s, 2))
+    return FALSE;
+  lx_info->rel_got_sec = s;
+  lx_info->dynbss_sec = bfd_get_section_by_name (abfd, ".dynbss");
+  lx_info->rel_dynbss_sec = bfd_get_section_by_name (abfd, ".rela.bss");
+  return TRUE;
+}
+
+/* Find and/or create a hash entry for local symbol.  */
+static struct elf_lx_local_hash_entry *
+get_local_sym_hash (lx_info, abfd, rel, create)
+     struct elf_lx_link_hash_table *lx_info;
+     bfd *abfd;
+     const Elf_Internal_Rela *rel;
+     bfd_boolean create;
+{
+  char *addr_name;
+  size_t len;
+  struct elf_lx_local_hash_entry *ret;
+  asection *sec = abfd->sections;
+  unsigned int h = (((sec->id & 0xff) << 24) | ((sec->id & 0xff00) << 8))
+                   ^ ELF32_R_SYM (rel->r_info) ^ (sec->id >> 16);
+
+  /* Construct a string for use in the elf_lx_local_hash_table.
+     name describes what was once anonymous memory.  */
+
+  len = sizeof (unsigned int)*2 + 1 + sizeof (bfd_vma)*4 + 1 + 1;
+  len += 10;	/* %u slop */
+
+  addr_name = bfd_malloc (len);
+  if (addr_name == NULL)
+    return 0;
+  sprintf (addr_name, "%u:%lx",
+	   h, (unsigned long) ELF32_R_SYM (rel->r_info));
+
+  /* Collect the canonical entry data for this address.  */
+  ret = elf_lx_local_hash_lookup (&lx_info->loc_hash_table,
+				  addr_name, create, create);
+  free (addr_name);
+  return ret;
+}
+
+/* Find and/or create a descriptor for dynamic symbol info.  This will
+   vary based on global or local symbol, and the addend to the reloc.  */
+
+static struct elf_lx_dyn_sym_info *
+get_dyn_sym_info (lx_info, h, abfd, rel, create)
+     struct elf_lx_link_hash_table *lx_info;
+     struct elf_link_hash_entry *h;
+     bfd *abfd;
+     const Elf_Internal_Rela *rel;
+     bfd_boolean create;
+{
+  struct elf_lx_dyn_sym_info **pp;
+  struct elf_lx_dyn_sym_info *dyn_i;
+  bfd_vma addend = rel ? rel->r_addend : 0;
+
+  if (h)
+    pp = &((struct elf_lx_link_hash_entry *)h)->info;
+  else
+    {
+      struct elf_lx_local_hash_entry *loc_h;
+
+      loc_h = get_local_sym_hash (lx_info, abfd, rel, create);
+      if (!loc_h)
+	{
+	  BFD_ASSERT (!create);
+	  return NULL;
+	}
+
+      pp = &loc_h->info;
+    }
+
+#if 0
+  printf ("get_dyn_sym_info: h = %p addend = %ld\n",
+	  h,
+	  (long)addend);
+#endif
+
+  for (dyn_i = *pp; dyn_i && dyn_i->addend != addend; dyn_i = *pp)
+    pp = &dyn_i->next;
+
+  if (dyn_i == NULL && create)
+    {
+      dyn_i = ((struct elf_lx_dyn_sym_info *)
+	       bfd_zalloc (abfd, (bfd_size_type) sizeof *dyn_i));
+      *pp = dyn_i;
+      dyn_i->addend = addend;
+    }
+
+  return dyn_i;
+}
+
+static asection *
+get_got (abfd, info, lx_info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     struct elf_lx_link_hash_table *lx_info;
+{
+  asection *got;
+  bfd *dynobj;
+
+  got = lx_info->got_sec;
+  if (!got)
+    {
+      dynobj = lx_info->root.dynobj;
+      if (!dynobj)
+	lx_info->root.dynobj = dynobj = abfd;
+      if (!_bfd_elf_create_got_section (dynobj, info))
+	return 0;
+
+      got = bfd_get_section_by_name (dynobj, ".got");
+      BFD_ASSERT (got);
+      lx_info->got_sec = got;
+      lx_info->got_bfd = abfd;
+    }
+
+  return got;
+}
+
+/* Create function descriptor section (.opd).  This section is called .opd
+   because it contains "official procedure descriptors".  The "official"
+   refers to the fact that these descriptors are used when taking the address
+   of a procedure, thus ensuring a unique address for each procedure.  */
+
+static asection *
+get_fptr (abfd, info, lx_info)
+     bfd *abfd;
+     struct bfd_link_info *info ATTRIBUTE_UNUSED;
+     struct elf_lx_link_hash_table *lx_info;
+{
+  asection *fptr;
+  bfd *dynobj;
+
+  fptr = lx_info->fptr_sec;
+  if (!fptr)
+    {
+      dynobj = lx_info->root.dynobj;
+      if (!dynobj)
+	lx_info->root.dynobj = dynobj = abfd;
+
+      fptr = bfd_make_section_with_flags (dynobj, ".opd",
+					  (SEC_ALLOC
+					   | SEC_LOAD
+					   | SEC_HAS_CONTENTS
+					   | SEC_IN_MEMORY
+					   | SEC_READONLY
+					   | SEC_LINKER_CREATED));
+      if (fptr == NULL
+	  || !bfd_set_section_alignment (abfd, fptr, 3))
+	{
+	  BFD_ASSERT (0);
+	  return NULL;
+	}
+
+      lx_info->fptr_sec = fptr;
+    }
+
+  return fptr;
+}
+
+static asection *
+get_pltoff (abfd, info, lx_info)
+     bfd *abfd;
+     struct bfd_link_info *info ATTRIBUTE_UNUSED;
+     struct elf_lx_link_hash_table *lx_info;
+{
+  asection *pltoff;
+  bfd *dynobj;
+
+  pltoff = lx_info->pltoff_sec;
+  if (!pltoff)	
+    {
+      if (pic_abi_p (abfd))
+	{
+	  dynobj = lx_info->root.dynobj;
+	  if (!dynobj)
+	    lx_info->root.dynobj = dynobj = abfd;
+	  
+	  pltoff = bfd_make_section_with_flags (dynobj, ELF_STRING_lx_pltoff,
+						(SEC_ALLOC
+						 | SEC_LOAD
+						 | SEC_HAS_CONTENTS
+						 | SEC_IN_MEMORY
+						 | SEC_LINKER_CREATED));
+	  if (pltoff == NULL
+	      || !bfd_set_section_alignment (abfd, pltoff, 3))
+	    {
+	      BFD_ASSERT (0);
+	      return NULL;
+	    }
+
+	}
+      else
+	pltoff = bfd_get_section_by_name (abfd, ".got.plt");
+      lx_info->pltoff_sec = pltoff;
+    }
+
+  return pltoff;
+}
+
+static asection *
+get_reloc_section (abfd, lx_info, sec, create)
+     bfd *abfd;
+     struct elf_lx_link_hash_table *lx_info;
+     asection *sec;
+     bfd_boolean create;
+{
+  const char *srel_name;
+  asection *srel;
+  bfd *dynobj;
+
+  srel_name = (bfd_elf_string_from_elf_section
+	       (abfd, elf_elfheader(abfd)->e_shstrndx,
+		_bfd_elf_single_rel_hdr (sec)->sh_name));
+  if (srel_name == NULL)
+    return NULL;
+
+  if (!sec->compress_status)
+      BFD_ASSERT ((strncmp (srel_name, ".rela", 5) == 0
+		   && strcmp (bfd_get_section_name (abfd, sec),
+			      srel_name+5) == 0)
+		  || (strncmp (srel_name, ".rel", 4) == 0
+		      && strcmp (bfd_get_section_name (abfd, sec),
+				 srel_name+4) == 0));
+  else /* When debug section is compressed, it's rename with a 'z'
+	  (refer to  elf.c:_bfd_elf_make_section_from_shdr()
+       */
+      BFD_ASSERT ((strncmp (srel_name, ".rela", 5) == 0
+		   && srel_name[5] == '.'
+		   && srel_name[6] == 'z'
+		   && strcmp ((bfd_get_section_name (abfd, sec) + 1) ,
+			      srel_name+7) == 0 )
+		  || (strncmp (srel_name, ".rel", 4) == 0
+		      && srel_name[4] == '.'
+		      && srel_name[5] == 'z'
+		      && strcmp ((bfd_get_section_name (abfd, sec) + 1),
+				 srel_name+6) == 0));
+  dynobj = lx_info->root.dynobj;
+  if (!dynobj)
+    lx_info->root.dynobj = dynobj = abfd;
+
+  srel = bfd_get_section_by_name (dynobj, srel_name);
+  if (srel == NULL && create)
+    {
+      srel = bfd_make_section_with_flags (dynobj, srel_name,
+					  (SEC_ALLOC
+					   | SEC_LOAD
+					   | SEC_HAS_CONTENTS
+					   | SEC_IN_MEMORY
+					   | SEC_LINKER_CREATED
+					   | SEC_READONLY));
+      if (srel == NULL
+	  || !bfd_set_section_alignment (dynobj, srel, 2))
+	return NULL;
+    }
+
+  return srel;
+}
+
+static bfd_boolean
+count_dyn_reloc (abfd, dyn_i, sec, srel, type)
+     bfd *abfd;
+     struct elf_lx_dyn_sym_info *dyn_i;
+     asection *sec;
+     asection *srel;
+     int type;
+{
+  struct elf_lx_dyn_reloc_entry *rent;
+
+  for (rent = dyn_i->reloc_entries; rent; rent = rent->next)
+    if (rent->srel == srel && rent->type == type && rent->sec == sec)
+      break;
+
+  if (!rent)
+    {
+      rent = ((struct elf_lx_dyn_reloc_entry *)
+	      bfd_alloc (abfd, (bfd_size_type) sizeof (*rent)));
+      if (!rent)
+	return FALSE;
+
+      rent->next = dyn_i->reloc_entries;
+      rent->sec = sec;
+      rent->srel = srel;
+      rent->type = type;
+      rent->count = 0;
+      dyn_i->reloc_entries = rent;
+    }
+  rent->count++;
+
+  return TRUE;
+}
+
+/* Determine the type of stub needed, if any, for a call.  */
+
+static enum elf_lx_stub_type
+lx_type_of_stub (abfd, info, input_sec, rel, destination)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     asection *input_sec;
+     const Elf_Internal_Rela *rel;
+     bfd_vma destination;
+{
+  bfd_vma location;
+  bfd_signed_vma branch_offset;
+
+  /* Determine where the call point is.  */
+  location = (input_sec->output_offset
+	      + input_sec->output_section->vma
+	      + rel->r_offset);
+
+  branch_offset = (bfd_signed_vma)(destination - location);
+  if (branch_offset > MAX_FWD_BRANCH_OFFSET
+       || branch_offset < MAX_BWD_BRANCH_OFFSET)
+    {
+      return (info->shared)
+	? (lx_mach_has_st240_encodings (abfd)
+	   ? lx_stub_pic_long_branch_st240
+	   : lx_stub_pic_long_branch_pre_st240)
+	: lx_stub_abs_long_branch;
+    }
+
+  return lx_stub_none;
+}
+
+/* Build a name for an entry in the stub hash table.  */
+
+static char *
+lx_stub_name (input_section, sym_sec, hash, rel)
+     const asection *input_section;
+     const asection *sym_sec;
+     const struct elf_lx_link_hash_entry *hash;
+     const Elf_Internal_Rela *rel;
+{
+  char *stub_name;
+  bfd_size_type len;
+
+  if (hash)
+    {
+      len = 8 + 1 + strlen (hash->root.root.root.string) + 1 + 8 + 1;
+      stub_name = bfd_malloc (len);
+      if (stub_name != NULL)
+	{
+	  sprintf (stub_name, "%08x_%s+%x",
+		   input_section->id & 0xffffffff,
+		   hash->root.root.root.string,
+		   (int) rel->r_addend & 0xffffffff);
+	}
+    }
+  else
+    {
+      len = 8 + 1 + 8 + 1 + 8 + 1 + 8 + 1;
+      stub_name = bfd_malloc (len);
+      if (stub_name != NULL)
+	{
+	  sprintf (stub_name, "%08x_%x:%x+%x",
+		   input_section->id & 0xffffffff,
+		   sym_sec->id & 0xffffffff,
+		   (int) ELF32_R_SYM (rel->r_info) & 0xffffffff,
+		   (int) rel->r_addend & 0xffffffff);
+	}
+    }
+  return stub_name;
+}
+
+void
+lx_elf_init_stub_bfd (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  struct elf_lx_link_hash_table *htab;
+
+  elf_elfheader (abfd)->e_ident[EI_CLASS] = ELFCLASS32;
+
+  htab = elf_lx_hash_table (info);
+  htab->stub_bfd = abfd;
+}
+
+/* Look up an entry in the stub hash.  Stub entries are cached because
+   creating the stub name takes a bit of time.  */
+
+static struct elf_lx_stub_hash_entry *
+lx_get_stub_entry (input_section, sym_sec, hash, rel, htab)
+     const asection *input_section;
+     const asection *sym_sec;
+     struct elf_link_hash_entry *hash;
+     const Elf_Internal_Rela *rel;
+     struct elf_lx_link_hash_table *htab;
+{
+  struct elf_lx_stub_hash_entry *stub_entry;
+  struct elf_lx_link_hash_entry *h = (struct elf_lx_link_hash_entry *) hash;
+  const asection *id_sec;
+
+  if ((input_section->flags & SEC_CODE) == 0)
+    return NULL;
+
+  /* If this input section is part of a group of sections sharing one
+     stub section, then use the id of the first section in the group.
+     Stub names need to include a section id, as there may well be
+     more than one stub used to reach say, printf, and we need to
+     distinguish between them.  */
+  id_sec = htab->stub_group[input_section->id].link_sec;
+
+  if (h != NULL && h->stub_cache != NULL
+      && h->stub_cache->h == h
+      && h->stub_cache->id_sec == id_sec)
+    {
+      stub_entry = h->stub_cache;
+    }
+  else
+    {
+      char *stub_name;
+
+      stub_name = lx_stub_name (id_sec, sym_sec, h, rel);
+      if (stub_name == NULL)
+	return NULL;
+
+      stub_entry = lx_stub_hash_lookup (&htab->stub_hash_table,
+					stub_name, FALSE, FALSE);
+      if (h != NULL)
+	h->stub_cache = stub_entry;
+
+      free (stub_name);
+    }
+
+  return stub_entry;
+}
+
+/* Add a new stub entry to the stub hash.  Not all fields of the new
+   stub entry are initialised.  */
+
+static struct elf_lx_stub_hash_entry *
+lx_add_stub (stub_name, section, htab)
+     const char *stub_name;
+     asection *section;
+     struct elf_lx_link_hash_table *htab;
+{
+  asection *link_sec;
+  asection *stub_sec;
+  struct elf_lx_stub_hash_entry *stub_entry;
+
+  link_sec = htab->stub_group[section->id].link_sec;
+  stub_sec = htab->stub_group[section->id].stub_sec;
+  if (stub_sec == NULL)
+    {
+      stub_sec = htab->stub_group[link_sec->id].stub_sec;
+      if (stub_sec == NULL)
+	{
+	  size_t namelen;
+	  bfd_size_type len;
+	  char *s_name;
+
+	  namelen = strlen (link_sec->name);
+	  len = namelen + sizeof (STUB_SUFFIX);
+	  s_name = bfd_alloc (htab->stub_bfd, len);
+	  if (s_name == NULL)
+	    return NULL;
+
+	  memcpy (s_name, link_sec->name, namelen);
+	  memcpy (s_name + namelen, STUB_SUFFIX, sizeof (STUB_SUFFIX));
+	  stub_sec = (*htab->add_stub_section) (s_name, link_sec);
+	  if (stub_sec == NULL)
+	    return NULL;
+	  htab->stub_group[link_sec->id].stub_sec = stub_sec;
+	}
+      htab->stub_group[section->id].stub_sec = stub_sec;
+    }
+
+  /* Enter this entry into the linker stub hash table.  */
+  stub_entry = lx_stub_hash_lookup (&htab->stub_hash_table, stub_name,
+				    TRUE, FALSE);
+  if (stub_entry == NULL)
+    {
+      (*_bfd_error_handler) (_("%B: cannot create stub entry %s"),
+			     section->owner,
+			     stub_name);
+      return NULL;
+    }
+
+  stub_entry->stub_sec = stub_sec;
+  stub_entry->stub_offset = 0;
+  stub_entry->id_sec = link_sec;
+  return stub_entry;
+}
+
+static bfd_boolean
+lx_build_one_stub (gen_entry, in_arg)
+     struct bfd_hash_entry *gen_entry;
+     PTR in_arg;
+{
+  struct elf_lx_stub_hash_entry *stub_entry;
+  struct bfd_link_info *info;
+  struct elf_lx_link_hash_table *htab;
+  asection *stub_sec;
+  bfd *stub_bfd;
+  bfd_vma stub_addr;
+  bfd_byte *loc;
+  bfd_vma sym_value;
+  unsigned long symndx;
+  Elf_Internal_Rela *relocs;
+  int template_size;
+  int size;
+  const insn_sequence *template;
+  int i;
+  bfd_boolean has_interlocks;
+  bfd_vma addend;
+  bfd_boolean stub_reloc_is_pic = FALSE;
+  int stub_reloc_idx = 0;
+
+  /* Assume we have at most 2 relocations per stub.  */
+#define MAX_RELOCS_PER_STUB 2
+  struct
+  {
+    int idx;
+    bfd_vma offset;
+    int r_type;
+  } stub_reloc[MAX_RELOCS_PER_STUB];
+
+  /* Massage our args to the form they really have.  */
+  stub_entry = (struct elf_lx_stub_hash_entry *) gen_entry;
+  info = (struct bfd_link_info *) in_arg;
+
+  htab = elf_lx_hash_table (info);
+  stub_sec = stub_entry->stub_sec;
+
+  /* Make a note of the offset within the stubs for this entry.  */
+  stub_entry->stub_offset = stub_sec->size;
+  loc = stub_sec->contents + stub_entry->stub_offset;
+
+  stub_bfd = htab->stub_bfd;
+
+  /* This is the address of the start of the stub */
+  stub_addr = stub_sec->output_section->vma + stub_sec->output_offset
+    + stub_entry->stub_offset;
+
+  /* This is the address of the stub destination */
+  sym_value = (stub_entry->target_value
+	       + stub_entry->target_section->output_offset
+	       + stub_entry->target_section->output_section->vma);
+
+  symndx = 0;
+  addend = sym_value;
+  relocs = NULL;
+
+  if (info->emitrelocations)
+    {
+      struct bfd_elf_section_data *elfsec_data;
+      struct elf_lx_link_hash_entry *h;
+      struct bfd_link_hash_entry *bh = NULL;
+      struct elf_link_hash_entry *eh;
+      const char *stub_name = stub_entry->root.string;
+
+      h = stub_entry->h;
+
+      /* Create a symbol to label the stub.
+	 For the relocations that are redirected to this stub, we will rewrite
+	 them to refer to this symbol.
+      */
+      /* Make a symbol to mark the start of the stub. */
+      if (! _bfd_generic_link_add_one_symbol (info, stub_bfd, stub_name, BSF_GLOBAL,
+					      stub_sec, stub_entry->stub_offset,
+					      NULL, TRUE, FALSE, &bh))
+	return FALSE;
+      stub_entry->sh = (struct elf_lx_link_hash_entry *)bh;
+      eh = (struct elf_link_hash_entry *)bh;
+      eh->type = STT_FUNC;
+      eh->other = (eh->other & ~ELF_ST_VISIBILITY (-1)) | STV_HIDDEN;
+      elf_lx_hash_hide_symbol (info, eh, TRUE);
+
+      if (stub_entry->stub_type != lx_stub_abs_long_branch)
+	/* We are only able to emit relocations for an absolute long
+	   branch stub.  The PC-relative long branch stubs require
+	   relocation types that do not exist (we would need something
+	   like R_LX_LO9_PCREL/R_LX_HI23_PCREL).
+	*/
+	{
+	  (*_bfd_error_handler)
+	    (_("%s: cannot emit relocations for PIC far call to %s"),
+	       bfd_get_filename (stub_entry->id_sec->owner),
+	       (h != NULL) ? h->root.root.root.string: "local symbol");
+	  return FALSE;
+	}
+      if (h != NULL)
+	{
+	  struct elf_link_hash_entry **hashes;
+
+	  hashes = elf_sym_hashes (stub_bfd);
+	  if (hashes == NULL)
+	    {
+	      bfd_size_type hsize;
+
+	      hsize = (htab->stub_globals + 1) * sizeof (*hashes);
+	      hashes = bfd_zalloc (stub_bfd, hsize);
+	      if (hashes == NULL)
+		return FALSE;
+	      elf_sym_hashes (stub_bfd) = hashes;
+	      htab->stub_globals = 1;
+	    }
+	  symndx = htab->stub_globals++;
+	  hashes[symndx] = &h->root;
+	  addend = 0;
+	}
+
+      elfsec_data = elf_section_data (stub_sec);
+      relocs = elfsec_data->relocs;
+      if (relocs == NULL)
+	{
+	  bfd_size_type relsize;
+	  relsize = stub_sec->reloc_count * sizeof (*relocs);
+	  relocs = bfd_alloc (stub_bfd, relsize);
+	  if (relocs == NULL)
+	    return FALSE;
+	  elfsec_data->relocs = relocs;
+	  elf_shstrtab (stub_bfd) = _bfd_elf_strtab_init();
+	  _bfd_elf_init_reloc_shdr(stub_bfd, &elfsec_data->rela, stub_sec, TRUE);
+	  _bfd_elf_single_rel_hdr (stub_sec)->sh_size = relsize;
+	  _bfd_elf_single_rel_hdr (stub_sec)->sh_entsize = sizeof (Elf32_External_Rela);
+	  stub_sec->reloc_count = 0;
+	}
+    }
+
+
+  template = stub_entry->stub_template;
+  template_size = stub_entry->stub_template_size;
+
+  has_interlocks = lx_mach_has_interlocks (stub_bfd);
+  size = 0;
+  for (i = 0; i < template_size; i++)
+    {
+      switch (template[i].type)
+	{
+	case CODE_TYPE:
+	  break;
+
+	case IMM9_TYPE:
+	case IMM23_TYPE:
+	  BFD_ASSERT (stub_reloc_idx < MAX_RELOCS_PER_STUB);
+	  stub_reloc[stub_reloc_idx].idx = i;
+	  stub_reloc[stub_reloc_idx].offset = size;
+	  stub_reloc[stub_reloc_idx].r_type = template[i].r_type;
+	  stub_reloc_idx++;
+	  break;
+
+	default:
+	  BFD_FAIL ();
+	  return FALSE;
+	}
+
+      if (template[i].reloc_type == STUB_RELOC_PIC)
+	{
+	  stub_reloc_is_pic = TRUE;
+	}
+
+      if (!has_interlocks
+	  || (template[i].opcode != NOP_BUNDLE
+	      && template[i].opcode != NOP_NOP_BUNDLE))
+	{
+	  bfd_put_32 (stub_bfd, template[i].opcode, loc + size);
+	  size += 4;
+	}
+    }
+
+  /* Stub size has already been computed in lx_size_one_stub. Check
+     consistency.  */
+  BFD_ASSERT (size == stub_entry->stub_size);
+
+  if (size & 7)
+    { /* To ensure all stubs are even-aligned (convenient because
+	 the templates do not work on odd-alignment) we tail pad. */
+      bfd_put_32 (stub_bfd, NOP_BUNDLE, loc + size);
+      size += 4;
+    }
+  stub_sec->size += size;
+  if (stub_entry->sh)
+    stub_entry->sh->root.size = size;
+
+  /* If the stub is in PIC mode, compute the PC relative offset here,
+     for lack of adequate relocation.  */
+  if (stub_reloc_is_pic) {
+    sym_value -= stub_addr + stub_reloc[0].offset;
+  }
+
+  for (i = 0; i < stub_reloc_idx; i++)
+    {
+      _bfd_final_link_relocate (elf32_lx_howto_table
+				+ template[stub_reloc[i].idx].r_type,
+				stub_bfd, stub_sec, stub_sec->contents,
+				stub_entry->stub_offset
+				+ stub_reloc[i].offset,
+				sym_value,
+				template[stub_reloc[i].idx].reloc_addend);
+
+      if (info->emitrelocations)
+	{
+	  /* We are only able to emit relocations for an absolute long
+	     branch stub. See above.  */
+	  BFD_ASSERT (stub_reloc_is_pic == FALSE);
+
+	  Elf_Internal_Rela *r = relocs + stub_sec->reloc_count++;
+	  r->r_offset = stub_entry->stub_offset + stub_reloc[i].offset;
+	  r->r_info = ELF32_R_INFO (symndx, stub_reloc[i].r_type);
+	  r->r_addend = addend;
+	}
+    }
+
+  return TRUE;
+}
+
+/* As above, but don't actually build the stub.  Just bump offset so
+   we know stub section sizes.  */
+
+static bfd_boolean
+lx_size_one_stub (gen_entry, in_arg)
+     struct bfd_hash_entry *gen_entry;
+     PTR in_arg;
+{
+  struct elf_lx_stub_hash_entry *stub_entry;
+  struct bfd_link_info *info;
+  struct elf_lx_link_hash_table *htab;
+  const insn_sequence *template;
+  int template_size;
+  int size;
+  int i;
+  bfd_boolean has_interlocks;
+  int relocs;
+  asection *stub_sec;
+
+  /* Massage our args to the form they really have.  */
+  stub_entry = (struct elf_lx_stub_hash_entry *) gen_entry;
+  info = in_arg;
+  htab = elf_lx_hash_table (info);
+
+  relocs = 0;
+  stub_sec = stub_entry->stub_sec;
+
+  switch (stub_entry->stub_type)
+    {
+    case lx_stub_abs_long_branch:
+      template = abs_long_branch_stub;
+      template_size = ARRAY_SIZE(abs_long_branch_stub);
+      relocs = 2;
+      break;
+    case lx_stub_pic_long_branch_pre_st240:
+      template = pic_long_branch_stub_pre_st240;
+      template_size = ARRAY_SIZE(pic_long_branch_stub_pre_st240);
+      break;
+    case lx_stub_pic_long_branch_st240:
+      template = pic_long_branch_stub_st240;
+      template_size = ARRAY_SIZE(pic_long_branch_stub_st240);
+      break;
+    default:
+      BFD_FAIL ();
+      return FALSE;
+      break;
+    }
+
+  has_interlocks = lx_mach_has_interlocks (stub_sec->owner);
+  size = 0;
+  for (i = 0; i < template_size; i++)
+    if (!has_interlocks	||
+	(template[i].opcode != NOP_BUNDLE
+	 && template[i].opcode != NOP_NOP_BUNDLE))
+      size += 4;
+
+  stub_entry->stub_size = size;
+  stub_entry->stub_template = template;
+  stub_entry->stub_template_size = template_size;
+
+  size = (size + 7) & ~7;
+  stub_sec->size += size;
+
+  if (info->emitrelocations)
+    {
+      stub_sec->reloc_count += relocs;
+      stub_sec->flags |= SEC_RELOC;
+    }
+  
+  return TRUE;
+}
+
+/* External entry points for sizing and building linker stubs.  */
+
+/* Set up various things so that we can make a list of input sections
+   for each output section included in the link.  Returns -1 on error,
+   0 when no stubs will be needed, and 1 on success.  */
+
+int
+elf_lx_setup_section_lists (output_bfd, info)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+{
+  bfd *input_bfd;
+  unsigned int bfd_count;
+  int top_id, top_index;
+  asection *section;
+  asection **input_list, **list;
+  bfd_size_type amt;
+  struct elf_lx_link_hash_table *htab = elf_lx_hash_table (info);
+
+  if (bfd_get_flavour (info->output_bfd) != bfd_target_elf_flavour)
+    return 0;
+
+  /* Count the number of input BFDs and find the top input section id.  */
+  for (input_bfd = info->input_bfds, bfd_count = 0, top_id = 0;
+       input_bfd != NULL;
+       input_bfd = input_bfd->link_next)
+    {
+      bfd_count += 1;
+      for (section = input_bfd->sections;
+	   section != NULL;
+	   section = section->next)
+	{
+	  if (top_id < section->id)
+	    top_id = section->id;
+	}
+    }
+  htab->bfd_count = bfd_count;
+
+  amt = sizeof (struct map_stub) * (top_id + 1);
+  htab->stub_group = (struct map_stub *) bfd_zmalloc (amt);
+  if (htab->stub_group == NULL)
+    return -1;
+
+  /* We can't use output_bfd->section_count here to find the top output
+     section index as some sections may have been removed, and
+     strip_excluded_output_sections doesn't renumber the indices. */
+  for (section = output_bfd->sections, top_index = 0;
+       section != NULL;
+       section = section->next)
+    {
+      if (top_index < section->index)
+	top_index = section->index;
+    }
+
+  htab->top_index = top_index;
+  amt = sizeof (asection *) * (top_index + 1);
+  input_list = (asection **) bfd_malloc (amt);
+  htab->input_list = input_list;
+  if (input_list == NULL)
+    return -1;
+
+  /* For sections we aren't interested in, mark their entries with a
+     value we can check later.  */
+  list = input_list + top_index;
+  do
+    *list = bfd_abs_section_ptr;
+  while (list-- != input_list);
+
+  for (section = output_bfd->sections;
+       section != NULL;
+       section = section->next)
+    {
+      if ((section->flags & SEC_CODE) != 0)
+	input_list[section->index] = NULL;
+    }
+
+  return 1;
+}
+
+/* The linker repeatedly calls this function for each input section,
+   in the order that input sections are linked into output sections.
+   Build lists of input sections to determine groupings between which
+   we may insert linker stubs.  */
+
+void
+elf_lx_next_input_section (info, isec)
+     struct bfd_link_info *info;
+     asection *isec;
+{
+  struct elf_lx_link_hash_table *htab = elf_lx_hash_table (info);
+
+  if (isec->output_section->index <= htab->top_index)
+    {
+      asection **list = htab->input_list + isec->output_section->index;
+      if (*list != bfd_abs_section_ptr)
+	{
+	  /* Steal the link_sec pointer for our list.  */
+#define PREV_SEC(sec) (htab->stub_group[(sec)->id].link_sec)
+	  /* This happens to make the list in reverse order,
+	     which we reverse later.  */
+	  PREV_SEC (isec) = *list;
+	  *list = isec;
+	}
+    }
+}
+
+/* See whether we can group stub sections together.  Grouping stub
+   sections may result in fewer stubs.  More importantly, we need to
+   put all .init* and .fini* stubs at the end of the .init or
+   .fini output sections respectively, because glibc splits the
+   _init and _fini functions into multiple parts.  Putting a stub in
+   the middle of a function is not a good idea.  */
+
+static void
+group_sections (htab, stub_group_size, stubs_always_after_branch)
+     struct elf_lx_link_hash_table *htab;
+     bfd_size_type stub_group_size;
+     bfd_boolean stubs_always_after_branch;
+{
+  asection **list = htab->input_list;
+  do
+    {
+      asection *tail = *list;
+      asection *head;
+
+      if (tail == bfd_abs_section_ptr)
+	continue;
+
+      /* Reverse the list: we must avoid placing stubs at the
+	 beginning of the section because the beginning of the text
+	 section may be required for an interrupt vector in bare metal
+	 code.  */
+#define NEXT_SEC PREV_SEC
+      head = NULL;
+      while (tail != NULL)
+        {
+          /* Pop from tail */
+          asection *item = tail;
+          tail = PREV_SEC(item);
+
+          /* Push on head */
+          NEXT_SEC(item) = head;
+          head = item;
+        }
+
+      while (head != NULL)
+	{
+	  asection *curr;
+	  asection *next;
+	  bfd_vma stub_group_start = head->output_offset;
+	  bfd_vma end_of_next;
+
+	  curr = head;
+	  while (NEXT_SEC (curr) != NULL)
+	    {
+	      next = NEXT_SEC(curr);
+	      end_of_next = next->output_offset + next->size;
+	      if (end_of_next - stub_group_start >= stub_group_size)
+		/* End of NEXT is too far from start, so stop */
+		break;
+	      /* Add NEXT to the group. */
+	      curr = next;
+	    }
+
+	  /* OK, the size from the start to the start of CURR is less
+	     than stub_group_size and thus can be handled by one stub
+	     section.  (or the head section is itself larger than
+	     stub_group_size, in which case we may be toast.)
+	     We should really be keeping track of the total size of
+	     stubs added here, as stubs contribute to the final output
+	     section size.  */
+	  do
+	    {
+	      next = NEXT_SEC (head);
+	      /* Set up this stub group.  */
+	      htab->stub_group[head->id].link_sec = curr;
+	    }
+	  while (head != curr && (head = next) != NULL);
+
+	  /* But wait, there's more!  Input sections up to stub_group_size
+	     bytes after the stub section can be handled by it too.  */
+	  if (!stubs_always_after_branch)
+	    {
+	      stub_group_start = curr->output_offset + curr->size;
+
+	      while (next != NULL)
+		{
+		  end_of_next = next->output_offset + next->size;
+		  if (end_of_next - stub_group_start >= stub_group_size)
+		    /* End of NEXT is too far from stubs, so stop */
+		    break;
+		  /* Add NEXT to the stub group */
+		  head = next;
+		  next = NEXT_SEC(head);
+		  htab->stub_group[head->id].link_sec = curr;
+		}
+	    }
+	  head = next;
+	}
+    }
+  while (list++ != htab->input_list + htab->top_index);
+
+  free (htab->input_list);
+#undef PREV_SEC
+#undef NEXT_SEC
+}
+
+/* Determine and set the size of the stub section for a final link.
+
+   The basic idea here is to examine all the relocations looking for
+   PC-relative calls to a target that is unreachable with a "bl"
+   instruction.  */
+
+bfd_boolean
+elf_lx_size_stubs (output_bfd, stub_bfd, info, group_size,
+		   add_stub_section, layout_sections_again)
+     bfd *output_bfd;
+     bfd *stub_bfd;
+     struct bfd_link_info *info;
+     bfd_signed_vma group_size;
+     asection * (*add_stub_section) PARAMS ((const char *, asection *));
+     void (*layout_sections_again) PARAMS ((void));
+{
+  bfd_size_type stub_group_size;
+  bfd_boolean stubs_always_after_branch;
+  bfd_boolean stub_changed = 0;
+  struct elf_lx_link_hash_table *htab = elf_lx_hash_table (info);
+
+  /* Propagate mach to stub bfd, because it may not have been
+     finalized when we created stub_bfd. */
+  bfd_set_arch_mach (stub_bfd, bfd_get_arch (output_bfd),
+		     bfd_get_mach (output_bfd));
+
+  /* Stash our params away.  */
+  htab->add_stub_section = add_stub_section;
+  htab->layout_sections_again = layout_sections_again;
+  stubs_always_after_branch = group_size < 0;
+  if (group_size < 0)
+    stub_group_size = -group_size;
+  else
+    stub_group_size = group_size;
+  if (stub_group_size == 1)
+    {
+      /* Default values.  */
+      /* Normal branch range is +-16MB.  This value is
+	 77K less than that, which allows for 2757 28-byte stubs.
+	 If we exceed that, then we will fail to link.  The user
+	 will have to relink with an explicit group size option.
+      */
+      stub_group_size = 16700000;
+    }
+
+  group_sections (htab, stub_group_size, stubs_always_after_branch);
+
+  while (1)
+    {
+      bfd *input_bfd;
+      unsigned int bfd_indx;
+      asection *stub_sec;
+
+      for (input_bfd = info->input_bfds, bfd_indx = 0;
+	   input_bfd != NULL;
+	   input_bfd = input_bfd->link_next, bfd_indx++)
+	{
+	  Elf_Internal_Shdr *symtab_hdr;
+	  asection *section;
+	  Elf_Internal_Sym *local_syms = NULL;
+
+	  /* We'll need the symbol table in a second.  */
+	  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+	  if (symtab_hdr->sh_info == 0)
+	    continue;
+
+	  /* Walk over each section attached to the input bfd.  */
+	  for (section = input_bfd->sections;
+	       section != NULL;
+	       section = section->next)
+	    {
+	      Elf_Internal_Rela *internal_relocs, *irelaend, *irela;
+
+	      /* If there aren't any relocs, then there's nothing more
+		 to do.  */
+	      if ((section->flags & SEC_RELOC) == 0
+		  || section->reloc_count == 0
+		  || (section->flags & SEC_CODE) == 0)
+		continue;
+
+	      /* If this section is a link-once section that will be
+		 discarded, then don't create any stubs.  */
+	      if (section->output_section == NULL
+		  || section->output_section->owner != output_bfd)
+		continue;
+
+	      /* Get the relocs.  */
+	      internal_relocs
+		= _bfd_elf_link_read_relocs (input_bfd, section, NULL,
+					       (Elf_Internal_Rela *) NULL,
+					       info->keep_memory);
+	      if (internal_relocs == NULL)
+		goto error_ret_free_local;
+
+	      /* Now examine each relocation.  */
+	      irela = internal_relocs;
+	      irelaend = irela + section->reloc_count;
+	      for (; irela < irelaend; irela++)
+		{
+		  unsigned int r_type, r_indx;
+		  enum elf_lx_stub_type stub_type;
+		  struct elf_lx_stub_hash_entry *stub_entry;
+		  asection *sym_sec;
+		  bfd_vma sym_value;
+		  bfd_vma destination;
+		  struct elf_lx_link_hash_entry *hash;
+		  char *stub_name;
+		  const asection *id_sec;
+
+		  r_type = ELF32_R_TYPE (irela->r_info);
+		  r_indx = ELF32_R_SYM (irela->r_info);
+
+		  if (r_type >= (unsigned int) R_LX_max)
+		    {
+		      bfd_set_error (bfd_error_bad_value);
+		    error_ret_free_internal:
+		      if (elf_section_data (section)->relocs == NULL)
+			free (internal_relocs);
+		      goto error_ret_free_local;
+		    }
+
+		  /* Only look for stubs on call instructions.  */
+		  if (r_type != (unsigned int) R_LX_23_PCREL)
+		    continue;
+
+		  /* Now determine the call target, its name, value,
+		     section.  */
+		  sym_sec = NULL;
+		  sym_value = 0;
+		  destination = 0;
+		  hash = NULL;
+		  if (r_indx < symtab_hdr->sh_info)
+		    {
+		      /* It's a local symbol.  */
+		      Elf_Internal_Sym *sym;
+		      Elf_Internal_Shdr *hdr;
+
+		      if (local_syms == NULL)
+			{
+			  local_syms
+			    = (Elf_Internal_Sym *) symtab_hdr->contents;
+			  if (local_syms == NULL)
+			    local_syms
+			      = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
+						      symtab_hdr->sh_info, 0,
+						      NULL, NULL, NULL);
+			  if (local_syms == NULL)
+			    goto error_ret_free_internal;
+			}
+
+		      sym = local_syms + r_indx;
+		      hdr = elf_elfsections (input_bfd)[sym->st_shndx];
+		      sym_sec = hdr->bfd_section;
+		      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
+			sym_value = sym->st_value;
+		      destination = (sym_value + irela->r_addend
+				     + sym_sec->output_offset
+				     + sym_sec->output_section->vma);
+		    }
+		  else
+		    {
+		      /* It's an external symbol.  */
+		      int e_indx;
+
+		      e_indx = r_indx - symtab_hdr->sh_info;
+		      hash = ((struct elf_lx_link_hash_entry *)
+			      elf_sym_hashes (input_bfd)[e_indx]);
+
+		      while (hash->root.root.type == bfd_link_hash_indirect
+			     || hash->root.root.type == bfd_link_hash_warning)
+			hash = ((struct elf_lx_link_hash_entry *)
+				hash->root.root.u.i.link);
+
+		      struct elf_lx_link_hash_table *lx_info = elf_lx_hash_table (info);
+		      struct elf_lx_dyn_sym_info *dyn_i =
+			get_dyn_sym_info (lx_info, &hash->root, NULL, NULL, FALSE); 
+		      if (dyn_i && dyn_i->want_plt2)
+			{
+			  /* Redirect to PLT */
+			  sym_sec = lx_info->plt_sec;
+			  sym_value = dyn_i->plt2_offset;
+			  if (sym_sec->output_section != NULL)
+			    destination = (sym_value + sym_sec->output_offset
+					   + sym_sec->output_section->vma);
+			}
+		      else if (hash->root.root.type == bfd_link_hash_defined
+			       || hash->root.root.type == bfd_link_hash_defweak)
+			{
+			  sym_sec = hash->root.root.u.def.section;
+			  sym_value = hash->root.root.u.def.value;
+			  if (sym_sec->output_section != NULL)
+			    destination = (sym_value + irela->r_addend
+					   + sym_sec->output_offset
+					   + sym_sec->output_section->vma);
+			}
+		      else if (hash->root.root.type == bfd_link_hash_undefweak
+			       || hash->root.root.type == bfd_link_hash_undefined)
+			{
+			  /* For a shared library, these will need a PLT stub,
+			     which is treated separately.
+			     For absolute code, they cannot be handled.
+			  */
+			  if (info->shared)
+			    /* We should have been redirected to a PLT stub. */
+			    bfd_set_error (bfd_error_bad_value);
+			  continue;
+			}
+		      else
+			{
+			  bfd_set_error (bfd_error_bad_value);
+			  goto error_ret_free_internal;
+			}
+		    }
+
+		  /* Determine what (if any) linker stub is needed.  */
+		  stub_type = lx_type_of_stub (output_bfd, info,
+					       section, irela,
+					       destination);
+		  if (stub_type == lx_stub_none)
+		    continue;
+
+		  /* Support for grouping stub sections.  */
+		  id_sec = htab->stub_group[section->id].link_sec;
+
+		  /* Get the name of this stub.  */
+		  stub_name = lx_stub_name (id_sec, sym_sec, hash, irela);
+		  if (!stub_name)
+		    goto error_ret_free_internal;
+
+		  stub_entry = lx_stub_hash_lookup (&htab->stub_hash_table,
+						    stub_name,
+						    FALSE, FALSE);
+		  if (stub_entry != NULL)
+		    {
+		      /* The proper stub has already been created.  */
+		      free (stub_name);
+		      continue;
+		    }
+
+		  stub_entry = lx_add_stub (stub_name, section, htab);
+		  if (stub_entry == NULL)
+		    {
+		      free (stub_name);
+		      goto error_ret_free_internal;
+		    }
+
+		  stub_entry->target_value = sym_value;
+		  stub_entry->target_section = sym_sec;
+		  stub_entry->stub_type = stub_type;
+		  stub_entry->h = hash;
+		  
+		  if (hash != NULL)
+		    htab->stub_globals += 1;
+
+		  stub_changed = TRUE;
+		}
+
+	      /* We're done with the internal relocs, free them.  */
+	      if (elf_section_data (section)->relocs == NULL)
+		free (internal_relocs);
+	    }
+	}
+
+      if (!stub_changed)
+	break;
+
+      /* OK, we've added some stubs.  Find out the new size of the
+	 stub sections.  */
+      for (stub_sec = stub_bfd->sections;
+	   stub_sec != NULL;
+	   stub_sec = stub_sec->next)
+	{
+	  stub_sec->size = 0;
+	}
+
+      bfd_hash_traverse (&htab->stub_hash_table, lx_size_one_stub, info);
+
+      /* Ask the linker to do its stuff.  */
+      (*htab->layout_sections_again) ();
+      stub_changed = FALSE;
+    }
+
+  return TRUE;
+
+ error_ret_free_local:
+  return FALSE;
+}
+
+/* Build all the stubs associated with the current output file.  The
+   stubs are kept in a hash table attached to the main linker hash
+   table.  We also set up the .plt entries for statically linked PIC
+   functions here.  This function is called via lx_elf_finish in the
+   linker.  */
+
+bfd_boolean
+elf_lx_build_stubs (info)
+     struct bfd_link_info *info;
+{
+  asection *stub_sec;
+  struct bfd_hash_table *table;
+  struct elf_lx_link_hash_table *htab;
+
+  htab = elf_lx_hash_table (info);
+
+  for (stub_sec = htab->stub_bfd->sections;
+       stub_sec != NULL;
+       stub_sec = stub_sec->next)
+    if (stub_sec->size != 0)
+      {
+	bfd_size_type size;
+
+	/* Allocate memory to hold the linker stubs.  */
+	size = stub_sec->size;
+	stub_sec->contents = (unsigned char *) bfd_zalloc (htab->stub_bfd, size);
+	if (stub_sec->contents == NULL)
+	  return FALSE;
+	stub_sec->size = 0;
+      }
+
+  /* Build the stubs as directed by the stub hash table.  */
+  table = &htab->stub_hash_table;
+  bfd_hash_traverse (table, lx_build_one_stub, info);
+
+  return TRUE;
+}
+
+/* Look through the relocs for a section during the first phase, and
+   calculate needed space in the global offset table, procedure linkage
+   table, and dynamic reloc sections.  */
+
+static bfd_boolean
+elf_lx_check_relocs (abfd, info, sec, relocs)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     asection *sec;
+     const Elf_Internal_Rela *relocs;
+{
+  struct elf_lx_link_hash_table *lx_info;
+  const Elf_Internal_Rela *rel;
+  const Elf_Internal_Rela *rel_end;
+  Elf_Internal_Shdr *symtab_hdr;
+  asection *got, *fptr, *srel;
+
+  if (info->relocatable)
+    return TRUE;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  lx_info = elf_lx_hash_table (info);
+
+  got = fptr = srel = NULL;
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      enum {
+	NEED_GOT = 1,
+	NEED_FPTR = 2,
+	NEED_PLTOFF = 4,
+	NEED_MIN_PLT = 8,
+	NEED_FULL_PLT = 16,
+	NEED_DYNREL = 32,
+	NEED_LTOFF_FPTR = 64,
+	NEED_TPREL = 128,
+	NEED_DTPLDM = 256,
+	NEED_DTPNDX = 512,
+	NEED_DYNBSS = 1024
+      };
+
+      struct elf_link_hash_entry *h = NULL;
+      unsigned long r_symndx = ELF32_R_SYM (rel->r_info);
+      struct elf_lx_dyn_sym_info *dyn_i;
+      int need_entry;
+      bfd_boolean maybe_dynamic;
+      int dynrel_type = R_LX_NONE;
+      unsigned int r_type;
+
+      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
+	{
+	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"),
+				 abfd, r_symndx);
+	  return FALSE;
+	}
+
+      if (r_symndx >= symtab_hdr->sh_info)
+	{
+	  /* We're dealing with a global symbol -- find its hash entry
+	     and mark it as being referenced.  */
+	  long indx = r_symndx - symtab_hdr->sh_info;
+	  h = elf_sym_hashes (abfd)[indx];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+	  h->ref_regular = 1;
+	}
+
+      /* We can only get preliminary data on whether a symbol is
+	 locally or externally defined, as not all of the input files
+	 have yet been processed.  Do something with what we know, as
+	 this may help reduce memory usage and processing time later.  */
+      maybe_dynamic = FALSE;
+      if (h && ((!info->executable
+		      && (!info->symbolic || info->unresolved_syms_in_shared_libs == RM_IGNORE))
+		|| ! h->def_regular
+		|| h->root.type == bfd_link_hash_defweak))
+	maybe_dynamic = TRUE;
+
+      need_entry = 0;
+
+      r_type = ELF32_R_TYPE (rel->r_info); 
+      switch (r_type)
+	{
+	case R_LX_GOTOFF_FPTR_HI23:
+	case R_LX_GOTOFF_FPTR_LO9:
+	  need_entry = NEED_FPTR | NEED_GOT | NEED_LTOFF_FPTR;
+	  break;
+
+	case R_LX_FPTR32:
+	  if (info->shared || h)
+	    need_entry = NEED_FPTR | NEED_DYNREL;
+	  else
+	    need_entry = NEED_FPTR;
+	  dynrel_type = R_LX_FPTR32;
+	  break;
+
+	case R_LX_GOTOFF_HI23:
+	case R_LX_GOTOFF_LO9:
+	case R_LX_GOTOFFX_HI23:
+	case R_LX_GOTOFFX_LO9:
+	  need_entry = NEED_GOT;
+	  break;
+
+	case R_LX_PLTOFF_HI23:
+	case R_LX_PLTOFF_LO9:
+	  need_entry = NEED_PLTOFF;
+	  if (h)
+	    {
+	      if (maybe_dynamic)
+		need_entry |= NEED_MIN_PLT;
+	    }
+	  else
+	    {
+	      (*info->callbacks->warning)
+		(info, _("@pltoff reloc against local symbol"), 0,
+		 abfd, 0, (bfd_vma) 0);
+	    }
+	  break;
+
+	case R_LX_23_PCREL:
+	  /* This is a call or jump (tailcall) to a symbol. */
+	  /* Depending on where the symbol is defined, we may or may not
+	     need a full plt entry.  Only skip if we know we'll not need
+	     the entry -- static or symbolic, and the symbol definition
+	     has already been seen.  */
+	  if (maybe_dynamic && rel->r_addend == 0)
+	    need_entry = NEED_FULL_PLT;
+	  break;
+
+	case R_LX_HI23:
+	case R_LX_LO9:
+	case R_LX_16:
+	  /* R_LX_HI23 and R_LX_LO9 use absolute addresses.  They should
+	     never appear in PIC code.  Currently, we only allow PIC
+	     code in shared libraries, so if we are linking a shared
+	     library, there is a mistake. */
+	  /* R_LX_16 should not appear in a dynamic object.
+	     ??? Should this be faulted? */
+	  /* ??? Would also like to check if these relocations occur
+	     in a PIC main program. */
+	  if (info->shared || L_RELOCATABLE)
+	    {
+	      (*_bfd_error_handler) (_("%B: contains absolute relocation: %d"),
+				     abfd, r_type);
+	      return FALSE;
+	    }
+	  if (h && ! (info->shared || L_RELOCATABLE))
+	    {
+	      h->non_got_ref = 1;
+	    }
+	  if (maybe_dynamic)
+	    need_entry = NEED_DYNBSS | NEED_DYNREL;
+	  dynrel_type = r_type;
+	  break;
+
+	case R_LX_32:
+	  if (h && !(info->shared || L_RELOCATABLE))
+	    {
+	      h->non_got_ref = 1;
+	    }
+	  /* Shared objects will always need at least a REL relocation.  */
+	  if (info->shared || L_RELOCATABLE || maybe_dynamic)
+	    need_entry = NEED_DYNREL;
+	  dynrel_type = R_LX_32;
+	  break;
+
+	case R_LX_IPLT:
+	  if (info->shared || maybe_dynamic)
+	    need_entry = NEED_DYNREL;
+	  dynrel_type = R_LX_IPLT;
+	  break;
+
+	case R_LX_32_PCREL:
+	  /* A PC-relative relocation to a symbol in another load module
+	     requires a dynamic relocation. */
+	  if (maybe_dynamic)
+	    need_entry = NEED_DYNREL;
+	  dynrel_type = R_LX_32_PCREL;
+	  break;
+
+	case R_LX_TPREL32:
+	  if (info->shared || maybe_dynamic)
+	    need_entry = NEED_DYNREL;
+	  dynrel_type = r_type;
+	  if (info->shared)
+	    info->flags |= DF_STATIC_TLS;
+	  break;
+
+	case R_LX_GOTOFF_TPREL_HI23:
+	case R_LX_GOTOFF_TPREL_LO9:
+	  need_entry = NEED_TPREL;
+	  if (info->shared)
+	    info->flags |= DF_STATIC_TLS;
+	  break;
+
+	case R_LX_GOTOFF_DTPLDM_HI23:
+	case R_LX_GOTOFF_DTPLDM_LO9:
+	  need_entry = NEED_DTPLDM;
+	  break;
+
+	case R_LX_GOTOFF_DTPNDX_HI23:
+	case R_LX_GOTOFF_DTPNDX_LO9:
+	  need_entry = NEED_DTPNDX;
+	  break;
+
+	case R_LX_DTPMOD32:
+	case R_LX_DTPREL32:
+	  if (info->shared || maybe_dynamic)
+	    need_entry = NEED_DYNREL;
+	  dynrel_type = r_type;
+	  break;
+	}
+
+      if (!need_entry)
+	continue;
+
+      if ((need_entry & NEED_FPTR) != 0
+	  && rel->r_addend)
+	{
+	  (*info->callbacks->warning)
+	    (info, _("non-zero addend in @fptr reloc"), 0,
+	     abfd, 0, (bfd_vma) 0);
+	}
+
+      dyn_i = get_dyn_sym_info (lx_info, h, abfd, rel, TRUE);
+
+      /* Record whether or not this is a local symbol. */
+      dyn_i->h = h;
+
+      if (need_entry & (NEED_GOT | NEED_TPREL | NEED_DTPLDM | NEED_DTPNDX))
+	{
+	  if (!got)
+	    {
+	      got = get_got (abfd, info, lx_info);
+	      if (!got)
+		return FALSE;
+	    }
+	  if (need_entry & NEED_GOT)
+	    dyn_i->want_got++;
+	  if (need_entry & NEED_TPREL)
+	    dyn_i->want_tprel++;
+	  if (need_entry & NEED_DTPLDM)
+	    dyn_i->want_dtpldm++;
+	  if (need_entry & NEED_DTPNDX)
+	    dyn_i->want_dtpndx++;
+	}
+      if (need_entry & NEED_FPTR)
+	{
+	  if (!fptr)
+	    {
+	      fptr = get_fptr (abfd, info, lx_info);
+	      if (!fptr)
+		return FALSE;
+	    }
+
+	  /* FPTRs for shared libraries are allocated by the dynamic
+	     linker.  Make sure this local symbol will appear in the
+	     dynamic symbol table. */
+	  if (!h && info->shared)
+	    {
+	      /* Old binutils does not support this, so give up. */
+	      if (! (bfd_elf_link_record_local_dynamic_symbol
+		     (info, abfd, (long) r_symndx)))
+		return FALSE;
+	    }
+	  dyn_i->want_fptr = 1;
+	}
+      if (need_entry & NEED_LTOFF_FPTR)
+	dyn_i->want_ltoff_fptr = 1;
+      if (need_entry & (NEED_MIN_PLT | NEED_FULL_PLT))
+	{
+	  if (!lx_info->root.dynobj)
+	    lx_info->root.dynobj = abfd;
+	  h->needs_plt = 1;
+	  dyn_i->want_plt = 1;
+	}
+      if (need_entry & NEED_FULL_PLT)
+	dyn_i->want_plt2 = 1;
+      if (need_entry & NEED_PLTOFF)
+	dyn_i->want_pltoff = 1;
+      if ((need_entry & NEED_DYNREL) && (sec->flags & SEC_ALLOC))
+	{
+	  if (!srel)
+	    {
+	      srel = get_reloc_section (abfd, lx_info, sec, TRUE);
+	      if (!srel)
+		return FALSE;
+	    }
+	  if (!count_dyn_reloc (abfd, dyn_i, sec, srel, dynrel_type))
+	    return FALSE;
+	}
+    }
+  return TRUE;
+}
+
+struct elf_lx_allocate_data
+{
+  struct bfd_link_info *info;
+  bfd *output_bfd;
+  bfd_size_type ofs;
+  bfd_size_type align;
+};
+
+/* For cleanliness, and potentially faster dynamic loading, allocate
+   external GOT entries first.  */
+
+static bfd_boolean
+allocate_global_data_got (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+  struct elf_lx_link_hash_table *lx_info = elf_lx_hash_table (x->info);
+  asection *got_sec = lx_info->got_sec;
+  bfd_boolean emitrelocations = x->info->emitrelocations;
+
+  if (dyn_i->want_got
+      && ! dyn_i->want_fptr
+      && elf_lx_dynamic_symbol_p (dyn_i->h, x->info))
+     {
+       dyn_i->got_offset = x->ofs;
+       x->ofs += 4;
+       if (emitrelocations)
+	 got_sec->reloc_count++;
+     }
+  if (dyn_i->want_tprel)
+    {
+      dyn_i->tprel_offset = x->ofs;
+      x->ofs += 4;
+      if (emitrelocations)
+	got_sec->reloc_count++;
+    }
+  if (dyn_i->want_dtpldm)
+    {
+      if (elf_lx_dynamic_symbol_p (dyn_i->h, x->info))
+	{
+	  dyn_i->dtpldm_offset = x->ofs;
+	  x->ofs += 8;
+	  if (emitrelocations)
+	    got_sec->reloc_count++;
+	}
+      else
+	{
+	  if (lx_info->self_dtpldm_offset == (bfd_vma) -1)
+	    {
+	      lx_info->self_dtpldm_offset = x->ofs;
+	      x->ofs += 8;
+	      if (emitrelocations)
+		got_sec->reloc_count++;
+	    }
+	  dyn_i->dtpldm_offset = lx_info->self_dtpldm_offset;
+	}
+    }
+  if (dyn_i->want_dtpndx)
+    {
+      dyn_i->dtpndx_offset = x->ofs;
+      x->ofs += 8;
+      if (emitrelocations)
+	got_sec->reloc_count += 2;
+    }
+  return TRUE;
+}
+
+/* Next, allocate all the GOT entries used by GOTOFF_FPTR relocs.  */
+
+static bfd_boolean
+allocate_global_fptr_got (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+  struct elf_lx_link_hash_table *lx_info = elf_lx_hash_table (x->info);
+  asection *got_sec = lx_info->got_sec;
+
+  if (dyn_i->want_got
+      && dyn_i->want_fptr
+      && elf_lx_dynamic_symbol_p (dyn_i->h, x->info))
+    {
+      dyn_i->got_offset = x->ofs;
+      x->ofs += 4;
+      if (x->info->emitrelocations)
+	got_sec->reloc_count += 1;
+    }
+  return TRUE;
+}
+
+/* Lastly, allocate all the GOT entries for local data.  */
+
+static bfd_boolean
+allocate_local_got (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+  struct elf_lx_link_hash_table *lx_info = elf_lx_hash_table (x->info);
+  asection *got_sec = lx_info->got_sec;
+
+  if (dyn_i->want_got
+      && ! elf_lx_dynamic_symbol_p (dyn_i->h, x->info))
+    {
+      dyn_i->got_offset = x->ofs;
+      x->ofs += 4;
+      if (x->info->emitrelocations)
+	got_sec->reloc_count += 1;
+    }
+  return TRUE;
+}
+
+/* Search for the index of a global symbol in it's defining object file.  */
+
+static long
+global_sym_index (h)
+     struct elf_link_hash_entry *h;
+{
+  struct elf_link_hash_entry **p;
+  bfd *obj;
+
+  BFD_ASSERT (h->root.type == bfd_link_hash_defined
+	      || h->root.type == bfd_link_hash_defweak);
+
+  obj = h->root.u.def.section->owner;
+  for (p = elf_sym_hashes (obj); *p != h; ++p)
+    continue;
+
+  return p - elf_sym_hashes (obj) + elf_tdata (obj)->symtab_hdr.sh_info;
+}
+
+/* Allocate function descriptors.  We can do these for every function
+   in a main executable that is not exported.  */
+
+static bfd_boolean
+allocate_fptr (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+
+  if (dyn_i->want_fptr)
+    {
+      struct elf_link_hash_entry *h = dyn_i->h;
+
+      if (h)
+	while (h->root.type == bfd_link_hash_indirect
+	       || h->root.type == bfd_link_hash_warning)
+	  h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+      if (!x->info->executable)
+	{
+	  if (h && h->dynindx == -1)
+	    {
+	      BFD_ASSERT ((h->root.type == bfd_link_hash_defined)
+			  || (h->root.type == bfd_link_hash_defweak));
+
+	      if (!bfd_elf_link_record_local_dynamic_symbol
+		    (x->info, h->root.u.def.section->owner,
+		     global_sym_index (h)))
+		return FALSE;
+	    }
+
+	  dyn_i->want_fptr = 0;
+	}
+      else if (h == NULL || h->dynindx == -1)
+	{
+	  dyn_i->fptr_offset = x->ofs;
+	  x->ofs += 8;
+	}
+      else
+	dyn_i->want_fptr = 0;
+    }
+  return TRUE;
+}
+
+/* Allocate all the minimal PLT entries.  */
+
+static bfd_boolean
+allocate_plt_entries (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+
+  if (dyn_i->want_plt)
+    {
+      struct elf_link_hash_entry *h = dyn_i->h;
+
+      if (h)
+	while (h->root.type == bfd_link_hash_indirect
+	       || h->root.type == bfd_link_hash_warning)
+	  h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+      /* ??? Versioned symbols seem to lose ELF_LINK_HASH_NEEDS_PLT.  */
+      if (elf_lx_dynamic_symbol_p (h, x->info)
+	  && !main_program_weak_def_p (h, x->info))
+	{
+	  bfd_size_type offset = x->ofs;
+	  if (offset == 0)
+	    offset = PLT_HEADER_SIZE;
+	  dyn_i->plt_offset = offset;
+	  
+	  x->ofs = offset + PLT_MIN_ENTRY_SIZE;
+
+	  dyn_i->want_pltoff = 1;
+	}
+      else
+	{
+	  dyn_i->want_plt = 0;
+	  dyn_i->want_plt2 = 0;
+	}
+    }
+  return TRUE;
+}
+
+/* Allocate all the full PLT entries.  */
+
+static bfd_boolean
+allocate_plt2_entries (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+
+  if (dyn_i->want_plt2)
+    {
+      struct elf_link_hash_entry *h = dyn_i->h;
+      bfd_size_type ofs = x->ofs;
+
+      dyn_i->plt2_offset = ofs;
+
+      x->ofs = ofs + (pic_abi_p (x->output_bfd)
+		      ? PLT_FULL_ENTRY_SIZE_PIC_ABI
+		      : PLT_FULL_ENTRY_SIZE);
+
+      while (h->root.type == bfd_link_hash_indirect
+	     || h->root.type == bfd_link_hash_warning)
+	h = (struct elf_link_hash_entry *) h->root.u.i.link;
+      dyn_i->h->plt.offset = ofs;
+
+      /* If this symbol is not defined in a regular file, and we are
+	 not generating a shared library, then set the symbol to this
+	 location in the .plt.  This is required to make function
+	 pointers compare as equal between the normal executable and
+	 the shared library.  */
+      if (! pic_abi_p (x->output_bfd)
+	  && ! x->info->shared
+	  && h
+	  && ! h->def_regular)
+	{
+	  struct elf_lx_link_hash_table *lx_info;
+
+	  lx_info = elf_lx_hash_table (x->info);
+	  h->root.u.def.section = lx_info->plt_sec;
+	  h->root.u.def.value = ofs;
+	}
+    }
+  return TRUE;
+}
+
+/* Allocate all the PLTOFF entries requested by relocations and
+   plt entries.  We can't share space with allocated FPTR entries,
+   because the latter are not necessarily addressable by the GP.
+   ??? Relaxation might be able to determine that they are.
+   PIC ABI: Allocate local function descriptors in .pltoff.
+   Embedded ABI: Allocate function pointers in .got.plt. */
+
+static bfd_boolean
+allocate_pltoff_entries (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+
+  if (dyn_i->want_pltoff)
+    {
+      dyn_i->pltoff_offset = x->ofs;
+      if (pic_abi_p (x->output_bfd))
+	/* pltoff contains function descriptors */
+	x->ofs += 8;
+      else
+	/* pltoff (.got.plt) contains function pointers */
+	x->ofs += 4;
+    }
+  return TRUE;
+}
+
+/* Allocate dynamic relocations for those symbols that turned out
+   to be dynamic.  */
+
+static bfd_boolean
+allocate_dynrel_entries (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+  struct elf_lx_link_hash_table *lx_info;
+  struct elf_lx_dyn_reloc_entry *rent;
+  bfd_boolean dynamic_symbol, shared;
+
+  lx_info = elf_lx_hash_table (x->info);
+  dynamic_symbol = elf_lx_dynamic_symbol_p (dyn_i->h, x->info);
+  shared = x->info->shared;
+
+ /* Take care of the normal data relocations.  */
+
+  for (rent = dyn_i->reloc_entries; rent; rent = rent->next)
+    {
+      int count = rent->count;
+
+      switch (rent->type)
+	{
+	case R_LX_FPTR32:
+	  /* Allocate one iff !want_fptr, which by this point will
+	     be true only if we're actually allocating one statically
+	     in the main executable.  */
+	  if (dyn_i->want_fptr)
+	    continue;
+	  break;
+	case R_LX_IPLT:
+	case R_LX_JMP_SLOT:
+	  if (!dynamic_symbol && !shared)
+	    continue;
+	  /* Use two REL relocations for IPLT relocations
+	     against local symbols, one REL relocation for
+	     JMP_SLOT relocations against local symbols.  */
+	  if (!dynamic_symbol && rent->type == R_LX_IPLT)
+	    count *= 2;
+	  break;
+	case R_LX_32_PCREL:
+	  if (!dynamic_symbol)
+	    continue;
+	  break;
+	case R_LX_32:
+	  /* Dynamic symbols need a relocation.
+	     All symbols in shared/L_relocatable links need a relocation,
+	     unless they are absolute.
+	  */
+	  if (! ((dynamic_symbol || shared || L_RELOCATABLE)
+		 && (rent->sec->flags & SEC_ALLOC) != 0
+		 && (dyn_i->h == NULL || ! dyn_i->h->non_got_ref)))
+	    continue;
+	  break;
+	case R_LX_LO9:
+	case R_LX_HI23:
+	  continue;
+	case R_LX_TPREL32:
+	case R_LX_DTPREL32:
+	case R_LX_DTPMOD32:
+	  break;
+	default:
+	  abort ();
+	}
+      rent->srel->size += sizeof (Elf32_External_Rela) * count;
+      if (count && (rent->sec->flags & SEC_READONLY))
+	lx_info->reltext = 1;
+    }
+
+  /* Take care of the GOT and PLT relocations.  */
+
+  if (((dynamic_symbol || shared) && dyn_i->want_got)
+      || (dyn_i->want_ltoff_fptr && dyn_i->h && dyn_i->h->dynindx != -1))
+    lx_info->rel_got_sec->size += sizeof (Elf32_External_Rela);
+  if ((dynamic_symbol || shared) && dyn_i->want_tprel)
+    lx_info->rel_got_sec->size += sizeof (Elf32_External_Rela);
+  if (dynamic_symbol && dyn_i->want_dtpldm)
+    lx_info->rel_got_sec->size += sizeof (Elf32_External_Rela);
+  if ((dynamic_symbol || shared) && dyn_i->want_dtpndx)
+    {
+      lx_info->rel_got_sec->size += sizeof (Elf32_External_Rela);
+      if (dynamic_symbol)
+	lx_info->rel_got_sec->size += sizeof (Elf32_External_Rela);
+    }
+
+  if (dyn_i->want_pltoff)
+    {
+      bfd_size_type t = 0;
+
+      /* Dynamic symbols get one IPLT relocation.
+         Local symbols in shared libraries get two REL
+         relocations (in the PIC ABI which uses fn descriptors)
+	 or one REL relocation (in the embedded ABI).
+	 Local symbols in main applications get nothing.  */
+      if (dynamic_symbol)
+	t = sizeof (Elf32_External_Rela);
+      else if (shared)
+	{
+	  if (pic_abi_p (x->output_bfd))
+	    t = 2 * sizeof (Elf32_External_Rela);
+	  else
+	    t = sizeof (Elf32_External_Rela);
+	}
+      lx_info->rel_pltoff_sec->size += t;
+    }
+
+  /* Take care of the COPY relocation. */
+  {
+    struct elf_lx_link_hash_entry *lx_h = (struct elf_lx_link_hash_entry *)dyn_i->h;
+
+    if (lx_h && lx_h->dynbss_size && ! lx_h->rel_dynbss_allocated)
+      {
+	lx_info->rel_dynbss_sec->size += sizeof (Elf32_External_Rela);
+	lx_h->rel_dynbss_allocated = TRUE;
+      }
+  }
+
+  return TRUE;
+}
+
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+
+static bfd_boolean
+elf_lx_adjust_dynamic_symbol (info, h)
+     struct bfd_link_info *info;
+     struct elf_link_hash_entry *h;
+{
+  bfd *dynobj;
+  struct elf_lx_link_hash_table *lx_info;
+  struct elf_lx_dyn_sym_info *dyn_i;
+  struct elf_lx_dyn_sym_info *d;
+  struct elf_lx_dyn_reloc_entry *rent;
+
+#if 0
+  printf ("elf_lx_adjust_dynamic_symbol: %s (%p)\n", h->root.root.string, h);
+#endif
+
+  lx_info = elf_lx_hash_table (info);
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  /* Make sure we know what is going on here.  */
+  BFD_ASSERT (dynobj != NULL
+	      && (h->needs_plt
+		  || h->u.weakdef != NULL
+		  || (h->def_dynamic
+		      && h->ref_regular
+		      && ! h->def_regular)));
+
+  dyn_i = get_dyn_sym_info (lx_info, h, NULL, NULL, FALSE);
+
+  /* Undefined symbols with PLT entries should be re-defined
+     to be the PLT entry.  */
+  if (h->type == STT_FUNC
+      || h->needs_plt)
+    {
+      if (! dyn_i
+	  || (! info->shared
+	      && ! h->def_dynamic
+	      && ! h->ref_dynamic
+	      && h->root.type != bfd_link_hash_undefined))
+	{
+	  h->needs_plt = 0;
+	  return TRUE;
+	}
+
+      dyn_i->want_plt = 1;
+      dyn_i->want_plt2 = 1;
+      /* We want to set the symbol to the location in the .plt
+	 section, but cannot do that until it is allocated in
+	 size_dynamic_sections. */
+      return TRUE;
+    }
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->u.weakdef != NULL)
+    {
+      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
+                  || h->u.weakdef->root.type == bfd_link_hash_defweak);
+      h->root.u.def.section = h->u.weakdef->root.u.def.section;
+      h->root.u.def.value = h->u.weakdef->root.u.def.value;
+      return TRUE;
+    }
+
+  /* If this is a reference to a symbol defined by a dynamic object which
+     is not a function, we might allocate the symbol in our .dynbss section
+     and allocate a COPY dynamic relocation.
+  */
+
+  /* If we are creating a shared library, we must presume that the
+     only references to the symbol are via the global offset table.
+     For such cases we need not do anything here; the relocations will
+     be handled correctly by relocate_section.  */
+  if (info->shared)
+    return TRUE;
+
+  /* If there are no references to this symbol that do not use the
+     GOT, we don't need to generate a copy reloc.  */
+  if (! h->non_got_ref)
+    return TRUE;
+
+  /* If -z nocopyreloc was given, we won't generate them either.  */
+  if (info->nocopyreloc)
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  for (d = ((struct elf_lx_link_hash_entry *)h)->info; d; d = d->next)
+    {
+      for (rent = d->reloc_entries; rent; rent = rent->next)
+	{
+	  asection *s = rent->sec->output_section;
+	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
+	    break;
+	}
+      if (rent)
+	break;
+    }
+
+  /* If we didn't find any dynamic relocs in read-only sections, then
+     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
+  if (! d)
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  /* We must allocate the symbol in our .dynbss section, which will
+     become part of the .bss section of the executable.  There will be
+     an entry for this symbol in the .dynsym section.  The dynamic
+     object will contain position independent code, so all references
+     from the dynamic object to this symbol will go through the global
+     offset table.  The dynamic linker will use the .dynsym entry to
+     determine the address it must put in the global offset table, so
+     both the dynamic object and the regular object will refer to the
+     same memory location for the variable.  */
+
+#if 0
+  printf ("Allocating %s (%p) in bss\n", h->root.root.string, h);
+#endif
+
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
+    {
+      h->needs_copy = 1;
+    }
+
+  {
+    struct elf_lx_link_hash_entry *lx_h = (struct elf_lx_link_hash_entry *)h;
+    asection *s = lx_info->dynbss_sec;
+    unsigned int power_of_two = bfd_log2 (h->size);
+
+    if (power_of_two > 3)
+      power_of_two = 3;
+
+    s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
+    if (power_of_two > bfd_get_section_alignment (lx_info->root.dynobj, s))
+      {
+	if (! bfd_set_section_alignment (lx_info->root.dynobj, s, power_of_two))
+	  return FALSE;
+      }
+
+    /* Define the symbol as being at this point in the section.  */
+    h->root.u.def.section = s;
+    h->root.u.def.value = s->size;
+
+    /* Increment the section size to make room for the symbol.  */
+    s->size += h->size;
+
+    lx_h->dynbss_size = h->size;
+  }
+
+  return TRUE;
+}
+
+static bfd_boolean
+elf_lx_size_dynamic_sections (output_bfd, info)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+{
+  struct elf_lx_allocate_data data;
+  struct elf_lx_link_hash_table *lx_info;
+  asection *sec;
+  bfd *dynobj;
+  bfd_boolean relplt = FALSE;
+
+  dynobj = elf_hash_table(info)->dynobj;
+  lx_info = elf_lx_hash_table (info);
+  lx_info->self_dtpldm_offset = (bfd_vma) -1;
+  BFD_ASSERT(dynobj != NULL);
+  data.info = info;
+  data.output_bfd = output_bfd;
+
+  /* Set the contents of the .interp section to the interpreter.  */
+  if (lx_info->root.dynamic_sections_created
+      && info->executable)
+    {
+      sec = bfd_get_section_by_name (dynobj, ".interp");
+      BFD_ASSERT (sec != NULL);
+      sec->contents = (bfd_byte *) ELF_DYNAMIC_INTERPRETER;
+      sec->size = strlen (ELF_DYNAMIC_INTERPRETER) + 1;
+    }
+
+  /* Allocate the GOT entries.  */
+
+  if (lx_info->got_sec)
+    {
+      asection *got_sec = lx_info->got_sec;
+
+      data.ofs = 0;
+      elf_lx_dyn_sym_traverse (lx_info, allocate_global_data_got, &data);
+      elf_lx_dyn_sym_traverse (lx_info, allocate_global_fptr_got, &data);
+      elf_lx_dyn_sym_traverse (lx_info, allocate_local_got, &data);
+      got_sec->size = data.ofs;
+      if (got_sec->reloc_count > 0)
+	{
+	  /* Allocate relocs now, but do not fill it until we enter
+	     elf_lx_relocate_section for the got section. */
+	  struct bfd_elf_section_data *elfsec_data = elf_section_data (got_sec);
+	  bfd_size_type relsize = got_sec->reloc_count * sizeof (Elf_Internal_Rela);
+	  Elf_Internal_Rela *relocs = bfd_zalloc(lx_info->got_bfd, relsize);
+	  bfd_size_type relhash_size = (got_sec->reloc_count
+					* sizeof (struct elf_link_hash_entry *));
+	  BFD_ASSERT (elfsec_data->relocs == 0);
+	  elfsec_data->relocs = relocs;
+	  elf_shstrtab (output_bfd) = _bfd_elf_strtab_init();
+	  _bfd_elf_init_reloc_shdr(output_bfd, &elfsec_data->rela, got_sec, TRUE);
+	  _bfd_elf_single_rel_hdr (got_sec)->sh_size = relsize;
+	  _bfd_elf_single_rel_hdr (got_sec)->sh_entsize = sizeof (Elf32_External_Rela);
+	  lx_info->got_rel_hash = bfd_zmalloc (relhash_size);
+	}
+    }
+
+  /* Allocate the FPTR entries.  */
+
+  if (lx_info->fptr_sec)
+    {
+      data.ofs = 0;
+      elf_lx_dyn_sym_traverse (lx_info, allocate_fptr, &data);
+      lx_info->fptr_sec->size = data.ofs;
+    }
+
+  /* Now that we've seen all of the input files, we can decide which
+     symbols need plt entries.  Allocate the minimal PLT entries first.
+     We do this even though dynamic_sections_created may be FALSE, because
+     this has the side-effect of clearing want_plt and want_plt2.  */
+
+  data.ofs = 0;
+  elf_lx_dyn_sym_traverse (lx_info, allocate_plt_entries, &data);
+
+  lx_info->minplt_entries = 0;
+  if (data.ofs)
+    {
+      lx_info->minplt_entries
+	= (data.ofs - PLT_HEADER_SIZE) / PLT_MIN_ENTRY_SIZE;
+    }
+
+  /* Align the pointer for the plt2 entries.  */
+  data.ofs = (data.ofs + 31) & (bfd_vma) -32;
+
+  elf_lx_dyn_sym_traverse (lx_info, allocate_plt2_entries, &data);
+  if (data.ofs != 0)
+    {
+      BFD_ASSERT (lx_info->root.dynamic_sections_created);
+
+      lx_info->plt_sec->size = data.ofs;
+
+      /* If we've got a .plt, we need some extra memory for the dynamic
+	 linker.  We stuff these in .got.plt.  */
+      sec = bfd_get_section_by_name (dynobj, ".got.plt");
+      sec->size = 4 * PLT_RESERVED_WORDS;
+    }
+
+  /* Allocate the PLTOFF entries.  */
+
+  if (lx_info->pltoff_sec)
+    {
+      if (pic_abi_p (output_bfd))
+	data.ofs = 0;
+      else
+	/* In the embedded ABI, the PLTOFF entries go in .got.plt.
+           Remember the start of .got.plt is reserved.
+	*/
+	data.ofs = lx_info->pltoff_sec->size;
+      elf_lx_dyn_sym_traverse (lx_info, allocate_pltoff_entries, &data);
+      lx_info->pltoff_sec->size = data.ofs;
+    }
+
+  if (lx_info->root.dynamic_sections_created)
+    {
+      /* Allocate space for the dynamic relocations that turned out to be
+	 required.  */
+
+      if (info->shared && lx_info->self_dtpldm_offset != (bfd_vma) -1)
+	lx_info->rel_got_sec->size += 2 * sizeof (Elf32_External_Rela);
+      elf_lx_dyn_sym_traverse (lx_info, allocate_dynrel_entries, &data);
+    }
+
+  /* We have now determined the sizes of the various dynamic sections.
+     Allocate memory for them.  */
+  for (sec = dynobj->sections; sec != NULL; sec = sec->next)
+    {
+      bfd_boolean strip;
+
+      if (!(sec->flags & SEC_LINKER_CREATED))
+	continue;
+
+      /* If we don't need this section, strip it from the output file.
+	 There were several sections primarily related to dynamic
+	 linking that must be create before the linker maps input
+	 sections to output sections.  The linker does that before
+	 bfd_elf_size_dynamic_sections is called, and it is that
+	 function which decides whether anything needs to go into
+	 these sections.  */
+
+      strip = (sec->size == 0);
+
+      if (sec == lx_info->got_sec)
+	strip = FALSE;
+      else if (sec == lx_info->rel_got_sec)
+	{
+	  if (strip)
+	    lx_info->rel_got_sec = NULL;
+	  else
+	    /* We use the reloc_count field as a counter if we need to
+	       copy relocs into the output file.  */
+	    sec->reloc_count = 0;
+	}
+      else if (sec == lx_info->fptr_sec)
+	{
+	  if (strip)
+	    lx_info->fptr_sec = NULL;
+	}
+      else if (sec == lx_info->plt_sec)
+	{
+	  if (strip)
+	    lx_info->plt_sec = NULL;
+	}
+      else if (sec == lx_info->pltoff_sec)
+	{
+	  if (strip)
+	    lx_info->pltoff_sec = NULL;
+	}
+      else if (sec == lx_info->rel_pltoff_sec)
+	{
+	  if (strip)
+	    lx_info->rel_pltoff_sec = NULL;
+	  else
+	    {
+	      relplt = TRUE;
+	      /* We use the reloc_count field as a counter if we need to
+		 copy relocs into the output file.  */
+	      sec->reloc_count = 0;
+	    }
+	}
+      else
+	{
+	  const char *name;
+
+	  /* It's OK to base decisions on the section name, because none
+	     of the dynobj section names depend upon the input files.  */
+	  name = bfd_get_section_name (dynobj, sec);
+
+	  if (strcmp (name, ".got.plt") == 0)
+	    strip = FALSE;
+	  else if (strncmp (name, ".rel", 4) == 0)
+	    {
+	      if (!strip)
+		{
+		  /* We use the reloc_count field as a counter if we need to
+		     copy relocs into the output file.  */
+		  sec->reloc_count = 0;
+		}
+	    }
+	  else
+	    continue;
+	}
+
+      if (strip)
+	sec->flags |= SEC_EXCLUDE;
+      else
+	{
+	  /* Allocate memory for the section contents.  */
+	  sec->contents = (bfd_byte *) bfd_zalloc (dynobj, sec->size);
+	  if (sec->contents == NULL && sec->size != 0)
+	    return FALSE;
+	}
+    }
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the values
+	 later (in finish_dynamic_sections) but we must add the entries now
+	 so that we get the correct size for the .dynamic section.  */
+
+      if (info->executable)
+	{
+	  /* The DT_DEBUG entry is filled in by the dynamic linker and used
+	     by the debugger.  */
+#define add_dynamic_entry(TAG, VAL) \
+  _bfd_elf_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
+
+	  if (!add_dynamic_entry (DT_DEBUG, 0))
+	    return FALSE;
+	}
+
+      if (!add_dynamic_entry (DT_PLTGOT, 0))
+	return FALSE;
+
+      if (relplt)
+	{
+	  if (!add_dynamic_entry (DT_PLTRELSZ, 0)
+	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
+	      || !add_dynamic_entry (DT_JMPREL, 0))
+	    return FALSE;
+	}
+
+      if (!add_dynamic_entry (DT_RELA, 0)
+	  || !add_dynamic_entry (DT_RELASZ, 0)
+	  || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
+	return FALSE;
+
+      if (lx_info->reltext)
+	{
+	  if (!add_dynamic_entry (DT_TEXTREL, 0))
+	    return FALSE;
+	  info->flags |= DF_TEXTREL;
+	}
+    }
+
+  return TRUE;
+}
+
+static void
+elf_lx_install_dyn_reloc (abfd, info, sec, srel, offset, type,
+			  dynindx, addend, relocate)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     asection *sec;
+     asection *srel;
+     bfd_vma offset;
+     unsigned int type;
+     long dynindx;
+     bfd_vma addend;
+     bfd_boolean *relocate;
+{
+  Elf_Internal_Rela outrel;
+
+  BFD_ASSERT (dynindx != -1);
+  outrel.r_info = ELF32_R_INFO (dynindx, type);
+  outrel.r_addend = addend;
+  outrel.r_offset = _bfd_elf_section_offset (abfd, info, sec, offset);
+  if (outrel.r_offset >= (bfd_vma) -2)
+    {
+      /* When we have a dynamic relocation against .eh_frame, but we are
+	 going to make addresses in the .eh_frame to be pc-relative, then
+	 bfd_elf_section_offset returns -2.  In this case,
+	 bfd_elf_write_section_eh_frame requires us to put the absolute
+	 address in the output section, and nullify the dynamic relocation.
+	 It will then rewrite this absolute address to be pc-relative.
+      */
+      *relocate = (outrel.r_offset == (bfd_vma) -2);
+      outrel.r_info = ELF32_R_INFO (0, R_LX_NONE);
+      outrel.r_addend = 0;
+      outrel.r_offset = 0;
+    }
+  else    
+    outrel.r_offset += sec->output_section->vma + sec->output_offset;
+
+  bfd_elf32_swap_reloca_out (abfd, &outrel,
+			     (bfd_byte *) (((Elf32_External_Rela *) 
+					    srel->contents)
+					   + srel->reloc_count++));
+  BFD_ASSERT ((srel->size > 0 
+	       && (sizeof (Elf32_External_Rela) * srel->reloc_count
+		   <= srel->size)));
+}
+
+static void
+elf_lx_install_got_static_reloc (struct bfd_link_info *info,
+				 bfd_vma got_offset, struct elf_link_hash_entry *h,
+				 unsigned int r_type,
+				 bfd_vma addend, bfd_vma value)
+{
+  struct elf_lx_link_hash_table *lx_info = elf_lx_hash_table (info);
+  asection *got_sec = lx_info->got_sec;
+  struct bfd_elf_section_data *elfsec_data = elf_section_data (got_sec);
+  unsigned int reloc_number = elfsec_data->rela.count++;
+  unsigned long symndx = STN_UNDEF;
+
+  Elf_Internal_Rela *rel = elfsec_data->relocs + reloc_number;
+  bfd_vma offset = got_offset + got_sec->output_section->vma + got_sec->output_offset;
+
+  if (h)
+    lx_info->got_rel_hash[reloc_number] = h;
+  else
+    {
+      /* For a local symbol, we do not know the symbol table index (it may not even
+	 have one), so we put the full value in the addend, and set the
+	 symbol index to undef.
+	 We could probably do better, by setting it relative to the section symbol of
+	 the output section that contains it. */
+      addend += value;
+    }
+  rel->r_info = ELF32_R_INFO (symndx, r_type);
+  rel->r_addend = addend;
+  rel->r_offset = offset;
+}
+
+/* Store an entry for target address DYN_I + ADDEND in the global offset
+   table and return the address of the linkage table entry.  */
+
+static bfd_vma
+set_got_entry (abfd, info, dyn_i, dynindx, addend, value, dyn_r_type)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     struct elf_lx_dyn_sym_info *dyn_i;
+     long dynindx;
+     bfd_vma addend;
+     bfd_vma value;
+     unsigned int dyn_r_type;
+{
+  struct elf_lx_link_hash_table *lx_info;
+  asection *got_sec;
+  bfd_boolean done;
+  bfd_vma got_offset;
+  bfd_vma value2 = 0;
+  bfd_boolean put_value = TRUE;
+  bfd_boolean put_value2 = FALSE;
+
+  lx_info = elf_lx_hash_table (info);
+  got_sec = lx_info->got_sec;
+
+  switch (dyn_r_type)
+    {
+    case R_LX_TPREL32:
+      done = dyn_i->tprel_done;
+      dyn_i->tprel_done = TRUE;
+      got_offset = dyn_i->tprel_offset;
+      break;
+    case R_LX_GOTOFF_DTPLDM_LO9:
+      /* We want a ldm ti_index structure in the GOT */
+      if (dyn_i->dtpldm_offset != lx_info->self_dtpldm_offset)
+	{
+	  done = dyn_i->dtpldm_done;
+	  dyn_i->dtpldm_done = TRUE;
+	}
+      else
+	{
+	  done = lx_info->self_dtpldm_done;
+	  lx_info->self_dtpldm_done = TRUE;
+	  dynindx = 0;
+	}
+      got_offset = dyn_i->dtpldm_offset;
+      dyn_r_type = R_LX_DTPMOD32;
+      break;
+    case R_LX_GOTOFF_DTPNDX_LO9:
+      /* We want an ndx ti_index structure in the GOT */
+      done = dyn_i->dtpndx_done;
+      dyn_i->dtpndx_done = TRUE;
+      got_offset = dyn_i->dtpndx_offset;
+      value2 = value;
+      if (info->executable && ! elf_lx_dynamic_symbol_p (dyn_i->h, info))
+	value = 1;
+      else
+	value = 0;
+      put_value2 = TRUE;
+      break;
+    default:
+      done = dyn_i->got_done;
+      dyn_i->got_done = TRUE;
+      got_offset = dyn_i->got_offset;
+      break;
+    }
+
+  BFD_ASSERT ((got_offset & 3) == 0);
+
+  if (! done)
+    {
+      unsigned int static_r_type = dyn_r_type;
+      bfd_vma static_addend = addend;
+      bfd_boolean dyn_needed;
+      bfd_boolean dummy;
+
+      dyn_needed = (info->shared
+		    || elf_lx_dynamic_symbol_p (dyn_i->h, info)
+		    || (dynindx != -1 && dyn_r_type == R_LX_FPTR32));
+
+      /* Install a dynamic relocation if needed.  */
+      if (dynindx == -1
+	  && dyn_r_type != R_LX_TPREL32
+	  && dyn_r_type != R_LX_DTPMOD32
+	  && dyn_r_type != R_LX_GOTOFF_DTPNDX_LO9)
+	{
+	  dyn_r_type = R_LX_REL32;
+	  dynindx = 0;
+	  addend = value;
+	}
+
+      if (dyn_r_type == R_LX_GOTOFF_DTPNDX_LO9)
+	{
+	  /* Create an ndx ti_index structure in the GOT */
+	  if (dyn_needed)
+            {
+              elf_lx_install_dyn_reloc (abfd, NULL, got_sec,
+                                        lx_info->rel_got_sec,
+                                        got_offset, R_LX_DTPMOD32,
+                                        dynindx, addend, &dummy);
+              put_value = FALSE;
+            }
+	  if (info->emitrelocations)
+	    elf_lx_install_got_static_reloc (info, got_offset,
+					     dyn_i->h, R_LX_DTPMOD32,
+					     static_addend, value);
+	  
+	  if (dynindx != 0)
+	    {
+	      if (dyn_needed)
+                {
+                  elf_lx_install_dyn_reloc (abfd, NULL, got_sec,
+                                            lx_info->rel_got_sec,
+                                            got_offset + 4, R_LX_DTPREL32,
+                                            dynindx, addend, &dummy);
+                  put_value2 = FALSE;
+                }
+	      if (info->emitrelocations)
+		elf_lx_install_got_static_reloc (info, got_offset + 4,
+						 dyn_i->h, R_LX_DTPREL32,
+						 static_addend, value2);
+	    }
+	}
+      else
+	{
+	  if (dyn_needed)
+            {
+              elf_lx_install_dyn_reloc (abfd, NULL, got_sec,
+                                        lx_info->rel_got_sec,
+                                        got_offset, dyn_r_type,
+                                        dynindx, addend, &dummy);
+              if (dyn_r_type != R_LX_REL32)
+                put_value = FALSE;
+            }
+	  if (info->emitrelocations)
+	    elf_lx_install_got_static_reloc (info, got_offset, dyn_i->h,
+					     static_r_type, static_addend,
+					     value);
+	}
+      if (put_value)
+        bfd_put_32 (abfd, value, got_sec->contents + got_offset);
+      if (put_value2)
+        bfd_put_32 (abfd, value2, got_sec->contents + got_offset + 4);
+    }
+  
+  /* Return the address of the global offset table entry.  */
+  value = (got_sec->output_section->vma
+	   + got_sec->output_offset
+	   + got_offset);
+
+  return value;
+}
+
+/* Fill in a function descriptor consisting of the function's code
+   address and its global pointer.  Return the descriptor's address.  */
+
+static bfd_vma
+set_fptr_entry (abfd, info, dyn_i, value)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     struct elf_lx_dyn_sym_info *dyn_i;
+     bfd_vma value;
+{
+  struct elf_lx_link_hash_table *lx_info;
+  asection *fptr_sec;
+
+  lx_info = elf_lx_hash_table (info);
+  fptr_sec = lx_info->fptr_sec;
+
+  if (!dyn_i->fptr_done)
+    {
+      dyn_i->fptr_done = 1;
+
+      /* Fill in the function descriptor.  */
+      bfd_put_32 (abfd, value, fptr_sec->contents + dyn_i->fptr_offset);
+      bfd_put_32 (abfd, _bfd_get_gp_value (abfd),
+		  fptr_sec->contents + dyn_i->fptr_offset + 4);
+    }
+
+  /* Return the descriptor's address.  */
+  value = (fptr_sec->output_section->vma
+	   + fptr_sec->output_offset
+	   + dyn_i->fptr_offset);
+
+  return value;
+}
+
+/* Fill in a PLTOFF entry consisting of the function's code address
+   and its global pointer.  Return the descriptor's address.  */
+
+static bfd_vma
+set_pltoff_entry (abfd, info, dyn_i, value, is_plt)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     struct elf_lx_dyn_sym_info *dyn_i;
+     bfd_vma value;
+     bfd_boolean is_plt;
+{
+  struct elf_lx_link_hash_table *lx_info;
+  asection *pltoff_sec;
+
+  lx_info = elf_lx_hash_table (info);
+  pltoff_sec = lx_info->pltoff_sec;
+
+  /* Don't do anything if this symbol uses a real PLT entry.  In
+     that case, we'll fill this in during finish_dynamic_symbol.  */
+  if ((! dyn_i->want_plt || is_plt)
+      && !dyn_i->pltoff_done)
+    {
+      bfd_vma gp = _bfd_get_gp_value (abfd);
+
+      /* Fill in the function descriptor.  */
+      bfd_put_32 (abfd, value, pltoff_sec->contents + dyn_i->pltoff_offset);
+      if (pic_abi_p (abfd))
+	bfd_put_32 (abfd, gp, pltoff_sec->contents + dyn_i->pltoff_offset + 4);
+
+      /* Install dynamic relocations if needed.  */
+      if (!is_plt && info->shared)
+	{
+	  bfd_boolean dummy;
+
+	  elf_lx_install_dyn_reloc (abfd, NULL, pltoff_sec,
+				    lx_info->rel_pltoff_sec,
+				    dyn_i->pltoff_offset,
+				    R_LX_REL32, 0, value, &dummy);
+	  if (pic_abi_p (abfd))
+	    elf_lx_install_dyn_reloc (abfd, NULL, pltoff_sec,
+				      lx_info->rel_pltoff_sec,
+				      dyn_i->pltoff_offset + 4,
+				      R_LX_REL32, 0, gp, &dummy);
+	}
+
+      dyn_i->pltoff_done = 1;
+    }
+
+  /* Return the descriptor's address.  */
+  value = (pltoff_sec->output_section->vma
+	   + pltoff_sec->output_offset
+	   + dyn_i->pltoff_offset);
+
+  return value;
+}
+
+/* Return the base VMA address which should be subtracted from real addresses
+   when resolving @tprel() relocation.
+   Main program TLS (whose template starts at PT_TLS p_vaddr)
+   is assigned offset round(16, PT_TLS p_align).  */
+
+static bfd_vma
+elf_lx_tprel_base (info)
+     struct bfd_link_info *info;
+{
+  asection *tls_sec = elf_hash_table (info)->tls_sec;
+
+  BFD_ASSERT (tls_sec != NULL);
+  return (tls_sec->vma - align_power ((bfd_vma) 16, tls_sec->alignment_power));
+}
+
+/* Return the base VMA address which should be subtracted from real addresses
+   when resolving @dtprel() relocation.
+   This is PT_TLS segment p_vaddr.  */
+
+static bfd_vma
+elf_lx_dtprel_base (info)
+     struct bfd_link_info *info;
+{
+  asection *tls_sec = elf_hash_table (info)->tls_sec;
+  
+  BFD_ASSERT (tls_sec != NULL);
+  return tls_sec->vma;
+}
+
+/* Called after we have determined section placement.  If sections
+   move, we'll be called again.  Provide a value for GP.  */
+
+bfd_boolean
+elf_lx_set_gp (output_bfd, info)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+{
+  /* Decide where gp should point.
+     We point it at the .got section if that exists,
+     otherwise at the lowest addressed data section. */
+  bfd_vma gp_val;
+  struct elf_lx_link_hash_table *lx_info = elf_lx_hash_table (info);
+
+  asection *got_sec = lx_info->got_sec;
+  if (got_sec)
+    gp_val = got_sec->output_section->vma;
+  else
+    {
+      bfd_vma min_vma = (bfd_vma) -1;
+      asection *os;
+      
+      for (os = output_bfd->sections; os ; os = os->next)
+	{
+	  if ((os->flags & (SEC_ALLOC | SEC_DATA))
+	      == (SEC_ALLOC | SEC_DATA)
+	      && os->size > 0)
+	    {
+	      if (os->vma < min_vma)
+		min_vma = os->vma;
+	    }
+	}
+      gp_val = min_vma;
+    }
+  _bfd_set_gp_value (output_bfd, gp_val);
+  return TRUE;
+}
+
+static void
+transform_tls_relocs (bfd *abfd,
+		      struct bfd_link_info *info, 
+		      Elf_Internal_Rela *relstart,
+		      Elf_Internal_Rela *relend,
+		      bfd_byte *contents)
+{
+  Elf_Internal_Rela *rel;
+  struct elf_lx_link_hash_table *lx_info;
+  struct elf_link_hash_entry *tls_get_addr;
+
+  if (info->shared
+      || info->relocatable)
+    /* No transformations are performed for shared libs or relocatable links */
+    return;
+
+  lx_info = elf_lx_hash_table (info);
+  tls_get_addr = elf_link_hash_lookup (&lx_info->root, "__tls_get_addr",
+				       FALSE, FALSE, TRUE);
+  for (rel = relstart; rel < relend; rel++)
+    {
+      unsigned int r_type;
+      unsigned long r_symndx;
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      r_symndx = ELF32_R_SYM (rel->r_info);
+
+      switch (r_type)
+	{
+	case R_LX_23_PCREL:
+	case R_LX_GOTOFF_DTPLDM_HI23:
+	case R_LX_GOTOFF_DTPLDM_LO9:
+	case R_LX_GOTOFF_DTPNDX_HI23:
+	case R_LX_GOTOFF_DTPNDX_LO9:
+	  {
+	    /* Any one of these could begin a TLS GD/LD sequence. */
+
+	    Elf_Internal_Rela *low_rel = NULL;
+	    Elf_Internal_Rela *high_rel = NULL;
+	    Elf_Internal_Rela *call_rel = NULL;
+	    bfd_vma low_offset = rel->r_offset;
+	    bfd_vma high_offset = rel->r_offset;
+	    bfd_vma offset;
+	    bfd_vma insn;
+	    Elf_Internal_Rela *rel2;
+	    struct elf_link_hash_entry *h = NULL;
+	    struct elf_link_hash_entry *call_h = NULL;
+
+	    for (rel2 = rel; rel2 < (rel + 3) && rel2 < relend; rel2++)
+	      {
+		unsigned int rel2_type = ELF32_R_TYPE (rel2->r_info);
+		if (rel2_type == R_LX_23_PCREL)
+		  {
+		    call_rel = rel2;
+		    call_h = symbol_for_relax (abfd, ELF32_R_SYM (rel2->r_info));
+		  }
+		else if (rel2_type == R_LX_GOTOFF_DTPLDM_LO9
+			 || rel2_type == R_LX_GOTOFF_DTPNDX_LO9)
+		  {
+		    low_rel = rel2;
+		    r_symndx = ELF32_R_SYM (rel2->r_info);
+		    h = symbol_for_relax (abfd, r_symndx);
+		  }
+		else if (rel2_type == R_LX_GOTOFF_DTPLDM_HI23
+			 || rel2_type == R_LX_GOTOFF_DTPNDX_HI23)
+		  high_rel = rel2;
+		if (rel2->r_offset < low_offset)
+		  low_offset = rel2->r_offset;
+		else if (rel2->r_offset > high_offset)
+		  high_offset = rel2->r_offset;
+	      }
+	    if (! (low_rel && high_rel && call_rel)
+		|| ! non_preemptible_def_p (h, info)
+		|| ! reloc_matching_pair (abfd, high_rel, high_rel->r_addend,
+                                          low_rel, contents)
+		|| ! INSN_IS_ADDI_R16_P(bfd_get_32 (abfd, contents + low_rel->r_offset))
+		|| ! INSN_IS_CALL_P (bfd_get_32 (abfd, contents + call_rel->r_offset))
+		|| call_h != tls_get_addr)
+	      continue;
+
+	    /* As a final check, all these operations must be in the same
+	       bundle. */
+	    for (offset = low_offset; offset < high_offset; offset += 4)
+	      {
+		insn = bfd_get_32 (abfd, contents + offset);
+		if (INSN_IS_BUNDLE_END_P (insn))
+		  break;
+	      }
+	    if (offset < high_offset)
+	      /* There is a bundle terminator separating the relocations */
+	      continue;
+
+	    /* Transformation GD/LD => LE */
+	    if (ELF32_R_TYPE (low_rel->r_info) == R_LX_GOTOFF_DTPLDM_LO9)
+	      {
+		/* Transforming LD to LE, so we want TPREL of module
+		   containing sym (i.e. main program), not TPREL of sym. */
+		r_symndx = 0;
+		low_rel->r_addend += elf_lx_dtprel_base (info);
+		high_rel->r_addend += elf_lx_dtprel_base (info);
+	      }
+
+	    low_rel->r_info = ELF32_R_INFO (r_symndx, R_LX_TPREL_LO9);
+	    insn = bfd_get_32 (abfd, contents + low_rel->r_offset);
+	    insn = (insn & ~0x3f) | 0x0d;
+	    bfd_put_32 (abfd, insn, contents + low_rel->r_offset);
+
+	    high_rel->r_info = ELF32_R_INFO (r_symndx, R_LX_TPREL_HI23);
+
+	    call_rel->r_info = ELF32_R_INFO (0, R_LX_NONE);
+	    insn = bfd_get_32 (abfd, contents + call_rel->r_offset);
+	    insn = (insn & 0x80000000) | 0;
+	    bfd_put_32 (abfd, insn, contents + call_rel->r_offset);
+	  }
+	  break;
+	case R_LX_GOTOFF_TPREL_LO9:
+	case R_LX_GOTOFF_TPREL_HI23:
+	  {
+	    /* These could begin a TLS IE sequence. */
+
+	    Elf_Internal_Rela *low_rel;
+	    Elf_Internal_Rela *high_rel;
+	    struct elf_link_hash_entry *h;
+	    bfd_vma insn;
+
+	    h = symbol_for_relax (abfd, r_symndx);
+
+	    if (rel == relend - 1
+		|| ! reloc_matching_pair (abfd, rel, rel->r_addend,
+                                          rel + 1, contents)
+		|| ! non_preemptible_def_p (h, info))
+	      continue;
+
+	    if (r_type == R_LX_GOTOFF_TPREL_LO9)
+	      {
+		low_rel = rel;
+		high_rel = rel + 1;
+	      }
+	    else
+	      {
+		high_rel = rel;
+		low_rel = rel + 1;
+	      }
+	    if (! INSN_IS_LDW_OR_LDWD_P (abfd,
+					 bfd_get_32 (abfd, contents + low_rel->r_offset)))
+	      continue;
+
+	    /* Transformation IE => LE */
+	    low_rel->r_info = ELF32_R_INFO (r_symndx, R_LX_TPREL_LO9);
+	    insn = bfd_get_32 (abfd, contents + low_rel->r_offset);
+	    /* Rewrite ldw[.d] to be add */
+	    insn = LDW_TO_ADD (insn);
+	    /* Rewrite base register as r0 */
+	    insn &= 0xffffffc0;
+
+	    bfd_put_32 (abfd, insn, contents + low_rel->r_offset);
+
+	    high_rel->r_info = ELF32_R_INFO (r_symndx, R_LX_TPREL_HI23);
+	  }
+	  break;
+	}
+    }
+}
+
+static bfd_boolean 
+elf_lx_relocate_section (
+                 bfd *output_bfd, struct bfd_link_info *info, bfd *input_bfd, 
+                 asection *input_section, bfd_byte *contents, 
+                 Elf_Internal_Rela *relocs, Elf_Internal_Sym *local_syms, 
+                 asection **local_sections)
+{
+  struct elf_lx_link_hash_table *lx_info;
+  Elf_Internal_Shdr *symtab_hdr;
+  /*   struct elf_link_hash_entry **sym_hashes; ??? worry about this */
+  Elf_Internal_Rela *rel, *relend;
+  asection *srel;
+  bfd_boolean ret_val = TRUE; /* for non-fatal errors */
+  bfd_vma gp_val;
+  struct elf_link_hash_entry **rel_hash;
+  asection *output_section;
+
+  /* sym_hashes = elf_sym_hashes (input_bfd); */
+  lx_info = elf_lx_hash_table (info);
+
+  /* Don't relocate stub sections.  */
+  if (input_section->owner == lx_info->stub_bfd)
+    return TRUE;
+
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+
+  gp_val = _bfd_get_gp_value (output_bfd);
+  srel = get_reloc_section (input_bfd, lx_info, input_section, FALSE);
+  rel = relocs;
+  relend = relocs + input_section->reloc_count;
+
+  output_section = input_section->output_section;
+  rel_hash = (elf_section_data (output_section)->rela.hashes
+	      + elf_section_data (output_section)->rela.count);
+
+  transform_tls_relocs (input_bfd, info, rel, relend, contents);
+
+  for (; rel < relend; rel++)
+    {
+      unsigned int r_type;
+      reloc_howto_type *howto;
+      unsigned long r_symndx;
+      Elf_Internal_Sym *sym;
+      struct elf_link_hash_entry *h;
+      struct elf_lx_dyn_sym_info *dyn_i;
+      bfd_vma value;
+      bfd_reloc_status_type r;
+      asection *sym_sec;
+      bfd_boolean dynamic_symbol_p;
+      bfd_boolean undef_weak_ref;
+      bfd_vma orig_r_addend;
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      /* Save the original value, before it is adjusted for a merge section. */
+      orig_r_addend = rel->r_addend;
+      if (r_type >= R_LX_max)
+	{
+	  (*_bfd_error_handler)
+	    (_("%B: unknown relocation type %d"),
+	     input_bfd, (int)r_type);
+	  bfd_set_error (bfd_error_bad_value);
+	  ret_val = FALSE;
+	  continue;
+	}
+      howto = elf32_lx_howto_table + r_type;
+      r_symndx = ELF32_R_SYM (rel->r_info);
+
+      /* A little checking, to catch relocation types
+	 that are not appropriate for the selected ABI. */
+      if (!abi_uses_reloc_p (pic_abi_p (output_bfd), r_type))
+	{
+	  (*_bfd_error_handler)
+	    (_("%B: contains relocation (%d) not appropriate for output ABI"),
+	     input_bfd, (int) r_type);
+	  ret_val = FALSE;
+	  continue;
+	}
+	     
+      /* This is a final link.  */
+      h = NULL;
+      sym = NULL;
+      sym_sec = NULL;
+      undef_weak_ref = FALSE;
+
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  /* Reloc against local symbol.  */
+          asection *msec;
+	  sym = local_syms + r_symndx;
+	  sym_sec = local_sections[r_symndx];
+          msec = sym_sec;
+	  value = _bfd_elf_rela_local_sym (output_bfd, sym, &msec, rel);
+	  if (! info->relocatable
+	      && (sym_sec->flags & SEC_MERGE) != 0
+	      && ELF_ST_TYPE (sym->st_info) == STT_SECTION
+	      && (sym_sec->sec_info_type == ELF_INFO_TYPE_MERGE))
+ 	    {
+	      struct elf_lx_local_hash_entry *loc_h;
+      
+	      loc_h = get_local_sym_hash (lx_info, input_bfd, rel, FALSE);
+	      if (loc_h && ! loc_h->sec_merge_done)
+		{
+		  struct elf_lx_dyn_sym_info *dynent;
+
+		  for (dynent = loc_h->info; dynent; dynent = dynent->next)
+		    {
+		      msec = sym_sec;
+		      dynent->addend =
+			_bfd_merged_section_offset (output_bfd, &msec,
+						    elf_section_data (msec)->sec_info,
+						    sym->st_value + dynent->addend);
+		      dynent->addend -= sym->st_value;
+		      dynent->addend += msec->output_section->vma
+					+ msec->output_offset
+					- sym_sec->output_section->vma
+					- sym_sec->output_offset;
+		    }
+		  loc_h->sec_merge_done = 1;
+		}
+	    }
+	}
+      else
+	{
+	  bfd_boolean unresolved_reloc;
+	  bfd_boolean warned;
+
+	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
+				   r_symndx, symtab_hdr, elf_sym_hashes (input_bfd),
+				   h, sym_sec, value,
+				   unresolved_reloc, warned);
+
+	  if (h->root.type == bfd_link_hash_undefweak)
+	    {
+	      undef_weak_ref = TRUE;
+	      /* (pp) modify default in order to avoid linker overflow */
+	      if (howto->pc_relative)
+		value = (input_section->output_section->vma
+			 + input_section->output_offset);
+	      
+	      else
+		value = 0;
+	    }
+	  else if (warned)
+	    continue;
+	}
+      
+      /* For relocs against symbols from removed linkonce sections,
+	 or sections discarded by a linker script, we just want the
+	 section contents zeroed.  Avoid any special processing.  */
+      if (sym_sec != NULL && elf_discarded_section (sym_sec))
+	  RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+					 rel, relend, howto, contents);
+
+      /* TB: when building a relocatable with pcrel relocs against local
+	 symbol resolved, ignore all reloc except R_LX_23_PCREL against
+	 local symbol*/
+	if (info->relocatable
+	    && (! info->relocatable_with_pcrel_resolved
+		|| ! howto->pc_relative
+		|| r_symndx >= symtab_hdr->sh_info))
+	continue;
+
+      value += rel->r_addend;
+      dynamic_symbol_p = elf_lx_dynamic_symbol_p (h, info);
+
+      switch (r_type)
+	{
+	case R_LX_NONE:
+	  continue;
+
+	case R_LX_HI23:
+	case R_LX_LO9:
+	case R_LX_16:
+	case R_LX_32:
+	case R_LX_DTPMOD32:
+	  /* These require a dynamic relocation if the symbol is
+	     dynamic or we are making a shared library. */
+	  /* clarkes: do not emit a dynamic relocation for an absolute
+	     symbol that is owned by a shared library or relocatable module - if
+	     it is absolute then it should not need relocating.  Note this differs
+	     from standard Linux behaviour for a shared library.  */
+	  if ((dynamic_symbol_p
+	       || ((info->shared || L_RELOCATABLE) && ! bfd_is_abs_section (sym_sec)))
+	      && r_symndx != 0
+	      && (input_section->flags & SEC_ALLOC) != 0
+	      && (h == NULL || ! h->non_got_ref))
+	    {
+	      /* Dynamic relocation required. */
+	      if ((output_section->flags & (SEC_CODE | SEC_READONLY)) != 0)
+		{
+		  (*_bfd_error_handler)
+		    (_("%B: dynamic relocation of non-writeable section required (reference to %s)"),
+		     input_bfd, (h != NULL) ? h->root.root.string : "local symbol");
+		  ret_val = FALSE;
+		  continue;
+		}
+	      else
+		{
+		  unsigned int dyn_r_type = r_type;
+		  long dynindx = 0;
+		  bfd_vma addend = 0;
+		  bfd_boolean relocate = FALSE;
+
+		  if (dynamic_symbol_p)
+		    {
+		      dynindx = h->dynindx;
+		      addend = rel->r_addend;
+		      value = 0;
+		    }
+		  else
+		    {
+		      switch (r_type)
+			{
+			case R_LX_32:
+			  dyn_r_type = R_LX_REL32;
+			  break;
+			case R_LX_DTPMOD32:
+			  value = 0;
+			  break;
+			default:
+			  /* We can't represent this without a dynamic symbol. */
+			  (*_bfd_error_handler)
+			    (_("%B: linking non-pic code in a shared library"),
+			     input_bfd);
+			  ret_val = FALSE;
+			  continue;
+			}
+		      addend = value;
+		    }
+
+		  elf_lx_install_dyn_reloc (output_bfd, info, input_section,
+					    srel, rel->r_offset, dyn_r_type,
+					    dynindx, addend, &relocate);
+		  if (!relocate)
+		    value = 0;
+		}
+	    }
+	  else if (r_type == R_LX_DTPMOD32)
+	    value = 1; /* Main program module number */
+	  goto default_reloc;
+
+	case R_LX_GPREL_HI23:
+	case R_LX_GPREL_LO9:
+	case R_LX_NEG_GPREL_HI23:
+	case R_LX_NEG_GPREL_LO9:
+	  if ((lx_info->transform_to_absolute
+               || bfd_is_abs_section (sym_sec))
+	      && ! info->shared
+	      && (r_type == R_LX_GPREL_HI23
+		  || r_type == R_LX_GPREL_LO9))
+	    {
+	      /* Convert the GP-relative instruction to absolute by
+		 rewriting the base register.
+	      */
+	      if (rel < (relend - 1)
+		  && reloc_matching_pair (output_bfd, rel, orig_r_addend,
+                                          rel + 1, contents))
+		{
+		  /* Handle this relocation and the next one together. */
+
+		  Elf_Internal_Rela *low_rel;
+		  Elf_Internal_Rela *high_rel;
+		  bfd_vma insn;
+
+		  if (r_type == R_LX_GPREL_LO9)
+		    {
+		      low_rel = rel;
+		      high_rel = rel + 1;
+		    }
+		  else
+		    {
+		      low_rel = rel + 1;
+		      high_rel = rel;
+		    }
+		  insn = bfd_get_32 (input_bfd, contents + low_rel->r_offset);
+		  if ((insn & 0x3f) != 0)
+		    { /* Do the transformation. */
+		      insn &= 0xffffffc0; /* Rewrite base register to be r0. */
+		      bfd_put_32 (input_bfd, insn, contents + low_rel->r_offset);
+		      low_rel->r_info = ELF32_R_INFO (r_symndx, R_LX_LO9);
+		      high_rel->r_info = ELF32_R_INFO (r_symndx, R_LX_HI23);
+#if 0
+		      (*_bfd_error_handler)
+			(_("%s: information: converting @gprel to absolute for %s"),
+			 bfd_get_filename (output_bfd),
+			 (h != NULL) ? h->root.root.string : "local symbol");
+#endif
+		    }
+		  else
+		    value -= gp_val;
+		  r = _bfd_final_link_relocate (elf32_lx_howto_table
+						+ ELF32_R_TYPE (low_rel->r_info),
+						input_bfd, input_section, contents,
+						low_rel->r_offset, value, 0);
+		  if (r == bfd_reloc_ok)
+		    {
+		      r = _bfd_final_link_relocate (elf32_lx_howto_table
+						    + ELF32_R_TYPE (high_rel->r_info),
+						    input_bfd, input_section, contents,
+						    high_rel->r_offset, value, 0);
+		    }
+		  rel++; /* We have processed the next rel */
+		  break;
+		}
+	    }
+	  if (dynamic_symbol_p)
+	    {
+	      (*_bfd_error_handler)
+		(_("%B: @gprel relocation against dynamic symbol %s"),
+		 input_bfd, h->root.root.string);
+	      ret_val = FALSE;
+	      continue;
+	    }
+	  value -= gp_val;
+	  if (r_type == R_LX_NEG_GPREL_HI23 || r_type == R_LX_NEG_GPREL_LO9)
+	    value = -value;
+	  goto default_reloc;
+
+	case R_LX_GOTOFF_HI23:
+	case R_LX_GOTOFF_LO9:
+	case R_LX_GOTOFFX_HI23:
+	case R_LX_GOTOFFX_LO9:
+	  dyn_i = get_dyn_sym_info (lx_info, h, input_bfd, rel, FALSE);
+	  value = set_got_entry (input_bfd, info, dyn_i, (h ? h->dynindx : -1),
+				 rel->r_addend, value, R_LX_32);
+	  if (lx_info->transform_to_absolute
+	      && ! info->shared)
+	    {
+	      /* Convert the GP-relative instruction to absolute by
+		 rewriting the base register.
+	      */
+	      if (rel < (relend - 1)
+		  && reloc_matching_pair (output_bfd, rel, orig_r_addend,
+                                          rel + 1, contents))
+		{
+		  /* Handle this relocation and the next one together. */
+		  Elf_Internal_Rela *low_rel;
+		  Elf_Internal_Rela *high_rel;
+		  bfd_vma insn;
+
+		  if (r_type == R_LX_GOTOFF_LO9
+		      || r_type == R_LX_GOTOFFX_LO9)
+		    {
+		      low_rel = rel;
+		      high_rel = rel + 1;
+		    }
+		  else
+		    {
+		      low_rel = rel + 1;
+		      high_rel = rel;
+		    }
+		  insn = bfd_get_32 (input_bfd, contents + low_rel->r_offset);
+		  if ((insn & 0x3f) != 0)
+		    { /* Do the transformation. */
+
+		      insn &= 0xffffffc0; /* Rewrite base register to be r0 */
+		      bfd_put_32 (input_bfd, insn, contents + low_rel->r_offset);
+		      if (info->emitrelocations)
+			{
+			  struct elf_link_hash_entry *hgot = elf_hash_table(info)->hgot;
+			  bfd_vma hgot_value = hgot->root.u.def.value
+			    + hgot->root.u.def.section->output_section->vma
+			    + hgot->root.u.def.section->output_offset;
+
+			  low_rel->r_info = ELF32_R_INFO(STN_UNDEF, R_LX_LO9);
+			  low_rel->r_addend = value - hgot_value;
+			  rel_hash[low_rel - relocs] = hgot;
+			  high_rel->r_info = ELF32_R_INFO(STN_UNDEF, R_LX_HI23);
+			  high_rel->r_addend = value - hgot_value;
+			  rel_hash[high_rel - relocs] = hgot;
+			}
+		    }
+		  else
+		    value -= gp_val;
+		  r = _bfd_final_link_relocate (elf32_lx_howto_table
+						+ ELF32_R_TYPE (low_rel->r_info),
+						input_bfd, input_section, contents,
+						low_rel->r_offset, value, 0);
+		  if (r == bfd_reloc_ok)
+		    {
+		      r = _bfd_final_link_relocate (elf32_lx_howto_table
+						    + ELF32_R_TYPE (high_rel->r_info),
+						    input_bfd, input_section, contents,
+						    high_rel->r_offset, value, 0);
+		    }
+		  rel++; /* We have processed the next rel */
+		  break;
+		}
+	    }
+	  value -= gp_val;
+	  goto default_reloc;
+
+	case R_LX_PLTOFF_HI23:
+	case R_LX_PLTOFF_LO9:
+          dyn_i = get_dyn_sym_info (lx_info, h, input_bfd, rel, FALSE);
+	  value = set_pltoff_entry (output_bfd, info, dyn_i, value, FALSE);
+	  value -= gp_val;
+	  goto default_reloc;
+
+	case R_LX_FPTR32:
+          dyn_i = get_dyn_sym_info (lx_info, h, input_bfd, rel, FALSE);
+	  if (dyn_i->want_fptr)
+	    {
+	      if (!undef_weak_ref)
+		value = set_fptr_entry (output_bfd, info, dyn_i, value);
+	    }
+	  else
+	    {
+	      long dynindx;
+	      bfd_boolean relocate = FALSE;
+
+	      /* Otherwise, we expect the dynamic linker to create
+		 the entry.  */
+
+	      if (h)
+		{
+		  if (h->dynindx != -1)
+		    dynindx = h->dynindx;
+		  else
+		    dynindx = (_bfd_elf_link_lookup_local_dynindx
+			       (info, h->root.u.def.section->owner,
+				global_sym_index (h)));
+		}
+	      else
+		{
+		  dynindx = (_bfd_elf_link_lookup_local_dynindx
+			     (info, input_bfd, (long) r_symndx));
+		}
+
+	      elf_lx_install_dyn_reloc (output_bfd, info, input_section,
+					srel, rel->r_offset, r_type,
+					dynindx, rel->r_addend, &relocate);
+	      if (!relocate) value = 0;
+	    }
+
+	  goto default_reloc;
+
+	case R_LX_GOTOFF_FPTR_HI23:
+	case R_LX_GOTOFF_FPTR_LO9:
+	  {
+	    long dynindx;
+
+	    dyn_i = get_dyn_sym_info (lx_info, h, input_bfd, rel, FALSE);
+	    if (dyn_i->want_fptr)
+	      {
+		BFD_ASSERT (h == NULL || h->dynindx == -1);
+	        if (!undef_weak_ref)
+	          value = set_fptr_entry (output_bfd, info, dyn_i, value);
+		dynindx = -1;
+	      }
+	    else
+	      {
+	        /* Otherwise, we expect the dynamic linker to create
+		   the entry.  */
+	        if (h)
+		  {
+		    if (h->dynindx != -1)
+		      dynindx = h->dynindx;
+		    else
+		      dynindx = (_bfd_elf_link_lookup_local_dynindx
+				 (info, h->root.u.def.section->owner,
+				  global_sym_index (h)));
+		  }
+		else
+		  dynindx = (_bfd_elf_link_lookup_local_dynindx
+			     (info, input_bfd, (long) r_symndx));
+		value = 0;
+	      }
+
+	    value = set_got_entry (output_bfd, info, dyn_i, dynindx,
+				   rel->r_addend, value, R_LX_FPTR32);
+	    value -= gp_val;
+	  }
+	  goto default_reloc;
+
+	case R_LX_32_PCREL:
+	  /* Install a dynamic relocation for this reloc.  */
+	  if (dynamic_symbol_p && r_symndx != 0)
+	    {
+	      bfd_boolean relocate = FALSE;
+	      BFD_ASSERT (srel != NULL);
+
+	      elf_lx_install_dyn_reloc (output_bfd, info, input_section,
+					srel, rel->r_offset, r_type,
+					h->dynindx, rel->r_addend, &relocate);
+	    }
+	  goto default_reloc;
+
+	case R_LX_23_PCREL:
+	  {
+	    bfd_vma from;
+	    bfd_signed_vma branch_offset;
+
+	    /* We should have created a PLT entry for any dynamic symbol.  */
+	    dyn_i = NULL;
+	    if (h)
+	      dyn_i = get_dyn_sym_info (lx_info, h, NULL, NULL, FALSE);
+
+	    if (dyn_i && dyn_i->want_plt2)
+	      {
+		/* Should have caught this earlier.  */
+		BFD_ASSERT (rel->r_addend == 0);
+
+		value = (lx_info->plt_sec->output_section->vma
+			 + lx_info->plt_sec->output_offset
+			 + dyn_i->plt2_offset);
+	      }
+	    else
+	      {
+		/* Since there's no PLT entry, Validate that this is
+		   locally defined.  */
+		BFD_ASSERT (undef_weak_ref || sym_sec->output_section != NULL);
+
+		/* If the symbol is undef_weak, we shouldn't be trying
+		   to call it.  There's every chance that we'd wind up
+		   with an out-of-range fixup here.  Don't bother setting
+		   any value at all.  */
+		if (undef_weak_ref)
+		  continue;
+	      }
+
+	    from = (input_section->output_section->vma
+		    + input_section->output_offset
+		    + rel->r_offset);
+	    branch_offset = (bfd_signed_vma)(value - from);
+	    if (branch_offset > MAX_FWD_BRANCH_OFFSET
+		|| branch_offset < MAX_BWD_BRANCH_OFFSET)
+	      {
+		/* The target is out of reach, so redirect the
+		   branch to the local stub for this function.
+		*/
+		struct elf_lx_stub_hash_entry *stub_entry;
+
+		stub_entry = lx_get_stub_entry (input_section, sym_sec, h,
+						rel, lx_info);
+		if (stub_entry != NULL)
+		  {
+		    value = (stub_entry->stub_offset
+			     + stub_entry->stub_sec->output_offset
+			     + stub_entry->stub_sec->output_section->vma);
+		    if (info->emitrelocations)
+		      {
+			/* Simpler version where we put the stub symbol in
+			   rel_hashes, and set the index to STN_UNDEF to prevent
+			   . */
+			rel_hash[rel - relocs] =
+			  (struct elf_link_hash_entry *)stub_entry->sh;
+
+			stub_entry->sh->root.indx = -2;
+			rel->r_info = ELF32_R_INFO(STN_UNDEF, r_type);
+		      }
+		  }
+	      }
+	  }
+	  goto default_reloc;
+
+	case R_LX_SEGREL32:
+	  {
+	    struct elf_segment_map *m;
+	    Elf_Internal_Phdr *p;
+	    
+	    /* Find the segment that contains the output_section.  */
+	    for (m = elf_tdata (output_bfd)->segment_map,
+		   p = elf_tdata (output_bfd)->phdr;
+		 m != NULL;
+		 m = m->next, p++)
+	      {
+		int i;
+		for (i = m->count - 1; i >= 0; i--)
+		  if (m->sections[i] == sym_sec->output_section)
+		    break;
+		if (i >= 0)
+		  break;
+	      }
+	    
+	    if (m == NULL)
+	      {
+		r = bfd_reloc_notsupported;
+	      }
+	    else
+	      {
+		/* The VMA of the segment is the vaddr of the associated
+		   program header.  */
+		if (value > p->p_vaddr)
+		  value -= p->p_vaddr;
+		else
+		  value = 0;
+		goto default_reloc;
+	      }
+	  }
+	  break;
+
+	case R_LX_IPLT:
+	case R_LX_JMP_SLOT:
+	  /* Install a dynamic relocation for this reloc.  */
+	  if ((dynamic_symbol_p || info->shared)
+	      && (input_section->flags & SEC_ALLOC) != 0)
+	    {
+	      BFD_ASSERT (srel != NULL);
+	      bfd_boolean relocate = FALSE;
+
+	      /* If we don't need dynamic symbol lookup, install
+		 RELATIVE relocations.  */
+	      if (! dynamic_symbol_p)
+		{
+		  unsigned int dyn_r_type;
+
+		  dyn_r_type = R_LX_REL32;
+
+		  elf_lx_install_dyn_reloc (output_bfd, info,
+					    input_section,
+					    srel, rel->r_offset,
+					    dyn_r_type, 0, value, &relocate);
+		  if (r_type == R_LX_IPLT)
+		    elf_lx_install_dyn_reloc (output_bfd, info,
+					      input_section,
+					      srel, rel->r_offset + 4,
+					      dyn_r_type, 0, gp_val, &relocate);
+		}
+	      else
+		elf_lx_install_dyn_reloc (output_bfd, info, input_section,
+					  srel, rel->r_offset, r_type,
+					  h->dynindx, rel->r_addend, &relocate);
+	    }
+
+	  howto = elf32_lx_howto_table + R_LX_32;
+	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
+					contents, rel->r_offset, value, 0);
+	  if (r == bfd_reloc_ok && r_type == R_LX_IPLT)
+	    r = _bfd_final_link_relocate (howto, input_bfd, input_section,
+					  contents, rel->r_offset + 4, gp_val,
+					  0);
+	  break;
+
+	case R_LX_LTV32:
+	default_reloc:
+	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
+					contents, rel->r_offset, value, 0);
+	  break;
+
+	case R_LX_TPREL_HI23:
+	case R_LX_TPREL_LO9:
+	case R_LX_TPREL32:
+	  value -= elf_lx_tprel_base (info);
+	  goto default_reloc;
+
+	case R_LX_DTPREL_HI23:
+	case R_LX_DTPREL_LO9:
+	case R_LX_DTPREL32:
+	  value -= elf_lx_dtprel_base (info);
+	  goto default_reloc;
+
+	case R_LX_GOTOFF_TPREL_HI23:
+	case R_LX_GOTOFF_TPREL_LO9:
+	case R_LX_GOTOFF_DTPLDM_HI23:
+	case R_LX_GOTOFF_DTPLDM_LO9:
+	case R_LX_GOTOFF_DTPNDX_HI23:
+	case R_LX_GOTOFF_DTPNDX_LO9:
+	  {
+	    int got_r_type;
+	    long dynindx = h ? h->dynindx : -1;
+	    bfd_vma r_addend = rel->r_addend;
+
+	    switch (r_type)
+	      {
+	      default:
+	      case R_LX_GOTOFF_TPREL_HI23:
+	      case R_LX_GOTOFF_TPREL_LO9:
+		if (!dynamic_symbol_p)
+		  {
+		    if (!info->shared)
+		      value -= elf_lx_tprel_base (info);
+		    else
+		      {
+			r_addend += value - elf_lx_dtprel_base (info);
+			dynindx = 0;
+		      }
+		  }
+		got_r_type = R_LX_TPREL32;
+		break;
+	      case R_LX_GOTOFF_DTPLDM_HI23:
+	      case R_LX_GOTOFF_DTPLDM_LO9:
+		if (!dynamic_symbol_p && !info->shared)
+		  value = 1;  /* Main program module number */
+		got_r_type = R_LX_GOTOFF_DTPLDM_LO9;
+		break;
+	      case R_LX_GOTOFF_DTPNDX_HI23:
+	      case R_LX_GOTOFF_DTPNDX_LO9:
+		if (!dynamic_symbol_p)
+		  {
+		    value -= elf_lx_dtprel_base (info);
+		    dynindx = 0;
+		  }
+		got_r_type = R_LX_GOTOFF_DTPNDX_LO9;
+		break;
+	      }
+	    dyn_i = get_dyn_sym_info (lx_info, h, input_bfd, rel, FALSE);
+	    value = set_got_entry (input_bfd, info, dyn_i, dynindx, r_addend,
+				   value, got_r_type);
+
+	    if (lx_info->transform_to_absolute
+		&& ! info->shared)
+	      {
+		/* Convert the GP-relative instruction to absolute by
+		   rewriting the base register.
+		*/
+		if (rel < (relend - 1)
+                    && reloc_matching_pair (output_bfd, rel, orig_r_addend,
+                                            rel + 1,
+                                            contents))
+		  {
+		    /* Handle this relocation and the next one together. */
+		    Elf_Internal_Rela *low_rel;
+		    Elf_Internal_Rela *high_rel;
+		    bfd_vma insn;
+		    
+
+		    if (r_type == R_LX_GOTOFF_TPREL_LO9
+			|| r_type == R_LX_GOTOFF_DTPLDM_LO9
+			|| r_type == R_LX_GOTOFF_DTPNDX_LO9)
+		      {
+			low_rel = rel;
+			high_rel = rel + 1;
+		      }
+		    else
+		      {
+			low_rel = rel + 1;
+			high_rel = rel;
+		      }
+		    insn = bfd_get_32 (input_bfd, contents + low_rel->r_offset);
+		    if ((insn & 0x3f) != 0)
+		      { /* Do the transformation. */
+			insn &= 0xffffffc0; /* Rewrite base register to be r0 */
+			bfd_put_32 (input_bfd, insn, contents + low_rel->r_offset);
+			if (info->emitrelocations)
+			  {
+			    struct elf_link_hash_entry *hgot = elf_hash_table(info)->hgot;
+			    bfd_vma hgot_value = hgot->root.u.def.value
+			      + hgot->root.u.def.section->output_section->vma
+			      + hgot->root.u.def.section->output_offset;
+
+			    low_rel->r_info = ELF32_R_INFO(STN_UNDEF, R_LX_LO9);
+			    low_rel->r_addend = value - hgot_value;
+			    rel_hash[low_rel - relocs] = hgot;
+			    high_rel->r_info = ELF32_R_INFO(STN_UNDEF, R_LX_HI23);
+			    high_rel->r_addend = value - hgot_value;
+			    rel_hash[high_rel - relocs] = hgot;
+			  }
+		      }
+		    else
+		      value -= gp_val;
+		    r = _bfd_final_link_relocate (elf32_lx_howto_table
+						  + ELF32_R_TYPE (low_rel->r_info),
+						  input_bfd, input_section, contents,
+						  low_rel->r_offset, value, 0);
+		    if (r == bfd_reloc_ok)
+		      {
+			r = _bfd_final_link_relocate (elf32_lx_howto_table
+						      + ELF32_R_TYPE (high_rel->r_info),
+						      input_bfd, input_section, contents,
+						      high_rel->r_offset, value, 0);
+		      }
+		    rel++; /* We have processed the next rel */
+		    break;
+		  }
+	      }
+	    else
+	      value -= gp_val;
+	    goto default_reloc;
+	  }
+
+	default:
+	  r = bfd_reloc_notsupported;
+	  break;
+	}
+
+      switch (r)
+	{
+	case bfd_reloc_ok:
+	  break;
+	  
+	case bfd_reloc_undefined:
+	  /* This can happen for global table relative relocs if
+	     __gp is undefined.  This is a panic situation so we
+	     don't try to continue.  */
+	  (*info->callbacks->undefined_symbol)
+	    (info, "__gp", input_bfd, input_section, rel->r_offset, 1);
+	  return FALSE;
+
+	case bfd_reloc_notsupported:
+	  {
+	    const char *name;
+
+	    if (h)
+	      name = h->root.root.string;
+	    else
+	      {
+		name = bfd_elf_string_from_elf_section (input_bfd,
+							symtab_hdr->sh_link,
+							sym->st_name);
+		if (name == NULL)
+		  return FALSE;
+		if (*name == '\0')
+		  name = bfd_section_name (input_bfd, input_section);
+	      }
+	    if (!(*info->callbacks->warning) (info, _("unsupported reloc"),
+					      name, input_bfd,
+					      input_section, rel->r_offset))
+	      return FALSE;
+	    ret_val = FALSE;
+	  }
+	  break;
+
+	case bfd_reloc_dangerous:
+	case bfd_reloc_outofrange:
+	case bfd_reloc_overflow:
+	default:
+	  {
+	    const char *name;
+
+	    if (h)
+	      name = h->root.root.string;
+	    else
+	      {
+		name = bfd_elf_string_from_elf_section (input_bfd,
+							symtab_hdr->sh_link,
+							sym->st_name);
+		if (name == NULL)
+		  return FALSE;
+		if (*name == '\0')
+		  name = bfd_section_name (input_bfd, input_section);
+	      }
+	    if (!(*info->callbacks->reloc_overflow) (info,
+						     (h ? &h->root : NULL),
+						     name,					     
+						     howto->name,
+						     (bfd_vma) 0,
+						     input_bfd,
+						     input_section,
+						     rel->r_offset))
+	      return FALSE;
+	    ret_val = FALSE;
+	  }
+	  break;
+	}
+    }
+
+  return ret_val;
+}
+
+static bfd_boolean elf_lx_output_arch_local_syms(
+  bfd *output_bfd,
+  struct bfd_link_info *info,
+  void *finfo ATTRIBUTE_UNUSED,
+  bfd_boolean (*func) (void *, const char *,
+		       Elf_Internal_Sym *,
+		       asection *,
+		       struct elf_link_hash_entry *) ATTRIBUTE_UNUSED)
+{
+  /* Ugly: hijack this hook to do some late GOT relocation processing.
+     It is not at all the purpose of this hook, but it happens to occur
+     at the correct stage of processing. */
+  struct elf_lx_link_hash_table *lx_info = elf_lx_hash_table (info);
+  asection *got_sec = lx_info->got_sec;
+  if (got_sec != NULL)
+    {
+      unsigned int reloc_count = got_sec->reloc_count;
+      if (reloc_count > 0)
+	{
+	  asection *output_section = got_sec->output_section;
+	  struct bfd_elf_section_data *esdo = elf_section_data (output_section);
+	  struct bfd_elf_section_data *esdg = elf_section_data (got_sec);
+	  Elf_Internal_Rela *relocs = esdg->relocs;
+	  unsigned int rel_count = esdg->rela.count;
+	  struct elf_link_hash_entry **rel_hash;
+	  
+	  rel_hash = esdo->rela.hashes + esdo->rela.count;
+	  memcpy (rel_hash, lx_info->got_rel_hash, reloc_count * sizeof (*rel_hash));
+	  free (lx_info->got_rel_hash);
+	  lx_info->got_rel_hash = NULL;
+	  if (rel_count < reloc_count)
+	    {
+	      /* We have reserved space for more relocs than we actually used.
+		 So, tidy the trailing ones so that they have a sensible offset.
+		 They will be of type R_LX_NONE.
+	      */
+	      bfd_vma last_offset;
+	      Elf_Internal_Rela *rel;
+	      
+	      if (rel_count > 0)      
+		last_offset = (relocs + rel_count - 1)->r_offset;
+	      else
+		last_offset = got_sec->output_section->vma + got_sec->output_offset;
+	      for (rel = relocs + rel_count; rel < relocs + reloc_count; rel++)
+		rel->r_offset = last_offset;
+	      elf_section_data (got_sec)->rela.count = reloc_count;
+	    }
+	  return _bfd_elf_link_output_relocs (output_bfd, output_section,
+					      _bfd_elf_single_rel_hdr (got_sec),
+					      relocs, rel_hash);
+	}
+    }
+  return TRUE;
+}
+
+static bfd_boolean
+elf_lx_gc_sweep_hook (bfd *abfd, struct bfd_link_info *link_info,
+		      asection *sec, const Elf_Internal_Rela *relocs)
+{
+  const Elf_Internal_Rela *rel, *relend;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_lx_link_hash_table *lx_info;
+
+  lx_info = elf_lx_hash_table (link_info);
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+
+  relend = relocs + sec->reloc_count;
+  for (rel = relocs; rel < relend; rel++)
+    {
+      unsigned long r_symndx;
+      unsigned int r_type;
+      struct elf_link_hash_entry *h = NULL;
+      struct elf_lx_dyn_sym_info *dyn_i;
+      struct elf_lx_dyn_reloc_entry **pp;
+      struct elf_lx_dyn_reloc_entry *p;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      if (r_symndx >= symtab_hdr->sh_info)
+	{
+	  long indx = r_symndx - symtab_hdr->sh_info;
+	  h = elf_sym_hashes (abfd)[indx];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	}
+      dyn_i = get_dyn_sym_info (lx_info, h, abfd, rel, FALSE);
+      if (dyn_i)
+	{
+	  for (pp = &dyn_i->reloc_entries; (p = *pp) != NULL; pp = &p->next)
+	    if (p->sec == sec)
+	      /* Everything must go for SEC. */
+	      *pp = p->next;
+	  r_type = ELF32_R_TYPE (rel->r_info);
+	  /* Update want_got, want_tprel, want_dtpndx, want_dtpldm counts for
+	     DYN_I. */
+	  /* Note that we do not have refcounts available for PLT requirements, so
+	     here we cannot eliminate unused PLT entries. */
+	  switch (r_type)
+	    {
+	    case R_LX_GOTOFF_FPTR_HI23:
+	    case R_LX_GOTOFF_FPTR_LO9:
+	    case R_LX_GOTOFF_HI23:
+	    case R_LX_GOTOFF_LO9:
+	    case R_LX_GOTOFFX_HI23:
+	    case R_LX_GOTOFFX_LO9:
+	      if (dyn_i->want_got > 0)
+		dyn_i->want_got--;
+	      break;
+	    case R_LX_GOTOFF_TPREL_HI23:
+	    case R_LX_GOTOFF_TPREL_LO9:
+	      if (dyn_i->want_tprel > 0)
+		dyn_i->want_tprel--;
+	      break;
+	    case R_LX_GOTOFF_DTPLDM_HI23:
+	    case R_LX_GOTOFF_DTPLDM_LO9:
+	      if (dyn_i->want_dtpldm > 0)
+		dyn_i->want_dtpldm--;
+	      break;
+	    case R_LX_GOTOFF_DTPNDX_HI23:
+	    case R_LX_GOTOFF_DTPNDX_LO9:
+	      if (dyn_i->want_dtpndx > 0)
+		dyn_i->want_dtpndx--;
+	      break;
+	    }
+	}
+    }
+  return TRUE;
+}
+
+static bfd_boolean
+elf_lx_finish_dynamic_symbol (
+			      bfd *output_bfd,
+			      struct bfd_link_info *info,
+			      struct elf_link_hash_entry *h,
+			      Elf_Internal_Sym *sym)
+{
+
+  struct elf_lx_link_hash_table *lx_info;
+  struct elf_lx_dyn_sym_info *dyn_i;
+
+  lx_info = elf_lx_hash_table (info);
+  dyn_i = get_dyn_sym_info (lx_info, h, NULL, NULL, FALSE);
+
+  /* Fill in the PLT data, if required.  */
+  if (dyn_i && dyn_i->want_plt)
+    {
+      Elf_Internal_Rela outrel;
+      bfd_byte *loc;
+      asection *plt_sec;
+      bfd_vma plt_addr, pltoff_addr, gp_val, plt_index, reloc_offset;
+      Elf32_External_Rela *rel;
+      int i;
+
+      gp_val = _bfd_get_gp_value (output_bfd);
+
+      /* Initialize the minimal PLT entry.  */
+
+      plt_index = (dyn_i->plt_offset - PLT_HEADER_SIZE) / PLT_MIN_ENTRY_SIZE;
+      plt_sec = lx_info->plt_sec;
+      loc = plt_sec->contents + dyn_i->plt_offset;
+      reloc_offset = plt_index * sizeof (Elf32_External_Rela);
+
+      const insn_sequence *template = plt_min_entry;
+      int template_size = (PLT_MIN_ENTRY_SIZE / 4);
+      for (i = 0; i < template_size; i++)
+	{
+	  bfd_vma reloc_value = 0;
+
+	  bfd_put_32 (output_bfd, template[i].opcode,
+		      loc + (4 * i));
+
+	  switch (template[i].type)
+	    {
+	    case CODE_TYPE:
+	      break;
+	    case IMM9_TYPE:
+	      reloc_value = reloc_offset;
+	      break;
+	    case IMM23_TYPE:
+	      if (template[i].reloc_type == STUB_RELOC_PCREL)
+		{
+		  reloc_value = plt_sec->output_section->vma;
+		}
+	      else if (template[i].reloc_type == STUB_RELOC_ABS)
+		{
+		  reloc_value = reloc_offset;
+		}
+	      break;
+	    default:
+	      BFD_FAIL ();
+	      return FALSE;
+	    }
+
+	  if (template[i].reloc_type != STUB_RELOC_NONE)
+	    {
+	      _bfd_final_link_relocate (elf32_lx_howto_table + template[i].r_type,
+					output_bfd, plt_sec, plt_sec->contents,
+					dyn_i->plt_offset + (4 * i), reloc_value,
+					template[i].reloc_addend);
+	    }
+	}
+
+      plt_addr = (plt_sec->output_section->vma
+		  + plt_sec->output_offset
+		  + dyn_i->plt_offset);
+      pltoff_addr = set_pltoff_entry (output_bfd, info, dyn_i, plt_addr,
+				      TRUE);
+
+      /* Initialize the FULL PLT entry, if needed.  */
+      if (dyn_i->want_plt2)
+	{
+	  bfd_vma got_entry_addr;
+	  loc = plt_sec->contents + dyn_i->plt2_offset;
+
+	  if (pic_abi_p (output_bfd))
+	    {
+	      /* PIC ABI */
+	      got_entry_addr = pltoff_addr - gp_val;
+	      template = (lx_mach_has_st240_encodings (output_bfd)
+			  ? pic_abi_plt_full_entry_st240
+			  : pic_abi_plt_full_entry_pre_st240);
+	      template_size = (PLT_FULL_ENTRY_SIZE_PIC_ABI / 4);
+	    }
+	  else
+	    {
+	      /* embedded ABI */
+	      got_entry_addr = pltoff_addr;
+	      template = (lx_mach_has_st240_encodings (output_bfd)
+			  ? embedded_abi_plt_full_entry_st240
+			  : embedded_abi_plt_full_entry_pre_st240);
+	      template_size = (PLT_FULL_ENTRY_SIZE / 4);
+
+	      if (info->shared)
+		{
+		  got_entry_addr = pltoff_addr - gp_val;
+		}
+	    }
+
+	  for (i = 0; i < template_size; i++)
+	    {
+	      bfd_vma val = template[i].opcode;
+	      if (info->shared && template[i].patch_based_reg != 0)
+		{
+		  val |= template[i].patch_based_reg;
+		}
+	      bfd_put_32 (output_bfd, val, loc + (4 * i));
+
+	      switch (template[i].type)
+		{
+		case CODE_TYPE:
+		case IMM9_TYPE:
+		case IMM23_TYPE:
+		  break;
+		default:
+		  BFD_FAIL ();
+		  return FALSE;
+		}
+
+	      if (template[i].reloc_type != STUB_RELOC_NONE)
+		{
+		  _bfd_final_link_relocate (elf32_lx_howto_table + template[i].r_type,
+					    output_bfd, plt_sec, plt_sec->contents,
+					    dyn_i->plt2_offset + (4 * i),
+					    got_entry_addr, template[i].reloc_addend);
+		}
+	    }
+
+	  /* Mark the symbol as undefined, rather than as defined in the
+	     plt section.  Leave the value alone.  */
+	  if (! h->def_regular)
+	    sym->st_shndx = SHN_UNDEF;
+	}
+
+      /* Create the dynamic relocation.  */
+      outrel.r_offset = pltoff_addr;
+      if (pic_abi_p (output_bfd))
+	outrel.r_info = ELF32_R_INFO (h->dynindx, R_LX_IPLT);
+      else
+	outrel.r_info = ELF32_R_INFO (h->dynindx, R_LX_JMP_SLOT);
+      outrel.r_addend = 0;
+
+      /* This is fun.  In the .lx.pltoff section, we've got entries
+	 that correspond both to real PLT entries, and those that
+	 happened to resolve to local symbols but need to be created
+	 to satisfy @pltoff relocations.  The .rela.lx.pltoff
+	 relocations for the real PLT should come at the end of the
+	 section, so that they can be indexed by plt entry at runtime.
+
+	 We emitted all of the relocations for the non-PLT @pltoff
+	 entries during relocate_section.  So we can consider the
+	 existing sec->reloc_count to be the base of the array of
+	 PLT relocations.  */
+
+      rel = (Elf32_External_Rela *)lx_info->rel_pltoff_sec->contents;
+      rel += lx_info->rel_pltoff_sec->reloc_count;
+
+      bfd_elf32_swap_reloca_out (output_bfd, &outrel, (bfd_byte *) (rel + plt_index));
+    }
+
+  {
+    /* Create a COPY relocation, if required. */
+    struct elf_lx_link_hash_entry *lx_h = (struct elf_lx_link_hash_entry *)h;
+    bfd_boolean dummy;
+
+    if (lx_h->rel_dynbss_allocated)
+      elf_lx_install_dyn_reloc (output_bfd, info,
+				h->root.u.def.section,
+				lx_info->rel_dynbss_sec,
+				h->root.u.def.value,
+				R_LX_COPY,
+				h->dynindx,
+				0,
+				&dummy);
+  }
+
+  /* Mark some specially defined symbols as absolute.  */
+  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
+      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0
+      || strcmp (h->root.root.string, "_PROCEDURE_LINKAGE_TABLE_") == 0)
+    sym->st_shndx = SHN_ABS;
+
+  return TRUE;
+}
+
+static bfd_boolean
+elf_lx_finish_dynamic_sections (
+				bfd *abfd,
+				struct bfd_link_info *info)
+{
+  struct elf_lx_link_hash_table *lx_info;
+  bfd *dynobj;
+
+  lx_info = elf_lx_hash_table (info);
+  dynobj = lx_info->root.dynobj;
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      Elf32_External_Dyn *dyncon, *dynconend;
+      asection *sdyn;
+      bfd_vma gp_val;
+
+      sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
+      BFD_ASSERT (sdyn != NULL);
+      dyncon = (Elf32_External_Dyn *) sdyn->contents;
+      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
+
+      gp_val = _bfd_get_gp_value (abfd);
+
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  Elf_Internal_Dyn dyn;
+
+	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
+
+	  switch (dyn.d_tag)
+	    {
+	    case DT_PLTGOT:
+	      dyn.d_un.d_ptr = gp_val;
+	      break;
+
+	    case DT_PLTRELSZ:
+	      dyn.d_un.d_val = (lx_info->minplt_entries
+				* sizeof (Elf32_External_Rela));
+	      break;
+
+	    case DT_JMPREL:
+	      /* See the comment above in finish_dynamic_symbol.  */
+	      dyn.d_un.d_ptr = (lx_info->rel_pltoff_sec->output_section->vma
+				+ lx_info->rel_pltoff_sec->output_offset
+				+ (lx_info->rel_pltoff_sec->reloc_count
+				   * sizeof (Elf32_External_Rela)));
+	      break;
+
+	    case DT_RELASZ:
+	      /* Do not have RELASZ include JMPREL.  This makes things
+		 easier on ld.so.  This is not what the rest of BFD set up.  */
+	      dyn.d_un.d_val -= (lx_info->minplt_entries
+				 * sizeof (Elf32_External_Rela));
+	      break;
+	    }
+
+	  bfd_elf32_swap_dyn_out (abfd, &dyn, dyncon);
+	}
+
+      /* Initialize the PLT0 entry */
+      if (lx_info->plt_sec)
+	{
+	  bfd_byte *loc = lx_info->plt_sec->contents;
+	  int i;
+	  const insn_sequence *template;
+	  int template_size;
+
+	  if (pic_abi_p (abfd))
+	    {
+	      template = (lx_mach_has_st240_encodings (abfd)
+			  ? pic_abi_plt_header_st240
+			  : pic_abi_plt_header_pre_st240);
+	      template_size = (PLT_HEADER_SIZE / 4);
+	    }
+	  else
+	    { /* embedded ABI */
+	      if (info->shared)
+		{
+		  template = (lx_mach_has_st240_encodings (abfd)
+			      ? embedded_abi_plt_header_st240
+			      : embedded_abi_plt_header_pre_st240);
+		  template_size = (PLT_HEADER_SIZE / 4);
+		}
+	      else
+		{
+		  template = (lx_mach_has_st240_encodings (abfd)
+			      ? embedded_abi_absolute_plt_header_st240
+			      : embedded_abi_absolute_plt_header_pre_st240);
+		  template_size = (PLT_HEADER_SIZE / 4);
+		}
+	    }
+
+	  for (i = 0; i < template_size; i++)
+	    {
+	      bfd_put_32 (abfd, template[i].opcode, loc + (4 * i));
+
+	      switch (template[i].type)
+		{
+		case CODE_TYPE:
+		case IMM9_TYPE:
+		case IMM23_TYPE:
+		  break;
+		default:
+		  BFD_FAIL ();
+		  return FALSE;
+		}
+
+	      if (template[i].reloc_type != STUB_RELOC_NONE)
+		{
+		  _bfd_final_link_relocate (elf32_lx_howto_table
+					    + template[i].r_type,
+					    abfd, lx_info->plt_sec,
+					    lx_info->plt_sec->contents,
+					    (4 * i),
+					    gp_val,
+					    template[i].reloc_addend);
+		}
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+void
+bfd_elf32_lx_set_transform_to_absolute (struct bfd_link_info *info,
+					bfd_boolean value)
+{
+  elf_lx_hash_table(info)->transform_to_absolute = value;
+}
+
+/* Return true if SYM represents a local label symbol. */
+
+static bfd_boolean
+lx_elf_is_local_label_name(
+			   bfd *abfd ATTRIBUTE_UNUSED,
+			   const char *name)
+{
+  return ((name[0] == '.' && name[1] == 'L') || 
+	  (name[0] == 'L' && name[1] == '?') ||
+	  (name[0] == '_' && name[1] == '?') ||
+	  (name[0] == '?') ||
+	  (name[0] == '$'));
+}
+
+/* 
+   Merge backend specific data from an object file to the output
+   object file when linking  -- we just use it to check object file
+ consistency -- we could also check lxbe vs. multiflow here 
+ see elf32-ppc.c for an example
+*/
+int first_core = 1;
+int first_cut = 1;
+int first_abi = 1;
+int first_osabi = 1;
+int first_code_generation_mode = 1;
+
+
+static bfd_boolean
+lx_elf_merge_private_bfd_data (
+			       bfd *ibfd,
+			       bfd *obfd)
+{
+  flagword input_flags;
+  flagword output_flags;
+  Elf_Internal_Ehdr * input_ehdrp;
+  Elf_Internal_Ehdr * output_ehdrp;
+
+  /* Check if we have the same endianess */
+
+  if (ibfd->xvec->byteorder != obfd->xvec->byteorder
+      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
+/* (pp) allow linking with other formats */
+      && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
+     )
+    {
+      (*_bfd_error_handler)
+	(_("%s: compiled for a %s endian system and target is %s endian"),
+	 bfd_get_filename (ibfd),
+	 bfd_big_endian (ibfd) ? "big" : "little",
+	 bfd_big_endian (obfd) ? "big" : "little");
+
+      bfd_set_error (bfd_error_wrong_format);
+      return FALSE;
+    }
+
+#if 0
+  lx_bfd_flags old_flags;
+  lx_bfd_flags new_flags;
+  new_flags.f = elf_elfheader (ibfd)->e_flags;
+  old_flags.f = elf_elfheader (obfd)->e_flags;
+  if (!elf_flags_init (obfd))	/* First call, no flags set */
+    {
+      elf_flags_init (obfd) = TRUE;
+      elf_elfheader (obfd)->e_flags = new_flags.f;
+    }
+
+  else if (new_flags.f == old_flags.f)	
+  	/* Same flags: always ok */
+    ;
+  else 
+    {
+      unsigned int old_rta = old_flags.obj_compat.rta;
+      unsigned int new_rta = new_flags.obj_compat.rta;
+      if (old_rta && new_rta && old_rta != new_rta)
+        {
+          (*_bfd_error_handler)(
+	      _("%s: uses different e_flags [%x] (rta:%d) fields "
+	      "than previous modules [%x] (rta:%d)"),
+	      bfd_get_filename (ibfd), 
+	      new_flags.f, new_flags.obj_compat.rta, 
+	      old_flags.f, old_flags.obj_compat.rta);
+          bfd_set_error(bfd_error_bad_value);
+          return FALSE;
+        }
+    }
+#endif
+
+  input_flags = lx_elf_get_private_flags(ibfd);
+  output_flags = lx_elf_get_private_flags(obfd);
+  input_ehdrp = elf_elfheader (ibfd);
+  output_ehdrp = elf_elfheader (obfd);
+
+  if (!elf_flags_init (obfd)) {  /* First call, no flags set */
+    lx_elf_set_private_flags (obfd, input_flags);
+    output_ehdrp->e_ident[EI_ABIVERSION] = input_ehdrp->e_ident[EI_ABIVERSION] ;
+    output_ehdrp->e_ident[EI_OSABI] = input_ehdrp->e_ident[EI_OSABI] ;
+    return TRUE;
+  }
+ 
+  if (strcmp(core_printable_name(input_flags),core_printable_name(output_flags)))
+  {
+    flagword input_core;
+    flagword output_core;
+
+    input_core = (input_flags & ELF_LX_CORE_MASK);
+    output_core = (output_flags & ELF_LX_CORE_MASK);
+  
+    /* This assumes that ST240 is the breaking point of compatibility */ 
+    if( ((input_core < ELF_LX_CORE_ST240) && (output_core>=ELF_LX_CORE_ST240)) ||
+        ((output_core < ELF_LX_CORE_ST240) && (input_core>=ELF_LX_CORE_ST240)))  {
+	    (*_bfd_error_handler)("cannot mix cores : %s (%s) and %s (%s)", 
+				  bfd_get_filename (ibfd), core_printable_name(input_flags), 
+				  bfd_get_filename (obfd), core_printable_name(output_flags) );  
+	    bfd_set_error (bfd_error_wrong_format);
+	    return FALSE;
+    }
+	    
+    (*_bfd_error_handler)("warning : mixing cores : %s (%s) and %s (%s)", bfd_get_filename (ibfd), core_printable_name(input_flags), bfd_get_filename (obfd), core_printable_name(output_flags) );  
+    /* take the highest machine number */
+    if (input_core > output_core)
+	output_core = input_core;
+      output_flags = ((output_flags | ELF_LX_CORE_MASK) & output_core);
+      lx_elf_set_private_flags (obfd, output_flags);
+  }
+
+  if (strcmp(cut_printable_name(input_flags),cut_printable_name(output_flags)))
+  {
+    (*_bfd_error_handler)("warning : mixing cuts : %s (%s) and %s (%s)", bfd_get_filename (ibfd), cut_printable_name(input_flags), bfd_get_filename (obfd), cut_printable_name(output_flags) );  
+  }
+
+  if (strcmp(abi_printable_name(input_flags, input_ehdrp),abi_printable_name(output_flags, output_ehdrp)))
+  {
+    (*_bfd_error_handler)("warning : mixing abis : %s (%s) and %s (%s)", bfd_get_filename (ibfd), abi_printable_name(input_flags, input_ehdrp), bfd_get_filename (obfd), abi_printable_name(output_flags, output_ehdrp) );  
+  }
+
+  if (strcmp(osabi_printable_name(input_ehdrp),osabi_printable_name(output_ehdrp)))
+  {
+    (*_bfd_error_handler)("warning : mixing osabis : %s (%s) and %s (%s)", bfd_get_filename (ibfd), osabi_printable_name(input_ehdrp), bfd_get_filename (obfd), osabi_printable_name(output_ehdrp) );  
+  }
+
+    if (strcmp(code_generation_mode_printable_name(input_ehdrp),code_generation_mode_printable_name(output_ehdrp)))
+  {
+    (*_bfd_error_handler)("warning : mixing code generation modes : %s (%s) and %s (%s)", bfd_get_filename (ibfd), osabi_printable_name(input_ehdrp), bfd_get_filename (obfd), osabi_printable_name(output_ehdrp) );  
+  }
+
+  return TRUE;
+}
+
+static bfd_boolean
+lx_elf_print_private_bfd_data (bfd *abfd, PTR farg)
+{
+  FILE *f = (FILE *) farg;
+
+  elf_lx_dump_secinit_table(abfd, f);
+  lx_elf_dump_target_info(abfd, f);
+  return _bfd_elf_print_private_bfd_data (abfd, farg);
+}
+
+static bfd_boolean
+lx_elf_set_mach_from_flags (
+			    bfd *abfd)
+{
+  flagword flags = elf_elfheader (abfd)->e_flags;
+
+  switch (flags & ELF_LX_CORE_MASK)
+    {
+    case ELF_LX_CORE_ST210:
+      bfd_default_set_arch_mach (abfd, bfd_arch_lx, bfd_mach_st210);
+      break;
+    case ELF_LX_CORE_ST220:
+      bfd_default_set_arch_mach (abfd, bfd_arch_lx, bfd_mach_st220);
+      break;
+    case ELF_LX_CORE_ST230:
+      bfd_default_set_arch_mach (abfd, bfd_arch_lx, bfd_mach_st230);
+      break;
+    case ELF_LX_CORE_ST231:
+      bfd_default_set_arch_mach (abfd, bfd_arch_lx, bfd_mach_st231);
+      break;
+    case ELF_LX_CORE_ST240:
+      bfd_default_set_arch_mach (abfd, bfd_arch_lx, bfd_mach_st240);
+      break;
+    default:
+      return FALSE;
+    }
+  return TRUE;
+}
+
+/* We set the machine architecture from flags
+   here.  */
+
+static bfd_boolean
+lx_elf_object_p (bfd *abfd)
+{
+  return lx_elf_set_mach_from_flags (abfd);
+}
+
+
+static bfd_boolean
+lx_mach_has_interlocks (abfd)
+     bfd *abfd;
+{
+  unsigned long mach = bfd_get_mach (abfd);
+  return mach != bfd_mach_st210 && mach != bfd_mach_st220;
+}
+
+static bfd_boolean
+lx_mach_has_st240_encodings (bfd *abfd)
+{
+  unsigned long mach = bfd_get_mach (abfd);
+  return mach >= bfd_mach_st240;
+}
+
+#if 0 /* SC - currently unused, so ifdef out to avoid warnings  */
+static bfd_boolean
+lx_elf_set_flags_from_mach (
+			    bfd *abfd)
+{
+  flagword flags = elf_elfheader (abfd)->e_flags;
+  unsigned long mach = bfd_get_mach(abfd);
+
+  switch (mach)
+    {
+    case bfd_mach_st210:
+      flags = ((flags | ELF_LX_CORE_MASK) & ELF_LX_CORE_ST210);
+      lx_elf_set_private_flags (abfd, flags);
+      break;
+    case bfd_mach_st220:
+      flags = ((flags | ELF_LX_CORE_MASK) & ELF_LX_CORE_ST220);
+      lx_elf_set_private_flags (abfd, flags);
+      break;
+    case bfd_mach_st230:
+      flags = ((flags | ELF_LX_CORE_MASK) & ELF_LX_CORE_ST230);
+      lx_elf_set_private_flags (abfd, flags);
+      break;
+    case bfd_mach_st231:
+      flags = ((flags | ELF_LX_CORE_MASK) & ELF_LX_CORE_ST231);
+      lx_elf_set_private_flags (abfd, flags);
+      break;
+    case bfd_mach_st240:
+      flags = ((flags | ELF_LX_CORE_MASK) & ELF_LX_CORE_ST240);
+      lx_elf_set_private_flags (abfd, flags);
+      break;
+    default:
+      return FALSE;
+    }
+  return TRUE;
+}
+#endif
+
+/*
+ * Function to set private flags in
+ * BFD file
+ */
+static bfd_boolean
+lx_elf_set_private_flags (
+			  bfd *abfd,
+			  flagword flags)
+{
+/*  BFD_ASSERT (!elf_flags_init (abfd)
+	      || elf_elfheader (abfd)->e_flags == flags); */
+
+  elf_elfheader (abfd)->e_flags = flags;
+  elf_flags_init (abfd) = TRUE;
+  return lx_elf_set_mach_from_flags (abfd);
+}
+
+flagword 
+lx_elf_get_private_flags (bfd* abfd)
+{
+  flagword flags;
+  flags=elf_elfheader (abfd)->e_flags;
+  return flags;
+}
+
+bfd_boolean
+lx_elf_copy_private_flags (bfd* ibfd, bfd* obfd)
+{
+
+#if 0 /* DFE - TO CHECK THAT IT WORKS */
+    if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour ||
+	bfd_get_flavour (obfd) != bfd_target_elf_flavour) {
+
+	if (bfd_external_binary_mach != 0) {
+	    /* objcopy has set this to the ELF machine number obtained from
+	     * the -B xxx option
+	     */
+	    bfd_set_arch_mach(obfd, bfd_external_binary_architecture, bfd_external_binary_mach);
+	    /* reset it */
+	    bfd_external_binary_mach = 0;
+	    return lx_elf_set_flags_from_mach(obfd);
+	} else
+	    return TRUE;
+    }
+#endif
+
+    _bfd_elf_copy_obj_attributes (ibfd, obfd);
+
+    return lx_elf_set_private_flags(obfd, lx_elf_get_private_flags(ibfd));
+}
+
+const char *
+core_printable_name(flagword flags)
+{
+      switch ( flags&ELF_LX_CORE_MASK )
+        {
+        case ELF_LX_CORE_ST210: return "st210";
+        case ELF_LX_CORE_ST220: return "st220";
+        case ELF_LX_CORE_ST230: return "st230";
+        case ELF_LX_CORE_ST231: return "st231";
+        case ELF_LX_CORE_ST240: return "st240";
+        default: return "undefined core";
+        }
+}
+
+const char *
+cut_printable_name(flagword flags)
+{
+      switch ( flags&ELF_LX_CUT_MASK )
+        {
+        case ELF_LX_CUT_0: return "cut0";
+        case ELF_LX_CUT_1: return "cut1";
+        case ELF_LX_CUT_2: return "cut2";
+        case ELF_LX_CUT_3: return "cut3";
+        case ELF_LX_CUT_4: return "cut4";
+        case ELF_LX_CUT_5: return "cut5";
+        default:  return "undefined cut";
+        }
+}
+
+const char *
+abi_printable_name(flagword flags, Elf_Internal_Ehdr * i_ehdrp)
+{
+  int temp;
+/* this is a bit tricky because on solaris, the previous implementation
+   of the assembler was storing in the high end bits instead of the low
+   end bits as was done on Win32 */
+
+  temp = (flags&ELF_LX_ABI_MASK)|(flags >> _ELF_LX_RTA_BIT);
+
+/* insure compatibility between .rta and assume directive */
+  temp = temp | ((i_ehdrp->e_ident[EI_ABIVERSION])&ELF_LX_ABI_MASK);
+
+      switch ( temp )
+        {
+        case ELF_LX_ABI_NO:  return "no-abi";
+        case ELF_LX_ABI_MULTI: return "old-multiflow-abi";
+        case ELF_LX_ABI_EMBED: return "lx-embedded-abi";
+        case ELF_LX_ABI_PIC: return "pic-abi";
+        case ELF_LX_ABI_GCC: return "gcc-abi";
+	case ELF_LX_ABI_RELOC_EMBED: return "relocatable-embedded-abi";
+        default: return "undefined abi";
+        }
+}
+
+const char *
+osabi_printable_name(Elf_Internal_Ehdr * i_ehdrp)
+{
+      switch ( i_ehdrp->e_ident[EI_OSABI] )
+        {
+        case ELFOSABI_NONE: return "bare-machine";
+        case ELFOSABI_LINUX: return "linux";
+        case ELFOSABI_OS21: return "os21";
+        default: return "undefined osabi";
+        }
+}
+
+const char *
+code_generation_mode_printable_name(Elf_Internal_Ehdr * i_ehdrp)
+{
+      switch ( (i_ehdrp->e_ident[EI_ABIVERSION])&ELF_LX_MODE_MASK )
+        {
+        case ELF_LX_MODE_USER: return " user";
+        case ELF_LX_MODE_KERNEL: return "kernel";
+        default: return "undefined code generation mode";
+        }
+}
+
+void
+lx_elf_dump_target_info(bfd *abfd, FILE *writer)
+{
+  Elf_Internal_Ehdr * i_ehdrp = elf_elfheader (abfd);
+ 
+  /* (pp) dump addtional flags for elf files only */
+  if ( strstr(abfd->xvec->name,"elf")!=NULL )  /* the test is a bit dirty... */
+    {                                          /* is it worth to clean it...? */
+      flagword flags = lx_elf_get_private_flags(abfd);
+      fprintf(writer,"eflags : %x -",flags);
+
+      /* (pp) consider core info */
+      fprintf(writer," %s", core_printable_name(flags));
+
+      /* (pp) consider cut info */
+      fprintf(writer," %s", cut_printable_name(flags));
+
+      /* (pp) consider abi info */
+      fprintf(writer," %s", abi_printable_name(flags, i_ehdrp));
+
+      /* (pp) consider osabi info */
+      fprintf(writer," %s", osabi_printable_name(i_ehdrp));
+
+      /* (pp) consider code generation mode info */
+      fprintf(writer," %s", code_generation_mode_printable_name(i_ehdrp));
+    }
+}
+
+#include "secinit.h"
+
+bfd_boolean 
+elf_lx_set_secinit_table ( bfd *abfd,
+  secinit_ptr secinit_table,
+  int secinit_table_entry_nb)
+{
+  asection *sec;
+  bfd_byte *contents = NULL;
+  int sec_size;
+  int offset = 0;
+  int i = 0;
+  int j = 0;
+
+  sec = bfd_get_section_by_name (abfd, ".secinit");
+  if (!sec) goto error_return;
+  sec_size = bfd_section_size (abfd, sec);
+  if (elf_section_data (sec)->this_hdr.contents != NULL)
+    contents = elf_section_data (sec)->this_hdr.contents;
+  else
+    {
+      contents = (bfd_byte *) bfd_malloc (sec_size);
+      if (contents == NULL)
+        goto error_return;
+      if (! bfd_get_section_contents (abfd, sec, contents,
+                                      (file_ptr) 0, sec_size))
+        goto error_return;
+    }
+
+  bfd_put_32 (abfd, secinit_table_entry_nb, contents + offset);
+  offset += 4;
+
+  for (i=0; i < secinit_table_entry_nb; i ++) {
+    bfd_put_32 (abfd, secinit_table[i].type, contents + offset);
+      offset +=4;
+    switch (secinit_table[i].type) {
+    case secinit_memory_compress_enum:
+      bfd_put_32 (abfd, secinit_table[i].u.compress.vma, contents + offset);
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.compress.lma, contents + offset);
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.compress.size, contents + offset);
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.compress.compressed_size, 
+        contents + offset); offset +=4;
+      for (j=0;j<MAX_NAME_LEN;j++) {
+        bfd_put_8 (abfd, secinit_table[i].u.compress.algo_name[j], 
+          contents + offset); offset ++;
+      }
+      bfd_put_32 (abfd, secinit_table[i].u.compress.algo, contents + offset);
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.compress.status, contents + offset);
+        offset +=4;
+      break;
+    case secinit_memory_data_enum:
+      bfd_put_32 (abfd, secinit_table[i].u.copy.vma, contents + offset );
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.copy.lma, contents + offset);
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.copy.size, contents + offset);
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.copy.status, contents + offset);
+        offset +=4;
+      break;
+    case secinit_memory_bss_enum:
+      bfd_put_32 (abfd, secinit_table[i].u.clear.vma, contents + offset );
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.clear.size, contents + offset);
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.clear.status, contents + offset);
+        offset +=4;
+      break;
+    default:
+      break;
+    }
+  }
+  if (! bfd_set_section_contents (abfd, sec, contents, (file_ptr) 0, sec_size))
+    goto error_return;
+
+  return TRUE;
+
+error_return:
+  if (contents != NULL) free (contents);
+  return FALSE;
+}
+
+bfd_boolean
+elf_lx_get_secinit_table (
+  bfd *abfd,
+  secinit_ptr *secinit_table_ptr,
+  unsigned int *secinit_table_entry_nb)
+{
+  asection *sec;
+  bfd_byte *contents = NULL;
+  int sec_size;
+  int offset = 0;
+  unsigned int i = 0;
+  int j = 0;
+  secinit_ptr secinit_table;
+  int temp_entry_nb;
+
+  sec = bfd_get_section_by_name (abfd, ".secinit");
+  if (!sec) goto error_return;
+  sec_size = bfd_section_size (abfd, sec);
+  if (elf_section_data (sec)->this_hdr.contents != NULL)
+    contents = elf_section_data (sec)->this_hdr.contents;
+  else
+    {
+      contents = (bfd_byte *) bfd_malloc (sec_size);
+      if (contents == NULL)
+        goto error_return;
+      if (! bfd_get_section_contents (abfd, sec, contents,
+                                      (file_ptr) 0, sec_size))
+        goto error_return;
+    }
+
+   temp_entry_nb = bfd_get_32 (abfd, contents+offset); offset+=4;
+
+   BFD_ASSERT (temp_entry_nb >= 0);
+   *secinit_table_entry_nb = (unsigned) temp_entry_nb;
+
+  secinit_table = (secinit_ptr) bfd_malloc ((*secinit_table_entry_nb) * 
+                                             sizeof(*secinit_table));
+
+  for (i=0; i < *secinit_table_entry_nb; i ++) {
+    secinit_table[i].type = bfd_get_32 (abfd, contents+offset); offset+=4;
+    switch (secinit_table[i].type) {
+    case secinit_memory_compress_enum:
+      secinit_table[i].u.compress.vma = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.compress.lma = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.compress.size = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.compress.compressed_size = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      for (j=0;j<MAX_NAME_LEN;j++) {
+        secinit_table[i].u.compress.algo_name[j] = 
+          bfd_get_8 (abfd, contents+offset); offset++;
+      }
+      secinit_table[i].u.compress.algo = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.compress.status = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      break;
+    case secinit_memory_data_enum:
+      secinit_table[i].u.copy.vma = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.copy.lma = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.copy.size = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.copy.status = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      break;
+    case secinit_memory_bss_enum:
+      secinit_table[i].u.clear.vma = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.clear.size = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.clear.status = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      break;
+    default:
+      break;
+    }
+  }
+  *secinit_table_ptr = secinit_table;
+
+  return TRUE;
+
+error_return:
+  if (contents != NULL) free (contents);
+  return FALSE;
+}
+
+void
+elf_lx_dump_secinit_table(bfd *abfd, FILE *writer)
+{
+  secinit_ptr secinit_table;
+  unsigned int secinit_table_entry_nb;
+  unsigned int i;
+
+  if (elf_lx_get_secinit_table(abfd, &secinit_table, &secinit_table_entry_nb)) {
+
+    fprintf(writer, "Secinit table size : %d\n", secinit_table_entry_nb);
+    for (i=0; i < secinit_table_entry_nb; i ++) {
+      switch (secinit_table[i].type) {
+      case secinit_memory_compress_enum:
+      fprintf(writer, "                %8s %8s %8s %8s %8s %8s %8s\n",
+	      "vma", "lma", "size", "c_size", "algo", "algo-@", "status");
+      fprintf(writer, "Entry compress: %08x %08x %08x %08x %8s %08x %08x\n",
+             (int) secinit_table[i].u.compress.vma,
+             (int) secinit_table[i].u.compress.lma,
+             secinit_table[i].u.compress.size,
+             secinit_table[i].u.compress.compressed_size,
+             secinit_table[i].u.compress.algo_name,
+             (int) secinit_table[i].u.compress.algo,
+             secinit_table[i].u.compress.status );
+        break;
+      case secinit_memory_data_enum:
+      fprintf(writer, "                %8s %8s %8s %8s\n",
+	      "vma", "lma", "size", "status");
+      fprintf(writer, "Entry data    : %08x %08x %08x %08x\n", 
+             (int) secinit_table[i].u.copy.vma,
+             (int) secinit_table[i].u.copy.lma,
+             secinit_table[i].u.copy.size, secinit_table[i].u.copy.status );
+        break;
+      case secinit_memory_bss_enum:
+      fprintf(writer, "                %8s %8s %8s\n",
+	      "vma", "size", "status");
+      fprintf(writer, "Entry bss     : %08x %08x %08x\n", 
+             (int) secinit_table[i].u.clear.vma,
+             secinit_table[i].u.clear.size, secinit_table[i].u.clear.status );
+        break;
+      default :
+        break;
+      }
+    }
+    fprintf(writer, "\n");
+  }
+}
+
+/*
+ * Function used by objcopy during second phase of compression 
+ * handling where sections lma addresses must be updated at ELF
+ * level, taking into account compressed section sizes.
+ * Input parameters: bfd and section to look for.
+ * Output parameters (if section in compact table):  initial_lma, compress_lma,
+ * initial_size, compress_size.
+ * Return Value: (-1) if section not found in compact table, 
+ *               (0) if section found in compact table.
+ */
+int
+elf_lx_get_compact_info (bfd *abfd ATTRIBUTE_UNUSED, sec_ptr sec, 
+			 bfd_vma *initial_lma, bfd_vma *compress_lma,
+			 bfd_size_type *initial_size, 
+			 bfd_size_type *compress_size) {
+    unsigned int i;
+
+    for (i = 0; i < elf_lx_cpt_tab_nb; i ++) {
+	if (!strcmp(elf_lx_cpt_tab[i]->sec_name, sec->name) &&
+	     (elf_lx_cpt_tab[i]->initial_lma == sec->lma) &&
+	     (elf_lx_cpt_tab[i]->initial_size == sec->size)) {
+	    *initial_lma = elf_lx_cpt_tab[i]->initial_lma;
+	    *compress_lma = elf_lx_cpt_tab[i]->compress_lma;
+	    *initial_size = elf_lx_cpt_tab[i]->initial_size;
+	    *compress_size = elf_lx_cpt_tab[i]->compress_size;
+
+	    return(0);
+	}
+    }
+    /* section not found in compact table */
+    return(-1);   
+}
+
+/* Sort sections by lma.  */
+int
+elf_lx_sort_sections_by_lma (const void *arg1, const void *arg2)
+{
+  const struct elf_lx_cpt *sec1 = 
+      *(const struct elf_lx_cpt **) arg1;
+  const struct elf_lx_cpt *sec2 = 
+      *(const struct elf_lx_cpt **) arg2;
+
+  if (sec1->initial_lma < sec2->initial_lma)
+    return -1;
+  else if (sec1->initial_lma > sec2->initial_lma)
+    return 1;
+
+  printf("Warning: Two sections with the same lma during section compression\n");
+  return -1;
+}
+
+#ifdef NO_COMPRESSION_SUPPORT
+bfd_boolean
+elf_lx_secinit_compress_or_decompress(bfd *abfd ATTRIBUTE_UNUSED,
+				      bfd_boolean compress ATTRIBUTE_UNUSED, 
+                                      char *library_name ATTRIBUTE_UNUSED)
+{
+  return FALSE;
+}
+#else
+#ifdef _WIN32
+#include "dlfcn_win32.h"
+#else
+#include <dlfcn.h>
+#endif /* _WIN32 */
+
+#if DEBUG_COMPRESSION
+static void 
+elf_lx_cpt_tab_dump(struct elf_lx_cpt **tab,
+		    unsigned int nb_entries,
+		    FILE *writer)
+{
+    unsigned int i;
+
+    fprintf(writer, "Section compaction table for compression: %d\n", nb_entries);
+    fprintf(writer, "%8s %8s %8s %8s\n", "lma", "c_lma", "size","c_size");
+    for (i = 0; i < nb_entries; i++) {
+	fprintf(writer, "%08x %08x %08x %08x   Section: %s (secinit index: %d)\n",
+		(int) tab[i]->initial_lma,
+		(int) tab[i]->compress_lma,
+		(int) tab[i]->initial_size,
+		(int) tab[i]->compress_size,
+		tab[i]->sec_name,
+		tab[i]->secinit_index);
+    }
+    
+    return;
+}
+#endif
+
+bfd_boolean
+elf_lx_secinit_compress_or_decompress(bfd *abfd, bfd_boolean compress, 
+                                      char *library_name)
+{
+  secinit_ptr secinit_table;
+  unsigned int secinit_table_entry_nb;
+  asection *sec;
+  bfd_byte *contents = NULL, *output_contents = NULL;
+  const char *sec_name;
+  unsigned int sec_size, size;
+  unsigned int i, shift;
+  void *p_handle = NULL;
+  char *p_error = NULL;
+  char *compress_name = NULL;
+  char *algo_name = NULL, *prefix = NULL;
+  void (*p_compress_or_decompress)(char * algo_name, int compress,
+                       const bfd_byte * buff_in, unsigned int in_len,
+                       bfd_byte * buff_out, unsigned int * p_out_len) = NULL;
+  void (*p_compress)(const bfd_byte * buff_in, unsigned int in_len,
+		     bfd_byte * buff_out, unsigned int * p_out_len) = NULL;
+
+  if (elf_lx_get_secinit_table(abfd,
+         &secinit_table, &secinit_table_entry_nb) ) {
+#if DEBUG_COMPRESSION
+    elf_lx_dump_secinit_table(abfd, stdout);
+#endif
+    if (!secinit_table_entry_nb) return TRUE;
+
+    if (library_name == NULL) {
+	/*	p_compress_or_decompress = &compress_or_decompress;*/
+	printf("Default compression algorithms not yet implemented!\n");
+	exit(1);
+    } else {
+#ifndef __CYGWIN__
+	p_handle = dlopen(library_name,RTLD_LAZY);
+#else
+	p_handle = dlopen(library_name,RTLD_LAZY);
+#endif
+	if (!p_handle) {
+	    fputs (dlerror(), stderr);
+	    printf("\n");
+	    exit(1);
+	}
+    }
+
+    /* 
+     * Initialize the lma-ordered list of sections that have a lma != vma 
+     * We use a temporary table not ordered and allocated with the 
+     * number of entries in the secinit table.
+     */
+    elf_lx_cpt_tab_nb = 0;
+    elf_lx_cpt_tab_ = (struct elf_lx_cpt *) 
+	bfd_malloc(secinit_table_entry_nb * 
+		   sizeof(struct elf_lx_cpt));
+    if (elf_lx_cpt_tab_ == NULL) {
+	printf("Error: memory allocation failed\n");
+	goto error_return;
+    }
+
+    for (i = 0; i < secinit_table_entry_nb; i ++) {
+      for (sec = abfd->sections; sec != NULL; sec = sec->next) {
+        sec_size = bfd_section_size (abfd, sec);
+        sec_name = (char *) bfd_get_section_name(abfd, sec);
+
+        switch (secinit_table[i].type) {
+        case secinit_memory_compress_enum:
+        if (secinit_table[i].u.compress.lma == bfd_section_lma(abfd, sec) &&
+            secinit_table[i].u.compress.vma == bfd_section_vma(abfd, sec) ) {
+#if DEBUG_COMPRESSION
+	    if (compress)
+		printf("Found section to compress: %s \n", bfd_get_section_name(abfd, sec));
+	    else
+		printf("Found section to decompress: %s \n", bfd_get_section_name(abfd, sec));
+#endif
+          if (elf_section_data (sec)->this_hdr.contents != NULL)
+            contents = elf_section_data (sec)->this_hdr.contents;
+          else {
+            contents = (bfd_byte *) bfd_malloc (sec_size);
+            if (contents == NULL)
+              goto error_return;
+            if (! bfd_get_section_contents (abfd, sec, contents,
+                                      (file_ptr) 0, sec_size))
+              goto error_return;
+          }	  
+
+	  if (library_name != NULL) {
+	      if (compress)
+		  prefix = "__compress_";
+	      else
+		  prefix = "__decompress_";
+	      
+	      algo_name = secinit_table[i].u.compress.algo_name;
+	      compress_name = (char *) bfd_malloc(strlen (prefix) + 
+						  strlen(algo_name) + 1);
+	      if (compress_name == NULL) {
+		  printf("Error: memory allocation failed\n");
+		  goto error_return;
+	      }
+
+	      strcpy(compress_name, prefix);
+	      strcat(compress_name, algo_name);
+	      p_compress = dlsym(p_handle,compress_name);
+	      if ((p_error = dlerror()) != NULL)  {
+		  printf("Error looking for %s symbol in compression library: %s", algo_name, library_name);
+		  fputs(p_error, stderr);
+		  printf("\n");
+		  exit(1);
+	      }
+	  }
+
+          if (compress) {
+	      if (sec_size != secinit_table[i].u.compress.size)
+		  printf("Warning: Section size (%d) != Secinit recorded size (%d)!\n",
+			 sec_size, secinit_table[i].u.compress.size);
+	      if (secinit_table[i].u.compress.compressed_size == 0) {
+		  /* Allocate the output buffer, using the input size */
+		  output_contents = (bfd_byte *) bfd_malloc (sec_size);
+		  if (output_contents == NULL) {
+		      printf("Error: memory allocation failed\n");
+		      goto error_return;
+		  }
+
+		  if (library_name == NULL) {
+		      (*p_compress_or_decompress)(
+			   secinit_table[i].u.compress.algo_name, compress,
+			   contents, sec_size,
+			   output_contents, &size);
+		  } else {
+#if DEBUG_COMPRESSION
+		      printf("Before calling compression in shared lib: %s()\n", compress_name);
+#endif
+		      (*p_compress)(contents, sec_size, 
+				    output_contents, &size);
+#if DEBUG_COMPRESSION
+		      printf("After call to compression in shared lib: %s()\n", compress_name);
+#endif
+
+		  }
+		  if (size > sec_size)
+		      printf("Warning: Compressed size (%d) > Initial section size (%d)!\n", size, sec_size);
+
+		  secinit_table[i].u.compress.compressed_size = size;
+#if DEBUG_COMPRESSION
+		  printf("Compress section %s \n", sec_name);
+#endif
+
+		  /* Fill lma-ordered list of sections that have a lma != vma */
+		  elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].sec_name = 
+		      (char *) bfd_malloc(strlen (sec_name) + 1);
+		  if (elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].sec_name == NULL) {
+		      printf("Error: memory allocation failed\n");
+		      goto error_return;
+		  }
+		  strcpy(elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].sec_name, sec_name);
+		  elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].secinit_index = i;
+		  elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].initial_lma = 
+		      secinit_table[i].u.compress.lma;
+		  elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].compress_lma = 0;
+		  elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].initial_size = sec_size;
+		  elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].compress_size = size;
+		  elf_lx_cpt_tab_nb++;
+
+	      } else {
+#if DEBUG_COMPRESSION
+		  printf("Section already compressed %s \n", sec_name);
+#endif
+	      }
+          } else {  /* decompress */
+	      if (secinit_table[i].u.compress.compressed_size) {
+		  if (sec_size != secinit_table[i].u.compress.compressed_size)
+		      printf("Warning: Section size (%d) != Secinit recorded compressed size (%d)!\n",
+			     sec_size, secinit_table[i].u.compress.compressed_size);
+
+		  /* Allocate the output buffer, using the uncompressed size */
+		  output_contents = (bfd_byte *) bfd_malloc (
+					     secinit_table[i].u.compress.size);
+		  if (output_contents == NULL) {
+		      printf("Error: memory allocation failed\n");
+		      goto error_return;
+		  }
+
+		  if (library_name == NULL) {
+		      (*p_compress_or_decompress)(
+			   secinit_table[i].u.compress.algo_name, compress,
+			   contents, sec_size, 
+			   output_contents, &size);
+		  } else {
+#if DEBUG_COMPRESSION
+		      printf("Before calling decompression in shared lib: %s()\n", compress_name);
+#endif
+		      (*p_compress)(contents, sec_size, 
+				    output_contents, &size);
+#if DEBUG_COMPRESSION
+		      printf("After call to decompression in shared lib: %s()\n", compress_name);
+#endif
+
+		  }
+		  if (size != secinit_table[i].u.compress.size)
+		      printf("Warning: Decompressed size (%d) != Initial section size in secinit (%d)!\n", size, secinit_table[i].u.compress.size);
+		  
+		  secinit_table[i].u.compress.compressed_size = 0;
+#if DEBUG_COMPRESSION
+		  printf("Decompress section %s \n", sec_name);
+#endif
+	      } else {
+#if DEBUG_COMPRESSION
+		  printf("Section not or already decompressed %s \n", sec_name);
+#endif
+	      }
+          }
+	  if ((output_contents == NULL) || 
+	      ! bfd_set_section_contents (abfd, sec, output_contents,
+					  (file_ptr) 0, size))
+		  goto error_return;
+        }
+          break;
+        case secinit_memory_data_enum:
+	    if (compress) {
+		if (secinit_table[i].u.copy.lma == bfd_section_lma(abfd, sec) &&
+		    secinit_table[i].u.copy.vma == bfd_section_vma(abfd, sec) ) {
+#if DEBUG_COMPRESSION
+		    printf("Found section to copy: %s \n", 
+			   bfd_get_section_name(abfd, sec));
+#endif
+
+		    /* Fill lma-ordered list of sections that have a lma != vma */
+		    elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].sec_name = 
+			(char *) bfd_malloc(strlen (sec_name) + 1);
+		    if (elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].sec_name == NULL) {
+			printf("Error: memory allocation failed\n");
+			goto error_return;
+		    }
+		    strcpy(elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].sec_name, sec_name);
+		    elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].secinit_index = i;
+		    elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].initial_lma = 
+			secinit_table[i].u.copy.lma;
+		    elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].compress_lma = 0;
+		    elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].initial_size = sec_size;
+		    elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].compress_size = sec_size;
+		    elf_lx_cpt_tab_nb++;
+		} 
+	    } else {
+		printf("Decompression not yet handled!\n");
+	    }
+	  break;
+        default:
+          break;
+        }
+      }
+    }
+
+    if (elf_lx_cpt_tab_nb == 0) {
+	/* Nothing to do */
+	return TRUE;
+    }
+
+    if (compress) {
+	/* Order list of sections that have a lma != vma */
+	elf_lx_cpt_tab = (struct elf_lx_cpt **) 
+	    bfd_malloc(elf_lx_cpt_tab_nb * 
+		       sizeof (struct elf_lx_cpt *));
+	if (elf_lx_cpt_tab == NULL) {
+	    printf("Error: memory allocation failed\n");
+	    goto error_return;
+	}
+
+	for (i = 0; i < elf_lx_cpt_tab_nb; i++) {
+	    elf_lx_cpt_tab[i] = &elf_lx_cpt_tab_[i];
+	}
+	
+	qsort (elf_lx_cpt_tab, (size_t) elf_lx_cpt_tab_nb,
+	       sizeof (struct elf_lx_cpt *), elf_lx_sort_sections_by_lma);
+	
+	/* 
+	 * Compute new lma addresses taking into account compressed 
+	 * sizes of sections.
+	 * Skip first section that cannot be impacted by previous 
+	 * compressed section.
+	 */
+	shift = 0;
+	elf_lx_cpt_tab[0]->compress_lma = elf_lx_cpt_tab[0]->initial_lma;
+	for (i = 1;  i < elf_lx_cpt_tab_nb; i++) {
+	    if (elf_lx_cpt_tab[i - 1]->initial_size >= 
+		elf_lx_cpt_tab[i - 1]->compress_size) {
+		shift += (elf_lx_cpt_tab[i - 1]->initial_size -
+			  elf_lx_cpt_tab[i - 1]->compress_size);
+		elf_lx_cpt_tab[i]->compress_lma =
+		    elf_lx_cpt_tab[i]->initial_lma - shift;
+	    } else {
+		printf("Error: compressed section size bigger than initial size\n");
+		goto error_return;
+	    }	  
+	}
+
+#if DEBUG_COMPRESSION
+	printf("\n");
+	elf_lx_cpt_tab_dump(elf_lx_cpt_tab, elf_lx_cpt_tab_nb, stdout);
+	printf("\n");
+#endif
+
+	/* Update the lma address in the secinit table */
+	for (i = 0; i < elf_lx_cpt_tab_nb; i ++) {
+	    int si_index = elf_lx_cpt_tab[i]->secinit_index;
+	    
+	    switch (secinit_table[si_index].type) {
+	    case secinit_memory_compress_enum:
+		secinit_table[si_index].u.compress.lma = 
+		    elf_lx_cpt_tab[i]->compress_lma;
+		break;
+	    case secinit_memory_data_enum:
+		secinit_table[si_index].u.copy.lma =
+		    elf_lx_cpt_tab[i]->compress_lma;
+		break;
+	    default:
+		break;
+	    }
+	}
+    }
+
+    elf_lx_set_secinit_table(abfd, secinit_table, secinit_table_entry_nb);
+#if DEBUG_COMPRESSION
+    elf_lx_dump_secinit_table(abfd, stdout);
+#endif
+  }
+
+  return TRUE;
+
+error_return:
+  printf("Error: Problem while compressing/decompressing \n");
+
+  return FALSE;
+}
+#endif /* ndef NO_COMPRESSION_SUPPORT */
+
+static enum elf_reloc_type_class
+elf_lx_reloc_type_class (
+			 const Elf_Internal_Rela *rela)
+{
+  switch ((int) ELF32_R_TYPE (rela->r_info))
+    {
+    case R_LX_REL32:
+      return reloc_class_relative;
+    case R_LX_IPLT:
+    case R_LX_JMP_SLOT:
+      return reloc_class_plt;
+    case R_LX_COPY:
+      return reloc_class_copy;
+    default:
+      return reloc_class_normal;
+    }
+}
+
+/* Merge non visibility st_other attributes. Ensure that the
+   STO_MOVEABLE and STO_USED flags for Binopt are copied into h->other, 
+   even if this is not a definiton of the symbol. */
+static void
+elf_lx_merge_symbol_attribute (struct elf_link_hash_entry *h,
+			       const Elf_Internal_Sym *isym,
+			       bfd_boolean definition,
+			       bfd_boolean dynamic ATTRIBUTE_UNUSED)
+{
+  if ((isym->st_other & ~ELF_ST_VISIBILITY (-1)) != 0)
+    {
+      unsigned char other;
+
+      other = (definition ? isym->st_other : h->other);
+      other &= ~ELF_ST_VISIBILITY (-1);
+      h->other = other | ELF_ST_VISIBILITY (h->other);
+
+      if (!definition
+	  && is_STO_MOVEABLE (isym->st_other))
+	  h->other |= STO_MOVEABLE;
+
+      if (!definition
+	  && is_STO_USED (isym->st_other))
+	  h->other |= STO_USED;
+    }
+}
+
+/*specific print_symbol  */
+static const char *
+lx_elf_print_symbol_all (
+			 bfd *abfd ATTRIBUTE_UNUSED,
+			 PTR filep,
+			 asymbol *symbol)
+{
+  if (symbol->name == NULL || symbol->name [0] == '\0')
+    /* Will be treated as if lx_elf_print_symbol_all were not defined */
+    return NULL;
+  else {
+    char *name;
+    size_t len;
+    unsigned char st_other;
+    bfd_print_symbol_vandf (abfd, (PTR) filep, symbol);
+    st_other = ((elf_symbol_type *) symbol)->internal_elf_sym.st_other;
+    len = strlen (symbol->name) + strlen(" (moveable)") + strlen (" (used)") + 1;
+    name = bfd_alloc (abfd, (bfd_size_type) len);
+    memcpy (name, symbol->name, strlen (symbol->name)+1);
+    if (is_STO_MOVEABLE(st_other)) {
+      sprintf (name, "%s (moveable)", name);
+    }
+    if (is_STO_USED(st_other)) {
+      sprintf (name, "%s (used)", name);
+    }
+    return name;
+  }
+}
+
+/* What to do when ld finds relocations against symbols defined in
+   discarded sections.  */
+
+static unsigned int
+elf_lx_action_discarded (asection *sec)
+{
+  if (strcmp (".profile_info", sec->name) == 0)
+    return 0;
+
+#if 1 /* DFE */
+  /* Open64 gnu.linkonce section generation requires to not complain
+   * when a discarded section is referenced by a reloc.
+   * This is a copy of _bfd_elf_default_action_discarded() that returns
+   * PRETEND instead of COMPLAIN to avoid the warning.
+   */
+  if (sec->flags & SEC_DEBUGGING)
+    return PRETEND;
+
+  if (strcmp (".eh_frame", sec->name) == 0)
+    return 0;
+
+  if (strcmp (".gcc_except_table", sec->name) == 0)
+    return 0;
+
+  return PRETEND;
+#else
+  /* The default behavior for recent GCC version using COMDAT instead of
+   * gnu.linkonce. Not yet supported by Open64.
+   */
+  return _bfd_elf_default_action_discarded (sec);
+#endif
+}
+
+#ifndef ELF_ARCH
+#define TARGET_BIG_SYM		        bfd_elf32_lx_vec
+#define TARGET_BIG_NAME		        "elf32-lx"
+#define TARGET_LITTLE_SYM               bfd_elf32_littlelx_vec
+#define TARGET_LITTLE_NAME              "elf32-littlelx"
+#define ELF_ARCH			bfd_arch_lx
+#define ELF_MACHINE_CODE		EM_LX
+#define ELF_MACHINE_ALT1		EM_LX_OLD
+#define ELF_MAXPAGESIZE         	0x1000
+#endif /* ELF_ARCH */
+
+#define elf_backend_object_p \
+        lx_elf_object_p
+#define bfd_elf32_bfd_is_local_label_name \
+        lx_elf_is_local_label_name
+#define elf_info_to_howto \
+	lx_info_to_howto
+#define elf_info_to_howto_rel \
+        lx_info_to_howto_rel	  
+#define elf_backend_relocate_section \
+        elf_lx_relocate_section
+#define elf_backend_output_arch_local_syms \
+        elf_lx_output_arch_local_syms
+#define bfd_elf32_bfd_set_private_flags	\
+        lx_elf_set_private_flags
+#define bfd_elf32_bfd_get_private_flags \
+        lx_elf_get_private_flags
+#define bfd_elf32_bfd_merge_private_bfd_data \
+        lx_elf_merge_private_bfd_data
+#define bfd_elf32_bfd_print_private_bfd_data \
+        lx_elf_print_private_bfd_data
+#define bfd_elf32_bfd_link_hash_table_create \
+        elf_lx_hash_table_create
+#define bfd_elf32_bfd_link_hash_table_free \
+        elf_lx_hash_table_free
+#define bfd_elf32_bfd_relax_section \
+        elf_lx_relax_section
+#define elf_backend_create_dynamic_sections \
+        elf_lx_create_dynamic_sections
+#define elf_backend_check_relocs \
+        elf_lx_check_relocs
+#define elf_backend_gc_sweep_hook \
+        elf_lx_gc_sweep_hook
+#define elf_backend_adjust_dynamic_symbol \
+        elf_lx_adjust_dynamic_symbol
+#define elf_backend_size_dynamic_sections \
+        elf_lx_size_dynamic_sections
+#define elf_backend_relocate_section \
+        elf_lx_relocate_section
+#define elf_backend_finish_dynamic_symbol \
+        elf_lx_finish_dynamic_symbol
+#define elf_backend_finish_dynamic_sections \
+        elf_lx_finish_dynamic_sections
+#define elf_backend_merge_symbol_attribute \
+        elf_lx_merge_symbol_attribute
+#define elf_backend_action_discarded \
+        elf_lx_action_discarded
+
+#define elf_backend_plt_readonly	1
+#define elf_backend_want_plt_sym	0
+#define elf_backend_plt_alignment	5
+#define elf_backend_got_header_size	12
+#define elf_backend_plt_header_size	PLT_HEADER_SIZE
+#define elf_backend_want_got_plt	1
+#define elf_backend_may_use_rel_p	1
+#define elf_backend_may_use_rela_p	1
+#define elf_backend_default_use_rela_p	1
+#define elf_backend_want_dynbss		1
+#define elf_backend_copy_indirect_symbol elf_lx_hash_copy_indirect
+#define elf_backend_hide_symbol		elf_lx_hash_hide_symbol
+#define elf_backend_reloc_type_class	elf_lx_reloc_type_class
+#define elf_backend_rela_normal		1
+#define elf_backend_can_gc_sections	1
+
+#define bfd_elf32_bfd_copy_private_bfd_data    lx_elf_copy_private_flags
+
+#define elf_backend_print_symbol_all \
+  lx_elf_print_symbol_all
+
+#include "elf32-target.h"
+
+
+
diff -r -N -u binutils-2.21.51/bfd/elf32-lx.h binutils/bfd/elf32-lx.h
--- binutils-2.21.51/bfd/elf32-lx.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils/bfd/elf32-lx.h	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,64 @@
+/* ELF/LX support
+
+   This file contains ELF/LX relocation support as specified
+   in the ST200 ELF Specification, 2004.
+
+   Copyright 2004
+   Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef _ELF32_LX_H
+#define _ELF32_LX_H
+
+#include "elf-bfd.h"
+#include "elf/lx.h"
+
+void lx_elf_init_stub_bfd
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+void elf_lx_next_input_section
+  PARAMS ((struct bfd_link_info *, asection *));
+
+int elf_lx_setup_section_lists
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+bfd_boolean elf_lx_size_stubs
+  PARAMS ((bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
+	   asection * (*) PARAMS ((const char *, asection *)),
+	   void (*) PARAMS ((void))));
+
+bfd_boolean elf_lx_set_gp
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+bfd_boolean elf_lx_build_stubs
+  PARAMS ((struct bfd_link_info *));
+
+bfd_boolean elf_lx_secinit_compress_or_decompress
+  PARAMS ((bfd *, bfd_boolean, char *));
+
+int elf_lx_get_compact_info 
+  PARAMS ((bfd *, sec_ptr, bfd_vma *, bfd_vma *,
+	   bfd_size_type *, bfd_size_type *));
+
+void lx_elf_dump_target_info
+PARAMS ((bfd *, FILE *));
+
+void
+bfd_elf32_lx_set_transform_to_absolute
+  PARAMS((struct bfd_link_info *, bfd_boolean value));
+#endif /* _ELF32_LX_H */
diff -r -N -u binutils-2.21.51/bfd/elf32-lx-linux.c binutils/bfd/elf32-lx-linux.c
--- binutils-2.21.51/bfd/elf32-lx-linux.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils/bfd/elf32-lx-linux.c	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,36 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
+/* LX specific support for 32-bit Linux
+   Copyright 2000 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#define TARGET_LITTLE_SYM               bfd_elf32_littlelx_linux_vec
+#define TARGET_LITTLE_NAME              "elf32-littlelx-linux"
+#define TARGET_BIG_SYM                  bfd_elf32_lx_linux_vec
+#define TARGET_BIG_NAME                 "elf32-lx-linux"
+#define ELF_ARCH			bfd_arch_lx
+#define ELF_MACHINE_CODE		EM_LX
+#define ELF_MACHINE_ALT1		EM_LX_OLD
+#define ELF_MAXPAGESIZE			0x100000
+#define ELF_COMMONPAGESIZE              0x2000
+#define LINUX_ABI			1
+#define NO_COMPRESSION_SUPPORT          1
+
+#include "elf32-lx.c"
diff -r -N -u binutils-2.21.51/bfd/elf-bfd.h binutils/bfd/elf-bfd.h
--- binutils-2.21.51/bfd/elf-bfd.h	2011-06-14 09:27:52.000000000 +0100
+++ binutils/bfd/elf-bfd.h	2011-07-06 12:44:26.137253000 +0100
@@ -187,6 +187,15 @@
   /* Symbol is referenced by a non-GOT/non-PLT relocation.  This is
      not currently set by all the backends.  */
   unsigned int non_got_ref : 1;
+
+#ifdef IPA_LINK
+  /* Symbol was marked as having their address taken.  */
+  unsigned int address_taken : 1;
+
+  /* The internal index ipa has for this symbol */
+  long ipa_indx;
+#endif
+
   /* Symbol has a definition in a shared object.
      FIXME: There is no real need for this field if def_dynamic is never
      cleared and all places that test def_dynamic also test def_regular.  */
@@ -1762,6 +1771,8 @@
   (bfd *);
 extern bfd_boolean bfd_elf_mkcorefile
   (bfd *);
+extern char *bfd_elf_get_str_section
+  (bfd *, unsigned int); /* !ST */
 extern bfd_boolean _bfd_elf_make_section_from_shdr
   (bfd *, Elf_Internal_Shdr *, const char *, int);
 extern bfd_boolean _bfd_elf_make_section_from_phdr
diff -r -N -u binutils-2.21.51/bfd/elf.c binutils/bfd/elf.c
--- binutils-2.21.51/bfd/elf.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/bfd/elf.c	2011-07-06 12:44:26.137253000 +0100
@@ -264,7 +264,7 @@
   return abfd->xvec->_bfd_set_format[(int) bfd_object] (abfd);
 }
 
-static char *
+/* !ST static */ char *
 bfd_elf_get_str_section (bfd *abfd, unsigned int shindex)
 {
   Elf_Internal_Shdr **i_shdrp;
@@ -1507,7 +1507,7 @@
 	/* If the st_other field is not zero, print it.  */
 	st_other = ((elf_symbol_type *) symbol)->internal_elf_sym.st_other;
 
-	switch (st_other)
+	switch (ELF_ST_VISIBILITY(st_other))
 	  {
 	  case 0: break;
 	  case STV_INTERNAL:  fprintf (file, " .internal");  break;
@@ -1516,7 +1516,7 @@
 	  default:
 	    /* Some other non-defined flags are also present, so print
 	       everything hex.  */
-	    fprintf (file, " 0x%02x", (unsigned int) st_other);
+	    fprintf (file," 0x%02x",(unsigned int) st_other);
 	  }
 
 	fprintf (file, " %s", name);
diff -r -N -u binutils-2.21.51/bfd/elf-eh-frame.c binutils/bfd/elf-eh-frame.c
--- binutils-2.21.51/bfd/elf-eh-frame.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/bfd/elf-eh-frame.c	2011-07-06 12:44:26.137253000 +0100
@@ -909,9 +909,11 @@
   goto success;
 
  free_no_table:
+#if 0 /* DFE - Removed warning until Binopt relocation re-ordering fix... */
   (*info->callbacks->einfo)
     (_("%P: error in %B(%A); no .eh_frame_hdr table will be created.\n"),
      abfd, sec);
+#endif /* DFE */
   hdr_info->table = FALSE;
   if (sec_info)
     free (sec_info);
diff -r -N -u binutils-2.21.51/bfd/elflink.c binutils/bfd/elflink.c
--- binutils-2.21.51/bfd/elflink.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/bfd/elflink.c	2011-07-13 14:57:59.654841000 +0100
@@ -30,6 +30,38 @@
 #include "libiberty.h"
 #include "objalloc.h"
 
+#ifdef IPA_LINK
+#define SHN_IPA_TEXT     0xff01         /* Allocated text symbols.  */
+#define SHN_IPA_DATA     0xff02         /* Allocated data symbols.  */
+#endif
+
+#ifdef IPA_LINK
+extern int ipa_set_ndx(bfd *);
+int ld_set_ndx (bfd *);
+#pragma weak ld_set_ndx
+int
+ld_set_ndx (bfd *abfd)
+{
+#if 0
+    return 0;
+#else
+    return ipa_set_ndx(abfd);
+#endif
+}
+
+extern bfd_boolean is_ipa;
+
+extern bfd_boolean
+ipa_is_whirl(bfd *);
+
+extern void
+ipa_process_whirl_in_archive ( bfd *, bfd *);
+
+#include "ipa_bfd.h" /* [CL] needed for symbol_comdat() */
+#include "elf-bfd.h" /* [CL] needed to support comdat: need to get ipa_indx */
+
+#endif /* IPA_LINK */
+
 /* This struct is used to pass information to routines called via
    elf_link_hash_traverse which must return failure.  */
 
@@ -962,7 +994,19 @@
 
   /* This code is for coping with dynamic objects, and is only useful
      if we are doing an ELF link.  */
+#ifdef IPA_LINK
+  /* [CL] when linking with a Whirl object, we must
+   * handle the alternative target (ie opposite endianness)
+   * because Whirl objects are encoded using the host's endianness
+   * which may or may not be the target's one */
+  if (!(*bed->relocs_compatible) (abfd->xvec, info->output_bfd->xvec) &&
+      ( is_ipa && ipa_is_whirl(abfd) &&
+	!(*bed->relocs_compatible) (abfd->xvec->alternative_target, info->output_bfd->xvec)
+	)
+      )
+#else
   if (!(*bed->relocs_compatible) (abfd->xvec, info->output_bfd->xvec))
+#endif
     return TRUE;
 
   /* For merging, we only care about real symbols.  */
@@ -983,12 +1027,32 @@
   if (h->root.type == bfd_link_hash_new)
     {
       h->non_elf = 0;
+      
+#ifdef IPA_LINK
+      /*
+        For SGI intermediate WHIRL format we need to mark the
+        symbol.
+      */
+      h->ipa_indx = ld_set_ndx (abfd);
+      /* [CL] store current bfd for this symbol */
+      if (is_ipa && ipa_is_whirl(abfd))
+	h->root.ipa_bfd = abfd;
+      else
+	h->root.ipa_bfd = NULL;
+#endif
+
       return TRUE;
     }
 
   /* OLDBFD and OLDSEC are a BFD and an ASECTION associated with the
      existing symbol.  */
 
+#ifdef IPA_LINK
+  if (h->root.ipa_bfd) {
+    oldbfd = h->root.ipa_bfd;
+  } else {
+#endif
+    
   switch (h->root.type)
     {
     default:
@@ -1014,6 +1078,10 @@
       break;
     }
 
+#ifdef IPA_LINK
+  }
+#endif
+
   /* Differentiate strong and weak symbols.  */
   newweak = bind == STB_WEAK;
   oldweak = (h->root.type == bfd_link_hash_defweak
@@ -1039,12 +1107,20 @@
   olddyn = FALSE;
   if (oldbfd != NULL)
     olddyn = (oldbfd->flags & DYNAMIC) != 0;
-  else if (oldsec != NULL)
+  else {
+#ifdef IPA_LINK 
+    /* [CL] IPA sections do not contain information selected above,
+       so ignore it */
+    if (is_ipa && ipa_is_whirl(abfd))
+      oldsec = NULL;
+#endif
+    if (oldsec != NULL)
     {
       /* This handles the special SHN_MIPS_{TEXT,DATA} section
 	 indices used by MIPS ELF.  */
       olddyn = (oldsec->symbol->flags & BSF_DYNAMIC) != 0;
     }
+  }
 
   /* NEWDEF and OLDDEF indicate whether the new or old symbol,
      respectively, appear to be a definition rather than reference.  */
@@ -1428,9 +1504,10 @@
   if (newdef && olddef && newweak)
     {
       /* Don't skip new non-IR weak syms.  */
-      if (!((oldbfd->flags & BFD_PLUGIN) != 0
-	    && (abfd->flags & BFD_PLUGIN) == 0))
-	*skip = TRUE;
+      if (oldbfd != NULL)
+	if (!((oldbfd->flags & BFD_PLUGIN) != 0
+	      && (abfd->flags & BFD_PLUGIN) == 0))
+	  *skip = TRUE;
 
       /* Merge st_other.  If the symbol already has a dynamic index,
 	 but visibility says it should not be visible, turn it into a
@@ -1653,6 +1730,14 @@
 	      0, name, FALSE, collect, &bh)))
 	return FALSE;
       hi = (struct elf_link_hash_entry *) bh;
+#if 0 /* [SC] This code breaks glibc build. */
+#ifdef IPA_LINK
+      if ((flags & BSF_WEAK) != 0) {
+	hi->weakdef = h->weakdef;
+	weaks = hi;
+      }
+#endif // IPA_LINK
+#endif
     }
   else
     {
@@ -3921,6 +4006,12 @@
 	     calls the value we call the alignment.  */
 	  value = isym->st_size;
 	}
+#ifdef IPA_LINK
+      else if (isym->st_shndx == SHN_IPA_TEXT)
+        sec = bfd_whirl_text_section_ptr;
+      else if (isym->st_shndx == SHN_IPA_DATA)
+        sec = bfd_whirl_data_section_ptr;
+#endif
       else
 	{
 	  sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
@@ -3985,6 +4076,36 @@
 	    continue;
 	}
 
+#ifdef IPA_LINK
+      /* Handle the case of symbols in GNU LINK_ONCE sections
+       * in context of Open64-IPA. Without this code, a multiple
+       * define of linkonce symbols will occur.
+       */
+      if (! bfd_is_und_section (sec)) {
+	struct elf_link_hash_entry *old_h;
+	
+	old_h = elf_link_hash_lookup (elf_hash_table (info), 
+				      name, FALSE, FALSE, FALSE);
+	if (old_h != NULL) {
+	  asection *old_sec;
+	  
+	  if ((old_h->root.type == bfd_link_hash_defined) || 
+	      (old_h->root.type == bfd_link_hash_defweak)) {
+	    old_sec = old_h->root.u.def.section;
+
+	    /* [CL] support for linkonce attribute. */
+	    if (is_ipa && ipa_is_whirl(old_h->root.ipa_bfd) &&
+		(*p_symbol_linkonce)(old_h->ipa_indx)) {
+	      /* Previous symbol is in LINK ONCE section. 
+		 We discard it. */
+	      *sym_hash = old_h;
+	      continue;
+	    }
+	  }
+	}
+      }
+#endif /* IPA_LINK */
+
       /* Sanity check that all possibilities were handled.  */
       if (sec == NULL)
 	{
@@ -4322,6 +4443,22 @@
 		   old_bfd, abfd,
 		   name, (unsigned long) h->size,
 		   (unsigned long) isym->st_size);
+	      
+/* DFE */
+	      /* The size of a symbol definition is replaced by the size of
+	       * the new symbol, while the linker keeps the first
+	       * implementation
+	       * TO DO: Handle this case better and handle the case of
+	       * dynamic objects.
+	       */
+	      if (! dynamic &&
+		  (h->size != 0 && h->size != isym->st_size) &&
+		  ((h->root.type == bfd_link_hash_defined) || 
+		   (h->root.type == bfd_link_hash_defweak)) &&
+		  (ELF_ST_BIND (isym->st_info) == STB_WEAK)) {
+		/* printf("Don't change the size\n"); */
+	      } else 
+/* DFE */
 
 	      h->size = isym->st_size;
 	    }
@@ -4371,6 +4508,9 @@
 	    {
 	      if (! definition)
 		{
+#ifdef IPA_LINK
+                  if (!ipa_is_whirl(abfd))
+#endif
 		  h->ref_regular = 1;
 		  if (bind != STB_WEAK)
 		    h->ref_regular_nonweak = 1;
@@ -5083,8 +5223,13 @@
 	     something wrong with the archive.  */
 	  if (element->archive_pass != 0)
 	    {
+#ifdef IPA_LINK
+              /* Already got this obj, skip it and continue */
+              continue;
+#else
 	      bfd_set_error (bfd_error_bad_value);
 	      goto error_return;
+#endif
 	    }
 	  element->archive_pass = 1;
 
@@ -5096,6 +5241,17 @@
 	  if (!bfd_link_add_symbols (element, info))
 	    goto error_return;
 
+#ifdef IPA_LINK
+	  /* [CL] support archive elements containing Whirl
+	     instead of plain object code */
+          if (is_ipa) {
+            ld_set_cur_obj(element);
+            if (ipa_is_whirl(element)) {
+              ipa_process_whirl_in_archive(abfd, element);
+            }
+          }
+#endif
+
 	  /* If there are any new undefined symbols, we need to make
 	     another pass through the archive in order to see whether
 	     they can be defined.  FIXME: This isn't perfect, because
@@ -8622,6 +8778,16 @@
 	return TRUE;
     }
 
+#if 0  /* DFE - Fix for Codex bug #25322 */
+  /* STV_HIDDEN and STV_INTERNAL symbols must be STB_LOCAL in shared objects
+     AND executables. Currently only shared objects are handled... */ 
+  if (!finfo->info->relocatable
+      && h->dynindx == -1
+      && (ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
+	  || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL))
+      h->forced_local = 1;
+#endif /* DFE */
+
   /* Decide whether to output this symbol in this pass.  */
   if (eoinfo->localsyms)
     {
diff -r -N -u binutils-2.21.51/bfd/ipa_bfd.c binutils/bfd/ipa_bfd.c
--- binutils-2.21.51/bfd/ipa_bfd.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils/bfd/ipa_bfd.c	2007-08-21 14:14:29.497741000 +0100
@@ -0,0 +1,626 @@
+/* THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003 */
+
+#ifdef IPA_LINK
+
+#if defined(__GNUC__)
+#include <stdio.h>		/* for sys_errlist */
+#endif
+#include <stdlib.h>		/* for getenv(3) */
+#include <unistd.h>		/* for unlink(2), rmdir(2), etc. */
+
+#if defined(__CYGWIN__) || defined(_WIN32) 
+#include "libiberty.h"		/* for basename(3) */
+#else
+#include <libgen.h>		/* for basename(3) */
+#endif
+
+#include <sys/stat.h>		/* for chmod(2) */
+
+#include <fcntl.h>		/* for open(2) */
+#if defined(sun) || defined(__CYGWIN__) || defined (_WIN32)
+#include <sys/types.h>
+#include <dirent.h>
+#else
+#include <sys/dir.h>		/* for opendir(2), readdir, closedir */
+#endif
+#include <signal.h>		/* for kill(2) */
+#include <limits.h>		/* for PATH_MAX */
+#include <errno.h>
+#include <string.h>
+
+
+#include "aout/ar.h"
+
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+
+#include "ipa_bfd.h"
+
+#include "strings.h"            /* for memcopy() */
+
+#if defined(__CYGWIN__)
+#include <sys/cygwin.h>         /* [CL] for cygwin_conv_to_full_posix_path */
+#endif
+
+extern bfd_boolean is_ipa;
+
+void *(*p_ipa_open_input)(char *, off_t *, int, char**) = NULL;
+void (*p_ipa_init_link_line)(int, char **) = NULL;
+void (*p_ipa_add_link_flag)(const char*) = NULL;
+void (*p_ipa_driver)(int, char **) = NULL;
+void (*p_process_whirl64)(void *, int, void *, int, const char *) = NULL;
+int  (*p_Count_elf_external_gots)(void) = NULL;
+void (*p_ipa_insert_whirl_marker)(void) = NULL;
+void (*p_Sync_symbol_attributes)(unsigned int, unsigned int, bfd_boolean, unsigned int) = NULL;
+bfd_boolean (*p_symbol_comdat)(unsigned int) = NULL;
+bfd_boolean (*p_symbol_linkonce)(unsigned int) = NULL;
+void (*p_ipa_initialize_external_symbols)(struct external_symbols_list*) = NULL;
+
+static mode_t cmask = 0;	    /* file creation mode mask */
+
+static string_t *tmp_list = 0;
+static int tmp_list_size = 0;
+static int tmp_list_max = 0;
+string_t tmpdir = 0;
+static int tmpdir_length = 0;
+
+static bfd *p_current_bfd = NULL;
+
+string_t outfilename = "./a.out";
+
+int ipa_argc = 0;
+char ** ipa_argv = NULL;
+
+LD_IPA_OPTION ld_ipa_opt[] = {
+/************************************************/
+/*  ld_ipa_option_enum	    flag	    set */
+/************************************************/
+    {LD_IPA_SHARABLE, 	    F_NON_SHARED,   F_NON_SHARED}, 
+    {LD_IPA_DEMANGLE, 	    0,		    0}, 
+    {LD_IPA_SHOW, 	    0,		    0}, 
+    {LD_IPA_HIDES, 	    0,		    0}, 
+    {LD_IPA_TARGOS, 	    TOS_IA64_64,    0}, 
+    {LD_IPA_VERBOSE,	    0,		    0},
+    {LD_IPA_KEEP_TEMPS,	    0,		    0},
+    {LD_IPA_ISA,	    0,		    0},
+    {LD_IPA_RELOCATABLE,    0,		    0},
+    {LD_IPA_EXPORTS, 	    0,		    0}, 
+    {LD_IPA_XXXX, 	    0,		    0}
+};
+
+
+string_t
+make_temp_file_with_suffix (string_t, char);
+void
+ipa_set_def_bfd(bfd *, struct bfd_link_hash_entry *);
+void
+ipa_process_whirl_in_archive ( bfd *archive, bfd *abfd);
+
+
+	/*******************************************************
+		Function: ipa_copy_of
+
+		Allocate for and copy given string into a copy.
+
+	 *******************************************************/
+char *
+ipa_copy_of (char *str)
+{
+    register int len;
+    register char *p;
+
+    len = strlen(str) + 1;
+    p = (char *) MALLOC (len);
+    MALLOC_ASSERT (p);
+    MEMCPY (p, str, len);
+    return p;
+} /* ipa_copy_of */
+
+
+	/*******************************************************
+		Function: concat_names
+
+		Create a new string by concating 2 other strings.
+
+	 *******************************************************/
+string_t
+concat_names(const string_t name1, const string_t name2)
+{
+    char *mangled_name = NULL;
+    int len = strlen(name1)+strlen(name2)+1;
+
+    mangled_name = (char *)MALLOC(len);
+    MALLOC_ASSERT(mangled_name);
+
+    strcpy(mangled_name, name1);
+    strcat(mangled_name, name2);
+
+    return(mangled_name);
+}
+
+
+
+	/*******************************************************
+		Function: add_to_tmp_file_list
+
+		Maintain list of temp. files created so they are all
+		removed on error or when done.  Assume the first entry
+		is "tmpdir".
+
+	 *******************************************************/
+void
+add_to_tmp_file_list (string_t path)
+{
+    if (tmp_list_max == 0) {
+	tmp_list_max = DEFAULT_TMP_LIST_SIZE;
+	tmp_list = (string_t *) MALLOC (tmp_list_max * sizeof(string_t));
+	MALLOC_ASSERT (tmp_list);
+    } else if (tmp_list_size >= tmp_list_max) {
+	tmp_list_max *= 2;
+	tmp_list = (string_t *)REALLOC (tmp_list, tmp_list_max * sizeof(string_t));
+	MALLOC_ASSERT (tmp_list);
+    }
+
+    tmp_list[tmp_list_size++] = path;
+
+} /* add_to_tmp_file_list */
+
+	/*******************************************************
+		Function: make_temp_file_with_suffix
+
+		Create a unique file
+
+	 *******************************************************/
+/* create a unique file */
+string_t
+make_temp_file_with_suffix (string_t name, char suffix)
+{
+    char path[PATH_MAX];
+    int len;
+    int count = 1;
+
+    len = strlen (name);
+    if (len+4 >= PATH_MAX) {
+	fprintf(stderr,"%s %s\n","path name too long:", name);
+	exit(1);
+    }
+
+    strcpy (path, name);
+
+    if (suffix && len >= 2) {
+	/* remove the original suffix */
+	if (path[len-2] == '.') {
+	    len -= 2;
+	    path[len] = 0;
+	}
+    }
+
+    if (suffix) {
+	path[len] = '.';
+	path[len+1] = suffix;
+	path[len+2] = 0;
+    }
+
+    if (access (path, F_OK) != 0)
+	return ipa_copy_of (path);
+
+    do {
+	if (suffix)
+	    sprintf (&(path[len]), ".%d.%c", count, suffix);
+	else
+	    sprintf (&(path[len]), "%d", count);
+	count++;
+    } while (access (path, F_OK) == 0);
+
+    return ipa_copy_of (path);
+
+} /* make_temp_file_with_suffix */
+
+/* ====================================================================
+ *
+ * create_tmpdir
+ *
+ * Create a temporary directory for (1) relocatable objects generated
+ * from the backend under IPA control, (2) IR objects extracted from an
+ * archive, and (3) IR objects generated by IPA.
+ *
+ * There are three cases.  If this is a directory to be kept, because
+ * either -keep or a trace flag is specified for an IPA build, then the
+ * directory is named <outfilename>.ipakeep, and if it already exists,
+ * all files are cleared from it.  If it is a temporary directory for
+ * an IPA build, a unique name is used with the template
+ * $TMPDIR/<outfilename_with_path_stripped>.ipaXXXXXX .  For a normal link, 
+ * a temporary directory
+ * is created in the DEFAULT_TMPDIR with the name template XXXXXX.
+ *
+ * ====================================================================
+ */
+
+int
+create_tmpdir ( int tracing )
+{
+    int fixedname = is_ipa && ( ld_ipa_opt[LD_IPA_KEEP_TEMPS].flag );
+
+    /* [CL] If we have already created tmpdir, return immediately:
+       this condition occurs when extracting Whirl files from an
+       archive; in this case, create_tmpdir() is called twice:
+       first when extracting from archive, second from ipa_driver()
+    */
+    if (tmpdir) return 0;
+
+    if ( is_ipa ) {
+	if ( fixedname ) {
+	    tmpdir = concat_names ( outfilename, ".ipakeep" );
+	} else {
+	    char *tmpdir_env_var;
+	    if ((tmpdir_env_var = getenv("TMPDIR")) != NULL) {
+		char *filename;
+	        tmpdir_env_var = concat_names ( tmpdir_env_var, "/");
+		if ((filename = strrchr(outfilename, '/')) != NULL)
+		    filename++;
+		else
+		    filename = outfilename;
+		
+	        tmpdir = concat_names ( tmpdir_env_var, filename);
+	    }
+	    else
+	        tmpdir = outfilename;
+	    tmpdir = concat_names ( tmpdir, ".ipaXXXXXX" );
+	}
+    } else {
+	tmpdir = concat_names ( DEFAULT_TMPDIR, "XXXXXX" );
+    }
+#if defined(__CYGWIN__)
+    char posix_driver_directory[_POSIX_PATH_MAX] ;
+    cygwin_conv_to_full_posix_path(tmpdir, posix_driver_directory) ;
+    tmpdir = ipa_copy_of(posix_driver_directory);
+#endif
+    if ( ! fixedname ) {
+	tmpdir = mktemp ( tmpdir );
+    }
+
+    tmpdir_length = strlen ( tmpdir );
+
+    if ( cmask == 0 ) {
+	cmask = umask (0);
+	(void) umask (cmask);
+    }
+
+    if ( MKDIR (tmpdir, 0777 & ~cmask) != 0 ) {
+	if ( errno == EEXIST && fixedname ) {
+	    /* We have an old instance of this directory -- clear it out: */
+	    DIR *dirp;
+#if defined(sun) || defined(__CYGWIN__) || defined (_WIN32)
+	    struct dirent *entryp;
+#else
+	    struct direct *entryp;
+#endif
+	    char *prefix;
+
+	    dirp = opendir ( tmpdir );
+	    if ( dirp != NULL ) {
+		prefix = concat_names ( tmpdir, "/" );
+		while ( ( entryp = readdir(dirp) ) != NULL ) {
+		    /* Don't bother with names of one or two characters, e.g. '.'
+		     * and '..', since we don't create temporary files with such
+		     * names:
+		     */
+#if defined(sun) || defined(__CYGWIN__) || defined (_WIN32)
+		  if ( strlen(entryp->d_name) > 2)
+#elif defined(_DIRENT_HAVE_D_NAMLEN)
+		  if ( entryp->d_namlen > 2 )
+#else
+		  if (_D_EXACT_NAMLEN(entryp) > 2)
+#endif
+		    {
+			string_t fname = concat_names ( prefix, entryp->d_name);
+			unlink (fname);
+			FREE (fname);
+		    }
+		}
+		FREE (prefix);
+		closedir ( dirp );
+	    }
+	} else {
+    	    perror("cannot create temporary directory for code generation");
+	    return -1;
+	}
+    }
+
+    add_to_tmp_file_list ( tmpdir );
+
+    if (tracing) {
+#if 0
+      printf("Created tmp dir %s\n", tmpdir);
+#endif
+    }
+    return 0;
+
+} /* create_tmpdir */
+
+	/*******************************************************
+		Function: create_unique_file
+
+		
+
+	 *******************************************************/
+string_t
+create_unique_file (const string_t path, char suffix)
+{
+    string_t p;
+    string_t base = basename (path);
+    string_t new_path;
+    int fd;
+
+    /* length of tmpdir + basename of path and '/' between the dir
+       and the basename + null terminator */
+    p = (string_t) MALLOC (strlen(tmpdir) + strlen(base) + 2);
+    MALLOC_ASSERT (p);
+    strcpy (p, tmpdir);
+    strcat (p, "/");
+    strcat (p, base);
+    new_path = make_temp_file_with_suffix (p, suffix);
+    FREE (p);
+
+    if ((fd = creat (new_path, 0666 & ~cmask)) == -1) {
+	perror(new_path);
+	exit(1);
+    }
+
+    CLOSE (fd);
+    
+    return new_path;
+
+} /* create_unique_file */
+
+
+	/*******************************************************
+		Function: create_unique_file_in_curdir
+                [CL] do not create file in tmpdir, but in
+                current directory. Useful for cleanup		
+
+	 *******************************************************/
+string_t
+create_unique_file_in_curdir (const string_t path, char suffix)
+{
+    string_t p;
+    string_t base = basename (path);
+    string_t new_path;
+    int fd;
+
+    /* length of tmpdir + basename of path and '/' between the dir
+       and the basename + null terminator */
+    p = (string_t) MALLOC (strlen(base) + 2);
+    MALLOC_ASSERT (p);
+    strcpy (p, base);
+    new_path = make_temp_file_with_suffix (p, suffix);
+    FREE (p);
+
+    if ((fd = creat (new_path, 0666 & ~cmask)) == -1) {
+	perror(new_path);
+	exit(1);
+    }
+
+    CLOSE (fd);
+    
+    return new_path;
+
+} /* create_unique_file_in_curdir */
+
+
+
+	/*******************************************************
+		Function: ipa_set_ndx
+
+		This field cannot be used beyond
+		the pass1 phase.
+	 *******************************************************/
+int
+ipa_set_ndx (bfd *abfd)
+{
+    if (ipa_is_whirl(abfd))
+      	return WHIRL_ST_IDX_UNINITIALIZED;
+    else
+      	return WHIRL_ST_IDX_NOT_AVAILABLE;
+}
+
+	/*******************************************************
+		Function: ipa_set_def_bfd
+
+
+	 *******************************************************/
+void
+ipa_set_def_bfd(bfd *abfd, struct bfd_link_hash_entry *p_bfd_hash)
+{
+    if (is_ipa)
+    	p_bfd_hash->u.def.section = (asection *)abfd;
+}
+
+	/*******************************************************
+		Function: ld_set_cur_bfd
+
+
+	 *******************************************************/
+void 
+ld_set_cur_obj(bfd *abfd)
+{
+    p_current_bfd = (bfd *)abfd;
+}
+
+
+
+	/*******************************************************
+		Function: ld_get_cur_bfd
+
+
+	 *******************************************************/
+void *
+ld_get_cur_obj(void)
+{
+    return p_current_bfd;
+}
+
+	/*******************************************************
+		Function: ipa_is_whirl
+
+
+	 *******************************************************/
+#define ET_SGI_IR   (ET_LOPROC + 0)
+
+bfd_boolean
+ipa_is_whirl(bfd *abfd)
+{
+    Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */
+
+    i_ehdrp = elf_elfheader (abfd);
+
+    if (i_ehdrp->e_type == ET_SGI_IR) {
+    	    return(TRUE);
+    }
+
+    return(FALSE);
+}
+
+
+	/*******************************************************
+		Function: ipa_process_whirl
+
+		I need to read the WHIRL symbol table so the
+		internal mechanisms of IPA will have their 
+		data structures correctly filled out.
+		
+		Since IPA needs an mmapped view of the object
+		I'm trying to remap it here. It is not ready
+		for archives yet.
+		
+		I am overloading the usrdata field of the bfd
+		with the assumption that bfd is done with it.
+		
+	 *******************************************************/
+void
+ipa_process_whirl ( bfd *abfd) 
+{
+
+    off_t mapped_size;
+    abfd->usrdata = (PTR)(*p_ipa_open_input)((char *)abfd->filename, &mapped_size, ipa_argc, ipa_argv);
+    (*p_process_whirl64) ( 
+    	    	(void *)abfd, 
+    	    	elf_elfheader (abfd)->e_shnum, 
+		abfd->usrdata+elf_elfheader(abfd)->e_shoff,
+	        0, /* check_whirl_revision */
+		abfd->filename);
+}
+
+
+
+#define MAX_RBUF_SIZE 1*1024*1024
+	/*******************************************************
+		Function: ipa_process_whirl_in_archive
+
+	 *******************************************************/
+void
+ipa_process_whirl_in_archive ( bfd *archive, bfd *abfd) 
+{
+  FILE *fd = NULL, *tmp_fd = NULL;
+  int elem_size = arelt_size (abfd);
+  off_t mapped_size;
+  string_t input_path;
+  string_t file_name = (string_t)abfd->filename;
+  void *rbuf = NULL;
+  size_t size_buf = 0;
+  long cur_size = 0;
+  int seek_pos = 0;
+
+#define ARCHIVE_ERROR_MESSAGE " cannot process archive member "
+  int n=strlen(archive->filename) + strlen(abfd->filename) + strlen(ARCHIVE_ERROR_MESSAGE);
+  char archive_msg[n];
+  sprintf(archive_msg, "%s" ARCHIVE_ERROR_MESSAGE "%s",
+	  archive->filename, abfd->filename);
+
+  if ( (fd = fopen(archive->filename, "rb")) == NULL) {
+    perror(archive_msg);
+    exit(1);
+  }
+
+  if (elem_size > MAX_RBUF_SIZE) {
+      rbuf = (void *) MALLOC(MAX_RBUF_SIZE);
+      MALLOC_ASSERT(rbuf);
+      size_buf = MAX_RBUF_SIZE;
+  } else {
+      rbuf = (void *) malloc(elem_size);
+      size_buf = elem_size;
+  }
+
+  memset(rbuf, 0, size_buf);
+
+  /* Start copying from the begining of the current object file in the
+     archive */
+  seek_pos = fseek(fd, abfd->origin, SEEK_SET);
+  if (seek_pos != 0) {
+      perror(archive_msg);
+      exit(1);
+  }
+
+  /* Code borrowed from ld_compile() -- [CL] */
+    
+  if (tmpdir == 0)
+    if (create_tmpdir (FALSE) != 0) {
+      perror(archive_msg);
+      exit(1);
+    }
+
+  if ((input_path = create_unique_file (file_name, 'B')) == 0) {
+    perror(archive_msg);
+    exit(1);
+  }
+
+  tmp_fd = fopen (input_path, "wb");
+  if (tmp_fd == NULL) {
+    perror(archive_msg);
+    exit(1);
+  }
+
+  cur_size = elem_size;
+  while (cur_size > 0) {
+      size_t ret;
+
+      ret = fread (rbuf, 1, size_buf, fd);
+
+      if (ret > 0) {
+	  size_t w_ret;
+
+	  w_ret = fwrite(rbuf , 1, ret, tmp_fd);
+	  if ((w_ret == 0) || (w_ret != ret)) {
+	      perror(archive_msg);
+	      exit(1);
+	  }
+	  cur_size -= ret;
+
+	  /* [CL] If we read nothing, but cur_size is still > 0, it
+	     means there was an error */
+      } else if ((ret == 0) ) {
+	  perror(archive_msg);
+	  exit(1);
+      }
+  }
+
+  FREE(rbuf);
+  fclose (fd);
+  fclose (tmp_fd);
+
+  abfd->usrdata = (PTR)(*p_ipa_open_input)((char *)input_path, &mapped_size, ipa_argc, ipa_argv);
+  if ((long) abfd->usrdata == -1) {
+    perror(archive_msg);
+    exit(1);
+  }
+
+  (*p_process_whirl64) ( 
+    	    	(void *)abfd, 
+    	    	elf_elfheader (abfd)->e_shnum, 
+		abfd->usrdata+elf_elfheader(abfd)->e_shoff,
+	        0, /* check_whirl_revision */
+		abfd->filename);
+}
+
+#endif
diff -r -N -u binutils-2.21.51/bfd/ipa_bfd.h binutils/bfd/ipa_bfd.h
--- binutils-2.21.51/bfd/ipa_bfd.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils/bfd/ipa_bfd.h	2010-07-01 12:20:17.411522000 +0100
@@ -0,0 +1,312 @@
+/* THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003 */
+
+#ifndef __IPA_BFD_H__
+#define __IPA_BFD_H__
+
+#define BCOPY(src, dst, len) \
+    bcopy((const void *)(src), (void *)(dst), (int)(len))    	       
+
+#define FREE(ptr) \
+    free((void *) (ptr))
+
+#define MALLOC_ASSERT(addr) \
+    if (addr == 0) { perror("malloc failed: "); exit(1);}
+
+#define MALLOC(nbytes) \
+    malloc((size_t)(nbytes))
+
+#define REALLOC(ptr, size) \
+    realloc((void *)(ptr), (size_t)(size))
+
+#define UNLINK(path) \
+    unlink((const char *)(path))
+
+#if defined (_WIN32)
+#define MKDIR(path, mode) \
+    mkdir((const char *)(path))
+#else /* _WIN32 */
+#define MKDIR(path, mode) \
+    mkdir((const char *)(path), (mode_t)(mode))
+#endif /* _WIN32 */
+
+#define RMDIR(path) \
+    rmdir((const char *)(path))	       
+
+#define OPEN(path, oflag, mode) \
+    open((char *)(path), (int)(oflag), (int)(mode))
+
+#define CLOSE(fid) \
+    close((int)(fid))
+
+#define READ(fildes, buf, nbyte) \
+    read((int) (fildes), (void *)(buf), (size_t) (nbyte))
+
+#define ALLOCA(size) \
+    alloca((unsigned int)(size))	       
+	       
+#define FCHMOD(fid, mode) \
+    fchmod((int)(fid), (mode_t)(mode))
+
+#define MMAP(addr, len, prot, flags, fd, off) \
+    mmap((void *)(addr), (int)(len), (int)(prot), (int)(flags), (int)(fd), \
+	 (off_t)(off))
+
+#define MUNMAP(addr, len) \
+    munmap((void *)(addr), (int)(len))
+
+#define MEMCPY(s1, s2, n) \
+    memcpy((void *)(s1), (void *)(s2), (size_t)(n))
+
+#define ELF_WORD int
+
+#define OBJ_ASSERT(EX, obj, str) \
+    if (!(EX)) {fprintf(stderr,"%s: %s\n", obj->filename, str); exit(1);}
+
+#define DEFAULT_TMP_LIST_SIZE 32
+#define DEFAULT_TMPDIR "./ldtmp"
+
+#define arch_eltdata(bfd) ((struct areltdata *)((bfd)->arelt_data))
+#define arch_hdr(_bfd) ((struct ar_hdr *)arch_eltdata(_bfd)->arch_header)
+
+#define FALSE 0
+#define TRUE 1
+
+typedef char *string_t;
+
+extern int ipa_argc;
+extern char **ipa_argv;
+
+/* These are taken from ipc_sumtab_merge.h in the ipa tree. */
+
+
+/*
+ * These are for passing option information from the
+ * static linker to ipa without involving the linkers
+ * internal option table. Any enumerated types defined
+ * here can be added to,  but not altered in any other
+ * way. This allows the linker to change without affecting
+ * ipa.
+ */
+
+typedef enum{
+    LD_IPA_SHARABLE, 
+    LD_IPA_DEMANGLE, 
+    LD_IPA_SHOW, 
+    LD_IPA_HIDES, 
+    LD_IPA_TARGOS, 
+    LD_IPA_VERBOSE, 
+    LD_IPA_KEEP_TEMPS, 
+    LD_IPA_ISA,
+    LD_IPA_RELOCATABLE, /* [CL] generate a relocatable file */
+    LD_IPA_EXPORTS,     /* [CL] all symbols are exported (-E)*/
+    LD_IPA_XXXX, 
+    MAX_LD_IPA
+}ld_ipa_option_enum;
+
+typedef struct ld_ipa_option {
+    ld_ipa_option_enum opt_ndx;
+    unsigned    flag		: 4;    /*  */
+    unsigned     set		: 4;    /*  */
+} LD_IPA_OPTION;
+
+extern LD_IPA_OPTION ld_ipa_opt[MAX_LD_IPA];
+
+#define HS_DEFAULT 0
+#define HS_HIDES 1
+#define HS_EXPORTS 2
+#define HS_IGNORE 3
+
+                 /* these are set to bit fields for */
+                 /* easy table initialization */
+#define          F_RELOCATABLE       1
+#define          F_NON_SHARED        2
+#define          F_CALL_SHARED       4
+#define          F_MAKE_SHARABLE     8
+#define          F_STATIC    (F_NON_SHARED | F_RELOCATABLE)
+#define          F_DYNAMIC   (~(F_STATIC))
+#define          F_MAIN      (F_NON_SHARED | F_CALL_SHARED)
+#define		 F_EXEC	     (~F_RELOCATABLE)
+#define          F_ALL       (F_STATIC | F_DYNAMIC)
+#define          F_CALL_SHARED_RELOC (F_RELOCATABLE | F_CALL_SHARED)
+
+typedef enum {
+	TOS_IA64_64,
+	TOS_IA64_32, 
+	TOS_MAX
+}targos_enum;
+
+extern string_t tos_string[TOS_MAX];
+extern string_t toolroot;
+extern string_t tmpdir;
+extern string_t outfilename;
+extern char * __Release_ID;
+
+extern void *(*p_ipa_open_input)(char *, off_t *, int, char**);
+extern void (*p_ipa_init_link_line)(int, char **);
+extern void (*p_ipa_add_link_flag)(const char*);
+extern void (*p_ipa_driver)(int, char **);
+extern void (*p_process_whirl64)(void *, int, void *, int, const char *);
+extern void (*p_ipa_insert_whirl_marker)(void);
+extern void (*p_Sync_symbol_attributes)(unsigned int, unsigned int, bfd_boolean, unsigned int);
+/* [CL] handle comdat attribute */
+extern bfd_boolean (*p_symbol_comdat)(unsigned int);
+/* [CL] handle comdat attribute */
+extern bfd_boolean (*p_symbol_linkonce)(unsigned int);
+
+/* [CL] pointers to external symbols used by ipa.so */
+typedef LD_IPA_OPTION ipa_option_array[MAX_LD_IPA];
+
+#define IPA_EXTERNAL_SYMBOLS_VERSION 1
+
+struct external_symbols_list {
+  /* Size and version of this struct, for sanity checks */
+    int size;
+    int version;
+
+    /* pass1.h */
+    unsigned int *used_gp_area;
+
+    /* ld_ipa_option.h */
+    ipa_option_array *ld_ipa_opt;
+/*     ipacom_flags */
+    string_t *WB_flags;
+    string_t *Y_flags;
+
+    /* error.h */
+/*     msg */
+
+    /* ext_tbl.h */
+    void (*merge_ext)(void*, char *, int, void*);
+/*     enter_mext */
+/*     slookup_mext */
+/*     slookup_mext_idx */
+/*     get_mext */
+/*     ext_tbl */
+    void* (*ld_slookup_mext)(char *, bfd_boolean);
+
+    /* obj_file.h */
+/*     num_ir */
+/*     get_next_ir */
+/*     is_archive_member */
+
+    /* process.h */
+    int (*create_tmpdir)(int);
+    string_t (*create_unique_file)(string_t, char);
+    string_t (*create_unique_file_in_curdir)(string_t, char);
+    void (*add_to_tmp_file_list)(string_t);
+    string_t *tmpdir;
+/*     get_command_line */
+/*     make_link */
+
+    /* ld_util.h */
+    string_t (*concat_names)(string_t, string_t);
+
+    /* ld_main.h */
+    int *arg_count;
+    char** *arg_vector;
+    char** *environ_vars;
+    int *max_gpa_size;
+
+    /* read.h */
+    void (*read_one_section)(int, void*);
+/*     read_headers */
+/*     unread_sections */
+/*     unread_obj */
+/*     objs_mapped_total_size */
+/*     copy_section */
+
+    /* dem.h */
+    char* (*always_demangle)(char *, char );
+
+    /* elfhash.h */
+/*     elfhash */
+
+    /* ld_ipa_interface.h */
+  unsigned long long (*ld_get_section_size) (void* pobj, int sect_ndx);
+
+  char *(*ld_get_section_name) (void* pobj, int sect_ndx);
+
+  char *(*ld_get_section_base) (void* pobj, int sect_ndx);
+
+  void *(*ld_get_mmap_addr) (void* pobj);
+
+/* extern unsigned int */
+/* ld_get_sym_attr (void* pext); */
+
+/* extern int */
+/* ld_is_weak_symbol (void* pext); */
+
+/* extern ST_EXPORT */
+/* ld_get_export (void* pext); */
+
+  void (*ld_set_st_idx) (void* pext, int st_idx);
+
+  int (*ld_get_st_idx) (void* pext);
+
+  bfd_boolean (*ld_resolved_to_obj) (void* pext, void* pobj);
+
+/*   extern void */
+/*   cleanup_symtab_for_ipa (void); */
+
+  int (*Count_elf_external_gots) (void);
+
+  string_t *outfilename;
+};
+
+extern void (*p_ipa_initialize_external_symbols)(struct external_symbols_list*);
+
+
+/* Function declarations
+ */
+ 
+extern char *
+ipa_copy_of(char *);
+
+extern string_t
+concat_names(const string_t, const string_t);
+
+extern void
+add_to_tmp_file_list (string_t);
+
+extern int
+create_tmpdir ( int);
+
+extern string_t
+create_unique_file (const string_t, char);
+
+extern string_t
+create_unique_file_in_curdir (const string_t, char);
+
+extern int
+ipa_set_ndx (bfd *);
+
+extern void 
+ld_set_cur_obj(bfd *);
+
+void *
+ld_get_cur_obj(void);
+
+extern bfd_boolean
+ipa_is_whirl(bfd *);
+
+extern void
+ipa_process_whirl ( bfd *);
+
+/* The following constant values are shared by both ld and ipa.  Each
+   symtab entry in ld's merged symbol table has an ST_IDX field pointing
+   back to the corresponding entry (if any) in the WHIRL merged symbol
+   table.  When a new entry is added to ld's merged symbol table, if the
+   symbol comes from an Elf object, we set the ST_IDX field to
+   WHIRL_ST_IDX_NOT_AVAILABLE because there is no corresponding ST entry in
+   the WHIRL merged symbol table. If the symbol comes from a WHIRL object,
+   we set the ST_IDX field to WHIRL_ST_IDX_UNINITIALIZED, which means that
+   there will be a corresponding entry in the WHIRL merged symtab but we
+   don't know the value yet.
+ */
+
+#define WHIRL_ST_IDX_UNINITIALIZED (0)
+#define WHIRL_ST_IDX_NOT_AVAILABLE (-1)
+
+
+
+#endif /* __IPA_BFD_H__ */
diff -r -N -u binutils-2.21.51/bfd/libbfd.h binutils/bfd/libbfd.h
--- binutils-2.21.51/bfd/libbfd.h	2011-06-14 09:27:52.000000000 +0100
+++ binutils/bfd/libbfd.h	2011-07-06 12:44:26.137253000 +0100
@@ -1335,6 +1335,44 @@
   "BFD_RELOC_PPC64_DTPREL16_HIGHESTA",
   "BFD_RELOC_I370_D12",
   "BFD_RELOC_CTOR",
+  "BFD_RELOC_LX_16",
+  "BFD_RELOC_LX_32 ",
+  "BFD_RELOC_LX_32_PCREL",
+  "BFD_RELOC_LX_23_PCREL",
+  "BFD_RELOC_LX_HI23",
+  "BFD_RELOC_LX_LO9",
+  "BFD_RELOC_LX_GPREL_HI23",
+  "BFD_RELOC_LX_GPREL_LO9",
+  "BFD_RELOC_LX_REL32",
+  "BFD_RELOC_LX_GOTOFF_HI23",
+  "BFD_RELOC_LX_GOTOFF_LO9",
+  "BFD_RELOC_LX_GOTOFFX_HI23",
+  "BFD_RELOC_LX_GOTOFFX_LO9",
+  "BFD_RELOC_LX_LTV32",
+  "BFD_RELOC_LX_SEGREL32",
+  "BFD_RELOC_LX_FPTR32",
+  "BFD_RELOC_LX_PLTOFF_HI23",
+  "BFD_RELOC_LX_PLTOFF_LO9",
+  "BFD_RELOC_LX_GOTOFF_FPTR_HI23",
+  "BFD_RELOC_LX_GOTOFF_FPTR_LO9",
+  "BFD_RELOC_LX_IPLT",
+  "BFD_RELOC_LX_NEG_GPREL_HI23",
+  "BFD_RELOC_LX_NEG_GPREL_LO9",
+  "BFD_RELOC_LX_COPY",
+  "BFD_RELOC_LX_JMP_SLOT",
+  "BFD_RELOC_LX_TPREL_HI23",
+  "BFD_RELOC_LX_TPREL_LO9",
+  "BFD_RELOC_LX_TPREL32",
+  "BFD_RELOC_LX_GOTOFF_TPREL_HI23",
+  "BFD_RELOC_LX_GOTOFF_TPREL_LO9",
+  "BFD_RELOC_LX_GOTOFF_DTPLDM_HI23",
+  "BFD_RELOC_LX_GOTOFF_DTPLDM_LO9",
+  "BFD_RELOC_LX_DTPREL_HI23",
+  "BFD_RELOC_LX_DTPREL_LO9",
+  "BFD_RELOC_LX_DTPMOD32",
+  "BFD_RELOC_LX_DTPREL32",
+  "BFD_RELOC_LX_GOTOFF_DTPNDX_HI23",
+  "BFD_RELOC_LX_GOTOFF_DTPNDX_LO9",
   "BFD_RELOC_ARM_PCREL_BRANCH",
   "BFD_RELOC_ARM_PCREL_BLX",
   "BFD_RELOC_THUMB_PCREL_BLX",
diff -r -N -u binutils-2.21.51/bfd/linker.c binutils/bfd/linker.c
--- binutils-2.21.51/bfd/linker.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/bfd/linker.c	2011-10-20 09:48:19.463637000 +0100
@@ -27,6 +27,16 @@
 #include "bfdlink.h"
 #include "genlink.h"
 
+#ifdef IPA_LINK
+#pragma weak ipa_is_whirl
+
+extern bfd_boolean
+ipa_is_whirl(bfd *);
+
+#include "ipa_bfd.h" /* [CL] needed for symbol_comdat() */
+#include "elf-bfd.h" /* [CL] needed to support comdat: need to get ipa_indx */
+#endif
+
 /*
 SECTION
 	Linker Functions
@@ -437,6 +447,10 @@
   (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *,
    bfd_boolean);
 
+#ifdef IPA_LINK
+bfd_boolean is_ipa = 0;
+#endif
+
 /* The link hash table structure is defined in bfdlink.h.  It provides
    a base hash table which the backend specific hash tables are built
    upon.  */
@@ -1658,11 +1672,28 @@
 
 	    /* Define a symbol.  */
 	    oldtype = h->type;
+#ifdef IPA_LINK
+	    /* [CL] if we have DEFW from a non-Whirl symbol, don't
+	       propagate the weak attribute to the reference:
+	       otherwise, it makes the compiler generate a weak
+	       reference, which is not resolved by the final link
+	       stage */
+	    if (is_ipa && (action == DEFW) && !ipa_is_whirl(abfd)) {
+	      action = DEF;
+	    }
+#endif
 	    if (action == DEFW)
 	      h->type = bfd_link_hash_defweak;
 	    else
 	      h->type = bfd_link_hash_defined;
 	    h->u.def.section = section;
+#ifdef IPA_LINK
+            /* ipa_set_def_bfd(abfd,h); */
+            if (is_ipa) {
+	      /*              h->u.def.section = (asection *)abfd;*/
+	      h->ipa_bfd = abfd;
+	    }
+#endif
 	    h->u.def.value = value;
 
 	    /* If we have been asked to, we act like collect2 and
@@ -1829,6 +1860,12 @@
 	  /* Fall through.  */
 	case MDEF:
 	  /* Handle a multiple definition.  */
+#ifdef IPA_LINK
+	   /* [DF] Moved in ldmain.c due to source reorg. in 2.21.51 */ 
+	   /* [CL] support comdat attribute: redefinition
+	      of a symbol with the comdat attribute is allowed.
+	      It will be fully resolved by the final link pass */
+#endif
 	  if (! ((*info->callbacks->multiple_definition)
 		 (info, h, abfd, section, value)))
 	    return FALSE;
diff -r -N -u binutils-2.21.51/bfd/Makefile.am binutils/bfd/Makefile.am
--- binutils-2.21.51/bfd/Makefile.am	2011-06-14 09:27:52.000000000 +0100
+++ binutils/bfd/Makefile.am	2011-07-06 12:44:26.137253000 +0100
@@ -97,6 +97,7 @@
 	cpu-ip2k.lo \
 	cpu-iq2000.lo \
 	cpu-lm32.lo \
+	cpu-lx.lo \
 	cpu-m10200.lo \
 	cpu-m10300.lo \
 	cpu-m32c.lo \
@@ -169,6 +170,7 @@
 	cpu-ip2k.c \
 	cpu-iq2000.c \
 	cpu-lm32.c \
+	cpu-lx.c \
 	cpu-m10200.c \
 	cpu-m10300.c \
 	cpu-m32c.c \
@@ -292,6 +294,8 @@
 	elf32-ip2k.lo \
 	elf32-iq2000.lo \
 	elf32-lm32.lo \
+	elf32-lx.lo \
+        elf32-lx-linux.lo \
 	elf32-m32c.lo \
 	elf32-m32r.lo \
 	elf32-m68hc11.lo \
@@ -343,6 +347,7 @@
 	i386netbsd.lo \
 	i386os9k.lo \
 	ieee.lo \
+	ipa_bfd.lo \
 	m68k4knetbsd.lo \
 	m68klinux.lo \
 	m68knetbsd.lo \
@@ -473,6 +478,8 @@
 	elf32-ip2k.c \
 	elf32-iq2000.c \
 	elf32-lm32.c \
+	elf32-lx.c \
+	elf32-lx-linux.c \
 	elf32-m32c.c \
 	elf32-m32r.c \
 	elf32-m68hc11.c \
@@ -524,6 +531,7 @@
 	i386netbsd.c \
 	i386os9k.c \
 	ieee.c \
+	ipa_bfd.c \
 	m68k4knetbsd.c \
 	m68klinux.c \
 	m68knetbsd.c \
diff -r -N -u binutils-2.21.51/bfd/Makefile.in binutils/bfd/Makefile.in
--- binutils-2.21.51/bfd/Makefile.in	2011-06-14 09:27:52.000000000 +0100
+++ binutils/bfd/Makefile.in	2011-07-06 12:44:26.137253000 +0100
@@ -396,6 +396,7 @@
 	cpu-ip2k.lo \
 	cpu-iq2000.lo \
 	cpu-lm32.lo \
+	cpu-lx.lo \
 	cpu-m10200.lo \
 	cpu-m10300.lo \
 	cpu-m32c.lo \
@@ -468,6 +469,7 @@
 	cpu-ip2k.c \
 	cpu-iq2000.c \
 	cpu-lm32.c \
+	cpu-lx.c \
 	cpu-m10200.c \
 	cpu-m10300.c \
 	cpu-m32c.c \
@@ -592,6 +594,8 @@
 	elf32-ip2k.lo \
 	elf32-iq2000.lo \
 	elf32-lm32.lo \
+	elf32-lx.lo \
+        elf32-lx-linux.lo \
 	elf32-m32c.lo \
 	elf32-m32r.lo \
 	elf32-m68hc11.lo \
@@ -643,6 +647,7 @@
 	i386netbsd.lo \
 	i386os9k.lo \
 	ieee.lo \
+	ipa_bfd.lo \
 	m68k4knetbsd.lo \
 	m68klinux.lo \
 	m68knetbsd.lo \
@@ -773,6 +778,8 @@
 	elf32-ip2k.c \
 	elf32-iq2000.c \
 	elf32-lm32.c \
+	elf32-lx.c \
+	elf32-lx-linux.c \
 	elf32-m32c.c \
 	elf32-m32r.c \
 	elf32-m68hc11.c \
@@ -824,6 +831,7 @@
 	i386netbsd.c \
 	i386os9k.c \
 	ieee.c \
+	ipa_bfd.c \
 	m68k4knetbsd.c \
 	m68klinux.c \
 	m68knetbsd.c \
@@ -1260,6 +1268,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-iq2000.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-l1om.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-lm32.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-lx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-m10200.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-m10300.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-m32c.Plo@am__quote@
@@ -1342,6 +1351,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-ip2k.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-iq2000.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-lm32.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-lx-linux.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-lx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-m32c.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-m32r.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-m68hc11.Plo@am__quote@
@@ -1414,6 +1425,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ieee.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ihex.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/init.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ipa_bfd.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/irix-core.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libbfd.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/linker.Plo@am__quote@
diff -r -N -u binutils-2.21.51/bfd/reloc.c binutils/bfd/reloc.c
--- binutils-2.21.51/bfd/reloc.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/bfd/reloc.c	2011-07-06 12:44:26.137253000 +0100
@@ -2831,6 +2831,85 @@
   It generally does map to one of the other relocation types.
 
 ENUM
+  BFD_RELOC_LX_16
+ENUMX
+  BFD_RELOC_LX_32 
+ENUMX
+  BFD_RELOC_LX_32_PCREL
+ENUMX
+  BFD_RELOC_LX_23_PCREL
+ENUMX 
+  BFD_RELOC_LX_HI23
+ENUMX
+  BFD_RELOC_LX_LO9
+ENUMX
+  BFD_RELOC_LX_GPREL_HI23
+ENUMX
+  BFD_RELOC_LX_GPREL_LO9
+ENUMX
+  BFD_RELOC_LX_REL32
+ENUMX
+  BFD_RELOC_LX_GOTOFF_HI23
+ENUMX
+  BFD_RELOC_LX_GOTOFF_LO9
+ENUMX
+  BFD_RELOC_LX_GOTOFFX_HI23
+ENUMX
+  BFD_RELOC_LX_GOTOFFX_LO9
+ENUMX
+  BFD_RELOC_LX_LTV32
+ENUMX
+  BFD_RELOC_LX_SEGREL32
+ENUMX
+  BFD_RELOC_LX_FPTR32
+ENUMX
+  BFD_RELOC_LX_PLTOFF_HI23
+ENUMX
+  BFD_RELOC_LX_PLTOFF_LO9
+ENUMX
+  BFD_RELOC_LX_GOTOFF_FPTR_HI23
+ENUMX
+  BFD_RELOC_LX_GOTOFF_FPTR_LO9
+ENUMX
+  BFD_RELOC_LX_IPLT
+ENUMX
+  BFD_RELOC_LX_NEG_GPREL_HI23
+ENUMX
+  BFD_RELOC_LX_NEG_GPREL_LO9
+ENUMX
+  BFD_RELOC_LX_COPY
+ENUMX
+  BFD_RELOC_JMP_SLOT
+ENUMX
+  BFD_RELOC_LX_TPREL_HI23
+ENUMX
+  BFD_RELOC_LX_TPREL_LO9
+ENUMX
+  BFD_RELOC_LX_TPREL32
+ENUMX
+  BFD_RELOC_LX_GOTOFF_TPREL_HI23
+ENUMX
+  BFD_RELOC_LX_GOTOFF_TPREL_LO9
+ENUMX
+  BFD_RELOC_LX_GOTOFF_DTPLDM_HI23
+ENUMX
+  BFD_RELOC_LX_GOTOFF_DTPLDM_LO9
+ENUMX
+  BFD_RELOC_LX_DTPREL_HI23
+ENUMX
+  BFD_RELOC_LX_DTPREL_LO9
+ENUMX
+  BFD_RELOC_LX_DTPMOD32
+ENUMX
+  BFD_RELOC_LX_DTPREL32
+ENUMX
+  BFD_RELOC_GOTOFF_DTPNDX_HI23
+ENUMX
+  BFD_RELOC_GOTOFF_DTPNDX_LO9
+ENUMDOC
+  LX relocations
+
+ENUM
   BFD_RELOC_ARM_PCREL_BRANCH
 ENUMDOC
   ARM 26 bit pc-relative branch.  The lowest two bits must be zero and are
diff -r -N -u binutils-2.21.51/bfd/section.c binutils/bfd/section.c
--- binutils-2.21.51/bfd/section.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/bfd/section.c	2011-07-06 12:44:26.137253000 +0100
@@ -723,7 +723,11 @@
   GLOBAL_SYM_INIT (BFD_COM_SECTION_NAME, &bfd_com_section),
   GLOBAL_SYM_INIT (BFD_UND_SECTION_NAME, &bfd_und_section),
   GLOBAL_SYM_INIT (BFD_ABS_SECTION_NAME, &bfd_abs_section),
-  GLOBAL_SYM_INIT (BFD_IND_SECTION_NAME, &bfd_ind_section)
+  GLOBAL_SYM_INIT (BFD_IND_SECTION_NAME, &bfd_ind_section),
+#ifdef IPA_LINK
+  GLOBAL_SYM_INIT (BFD_WHD_SECTION_NAME, &bfd_whirl_data_section),
+  GLOBAL_SYM_INIT (BFD_WHT_SECTION_NAME, &bfd_whirl_text_section)
+#endif
 };
 
 #define STD_SECTION(SEC, FLAGS, NAME, IDX)				\
@@ -734,6 +738,10 @@
 STD_SECTION (bfd_und_section, 0, BFD_UND_SECTION_NAME, 1);
 STD_SECTION (bfd_abs_section, 0, BFD_ABS_SECTION_NAME, 2);
 STD_SECTION (bfd_ind_section, 0, BFD_IND_SECTION_NAME, 3);
+#ifdef IPA_LINK
+STD_SECTION (bfd_whirl_data_section, 0, BFD_WHD_SECTION_NAME, 4);
+STD_SECTION (bfd_whirl_text_section, 0, BFD_WHT_SECTION_NAME, 5);
+#endif /* IPA_LINK */
 #undef STD_SECTION
 
 /* Initialize an entry in the section hash table.  */
@@ -1009,6 +1017,12 @@
     newsect = bfd_und_section_ptr;
   else if (strcmp (name, BFD_IND_SECTION_NAME) == 0)
     newsect = bfd_ind_section_ptr;
+#ifdef IPA_LINK
+  else if (strcmp (name, BFD_WHD_SECTION_NAME) == 0)
+    newsect = bfd_whirl_data_section_ptr;
+  else if (strcmp (name, BFD_WHT_SECTION_NAME) == 0)
+    newsect = bfd_whirl_text_section_ptr;
+#endif
   else
     {
       struct section_hash_entry *sh;
diff -r -N -u binutils-2.21.51/bfd/targets.c binutils/bfd/targets.c
--- binutils-2.21.51/bfd/targets.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/bfd/targets.c	2011-07-06 12:44:26.137253000 +0100
@@ -624,6 +624,10 @@
 extern const bfd_target bfd_elf32_littlearm_vxworks_vec;
 extern const bfd_target bfd_elf32_littlemips_vec;
 extern const bfd_target bfd_elf32_littlemips_vxworks_vec;
+extern const bfd_target bfd_elf32_lx_vec;
+extern const bfd_target bfd_elf32_littlelx_vec;
+extern const bfd_target bfd_elf32_lx_linux_vec;
+extern const bfd_target bfd_elf32_littlelx_linux_vec;
 extern const bfd_target bfd_elf32_m32c_vec;
 extern const bfd_target bfd_elf32_m32r_vec;
 extern const bfd_target bfd_elf32_m32rle_vec;
@@ -982,6 +986,9 @@
 	&bfd_elf32_littlearm_vxworks_vec,
 	&bfd_elf32_littlemips_vec,
 	&bfd_elf32_littlemips_vxworks_vec,
+	&bfd_elf32_lx_vec,
+	&bfd_elf32_littlelx_vec,
+	&bfd_elf32_littlelx_linux_vec,
 	&bfd_elf32_m32c_vec,
 	&bfd_elf32_m32r_vec,
         &bfd_elf32_m32rle_vec,
diff -r -N -u binutils-2.21.51/binutils/arlex.c binutils/binutils/arlex.c
--- binutils-2.21.51/binutils/arlex.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/arlex.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1839 +0,0 @@
-/* A lexical scanner generated by flex */
-
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
- */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-
-#include <stdio.h>
-#include <unistd.h>
-
-
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
-
-
-#ifdef __cplusplus
-
-#include <stdlib.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_PROTOS
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yy_start = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yy_start - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#define YY_BUF_SIZE 16384
-
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-
-extern int yyleng;
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
-
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-	};
-
-static YY_BUFFER_STATE yy_current_buffer = 0;
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- */
-#define YY_CURRENT_BUFFER yy_current_buffer
-
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
-
-typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
-
-#define YY_NUM_RULES 40
-#define YY_END_OF_BUFFER 41
-static yyconst short int yy_accept[177] =
-    {   0,
-        0,    0,   41,   40,   39,   38,   35,   32,   33,   36,
-       40,   34,   37,   35,   35,   35,   35,   35,   35,   35,
-       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
-       35,   35,   35,   35,   35,   35,   36,   31,   37,   35,
-       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
-       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
-       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
-       35,   35,    7,   35,   35,   35,   35,   35,   35,   35,
-       35,   35,   35,   35,   35,   35,   22,   35,   35,   35,
-       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
-
-       35,   35,   35,   10,   11,   12,   35,   15,   35,   35,
-       35,   35,   35,   35,   35,   35,   35,   25,   26,   27,
-       35,   30,   35,   35,   35,    3,   35,   35,   35,   35,
-       35,   35,   35,   35,   35,   18,   35,   35,   35,   35,
-       35,   35,   35,    1,    2,    4,    5,   35,   35,   35,
-       35,   35,   16,   17,   19,   20,   35,   35,   35,   35,
-       35,   35,    8,    9,   13,   14,   35,   23,   24,   28,
-       29,   35,   35,    6,   21,    0
-    } ;
-
-static yyconst int yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    3,    1,    1,    1,    4,    1,    1,    1,    5,
-        6,    7,    8,    9,    4,    4,    4,    4,    4,    4,
-        4,    4,    4,    4,    4,    4,    4,    4,   10,    1,
-        1,    1,    1,    1,   11,   12,   13,   14,   15,   16,
-        4,   17,   18,    4,    4,   19,   20,   21,   22,   23,
-        4,   24,   25,   26,   27,   28,    4,   29,   30,    4,
-        1,    4,    1,    1,    4,    1,   31,   32,   33,   34,
-
-       35,   36,    4,   37,   38,    4,    4,   39,   40,   41,
-       42,   43,    4,   44,   45,   46,   47,   48,    4,   49,
-       50,    4,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst int yy_meta[51] =
-    {   0,
-        1,    2,    1,    3,    1,    1,    1,    1,    1,    1,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3
-    } ;
-
-static yyconst short int yy_base[180] =
-    {   0,
-        0,    0,  193,  194,  194,  194,    0,  194,  194,    0,
-      190,  194,    0,  177,   32,   37,   32,  163,  174,  170,
-      164,  171,  174,  169,  149,   15,   22,   17,  135,  146,
-      142,  136,  143,  146,  141,    0,    0,  194,    0,  161,
-      159,  158,  153,  147,  156,  143,  149,  148,  141,  150,
-      141,  135,  138,  127,  125,  124,  119,  113,  122,  109,
-      115,  114,  107,  116,  107,  101,  104,   43,  136,  135,
-      130,  129,    0,  119,  123,  118,  114,  118,  119,  122,
-      124,   25,  104,  103,   98,   97,    0,   87,   91,   86,
-       82,   86,   87,   90,   92,  105,  100,   97,   94,   93,
-
-      105,  106,  102,    0,    0,    0,  104,    0,   92,   75,
-       70,   67,   64,   63,   75,   76,   72,    0,    0,    0,
-       74,    0,   62,   91,   88,    0,   86,   85,   73,   85,
-       79,   83,   70,   62,   59,    0,   57,   56,   44,   56,
-       50,   54,   41,    0,    0,    0,    0,   63,   58,   59,
-       67,   66,    0,    0,    0,    0,   38,   33,   34,   42,
-       41,   51,    0,    0,    0,    0,   30,    0,    0,    0,
-        0,   43,   21,    0,    0,  194,   65,   66,   69
-    } ;
-
-static yyconst short int yy_def[180] =
-    {   0,
-      176,    1,  176,  176,  176,  176,  177,  176,  176,  178,
-      176,  176,  179,  177,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,  177,  178,  176,  179,  177,
-      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
-
-      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
-      177,  177,  177,  177,  177,    0,  176,  176,  176
-    } ;
-
-static yyconst short int yy_nxt[245] =
-    {   0,
-        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
-       14,    7,   15,   16,   17,   18,   19,    7,   20,    7,
-        7,   21,    7,   22,   23,    7,    7,   24,    7,    7,
-       25,    7,   26,   27,   28,   29,   30,    7,   31,    7,
-        7,   32,    7,   33,   34,    7,    7,   35,    7,    7,
-       41,   43,   45,   55,   44,   42,   57,   59,   56,   58,
-       46,   96,   97,  110,  111,   60,   37,   36,   37,   39,
-      175,   39,  174,  173,  172,  171,  170,  169,  168,  167,
-      166,  165,  164,  163,  162,  161,  160,  159,  158,  157,
-      156,  155,  154,  153,  152,  151,  150,  149,  148,  147,
-
-      146,  145,  144,  143,  142,  141,  140,  139,  138,  137,
-      136,  135,  134,  133,  132,  131,  130,  129,  128,  127,
-      126,  125,  124,  123,  122,  121,  120,  119,  118,  117,
-      116,  115,  114,  113,  112,  109,  108,  107,  106,  105,
-      104,  103,  102,  101,  100,   99,   98,   95,   94,   93,
-       92,   91,   90,   89,   88,   87,   86,   85,   84,   83,
-       82,   81,   80,   79,   78,   77,   76,   75,   74,   73,
-       72,   71,   70,   69,   68,   67,   66,   65,   64,   63,
-       62,   61,   54,   53,   52,   51,   50,   49,   48,   47,
-       40,   38,  176,    3,  176,  176,  176,  176,  176,  176,
-
-      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
-      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
-      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
-      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
-      176,  176,  176,  176
-    } ;
-
-static yyconst short int yy_chk[245] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-       15,   16,   17,   26,   16,   15,   27,   28,   26,   27,
-       17,   68,   68,   82,   82,   28,  178,  177,  178,  179,
-      173,  179,  172,  167,  162,  161,  160,  159,  158,  157,
-      152,  151,  150,  149,  148,  143,  142,  141,  140,  139,
-      138,  137,  135,  134,  133,  132,  131,  130,  129,  128,
-
-      127,  125,  124,  123,  121,  117,  116,  115,  114,  113,
-      112,  111,  110,  109,  107,  103,  102,  101,  100,   99,
-       98,   97,   96,   95,   94,   93,   92,   91,   90,   89,
-       88,   86,   85,   84,   83,   81,   80,   79,   78,   77,
-       76,   75,   74,   72,   71,   70,   69,   67,   66,   65,
-       64,   63,   62,   61,   60,   59,   58,   57,   56,   55,
-       54,   53,   52,   51,   50,   49,   48,   47,   46,   45,
-       44,   43,   42,   41,   40,   35,   34,   33,   32,   31,
-       30,   29,   25,   24,   23,   22,   21,   20,   19,   18,
-       14,   11,    3,  176,  176,  176,  176,  176,  176,  176,
-
-      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
-      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
-      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
-      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
-      176,  176,  176,  176
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "arlex.l"
-#define INITIAL 0
-#define YY_NO_INPUT 1
-#define YY_NO_UNPUT 1
-#line 4 "arlex.l"
-/* arlex.l - Strange script language lexer */
-
-/* Copyright 1992, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2011
-   Free Software Foundation, Inc.
-
-   This file is part of GNU Binutils.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-
-/* Contributed by Steve Chamberlain <sac@cygnus.com>.  */
-
-#define DONTDECLARE_MALLOC
-#include "ansidecl.h"
-#include "libiberty.h"
-#include "arparse.h"
-
-#ifndef YY_NO_UNPUT
-#define YY_NO_UNPUT
-#endif
- 
-extern int yylex (void);
-
-int linenumber;
-#line 513 "arlex.c"
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
-#else
-extern int yywrap YY_PROTO(( void ));
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
-
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
-#endif
-
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
-		{ \
-		int c = '*', n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-YY_DECL
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp = NULL, *yy_bp = NULL;
-	register int yy_act;
-
-#line 46 "arlex.l"
-
-
-#line 667 "arlex.c"
-
-	if ( yy_init )
-		{
-		yy_init = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-
-		yy_load_buffer_state();
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yy_start;
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 177 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 194 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-
-do_action:	/* This label is used only to access EOF actions. */
-
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 48 "arlex.l"
-{ return ADDLIB; }
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 49 "arlex.l"
-{ return ADDMOD; }
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 50 "arlex.l"
-{ return CLEAR; }
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 51 "arlex.l"
-{ return CREATE; }
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 52 "arlex.l"
-{ return DELETE; }
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 53 "arlex.l"
-{ return DIRECTORY; }
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 54 "arlex.l"
-{ return END; }
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 55 "arlex.l"
-{ return EXTRACT; }
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 56 "arlex.l"
-{ return FULLDIR; }
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 57 "arlex.l"
-{ return HELP; }
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 58 "arlex.l"
-{ return LIST; }
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 59 "arlex.l"
-{ return OPEN; }
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 60 "arlex.l"
-{ return REPLACE; }
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 61 "arlex.l"
-{ return VERBOSE; }
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 62 "arlex.l"
-{ return SAVE; }
-	YY_BREAK
-case 16:
-YY_RULE_SETUP
-#line 63 "arlex.l"
-{ return ADDLIB; }
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 64 "arlex.l"
-{ return ADDMOD; }
-	YY_BREAK
-case 18:
-YY_RULE_SETUP
-#line 65 "arlex.l"
-{ return CLEAR; }
-	YY_BREAK
-case 19:
-YY_RULE_SETUP
-#line 66 "arlex.l"
-{ return CREATE; }
-	YY_BREAK
-case 20:
-YY_RULE_SETUP
-#line 67 "arlex.l"
-{ return DELETE; }
-	YY_BREAK
-case 21:
-YY_RULE_SETUP
-#line 68 "arlex.l"
-{ return DIRECTORY; }
-	YY_BREAK
-case 22:
-YY_RULE_SETUP
-#line 69 "arlex.l"
-{ return END; }
-	YY_BREAK
-case 23:
-YY_RULE_SETUP
-#line 70 "arlex.l"
-{ return EXTRACT; }
-	YY_BREAK
-case 24:
-YY_RULE_SETUP
-#line 71 "arlex.l"
-{ return FULLDIR; }
-	YY_BREAK
-case 25:
-YY_RULE_SETUP
-#line 72 "arlex.l"
-{ return HELP; }
-	YY_BREAK
-case 26:
-YY_RULE_SETUP
-#line 73 "arlex.l"
-{ return LIST; }
-	YY_BREAK
-case 27:
-YY_RULE_SETUP
-#line 74 "arlex.l"
-{ return OPEN; }
-	YY_BREAK
-case 28:
-YY_RULE_SETUP
-#line 75 "arlex.l"
-{ return REPLACE; }
-	YY_BREAK
-case 29:
-YY_RULE_SETUP
-#line 76 "arlex.l"
-{ return VERBOSE; }
-	YY_BREAK
-case 30:
-YY_RULE_SETUP
-#line 77 "arlex.l"
-{ return SAVE; }
-	YY_BREAK
-case 31:
-YY_RULE_SETUP
-#line 78 "arlex.l"
-{ linenumber ++; }
-	YY_BREAK
-case 32:
-YY_RULE_SETUP
-#line 79 "arlex.l"
-{ return '('; }
-	YY_BREAK
-case 33:
-YY_RULE_SETUP
-#line 80 "arlex.l"
-{ return ')'; }
-	YY_BREAK
-case 34:
-YY_RULE_SETUP
-#line 81 "arlex.l"
-{ return ','; }
-	YY_BREAK
-case 35:
-YY_RULE_SETUP
-#line 82 "arlex.l"
-{ 	
-		yylval.name =  xstrdup (yytext);
-		return FILENAME;
-		}
-	YY_BREAK
-case 36:
-YY_RULE_SETUP
-#line 86 "arlex.l"
-{ }
-	YY_BREAK
-case 37:
-YY_RULE_SETUP
-#line 87 "arlex.l"
-{ }
-	YY_BREAK
-case 38:
-YY_RULE_SETUP
-#line 88 "arlex.l"
-{ }
-	YY_BREAK
-case 39:
-YY_RULE_SETUP
-#line 89 "arlex.l"
-{ linenumber ++; return NEWLINE; }	
-	YY_BREAK
-case 40:
-YY_RULE_SETUP
-#line 91 "arlex.l"
-ECHO;
-	YY_BREAK
-#line 953 "arlex.c"
-case YY_STATE_EOF(INITIAL):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state();
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer() )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap() )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of yylex */
-
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
-
-	else
-		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
-
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
-#endif
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
-
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	if ( yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
-
-	return ret_val;
-	}
-
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-static yy_state_type yy_get_previous_state()
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 177 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-	}
-
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 177 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 176);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
-
-
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
-
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
-
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
-
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput()
-#else
-static int input()
-#endif
-	{
-	int c;
-
-	*yy_c_buf_p = yy_hold_char;
-
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
-
-			switch ( yy_get_next_buffer() )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/* fall through */
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap() )
-						return EOF;
-
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
-
-	return c;
-	}
-#endif /* YY_NO_INPUT */
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
-
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
-		return;
-
-	if ( yy_current_buffer )
-		{
-		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
-
-
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
-	if ( ! b )
-		return;
-
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
-
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
-
-	{
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
-	{
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
-	}
-
-
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b );
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
-#endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
-
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
-
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
-
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
-
-
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
-
-
-/* Internal utility routines. */
-
-#ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-	}
-#endif
-
-#ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-	}
-#endif
-
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
-
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 91 "arlex.l"
-
-#ifndef yywrap
-/* Needed for lex, though not flex. */
-int yywrap(void) { return 1; }
-#endif
diff -r -N -u binutils-2.21.51/binutils/arparse.c binutils/binutils/arparse.c
--- binutils-2.21.51/binutils/arparse.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/arparse.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1449 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     NEWLINE = 258,
-     VERBOSE = 259,
-     FILENAME = 260,
-     ADDLIB = 261,
-     LIST = 262,
-     ADDMOD = 263,
-     CLEAR = 264,
-     CREATE = 265,
-     DELETE = 266,
-     DIRECTORY = 267,
-     END = 268,
-     EXTRACT = 269,
-     FULLDIR = 270,
-     HELP = 271,
-     QUIT = 272,
-     REPLACE = 273,
-     SAVE = 274,
-     OPEN = 275
-   };
-#endif
-#define NEWLINE 258
-#define VERBOSE 259
-#define FILENAME 260
-#define ADDLIB 261
-#define LIST 262
-#define ADDMOD 263
-#define CLEAR 264
-#define CREATE 265
-#define DELETE 266
-#define DIRECTORY 267
-#define END 268
-#define EXTRACT 269
-#define FULLDIR 270
-#define HELP 271
-#define QUIT 272
-#define REPLACE 273
-#define SAVE 274
-#define OPEN 275
-
-
-
-
-/* Copy the first part of user declarations.  */
-#line 1 "arparse.y"
-
-/* arparse.y - Stange script language parser */
-
-/* Copyright 1992, 1993, 1995, 1997, 1999, 2002, 2003, 2005, 2007
-   Free Software Foundation, Inc.
-
-   This file is part of GNU Binutils.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-
-/* Contributed by Steve Chamberlain
-   		  sac@cygnus.com
-
-*/
-#define DONTDECLARE_MALLOC
-#include "sysdep.h"
-#include "bfd.h"
-#include "arsup.h"
-extern int verbose;
-extern int yylex (void);
-static int yyerror (const char *);
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 38 "arparse.y"
-typedef union YYSTYPE {
-  char *name;
-struct list *list ;
-
-} YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 159 "arparse.c"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 214 of yacc.c.  */
-#line 171 "arparse.c"
-
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
-
-# ifndef YYFREE
-#  define YYFREE free
-# endif
-# ifndef YYMALLOC
-#  define YYMALLOC malloc
-# endif
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
-#  endif
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-# endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
-
-
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  short yyss;
-  YYSTYPE yyvs;
-  };
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAXIMUM)
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  register YYSIZE_T yyi;		\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (0)
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (0)
-
-#endif
-
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
-#define YYFINAL  3
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   34
-
-/* YYNTOKENS -- Number of terminals. */
-#define YYNTOKENS  24
-/* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  22
-/* YYNRULES -- Number of rules. */
-#define YYNRULES  42
-/* YYNRULES -- Number of states. */
-#define YYNSTATES  53
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   275
-
-#define YYTRANSLATE(YYX) 						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-      21,    22,     2,     2,    23,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    20
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const unsigned char yyprhs[] =
-{
-       0,     0,     3,     4,     7,    10,    11,    14,    16,    18,
-      20,    22,    24,    26,    28,    30,    32,    34,    36,    38,
-      40,    42,    44,    45,    48,    51,    53,    56,    59,    61,
-      63,    66,    69,    73,    78,    80,    81,    85,    86,    90,
-      91,    93,    94
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
-{
-      25,     0,    -1,    -1,    26,    27,    -1,    27,    28,    -1,
-      -1,    29,     3,    -1,    37,    -1,    38,    -1,    45,    -1,
-      40,    -1,    39,    -1,    32,    -1,    34,    -1,    36,    -1,
-      30,    -1,    31,    -1,    33,    -1,    35,    -1,    13,    -1,
-       1,    -1,     5,    -1,    -1,    14,    43,    -1,    18,    43,
-      -1,     9,    -1,    11,    43,    -1,     8,    43,    -1,     7,
-      -1,    19,    -1,    20,     5,    -1,    10,     5,    -1,     6,
-       5,    42,    -1,    12,     5,    42,    41,    -1,     5,    -1,
-      -1,    21,    43,    22,    -1,    -1,    43,    44,     5,    -1,
-      -1,    23,    -1,    -1,     4,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned char yyrline[] =
-{
-       0,    69,    69,    69,    73,    74,    78,    82,    83,    84,
-      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
-      95,    96,    97,   102,   107,   112,   117,   121,   126,   131,
-     138,   143,   149,   153,   160,   162,   166,   169,   173,   179,
-     184,   185,   190
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "NEWLINE", "VERBOSE", "FILENAME",
-  "ADDLIB", "LIST", "ADDMOD", "CLEAR", "CREATE", "DELETE", "DIRECTORY",
-  "END", "EXTRACT", "FULLDIR", "HELP", "QUIT", "REPLACE", "SAVE", "OPEN",
-  "'('", "')'", "','", "$accept", "start", "@1", "session", "command_line",
-  "command", "extract_command", "replace_command", "clear_command",
-  "delete_command", "addmod_command", "list_command", "save_command",
-  "open_command", "create_command", "addlib_command", "directory_command",
-  "optional_filename", "modulelist", "modulename", "optcomma",
-  "verbose_command", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,    40,    41,    44
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
-{
-       0,    24,    26,    25,    27,    27,    28,    29,    29,    29,
-      29,    29,    29,    29,    29,    29,    29,    29,    29,    29,
-      29,    29,    29,    30,    31,    32,    33,    34,    35,    36,
-      37,    38,    39,    40,    41,    41,    42,    42,    43,    43,
-      44,    44,    45
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
-{
-       0,     2,     0,     2,     2,     0,     2,     1,     1,     1,
-       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-       1,     1,     0,     2,     2,     1,     2,     2,     1,     1,
-       2,     2,     3,     4,     1,     0,     3,     0,     3,     0,
-       1,     0,     1
-};
-
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const unsigned char yydefact[] =
-{
-       2,     0,     5,     1,     0,    20,    42,    21,     0,    28,
-      39,    25,     0,    39,     0,    19,    39,    39,    29,     0,
-       4,     0,    15,    16,    12,    17,    13,    18,    14,     7,
-       8,    11,    10,     9,    37,    27,    31,    26,    37,    23,
-      24,    30,     6,    39,    32,    40,     0,    35,    41,    38,
-      34,    33,    36
-};
-
-/* YYDEFGOTO[NTERM-NUM]. */
-static const yysigned_char yydefgoto[] =
-{
-      -1,     1,     2,     4,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    51,    44,    35,
-      46,    33
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -14
-static const yysigned_char yypact[] =
-{
-     -14,     1,   -14,   -14,     5,   -14,   -14,   -14,     2,   -14,
-     -14,   -14,    21,   -14,    22,   -14,   -14,   -14,   -14,    23,
-     -14,    26,   -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,
-     -14,   -14,   -14,   -14,    10,    -3,   -14,    -3,    10,    -3,
-      -3,   -14,   -14,   -14,   -14,   -14,    27,    28,    -1,   -14,
-     -14,   -14,   -14
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const yysigned_char yypgoto[] =
-{
-     -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,
-     -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,    -4,   -13,
-     -14,   -14
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -42
-static const yysigned_char yytable[] =
-{
-      37,     3,   -41,    39,    40,    -3,     5,    34,   -22,     6,
-       7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
-      45,    52,    45,    17,    18,    19,    36,    38,    41,    42,
-      48,    43,    49,    50,    47
-};
-
-static const unsigned char yycheck[] =
-{
-      13,     0,     5,    16,    17,     0,     1,     5,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      23,    22,    23,    18,    19,    20,     5,     5,     5,     3,
-      43,    21,     5,     5,    38
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
-{
-       0,    25,    26,     0,    27,     1,     4,     5,     6,     7,
-       8,     9,    10,    11,    12,    13,    14,    18,    19,    20,
-      28,    29,    30,    31,    32,    33,    34,    35,    36,    37,
-      38,    39,    40,    45,     5,    43,     5,    43,     5,    43,
-      43,     5,     3,    21,    42,    23,    44,    42,    43,     5,
-       5,    41,    22
-};
-
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-
-#define YYFAIL		goto yyerrlab
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
-      YYERROR;							\
-    }								\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
-
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
-#endif
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
-#endif
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (0)
-
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
-
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_stack_print (short *bottom, short *top)
-#else
-static void
-yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
-#endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (0)
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_reduce_print (int yyrule)
-#else
-static void
-yy_reduce_print (yyrule)
-    int yyrule;
-#endif
-{
-  int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
-yystrlen (const char *yystr)
-#   else
-yystrlen (yystr)
-     const char *yystr;
-#   endif
-{
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
-    continue;
-
-  return yys - yystr - 1;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-#   if defined (__STDC__) || defined (__cplusplus)
-yystpcpy (char *yydest, const char *yysrc)
-#   else
-yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
-{
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-#endif /* !YYERROR_VERBOSE */
-
-
-
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  if (yytype < YYNTOKENS)
-    {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-  switch (yytype)
-    {
-      default:
-        break;
-    }
-  YYFPRINTF (yyoutput, ")");
-}
-
-#endif /* ! YYDEBUG */
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yydestruct (yytype, yyvaluep)
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  switch (yytype)
-    {
-
-      default:
-        break;
-    }
-}
-
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM);
-# else
-int yyparse ();
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-
-/* The lookahead symbol.  */
-int yychar;
-
-/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int
-yyparse (void)
-#else
-int
-yyparse ()
-
-#endif
-#endif
-{
-  
-  register int yystate;
-  register int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss;
-  yyvsp = yyvs;
-
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-	/* Give user a chance to reallocate the stack. Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
-
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-
-		    &yystacksize);
-
-	yyss = yyss1;
-	yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
-      {
-	short *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyoverflowlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
-    {
-        case 2:
-#line 69 "arparse.y"
-    { prompt(); }
-    break;
-
-  case 6:
-#line 78 "arparse.y"
-    { prompt(); }
-    break;
-
-  case 19:
-#line 94 "arparse.y"
-    { ar_end(); return 0; }
-    break;
-
-  case 21:
-#line 96 "arparse.y"
-    { yyerror("foo"); }
-    break;
-
-  case 23:
-#line 103 "arparse.y"
-    { ar_extract(yyvsp[0].list); }
-    break;
-
-  case 24:
-#line 108 "arparse.y"
-    { ar_replace(yyvsp[0].list); }
-    break;
-
-  case 25:
-#line 113 "arparse.y"
-    { ar_clear(); }
-    break;
-
-  case 26:
-#line 118 "arparse.y"
-    { ar_delete(yyvsp[0].list); }
-    break;
-
-  case 27:
-#line 122 "arparse.y"
-    { ar_addmod(yyvsp[0].list); }
-    break;
-
-  case 28:
-#line 127 "arparse.y"
-    { ar_list(); }
-    break;
-
-  case 29:
-#line 132 "arparse.y"
-    { ar_save(); }
-    break;
-
-  case 30:
-#line 139 "arparse.y"
-    { ar_open(yyvsp[0].name,0); }
-    break;
-
-  case 31:
-#line 144 "arparse.y"
-    { ar_open(yyvsp[0].name,1); }
-    break;
-
-  case 32:
-#line 150 "arparse.y"
-    { ar_addlib(yyvsp[-1].name,yyvsp[0].list); }
-    break;
-
-  case 33:
-#line 154 "arparse.y"
-    { ar_directory(yyvsp[-2].name, yyvsp[-1].list, yyvsp[0].name); }
-    break;
-
-  case 34:
-#line 161 "arparse.y"
-    { yyval.name = yyvsp[0].name; }
-    break;
-
-  case 35:
-#line 162 "arparse.y"
-    { yyval.name = 0; }
-    break;
-
-  case 36:
-#line 167 "arparse.y"
-    { yyval.list = yyvsp[-1].list; }
-    break;
-
-  case 37:
-#line 169 "arparse.y"
-    { yyval.list = 0; }
-    break;
-
-  case 38:
-#line 174 "arparse.y"
-    { 	struct list *n  = (struct list *) malloc(sizeof(struct list));
-			n->next = yyvsp[-2].list; 
-			n->name = yyvsp[0].name;
-			yyval.list = n;
-		 }
-    break;
-
-  case 39:
-#line 179 "arparse.y"
-    { yyval.list = 0; }
-    break;
-
-  case 42:
-#line 191 "arparse.y"
-    { verbose = !verbose; }
-    break;
-
-
-    }
-
-/* Line 1000 of yacc.c.  */
-#line 1214 "arparse.c"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
-	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
-
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
-	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
-      else
-	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
-	  yychar = YYEMPTY;
-
-	}
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
-     goto yyerrorlab;
-#endif
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-	YYABORT;
-
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
-  *++yyvsp = yylval;
-
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-yyreturn:
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-  return yyresult;
-}
-
-
-#line 195 "arparse.y"
-
-
-static int
-yyerror (const char *x ATTRIBUTE_UNUSED)
-{
-  extern int linenumber;
-
-  printf (_("Syntax error in archive script, line %d\n"), linenumber + 1);
-  return 0;
-}
-
diff -r -N -u binutils-2.21.51/binutils/arparse.h binutils/binutils/arparse.h
--- binutils-2.21.51/binutils/arparse.h	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/arparse.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,91 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     NEWLINE = 258,
-     VERBOSE = 259,
-     FILENAME = 260,
-     ADDLIB = 261,
-     LIST = 262,
-     ADDMOD = 263,
-     CLEAR = 264,
-     CREATE = 265,
-     DELETE = 266,
-     DIRECTORY = 267,
-     END = 268,
-     EXTRACT = 269,
-     FULLDIR = 270,
-     HELP = 271,
-     QUIT = 272,
-     REPLACE = 273,
-     SAVE = 274,
-     OPEN = 275
-   };
-#endif
-#define NEWLINE 258
-#define VERBOSE 259
-#define FILENAME 260
-#define ADDLIB 261
-#define LIST 262
-#define ADDMOD 263
-#define CLEAR 264
-#define CREATE 265
-#define DELETE 266
-#define DIRECTORY 267
-#define END 268
-#define EXTRACT 269
-#define FULLDIR 270
-#define HELP 271
-#define QUIT 272
-#define REPLACE 273
-#define SAVE 274
-#define OPEN 275
-
-
-
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 38 "arparse.y"
-typedef union YYSTYPE {
-  char *name;
-struct list *list ;
-
-} YYSTYPE;
-/* Line 1275 of yacc.c.  */
-#line 83 "arparse.h"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-extern YYSTYPE yylval;
-
-
-
diff -r -N -u binutils-2.21.51/binutils/configure binutils/binutils/configure
--- binutils-2.21.51/binutils/configure	2011-06-14 09:27:52.000000000 +0100
+++ binutils/binutils/configure	2011-07-06 12:44:26.137253000 +0100
@@ -650,6 +650,7 @@
 YACC
 NO_WERROR
 WARN_CFLAGS
+SIM
 OTOOL64
 OTOOL
 LIPO
@@ -11543,6 +11544,8 @@
 
 
 
+
+
 # Check whether --enable-targets was given.
 if test "${enable_targets+set}" = set; then :
   enableval=$enable_targets; case "${enableval}" in
@@ -13880,6 +13883,9 @@
 	  fi
 	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_I386"
 	  ;;
+	lx-*-*)
+	  OBJDUMP_DEFS="$OBJDUMP_DEFS -DSKIP_ZEROES=16"
+	  ;;
 	powerpc*-aix5.[01])
 	  ;;
 	powerpc*-aix[5-9].*)
diff -r -N -u binutils-2.21.51/binutils/configure.in binutils/binutils/configure.in
--- binutils-2.21.51/binutils/configure.in	2011-06-14 09:27:52.000000000 +0100
+++ binutils/binutils/configure.in	2011-07-06 12:44:26.137253000 +0100
@@ -19,6 +19,8 @@
 ACX_LARGEFILE
 LT_INIT
 
+AC_SUBST(SIM)
+
 AC_ARG_ENABLE(targets,
 [  --enable-targets        alternative target configurations],
 [case "${enableval}" in
@@ -285,6 +287,9 @@
 	  fi
 	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_I386"
 	  ;;
+	lx-*-*)
+	  OBJDUMP_DEFS="$OBJDUMP_DEFS -DSKIP_ZEROES=16"
+	  ;;
 changequote(,)dnl
 	powerpc*-aix5.[01])
 changequote([,])dnl
diff -r -N -u binutils-2.21.51/binutils/deflex.c binutils/binutils/deflex.c
--- binutils-2.21.51/binutils/deflex.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/deflex.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1867 +0,0 @@
-/* A lexical scanner generated by flex */
-
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
- */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-
-#include <stdio.h>
-#include <unistd.h>
-
-
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
-
-
-#ifdef __cplusplus
-
-#include <stdlib.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_PROTOS
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yy_start = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yy_start - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#define YY_BUF_SIZE 16384
-
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-
-extern int yyleng;
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
-
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-	};
-
-static YY_BUFFER_STATE yy_current_buffer = 0;
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- */
-#define YY_CURRENT_BUFFER yy_current_buffer
-
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
-
-typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
-
-#define YY_NUM_RULES 42
-#define YY_END_OF_BUFFER 43
-static yyconst short int yy_accept[199] =
-    {   0,
-        0,    0,   43,   42,   34,   36,   35,   33,   42,   28,
-       42,   31,   41,   39,   27,   32,   38,   40,   28,   28,
-       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
-       28,   28,   28,    0,   29,   28,    0,   30,   31,   27,
-       32,   37,   28,   28,   28,   28,   28,   28,   28,   28,
-       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
-       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
-       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
-       28,   28,   28,   28,   28,   28,   28,   12,    6,   28,
-        7,   28,   28,   28,   28,   28,   28,   28,   28,    1,
-
-       28,   28,   28,   16,   28,   28,   28,   28,   28,   28,
-       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
-       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
-       28,   17,   28,   28,   28,   28,   28,   28,   28,   28,
-       28,   28,   14,   28,   28,   28,   19,   21,   28,   28,
-       28,   28,   28,   28,   18,    9,   28,   10,   28,   28,
-        2,   28,   28,   15,   28,   28,   28,   28,   11,   13,
-       28,    5,   28,   28,   22,   28,    8,   28,   28,   28,
-       28,   28,   28,   20,    4,   28,   28,   28,   24,   28,
-       26,   28,    3,   28,   28,   23,   25,    0
-
-    } ;
-
-static yyconst int yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    5,    1,    6,    1,    7,    1,    1,    8,    1,
-        1,    9,    1,   10,    7,   11,   12,   13,   13,   13,
-       13,   13,   13,   13,   13,   13,   13,    7,   14,   12,
-       15,   12,    7,   16,   17,   18,   19,   20,   21,   22,
-       23,   24,   25,    7,   26,   27,   28,   29,   30,   31,
-        7,   32,   33,   34,   35,   36,   37,   38,   39,   40,
-        1,    1,    1,    1,    7,    1,   22,   22,   22,   22,
-
-       22,   22,    7,    7,    7,    7,    7,    7,    7,    7,
-        7,    7,    7,    7,    7,    7,    7,    7,    7,   22,
-        7,    7,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst int yy_meta[41] =
-    {   0,
-        1,    1,    2,    1,    1,    1,    3,    1,    1,    1,
-        1,    4,    5,    1,    1,    4,    6,    6,    6,    6,
-        6,    6,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3
-    } ;
-
-static yyconst short int yy_base[206] =
-    {   0,
-        0,    0,  230,  231,  231,  231,  231,  231,  223,    0,
-      220,    0,  231,  231,    0,    0,  212,    0,  209,  195,
-       24,  186,  202,   14,  197,  186,   27,  188,  198,   25,
-      197,  196,  184,  209,  231,    0,  206,  231,    0,    0,
-        0,  231,    0,  180,   27,  178,  178,   27,  193,  178,
-      183,  189,  179,  177,  175,  178,  185,  182,  183,  170,
-      181,  165,  164,  170,  173,  172,  159,  174,  171,  170,
-      158,  156,  156,  151,  152,  149,  161,   34,  145,  160,
-      145,  146,  154,  157,  147,  141,  139,    0,    0,  138,
-        0,  139,  135,  137,  135,  135,   29,  149,  140,    0,
-
-      136,  139,  145,    0,  136,  139,  132,  132,   30,  132,
-      135,  138,  129,  119,  118,  126,  116,  122,  119,  115,
-      115,  124,  127,  109,  112,  121,  119,  106,  111,  108,
-      106,    0,  106,  103,  112,   99,   91,   97,   99,   95,
-       88,   99,    0,   93,  103,   94,    0,    0,   97,   91,
-       87,   90,   84,   83,    0,    0,   95,    0,   97,   80,
-        0,   92,   91,    0,   78,   70,   91,   74,    0,    0,
-       82,    0,   89,   88,    0,   84,    0,   82,   85,   83,
-       69,   66,   56,    0,    0,   39,   36,   35,    0,   44,
-        0,   43,    0,   40,   39,    0,    0,  231,   67,   71,
-
-       77,   83,   85,   91,   95
-    } ;
-
-static yyconst short int yy_def[206] =
-    {   0,
-      198,    1,  198,  198,  198,  198,  198,  198,  199,  200,
-      201,  202,  198,  198,  203,  204,  198,  205,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  199,  198,  200,  201,  198,  202,  203,
-      204,  198,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
-      200,  200,  200,  200,  200,  200,  200,    0,  198,  198,
-
-      198,  198,  198,  198,  198
-    } ;
-
-static yyconst short int yy_nxt[272] =
-    {   0,
-        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
-       14,    4,   15,   16,   17,   18,   10,   19,   20,   21,
-       22,   10,   10,   23,   24,   10,   25,   26,   27,   10,
-       28,   29,   30,   31,   10,   32,   33,   10,   10,   10,
-       46,   50,   51,   54,   47,   58,   66,   70,   59,   60,
-      101,  118,  129,  119,  130,   67,   55,   71,   61,  197,
-      196,  195,  194,  193,  192,  191,  102,   34,   34,   34,
-       34,   34,   34,   36,   36,   36,   36,   37,   37,   37,
-       37,   37,   37,   39,  190,   39,   39,   39,   39,   40,
-       40,   41,  189,   41,   41,   41,   41,   43,  188,  187,
-
-       43,  186,  185,  184,  183,  182,  181,  180,  179,  178,
-      177,  176,  175,  174,  173,  172,  171,  170,  169,  168,
-      167,  166,  165,  164,  163,  162,  161,  160,  159,  158,
-      157,  156,  155,  154,  153,  152,  151,  150,  149,  148,
-      147,  146,  145,  144,  143,  142,  141,  140,  139,  138,
-      137,  136,  135,  134,  133,  132,  131,  128,  127,  126,
-      125,  124,  123,  122,  121,  120,  117,  116,  115,  114,
-      113,  112,  111,  110,  109,  108,  107,  106,  105,  104,
-      103,  100,   99,   98,   97,   96,   95,   94,   93,   92,
-       91,   90,   89,   88,   87,   86,   85,   84,   83,   82,
-
-       81,   80,   79,   78,   77,   76,   75,   74,   73,   72,
-       69,   68,   65,   38,   35,   64,   63,   62,   57,   56,
-       53,   52,   49,   48,   45,   44,   42,   38,   35,  198,
-        3,  198,  198,  198,  198,  198,  198,  198,  198,  198,
-      198,  198,  198,  198,  198,  198,  198,  198,  198,  198,
-      198,  198,  198,  198,  198,  198,  198,  198,  198,  198,
-      198,  198,  198,  198,  198,  198,  198,  198,  198,  198,
-      198
-    } ;
-
-static yyconst short int yy_chk[272] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-       21,   24,   24,   27,   21,   30,   45,   48,   30,   30,
-       78,   97,  109,   97,  109,   45,   27,   48,   30,  195,
-      194,  192,  190,  188,  187,  186,   78,  199,  199,  199,
-      199,  199,  199,  200,  200,  200,  200,  201,  201,  201,
-      201,  201,  201,  202,  183,  202,  202,  202,  202,  203,
-      203,  204,  182,  204,  204,  204,  204,  205,  181,  180,
-
-      205,  179,  178,  176,  174,  173,  171,  168,  167,  166,
-      165,  163,  162,  160,  159,  157,  154,  153,  152,  151,
-      150,  149,  146,  145,  144,  142,  141,  140,  139,  138,
-      137,  136,  135,  134,  133,  131,  130,  129,  128,  127,
-      126,  125,  124,  123,  122,  121,  120,  119,  118,  117,
-      116,  115,  114,  113,  112,  111,  110,  108,  107,  106,
-      105,  103,  102,  101,   99,   98,   96,   95,   94,   93,
-       92,   90,   87,   86,   85,   84,   83,   82,   81,   80,
-       79,   77,   76,   75,   74,   73,   72,   71,   70,   69,
-       68,   67,   66,   65,   64,   63,   62,   61,   60,   59,
-
-       58,   57,   56,   55,   54,   53,   52,   51,   50,   49,
-       47,   46,   44,   37,   34,   33,   32,   31,   29,   28,
-       26,   25,   23,   22,   20,   19,   17,   11,    9,    3,
-      198,  198,  198,  198,  198,  198,  198,  198,  198,  198,
-      198,  198,  198,  198,  198,  198,  198,  198,  198,  198,
-      198,  198,  198,  198,  198,  198,  198,  198,  198,  198,
-      198,  198,  198,  198,  198,  198,  198,  198,  198,  198,
-      198
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "deflex.l"
-#define INITIAL 0
-#line 2 "deflex.l"
-
-/* Copyright 1995, 1997, 1998, 1999, 2002, 2003, 2004, 2005, 2007
-   Free Software Foundation, Inc.
-   
-   This file is part of GNU Binutils.
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-
-/* Contributed by Steve Chamberlain: sac@cygnus.com  */
-
-#define DONTDECLARE_MALLOC
-#include "libiberty.h"
-#include "defparse.h"
-#include "dlltool.h"
-
-#define YY_NO_UNPUT
-
-int linenumber;
-
-#line 523 "deflex.c"
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
-#else
-extern int yywrap YY_PROTO(( void ));
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
-
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
-#endif
-
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
-		{ \
-		int c = '*', n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-YY_DECL
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp = NULL, *yy_bp = NULL;
-	register int yy_act;
-
-#line 36 "deflex.l"
-
-#line 676 "deflex.c"
-
-	if ( yy_init )
-		{
-		yy_init = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-
-		yy_load_buffer_state();
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yy_start;
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 199 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 231 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-
-do_action:	/* This label is used only to access EOF actions. */
-
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 37 "deflex.l"
-{ return NAME;}
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 38 "deflex.l"
-{ return LIBRARY;}
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 39 "deflex.l"
-{ return DESCRIPTION;}
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 40 "deflex.l"
-{ return STACKSIZE;}
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 41 "deflex.l"
-{ return HEAPSIZE;}
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 42 "deflex.l"
-{ return CODE;}
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 43 "deflex.l"
-{ return DATA;}
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 44 "deflex.l"
-{ return SECTIONS;}
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 45 "deflex.l"
-{ return EXPORTS;}
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 46 "deflex.l"
-{ return IMPORTS;}
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 47 "deflex.l"
-{ return VERSIONK;}
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 48 "deflex.l"
-{ return BASE;}
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 49 "deflex.l"
-{ return CONSTANT; }
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 50 "deflex.l"
-{ return NONAME; }
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 51 "deflex.l"
-{ return PRIVATE; }
-	YY_BREAK
-case 16:
-YY_RULE_SETUP
-#line 52 "deflex.l"
-{ return READ;}
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 53 "deflex.l"
-{ return WRITE;}
-	YY_BREAK
-case 18:
-YY_RULE_SETUP
-#line 54 "deflex.l"
-{ return EXECUTE;}
-	YY_BREAK
-case 19:
-YY_RULE_SETUP
-#line 55 "deflex.l"
-{ return SHARED;}
-	YY_BREAK
-case 20:
-YY_RULE_SETUP
-#line 56 "deflex.l"
-{ return NONSHARED;}
-	YY_BREAK
-case 21:
-YY_RULE_SETUP
-#line 57 "deflex.l"
-{ return SINGLE;}
-	YY_BREAK
-case 22:
-YY_RULE_SETUP
-#line 58 "deflex.l"
-{ return MULTIPLE;}
-	YY_BREAK
-case 23:
-YY_RULE_SETUP
-#line 59 "deflex.l"
-{ return INITINSTANCE;}
-	YY_BREAK
-case 24:
-YY_RULE_SETUP
-#line 60 "deflex.l"
-{ return INITGLOBAL;}
-	YY_BREAK
-case 25:
-YY_RULE_SETUP
-#line 61 "deflex.l"
-{ return TERMINSTANCE;}
-	YY_BREAK
-case 26:
-YY_RULE_SETUP
-#line 62 "deflex.l"
-{ return TERMGLOBAL;}
-	YY_BREAK
-case 27:
-YY_RULE_SETUP
-#line 64 "deflex.l"
-{ yylval.number = strtol (yytext,0,0); 
-		return NUMBER; }
-	YY_BREAK
-case 28:
-YY_RULE_SETUP
-#line 67 "deflex.l"
-{ 	
-		yylval.id =  xstrdup (yytext);
-		return ID;
-		}
-	YY_BREAK
-case 29:
-YY_RULE_SETUP
-#line 72 "deflex.l"
-{
-		yylval.id = xstrdup (yytext+1);
-		yylval.id[yyleng-2] = 0;
-		return ID;
-		}
-	YY_BREAK
-case 30:
-YY_RULE_SETUP
-#line 78 "deflex.l"
-{
-		yylval.id = xstrdup (yytext+1);
-		yylval.id[yyleng-2] = 0;
-		return ID;
-		}
-	YY_BREAK
-case 31:
-YY_RULE_SETUP
-#line 83 "deflex.l"
-{ }
-	YY_BREAK
-case 32:
-YY_RULE_SETUP
-#line 84 "deflex.l"
-{ }
-	YY_BREAK
-case 33:
-YY_RULE_SETUP
-#line 85 "deflex.l"
-{ }
-	YY_BREAK
-case 34:
-YY_RULE_SETUP
-#line 86 "deflex.l"
-{ }
-	YY_BREAK
-case 35:
-YY_RULE_SETUP
-#line 87 "deflex.l"
-{ }
-	YY_BREAK
-case 36:
-YY_RULE_SETUP
-#line 88 "deflex.l"
-{ linenumber ++ ;}
-	YY_BREAK
-case 37:
-YY_RULE_SETUP
-#line 89 "deflex.l"
-{ return EQUAL;}
-	YY_BREAK
-case 38:
-YY_RULE_SETUP
-#line 90 "deflex.l"
-{ return '=';}
-	YY_BREAK
-case 39:
-YY_RULE_SETUP
-#line 91 "deflex.l"
-{ return '.';}
-	YY_BREAK
-case 40:
-YY_RULE_SETUP
-#line 92 "deflex.l"
-{ return '@';}
-	YY_BREAK
-case 41:
-YY_RULE_SETUP
-#line 93 "deflex.l"
-{ return ',';}
-	YY_BREAK
-case 42:
-YY_RULE_SETUP
-#line 94 "deflex.l"
-ECHO;
-	YY_BREAK
-#line 981 "deflex.c"
-case YY_STATE_EOF(INITIAL):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state();
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer() )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap() )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of yylex */
-
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
-
-	else
-		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
-
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
-#endif
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
-
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	if ( yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
-
-	return ret_val;
-	}
-
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-static yy_state_type yy_get_previous_state()
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 199 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-	}
-
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 199 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 198);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
-
-
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
-
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
-
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
-
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput()
-#else
-static int input()
-#endif
-	{
-	int c;
-
-	*yy_c_buf_p = yy_hold_char;
-
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
-
-			switch ( yy_get_next_buffer() )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/* fall through */
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap() )
-						return EOF;
-
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
-
-	return c;
-	}
-#endif /* YY_NO_INPUT */
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
-
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
-		return;
-
-	if ( yy_current_buffer )
-		{
-		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
-
-
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
-	if ( ! b )
-		return;
-
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
-
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
-
-	{
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
-	{
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
-	}
-
-
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b );
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
-#endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
-
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
-
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
-
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
-
-
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
-
-
-/* Internal utility routines. */
-
-#ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-	}
-#endif
-
-#ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-	}
-#endif
-
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
-
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 94 "deflex.l"
-
-#ifndef yywrap
-/* Needed for lex, though not flex. */
-int yywrap(void) { return 1; }
-#endif
diff -r -N -u binutils-2.21.51/binutils/defparse.c binutils/binutils/defparse.c
--- binutils-2.21.51/binutils/defparse.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/defparse.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1645 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     NAME = 258,
-     LIBRARY = 259,
-     DESCRIPTION = 260,
-     STACKSIZE = 261,
-     HEAPSIZE = 262,
-     CODE = 263,
-     DATA = 264,
-     SECTIONS = 265,
-     EXPORTS = 266,
-     IMPORTS = 267,
-     VERSIONK = 268,
-     BASE = 269,
-     CONSTANT = 270,
-     READ = 271,
-     WRITE = 272,
-     EXECUTE = 273,
-     SHARED = 274,
-     NONSHARED = 275,
-     NONAME = 276,
-     PRIVATE = 277,
-     SINGLE = 278,
-     MULTIPLE = 279,
-     INITINSTANCE = 280,
-     INITGLOBAL = 281,
-     TERMINSTANCE = 282,
-     TERMGLOBAL = 283,
-     EQUAL = 284,
-     ID = 285,
-     NUMBER = 286
-   };
-#endif
-#define NAME 258
-#define LIBRARY 259
-#define DESCRIPTION 260
-#define STACKSIZE 261
-#define HEAPSIZE 262
-#define CODE 263
-#define DATA 264
-#define SECTIONS 265
-#define EXPORTS 266
-#define IMPORTS 267
-#define VERSIONK 268
-#define BASE 269
-#define CONSTANT 270
-#define READ 271
-#define WRITE 272
-#define EXECUTE 273
-#define SHARED 274
-#define NONSHARED 275
-#define NONAME 276
-#define PRIVATE 277
-#define SINGLE 278
-#define MULTIPLE 279
-#define INITINSTANCE 280
-#define INITGLOBAL 281
-#define TERMINSTANCE 282
-#define TERMGLOBAL 283
-#define EQUAL 284
-#define ID 285
-#define NUMBER 286
-
-
-
-
-/* Copy the first part of user declarations.  */
-#line 1 "defparse.y"
- /* defparse.y - parser for .def files */
-
-/* Copyright 1995, 1997, 1998, 1999, 2001, 2004, 2005, 2007
-   Free Software Foundation, Inc.
-   
-   This file is part of GNU Binutils.
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-#include "sysdep.h"
-#include "bfd.h"
-#include "libiberty.h"
-#include "dlltool.h"
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 29 "defparse.y"
-typedef union YYSTYPE {
-  char *id;
-  int number;
-} YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 171 "defparse.c"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 214 of yacc.c.  */
-#line 183 "defparse.c"
-
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
-
-# ifndef YYFREE
-#  define YYFREE free
-# endif
-# ifndef YYMALLOC
-#  define YYMALLOC malloc
-# endif
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
-#  endif
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-# endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
-
-
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  short yyss;
-  YYSTYPE yyvs;
-  };
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAXIMUM)
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  register YYSIZE_T yyi;		\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (0)
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (0)
-
-#endif
-
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
-#define YYFINAL  38
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   120
-
-/* YYNTOKENS -- Number of terminals. */
-#define YYNTOKENS  36
-/* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  24
-/* YYNRULES -- Number of rules. */
-#define YYNRULES  70
-/* YYNRULES -- Number of states. */
-#define YYNSTATES  109
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   286
-
-#define YYTRANSLATE(YYX) 						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,    34,     2,    32,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,    33,     2,     2,    35,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const unsigned char yyprhs[] =
-{
-       0,     0,     3,     6,     8,    12,    17,    20,    23,    27,
-      31,    34,    37,    40,    43,    46,    51,    52,    55,    64,
-      67,    69,    78,    87,    94,   101,   108,   115,   120,   125,
-     128,   130,   133,   137,   139,   141,   142,   145,   146,   148,
-     150,   152,   154,   156,   158,   160,   162,   163,   165,   166,
-     168,   169,   171,   172,   174,   178,   179,   182,   183,   186,
-     187,   190,   195,   196,   200,   201,   202,   206,   208,   210,
-     212
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
-{
-      37,     0,    -1,    37,    38,    -1,    38,    -1,     3,    53,
-      57,    -1,     4,    53,    57,    58,    -1,    11,    39,    -1,
-       5,    30,    -1,     6,    31,    47,    -1,     7,    31,    47,
-      -1,     8,    45,    -1,     9,    45,    -1,    10,    43,    -1,
-      12,    41,    -1,    13,    31,    -1,    13,    31,    32,    31,
-      -1,    -1,    39,    40,    -1,    30,    56,    54,    50,    49,
-      51,    52,    55,    -1,    41,    42,    -1,    42,    -1,    30,
-      33,    30,    32,    30,    32,    30,    55,    -1,    30,    33,
-      30,    32,    30,    32,    31,    55,    -1,    30,    33,    30,
-      32,    30,    55,    -1,    30,    33,    30,    32,    31,    55,
-      -1,    30,    32,    30,    32,    30,    55,    -1,    30,    32,
-      30,    32,    31,    55,    -1,    30,    32,    30,    55,    -1,
-      30,    32,    31,    55,    -1,    43,    44,    -1,    44,    -1,
-      30,    45,    -1,    45,    46,    48,    -1,    48,    -1,    34,
-      -1,    -1,    34,    31,    -1,    -1,    16,    -1,    17,    -1,
-      18,    -1,    19,    -1,    20,    -1,    23,    -1,    24,    -1,
-      15,    -1,    -1,    21,    -1,    -1,     9,    -1,    -1,    22,
-      -1,    -1,    30,    -1,    30,    32,    30,    -1,    -1,    35,
-      31,    -1,    -1,    29,    30,    -1,    -1,    33,    30,    -1,
-      33,    30,    32,    30,    -1,    -1,    14,    33,    31,    -1,
-      -1,    -1,    58,    46,    59,    -1,    25,    -1,    26,    -1,
-      27,    -1,    28,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned char yyrline[] =
-{
-       0,    47,    47,    48,    52,    53,    54,    55,    56,    57,
-      58,    59,    60,    61,    62,    63,    67,    69,    73,    78,
-      79,    83,    85,    87,    89,    91,    93,    95,    97,   102,
-     103,   107,   111,   112,   116,   117,   119,   120,   124,   125,
-     126,   127,   128,   129,   130,   134,   135,   139,   140,   144,
-     145,   149,   150,   153,   154,   160,   164,   165,   169,   170,
-     174,   175,   181,   184,   185,   188,   190,   194,   195,   196,
-     197
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "NAME", "LIBRARY", "DESCRIPTION",
-  "STACKSIZE", "HEAPSIZE", "CODE", "DATA", "SECTIONS", "EXPORTS",
-  "IMPORTS", "VERSIONK", "BASE", "CONSTANT", "READ", "WRITE", "EXECUTE",
-  "SHARED", "NONSHARED", "NONAME", "PRIVATE", "SINGLE", "MULTIPLE",
-  "INITINSTANCE", "INITGLOBAL", "TERMINSTANCE", "TERMGLOBAL", "EQUAL",
-  "ID", "NUMBER", "'.'", "'='", "','", "'@'", "$accept", "start",
-  "command", "explist", "expline", "implist", "impline", "seclist",
-  "secline", "attr_list", "opt_comma", "opt_number", "attr",
-  "opt_CONSTANT", "opt_NONAME", "opt_DATA", "opt_PRIVATE", "opt_name",
-  "opt_ordinal", "opt_import_name", "opt_equal_name", "opt_base",
-  "option_list", "option", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,    46,    61,    44,    64
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
-{
-       0,    36,    37,    37,    38,    38,    38,    38,    38,    38,
-      38,    38,    38,    38,    38,    38,    39,    39,    40,    41,
-      41,    42,    42,    42,    42,    42,    42,    42,    42,    43,
-      43,    44,    45,    45,    46,    46,    47,    47,    48,    48,
-      48,    48,    48,    48,    48,    49,    49,    50,    50,    51,
-      51,    52,    52,    53,    53,    53,    54,    54,    55,    55,
-      56,    56,    56,    57,    57,    58,    58,    59,    59,    59,
-      59
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
-{
-       0,     2,     2,     1,     3,     4,     2,     2,     3,     3,
-       2,     2,     2,     2,     2,     4,     0,     2,     8,     2,
-       1,     8,     8,     6,     6,     6,     6,     4,     4,     2,
-       1,     2,     3,     1,     1,     0,     2,     0,     1,     1,
-       1,     1,     1,     1,     1,     1,     0,     1,     0,     1,
-       0,     1,     0,     1,     3,     0,     2,     0,     2,     0,
-       2,     4,     0,     3,     0,     0,     3,     1,     1,     1,
-       1
-};
-
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const unsigned char yydefact[] =
-{
-       0,    55,    55,     0,     0,     0,     0,     0,     0,    16,
-       0,     0,     0,     3,    53,    64,    64,     7,    37,    37,
-      38,    39,    40,    41,    42,    43,    44,    10,    33,    11,
-       0,    12,    30,     6,     0,    13,    20,    14,     1,     2,
-       0,     0,     4,    65,     0,     8,     9,    34,     0,    31,
-      29,    62,    17,     0,     0,    19,     0,    54,     0,     5,
-      36,    32,     0,    57,    59,    59,     0,    15,    63,     0,
-      60,     0,    48,     0,     0,    27,    28,     0,    67,    68,
-      69,    70,    66,     0,    56,    47,    46,    58,    59,    59,
-      59,    59,    61,    45,    50,    25,    26,     0,    23,    24,
-      49,    52,    59,    59,    51,    59,    21,    22,    18
-};
-
-/* YYDEFGOTO[NTERM-NUM]. */
-static const yysigned_char yydefgoto[] =
-{
-      -1,    12,    13,    33,    52,    35,    36,    31,    32,    27,
-      48,    45,    28,    94,    86,   101,   105,    15,    72,    75,
-      63,    42,    59,    82
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -66
-static const yysigned_char yypact[] =
-{
-      50,   -29,   -29,    -8,   -28,    10,    48,    48,    40,   -66,
-      47,    38,    39,   -66,    46,    65,    65,   -66,    49,    49,
-     -66,   -66,   -66,   -66,   -66,   -66,   -66,    -6,   -66,    -6,
-      48,    40,   -66,    51,   -12,    47,   -66,    52,   -66,   -66,
-      55,    53,   -66,   -66,    56,   -66,   -66,   -66,    48,    -6,
-     -66,    57,   -66,     3,    58,   -66,    60,   -66,    61,   -19,
-     -66,   -66,    59,    62,   -27,    64,    63,   -66,   -66,     4,
-      66,    68,    73,    70,     5,   -66,   -66,    43,   -66,   -66,
-     -66,   -66,   -66,    71,   -66,   -66,    67,   -66,    64,    64,
-     -13,    64,   -66,   -66,    87,   -66,   -66,    45,   -66,   -66,
-     -66,    80,    64,    64,   -66,    64,   -66,   -66,   -66
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const yysigned_char yypgoto[] =
-{
-     -66,   -66,    91,   -66,   -66,   -66,    69,   -66,    74,    -3,
-      21,    88,    72,   -66,   -66,   -66,   -66,   104,   -66,   -65,
-     -66,    92,   -66,   -66
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -36
-static const yysigned_char yytable[] =
-{
-      76,    14,    73,    18,    29,    74,   -35,   -35,   -35,   -35,
-     -35,   -35,   -35,   -35,   -35,    47,    73,   -35,   -35,    97,
-      53,    54,    17,    95,    96,    98,    99,    49,    47,    78,
-      79,    80,    81,    64,    65,    88,    89,   106,   107,    38,
-     108,    19,     1,     2,     3,     4,     5,     6,     7,     8,
-       9,    10,    11,     1,     2,     3,     4,     5,     6,     7,
-       8,     9,    10,    11,    20,    21,    22,    23,    24,    37,
-      30,    25,    26,    90,    91,   102,   103,    34,    40,    41,
-      69,    51,    93,    44,    56,    57,    58,    60,    66,    70,
-      62,    67,    68,    73,    85,    77,   100,    71,    83,    84,
-      87,    92,   104,    39,    55,    50,    16,    46,    43,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-      61
-};
-
-static const yysigned_char yycheck[] =
-{
-      65,    30,    29,    31,     7,    32,    25,    26,    27,    28,
-      16,    17,    18,    19,    20,    34,    29,    23,    24,    32,
-      32,    33,    30,    88,    89,    90,    91,    30,    34,    25,
-      26,    27,    28,    30,    31,    30,    31,   102,   103,     0,
-     105,    31,     3,     4,     5,     6,     7,     8,     9,    10,
-      11,    12,    13,     3,     4,     5,     6,     7,     8,     9,
-      10,    11,    12,    13,    16,    17,    18,    19,    20,    31,
-      30,    23,    24,    30,    31,    30,    31,    30,    32,    14,
-      59,    30,    15,    34,    32,    30,    33,    31,    30,    30,
-      33,    31,    31,    29,    21,    32,     9,    35,    32,    31,
-      30,    30,    22,    12,    35,    31,     2,    19,    16,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      48
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
-{
-       0,     3,     4,     5,     6,     7,     8,     9,    10,    11,
-      12,    13,    37,    38,    30,    53,    53,    30,    31,    31,
-      16,    17,    18,    19,    20,    23,    24,    45,    48,    45,
-      30,    43,    44,    39,    30,    41,    42,    31,     0,    38,
-      32,    14,    57,    57,    34,    47,    47,    34,    46,    45,
-      44,    30,    40,    32,    33,    42,    32,    30,    33,    58,
-      31,    48,    33,    56,    30,    31,    30,    31,    31,    46,
-      30,    35,    54,    29,    32,    55,    55,    32,    25,    26,
-      27,    28,    59,    32,    31,    21,    50,    30,    30,    31,
-      30,    31,    30,    15,    49,    55,    55,    32,    55,    55,
-       9,    51,    30,    31,    22,    52,    55,    55,    55
-};
-
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-
-#define YYFAIL		goto yyerrlab
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
-      YYERROR;							\
-    }								\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
-
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
-#endif
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
-#endif
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (0)
-
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
-
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_stack_print (short *bottom, short *top)
-#else
-static void
-yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
-#endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (0)
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_reduce_print (int yyrule)
-#else
-static void
-yy_reduce_print (yyrule)
-    int yyrule;
-#endif
-{
-  int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
-yystrlen (const char *yystr)
-#   else
-yystrlen (yystr)
-     const char *yystr;
-#   endif
-{
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
-    continue;
-
-  return yys - yystr - 1;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-#   if defined (__STDC__) || defined (__cplusplus)
-yystpcpy (char *yydest, const char *yysrc)
-#   else
-yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
-{
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-#endif /* !YYERROR_VERBOSE */
-
-
-
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  if (yytype < YYNTOKENS)
-    {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-  switch (yytype)
-    {
-      default:
-        break;
-    }
-  YYFPRINTF (yyoutput, ")");
-}
-
-#endif /* ! YYDEBUG */
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yydestruct (yytype, yyvaluep)
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  switch (yytype)
-    {
-
-      default:
-        break;
-    }
-}
-
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM);
-# else
-int yyparse ();
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-
-/* The lookahead symbol.  */
-int yychar;
-
-/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int
-yyparse (void)
-#else
-int
-yyparse ()
-
-#endif
-#endif
-{
-  
-  register int yystate;
-  register int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss;
-  yyvsp = yyvs;
-
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-	/* Give user a chance to reallocate the stack. Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
-
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-
-		    &yystacksize);
-
-	yyss = yyss1;
-	yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
-      {
-	short *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyoverflowlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
-    {
-        case 4:
-#line 52 "defparse.y"
-    { def_name (yyvsp[-1].id, yyvsp[0].number); }
-    break;
-
-  case 5:
-#line 53 "defparse.y"
-    { def_library (yyvsp[-2].id, yyvsp[-1].number); }
-    break;
-
-  case 7:
-#line 55 "defparse.y"
-    { def_description (yyvsp[0].id);}
-    break;
-
-  case 8:
-#line 56 "defparse.y"
-    { def_stacksize (yyvsp[-1].number, yyvsp[0].number);}
-    break;
-
-  case 9:
-#line 57 "defparse.y"
-    { def_heapsize (yyvsp[-1].number, yyvsp[0].number);}
-    break;
-
-  case 10:
-#line 58 "defparse.y"
-    { def_code (yyvsp[0].number);}
-    break;
-
-  case 11:
-#line 59 "defparse.y"
-    { def_data (yyvsp[0].number);}
-    break;
-
-  case 14:
-#line 62 "defparse.y"
-    { def_version (yyvsp[0].number,0);}
-    break;
-
-  case 15:
-#line 63 "defparse.y"
-    { def_version (yyvsp[-2].number,yyvsp[0].number);}
-    break;
-
-  case 18:
-#line 75 "defparse.y"
-    { def_exports (yyvsp[-7].id, yyvsp[-6].id, yyvsp[-5].number, yyvsp[-4].number, yyvsp[-3].number, yyvsp[-2].number, yyvsp[-1].number, yyvsp[0].id);}
-    break;
-
-  case 21:
-#line 84 "defparse.y"
-    { def_import (yyvsp[-7].id,yyvsp[-5].id,yyvsp[-3].id,yyvsp[-1].id, 0, yyvsp[0].id); }
-    break;
-
-  case 22:
-#line 86 "defparse.y"
-    { def_import (yyvsp[-7].id,yyvsp[-5].id,yyvsp[-3].id, 0,yyvsp[-1].number, yyvsp[0].id); }
-    break;
-
-  case 23:
-#line 88 "defparse.y"
-    { def_import (yyvsp[-5].id,yyvsp[-3].id, 0,yyvsp[-1].id, 0, yyvsp[0].id); }
-    break;
-
-  case 24:
-#line 90 "defparse.y"
-    { def_import (yyvsp[-5].id,yyvsp[-3].id, 0, 0,yyvsp[-1].number, yyvsp[0].id); }
-    break;
-
-  case 25:
-#line 92 "defparse.y"
-    { def_import ( 0,yyvsp[-5].id,yyvsp[-3].id,yyvsp[-1].id, 0, yyvsp[0].id); }
-    break;
-
-  case 26:
-#line 94 "defparse.y"
-    { def_import ( 0,yyvsp[-5].id,yyvsp[-3].id, 0,yyvsp[-1].number, yyvsp[0].id); }
-    break;
-
-  case 27:
-#line 96 "defparse.y"
-    { def_import ( 0,yyvsp[-3].id, 0,yyvsp[-1].id, 0, yyvsp[0].id); }
-    break;
-
-  case 28:
-#line 98 "defparse.y"
-    { def_import ( 0,yyvsp[-3].id, 0, 0,yyvsp[-1].number, yyvsp[0].id); }
-    break;
-
-  case 31:
-#line 107 "defparse.y"
-    { def_section (yyvsp[-1].id,yyvsp[0].number);}
-    break;
-
-  case 36:
-#line 119 "defparse.y"
-    { yyval.number=yyvsp[0].number;}
-    break;
-
-  case 37:
-#line 120 "defparse.y"
-    { yyval.number=-1;}
-    break;
-
-  case 38:
-#line 124 "defparse.y"
-    { yyval.number = 1; }
-    break;
-
-  case 39:
-#line 125 "defparse.y"
-    { yyval.number = 2; }
-    break;
-
-  case 40:
-#line 126 "defparse.y"
-    { yyval.number = 4; }
-    break;
-
-  case 41:
-#line 127 "defparse.y"
-    { yyval.number = 8; }
-    break;
-
-  case 42:
-#line 128 "defparse.y"
-    { yyval.number = 0; }
-    break;
-
-  case 43:
-#line 129 "defparse.y"
-    { yyval.number = 0; }
-    break;
-
-  case 44:
-#line 130 "defparse.y"
-    { yyval.number = 0; }
-    break;
-
-  case 45:
-#line 134 "defparse.y"
-    {yyval.number=1;}
-    break;
-
-  case 46:
-#line 135 "defparse.y"
-    {yyval.number=0;}
-    break;
-
-  case 47:
-#line 139 "defparse.y"
-    {yyval.number=1;}
-    break;
-
-  case 48:
-#line 140 "defparse.y"
-    {yyval.number=0;}
-    break;
-
-  case 49:
-#line 144 "defparse.y"
-    { yyval.number = 1; }
-    break;
-
-  case 50:
-#line 145 "defparse.y"
-    { yyval.number = 0; }
-    break;
-
-  case 51:
-#line 149 "defparse.y"
-    { yyval.number = 1; }
-    break;
-
-  case 52:
-#line 150 "defparse.y"
-    { yyval.number = 0; }
-    break;
-
-  case 53:
-#line 153 "defparse.y"
-    { yyval.id =yyvsp[0].id; }
-    break;
-
-  case 54:
-#line 155 "defparse.y"
-    { 
-	    char *name = xmalloc (strlen (yyvsp[-2].id) + 1 + strlen (yyvsp[0].id) + 1);
-	    sprintf (name, "%s.%s", yyvsp[-2].id, yyvsp[0].id);
-	    yyval.id = name;
-	  }
-    break;
-
-  case 55:
-#line 160 "defparse.y"
-    { yyval.id=""; }
-    break;
-
-  case 56:
-#line 164 "defparse.y"
-    { yyval.number=yyvsp[0].number;}
-    break;
-
-  case 57:
-#line 165 "defparse.y"
-    { yyval.number=-1;}
-    break;
-
-  case 58:
-#line 169 "defparse.y"
-    { yyval.id = yyvsp[0].id; }
-    break;
-
-  case 59:
-#line 170 "defparse.y"
-    { yyval.id = 0; }
-    break;
-
-  case 60:
-#line 174 "defparse.y"
-    { yyval.id = yyvsp[0].id; }
-    break;
-
-  case 61:
-#line 176 "defparse.y"
-    { 
-	    char *name = xmalloc (strlen (yyvsp[-2].id) + 1 + strlen (yyvsp[0].id) + 1);
-	    sprintf (name, "%s.%s", yyvsp[-2].id, yyvsp[0].id);
-	    yyval.id = name;
-	  }
-    break;
-
-  case 62:
-#line 181 "defparse.y"
-    { yyval.id =  0; }
-    break;
-
-  case 63:
-#line 184 "defparse.y"
-    { yyval.number= yyvsp[0].number;}
-    break;
-
-  case 64:
-#line 185 "defparse.y"
-    { yyval.number=-1;}
-    break;
-
-
-    }
-
-/* Line 1000 of yacc.c.  */
-#line 1421 "defparse.c"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
-	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
-
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
-	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
-      else
-	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
-	  yychar = YYEMPTY;
-
-	}
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
-     goto yyerrorlab;
-#endif
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-	YYABORT;
-
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
-  *++yyvsp = yylval;
-
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-yyreturn:
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-  return yyresult;
-}
-
-
-
diff -r -N -u binutils-2.21.51/binutils/defparse.h binutils/binutils/defparse.h
--- binutils-2.21.51/binutils/defparse.h	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/defparse.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,112 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     NAME = 258,
-     LIBRARY = 259,
-     DESCRIPTION = 260,
-     STACKSIZE = 261,
-     HEAPSIZE = 262,
-     CODE = 263,
-     DATA = 264,
-     SECTIONS = 265,
-     EXPORTS = 266,
-     IMPORTS = 267,
-     VERSIONK = 268,
-     BASE = 269,
-     CONSTANT = 270,
-     READ = 271,
-     WRITE = 272,
-     EXECUTE = 273,
-     SHARED = 274,
-     NONSHARED = 275,
-     NONAME = 276,
-     PRIVATE = 277,
-     SINGLE = 278,
-     MULTIPLE = 279,
-     INITINSTANCE = 280,
-     INITGLOBAL = 281,
-     TERMINSTANCE = 282,
-     TERMGLOBAL = 283,
-     EQUAL = 284,
-     ID = 285,
-     NUMBER = 286
-   };
-#endif
-#define NAME 258
-#define LIBRARY 259
-#define DESCRIPTION 260
-#define STACKSIZE 261
-#define HEAPSIZE 262
-#define CODE 263
-#define DATA 264
-#define SECTIONS 265
-#define EXPORTS 266
-#define IMPORTS 267
-#define VERSIONK 268
-#define BASE 269
-#define CONSTANT 270
-#define READ 271
-#define WRITE 272
-#define EXECUTE 273
-#define SHARED 274
-#define NONSHARED 275
-#define NONAME 276
-#define PRIVATE 277
-#define SINGLE 278
-#define MULTIPLE 279
-#define INITINSTANCE 280
-#define INITGLOBAL 281
-#define TERMINSTANCE 282
-#define TERMGLOBAL 283
-#define EQUAL 284
-#define ID 285
-#define NUMBER 286
-
-
-
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 29 "defparse.y"
-typedef union YYSTYPE {
-  char *id;
-  int number;
-} YYSTYPE;
-/* Line 1275 of yacc.c.  */
-#line 104 "defparse.h"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-extern YYSTYPE yylval;
-
-
-
diff -r -N -u binutils-2.21.51/binutils/doc/Makefile.in binutils/binutils/doc/Makefile.in
--- binutils-2.21.51/binutils/doc/Makefile.in	2011-06-14 09:27:52.000000000 +0100
+++ binutils/binutils/doc/Makefile.in	2011-07-06 12:44:26.137253000 +0100
@@ -198,6 +198,7 @@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SIM = @SIM@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
 VERSION = @VERSION@
diff -r -N -u binutils-2.21.51/binutils/Makefile.am binutils/binutils/Makefile.am
--- binutils-2.21.51/binutils/Makefile.am	2011-06-14 09:27:52.000000000 +0100
+++ binutils/binutils/Makefile.am	2011-07-06 12:44:26.137253000 +0100
@@ -89,7 +89,7 @@
 	arsup.h binemul.h bucomm.h budbg.h \
 	coffgrok.h debug.h dlltool.h dwarf.h elfcomm.h nlmconv.h \
 	objdump.h sysdep.h unwind-ia64.h windres.h winduni.h windint.h \
-	windmc.h
+	windmc.h ST_version.h
 
 GENERATED_HFILES = arparse.h sysroff.h sysinfo.h defparse.h rcparse.h mcparse.h
 BUILT_SOURCES = $(GENERATED_HFILES)
@@ -161,12 +161,36 @@
 	EXPECT=$(EXPECT); export EXPECT; \
 	runtest=$(RUNTEST); \
 	if $(SHELL) -c "$$runtest --version" > /dev/null 2>&1; then \
-	  CC_FOR_TARGET="$(CC_FOR_TARGET)" CFLAGS_FOR_TARGET="$(CFLAGS)" \
+	  CC_FOR_TARGET="$(CC_FOR_TARGET)" CFLAGS_FOR_TARGET="$(FLAGS_FOR_TARGET)" \
 		$$runtest --tool $(DEJATOOL) --srcdir $${srcdir}/testsuite \
 			$(RUNTESTFLAGS); \
 	else echo "WARNING: could not find \`runtest'" 1>&2; :;\
 	fi
 
+site.exp: Makefile
+	@echo 'Making a new site.exp file...'
+	@test ! -f site.bak || rm -f site.bak
+	@echo '## these variables are automatically generated by make ##' > $@-t
+	@echo '# Do not edit here.  If you wish to override these values' >> $@-t
+	@echo '# edit the last section' >> $@-t
+	@echo 'set tool $(DEJATOOL)' >> $@-t
+	@echo 'set srcdir $(srcdir)' >> $@-t
+	@echo 'set objdir' `pwd` >> $@-t
+	@echo 'set host_alias $(host_alias)' >> $@-t
+	@echo 'set host_triplet $(host_triplet)' >> $@-t
+	@echo 'set target_alias $(target_alias)' >> $@-t
+	@echo 'set target_triplet $(target_triplet)' >> $@-t
+	@echo 'set build_alias $(build_alias)' >> $@-t
+	@echo 'set build_triplet $(build_triplet)' >> $@-t
+	@echo 'set target_list ${target_alias}' >> $@-t
+	@echo 'set boards_dir ${srcdir}/../boards' >> $@-t
+	@echo 'set SIM "$(SIM)"' >> $@-t
+	@echo 'set CC_FOR_TARGET "$(CC_FOR_TARGET)"' >> $@-t
+	@echo '## All variables above are generated by configure. Do Not Edit ##' >> $@-t
+	@test ! -f site.exp || sed '1,/^## All variables above are.*##/ d' site.exp >> $@-t
+	@test ! -f site.exp || mv site.exp site.bak
+	@mv $@-t site.exp
+
 installcheck-local:
 	/bin/sh $(srcdir)/sanity.sh $(bindir)
 
diff -r -N -u binutils-2.21.51/binutils/Makefile.in binutils/binutils/Makefile.in
--- binutils-2.21.51/binutils/Makefile.in	2011-06-14 09:27:52.000000000 +0100
+++ binutils/binutils/Makefile.in	2011-07-06 12:44:26.137253000 +0100
@@ -341,6 +341,7 @@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SIM = @SIM@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
 VERSION = @VERSION@
@@ -459,7 +460,7 @@
 	arsup.h binemul.h bucomm.h budbg.h \
 	coffgrok.h debug.h dlltool.h dwarf.h elfcomm.h nlmconv.h \
 	objdump.h sysdep.h unwind-ia64.h windres.h winduni.h windint.h \
-	windmc.h
+	windmc.h ST_version.h
 
 GENERATED_HFILES = arparse.h sysroff.h sysinfo.h defparse.h rcparse.h mcparse.h
 BUILT_SOURCES = $(GENERATED_HFILES)
@@ -1055,25 +1056,6 @@
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-site.exp: Makefile
-	@echo 'Making a new site.exp file...'
-	@echo '## these variables are automatically generated by make ##' >site.tmp
-	@echo '# Do not edit here.  If you wish to override these values' >>site.tmp
-	@echo '# edit the last section' >>site.tmp
-	@echo 'set srcdir $(srcdir)' >>site.tmp
-	@echo "set objdir `pwd`" >>site.tmp
-	@echo 'set build_alias "$(build_alias)"' >>site.tmp
-	@echo 'set build_triplet $(build_triplet)' >>site.tmp
-	@echo 'set host_alias "$(host_alias)"' >>site.tmp
-	@echo 'set host_triplet $(host_triplet)' >>site.tmp
-	@echo 'set target_alias "$(target_alias)"' >>site.tmp
-	@echo 'set target_triplet $(target_triplet)' >>site.tmp
-	@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp
-	@test ! -f site.exp || \
-	  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp
-	@-rm -f site.bak
-	@test ! -f site.exp || mv site.exp site.bak
-	@mv site.tmp site.exp
 
 distclean-DEJAGNU:
 	-rm -f site.exp site.bak
@@ -1239,12 +1221,36 @@
 	EXPECT=$(EXPECT); export EXPECT; \
 	runtest=$(RUNTEST); \
 	if $(SHELL) -c "$$runtest --version" > /dev/null 2>&1; then \
-	  CC_FOR_TARGET="$(CC_FOR_TARGET)" CFLAGS_FOR_TARGET="$(CFLAGS)" \
+	  CC_FOR_TARGET="$(CC_FOR_TARGET)" CFLAGS_FOR_TARGET="$(FLAGS_FOR_TARGET)" \
 		$$runtest --tool $(DEJATOOL) --srcdir $${srcdir}/testsuite \
 			$(RUNTESTFLAGS); \
 	else echo "WARNING: could not find \`runtest'" 1>&2; :;\
 	fi
 
+site.exp: Makefile
+	@echo 'Making a new site.exp file...'
+	@test ! -f site.bak || rm -f site.bak
+	@echo '## these variables are automatically generated by make ##' > $@-t
+	@echo '# Do not edit here.  If you wish to override these values' >> $@-t
+	@echo '# edit the last section' >> $@-t
+	@echo 'set tool $(DEJATOOL)' >> $@-t
+	@echo 'set srcdir $(srcdir)' >> $@-t
+	@echo 'set objdir' `pwd` >> $@-t
+	@echo 'set host_alias $(host_alias)' >> $@-t
+	@echo 'set host_triplet $(host_triplet)' >> $@-t
+	@echo 'set target_alias $(target_alias)' >> $@-t
+	@echo 'set target_triplet $(target_triplet)' >> $@-t
+	@echo 'set build_alias $(build_alias)' >> $@-t
+	@echo 'set build_triplet $(build_triplet)' >> $@-t
+	@echo 'set target_list ${target_alias}' >> $@-t
+	@echo 'set boards_dir ${srcdir}/../boards' >> $@-t
+	@echo 'set SIM "$(SIM)"' >> $@-t
+	@echo 'set CC_FOR_TARGET "$(CC_FOR_TARGET)"' >> $@-t
+	@echo '## All variables above are generated by configure. Do Not Edit ##' >> $@-t
+	@test ! -f site.exp || sed '1,/^## All variables above are.*##/ d' site.exp >> $@-t
+	@test ! -f site.exp || mv site.exp site.bak
+	@mv $@-t site.exp
+
 installcheck-local:
 	/bin/sh $(srcdir)/sanity.sh $(bindir)
 
diff -r -N -u binutils-2.21.51/binutils/mcparse.c binutils/binutils/mcparse.c
--- binutils-2.21.51/binutils/mcparse.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/mcparse.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1835 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     NL = 258,
-     MCIDENT = 259,
-     MCFILENAME = 260,
-     MCLINE = 261,
-     MCCOMMENT = 262,
-     MCTOKEN = 263,
-     MCENDLINE = 264,
-     MCLANGUAGENAMES = 265,
-     MCFACILITYNAMES = 266,
-     MCSEVERITYNAMES = 267,
-     MCOUTPUTBASE = 268,
-     MCMESSAGEIDTYPEDEF = 269,
-     MCLANGUAGE = 270,
-     MCMESSAGEID = 271,
-     MCSEVERITY = 272,
-     MCFACILITY = 273,
-     MCSYMBOLICNAME = 274,
-     MCNUMBER = 275
-   };
-#endif
-#define NL 258
-#define MCIDENT 259
-#define MCFILENAME 260
-#define MCLINE 261
-#define MCCOMMENT 262
-#define MCTOKEN 263
-#define MCENDLINE 264
-#define MCLANGUAGENAMES 265
-#define MCFACILITYNAMES 266
-#define MCSEVERITYNAMES 267
-#define MCOUTPUTBASE 268
-#define MCMESSAGEIDTYPEDEF 269
-#define MCLANGUAGE 270
-#define MCMESSAGEID 271
-#define MCSEVERITY 272
-#define MCFACILITY 273
-#define MCSYMBOLICNAME 274
-#define MCNUMBER 275
-
-
-
-
-/* Copy the first part of user declarations.  */
-#line 1 "mcparse.y"
- /* mcparse.y -- parser for Windows mc files
-  Copyright 2007
-  Free Software Foundation, Inc.
-  
-  Parser for Windows mc files
-  Written by Kai Tietz, Onevision.
-  
-  This file is part of GNU Binutils.
-  
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 3 of the License, or
-  (at your option) any later version.
-  
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-  
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-  02110-1301, USA.  */
-
-/* This is a parser for Windows rc files.  It is based on the parser
-   by Gunther Ebert <gunther.ebert@ixos-leipzig.de>.  */
-
-#include "sysdep.h"
-#include "bfd.h"
-#include "bucomm.h"
-#include "libiberty.h"
-#include "windmc.h"
-#include "safe-ctype.h"
-
-static rc_uint_type mc_last_id = 0;
-static rc_uint_type mc_sefa_val = 0;
-static unichar *mc_last_symbol = NULL;
-static const mc_keyword *mc_cur_severity = NULL;
-static const mc_keyword *mc_cur_facility = NULL;
-static mc_node *cur_node = NULL;
-
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 45 "mcparse.y"
-typedef union YYSTYPE {
-  rc_uint_type ival;
-  unichar *ustr;
-  const mc_keyword *tok;
-  mc_node *nod;
-} YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 166 "mcparse.c"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 214 of yacc.c.  */
-#line 178 "mcparse.c"
-
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
-
-# ifndef YYFREE
-#  define YYFREE free
-# endif
-# ifndef YYMALLOC
-#  define YYMALLOC malloc
-# endif
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
-#  endif
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-# endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
-
-
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  short yyss;
-  YYSTYPE yyvs;
-  };
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAXIMUM)
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  register YYSIZE_T yyi;		\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (0)
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (0)
-
-#endif
-
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
-#define YYFINAL  3
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   114
-
-/* YYNTOKENS -- Number of terminals. */
-#define YYNTOKENS  26
-/* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  29
-/* YYNRULES -- Number of rules. */
-#define YYNRULES  82
-/* YYNRULES -- Number of states. */
-#define YYNSTATES  125
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   275
-
-#define YYTRANSLATE(YYX) 						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-      22,    23,     2,    25,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,    24,     2,
-       2,    21,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    20
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const unsigned short yyprhs[] =
-{
-       0,     0,     3,     5,     6,     9,    11,    13,    15,    17,
-      23,    29,    33,    36,    42,    48,    52,    55,    61,    67,
-      71,    74,    78,    82,    86,    89,    91,    94,    96,   101,
-     105,   108,   110,   113,   115,   120,   124,   127,   129,   132,
-     134,   141,   148,   153,   157,   160,   161,   164,   167,   168,
-     173,   177,   181,   184,   185,   187,   190,   193,   194,   197,
-     200,   203,   207,   211,   215,   217,   220,   225,   227,   230,
-     232,   235,   237,   240,   246,   252,   258,   263,   266,   268,
-     270,   271,   272
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
-{
-      27,     0,    -1,    28,    -1,    -1,    28,    29,    -1,    30,
-      -1,    38,    -1,    49,    -1,     1,    -1,    12,    21,    22,
-      31,    23,    -1,    12,    21,    22,    31,     1,    -1,    12,
-      21,     1,    -1,    12,     1,    -1,    10,    21,    22,    35,
-      23,    -1,    10,    21,    22,    35,     1,    -1,    10,    21,
-       1,    -1,    10,     1,    -1,    11,    21,    22,    33,    23,
-      -1,    11,    21,    22,    33,     1,    -1,    11,    21,     1,
-      -1,    11,     1,    -1,    13,    21,    20,    -1,    14,    21,
-       4,    -1,    14,    21,     1,    -1,    14,     1,    -1,    32,
-      -1,    31,    32,    -1,     1,    -1,    51,    21,    20,    37,
-      -1,    51,    21,     1,    -1,    51,     1,    -1,    34,    -1,
-      33,    34,    -1,     1,    -1,    51,    21,    20,    37,    -1,
-      51,    21,     1,    -1,    51,     1,    -1,    36,    -1,    35,
-      36,    -1,     1,    -1,    51,    21,    20,    54,    24,     5,
-      -1,    51,    21,    20,    54,    24,     1,    -1,    51,    21,
-      20,     1,    -1,    51,    21,     1,    -1,    51,     1,    -1,
-      -1,    24,     4,    -1,    24,     1,    -1,    -1,    40,    42,
-      39,    46,    -1,    16,    21,    41,    -1,    16,    21,     1,
-      -1,    16,     1,    -1,    -1,    20,    -1,    25,    20,    -1,
-      25,     1,    -1,    -1,    42,    43,    -1,    42,    44,    -1,
-      42,    45,    -1,    17,    21,     8,    -1,    18,    21,     8,
-      -1,    19,    21,     4,    -1,    47,    -1,    46,    47,    -1,
-      50,    53,    48,     9,    -1,     6,    -1,    48,     6,    -1,
-       1,    -1,    48,     1,    -1,     7,    -1,    49,     7,    -1,
-      15,    52,    21,     8,     3,    -1,    15,    52,    21,     4,
-       3,    -1,    15,    52,    21,    51,     1,    -1,    15,    52,
-      21,     1,    -1,    15,     1,    -1,     4,    -1,     8,    -1,
-      -1,    -1,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
-{
-       0,    67,    67,    70,    72,    74,    75,    76,    81,    85,
-      86,    87,    88,    89,    90,    91,    92,    93,    94,    95,
-      96,    97,   103,   107,   111,   118,   119,   120,   124,   128,
-     129,   133,   134,   135,   139,   143,   144,   148,   149,   150,
-     154,   158,   159,   160,   161,   166,   169,   173,   178,   177,
-     190,   191,   192,   196,   199,   203,   207,   212,   219,   225,
-     231,   239,   247,   255,   262,   263,   267,   277,   281,   293,
-     294,   297,   298,   312,   316,   321,   326,   331,   338,   339,
-     343,   347,   351
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "NL", "MCIDENT", "MCFILENAME", "MCLINE",
-  "MCCOMMENT", "MCTOKEN", "MCENDLINE", "MCLANGUAGENAMES",
-  "MCFACILITYNAMES", "MCSEVERITYNAMES", "MCOUTPUTBASE",
-  "MCMESSAGEIDTYPEDEF", "MCLANGUAGE", "MCMESSAGEID", "MCSEVERITY",
-  "MCFACILITY", "MCSYMBOLICNAME", "MCNUMBER", "'='", "'('", "')'", "':'",
-  "'+'", "$accept", "input", "entities", "entity", "global_section",
-  "severitymaps", "severitymap", "facilitymaps", "facilitymap", "langmaps",
-  "langmap", "alias_name", "message", "@1", "id", "vid", "sefasy_def",
-  "severity", "facility", "symbol", "lang_entities", "lang_entity",
-  "lines", "comments", "lang", "token", "lex_want_nl", "lex_want_line",
-  "lex_want_filename", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,    61,    40,    41,    58,    43
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
-{
-       0,    26,    27,    28,    28,    29,    29,    29,    29,    30,
-      30,    30,    30,    30,    30,    30,    30,    30,    30,    30,
-      30,    30,    30,    30,    30,    31,    31,    31,    32,    32,
-      32,    33,    33,    33,    34,    34,    34,    35,    35,    35,
-      36,    36,    36,    36,    36,    37,    37,    37,    39,    38,
-      40,    40,    40,    41,    41,    41,    41,    42,    42,    42,
-      42,    43,    44,    45,    46,    46,    47,    48,    48,    48,
-      48,    49,    49,    50,    50,    50,    50,    50,    51,    51,
-      52,    53,    54
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
-{
-       0,     2,     1,     0,     2,     1,     1,     1,     1,     5,
-       5,     3,     2,     5,     5,     3,     2,     5,     5,     3,
-       2,     3,     3,     3,     2,     1,     2,     1,     4,     3,
-       2,     1,     2,     1,     4,     3,     2,     1,     2,     1,
-       6,     6,     4,     3,     2,     0,     2,     2,     0,     4,
-       3,     3,     2,     0,     1,     2,     2,     0,     2,     2,
-       2,     3,     3,     3,     1,     2,     4,     1,     2,     1,
-       2,     1,     2,     5,     5,     5,     4,     2,     1,     1,
-       0,     0,     0
-};
-
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const unsigned char yydefact[] =
-{
-       3,     0,     0,     1,     8,    71,     0,     0,     0,     0,
-       0,     0,     4,     5,     6,    57,     7,    16,     0,    20,
-       0,    12,     0,     0,    24,     0,    52,     0,    48,    72,
-      15,     0,    19,     0,    11,     0,    21,    23,    22,    51,
-      54,     0,    50,     0,     0,     0,     0,    58,    59,    60,
-      39,    78,    79,     0,    37,     0,    33,     0,    31,     0,
-      27,     0,    25,     0,    56,    55,     0,     0,     0,     0,
-      49,    64,    81,    14,    13,    38,    44,     0,    18,    17,
-      32,    36,     0,    10,     9,    26,    30,     0,    61,    62,
-      63,    77,     0,    65,     0,    43,     0,    35,    45,    29,
-      45,     0,    69,    67,     0,    42,     0,     0,    34,    28,
-      76,    78,    79,     0,    70,    68,    66,     0,    47,    46,
-      74,    73,    75,    41,    40
-};
-
-/* YYDEFGOTO[NTERM-NUM]. */
-static const yysigned_char yydefgoto[] =
-{
-      -1,     1,     2,    12,    13,    61,    62,    57,    58,    53,
-      54,   108,    14,    46,    15,    42,    28,    47,    48,    49,
-      70,    71,   104,    16,    72,    55,    92,    94,   106
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -34
-static const yysigned_char yypact[] =
-{
-     -34,    62,    70,   -34,   -34,   -34,    15,    22,    30,   -15,
-      34,    37,   -34,   -34,   -34,   -34,    56,   -34,    10,   -34,
-      12,   -34,    20,    25,   -34,    52,   -34,     0,    80,   -34,
-     -34,    71,   -34,    84,   -34,    86,   -34,   -34,   -34,   -34,
-     -34,    45,   -34,     1,    68,    74,    76,   -34,   -34,   -34,
-     -34,   -34,   -34,     4,   -34,    38,   -34,     6,   -34,    39,
-     -34,    29,   -34,    40,   -34,   -34,    93,    94,    99,    43,
-      76,   -34,   -34,   -34,   -34,   -34,   -34,    46,   -34,   -34,
-     -34,   -34,    47,   -34,   -34,   -34,   -34,    49,   -34,   -34,
-     -34,   -34,    83,   -34,     3,   -34,     2,   -34,    81,   -34,
-      81,    92,   -34,   -34,    48,   -34,    82,    72,   -34,   -34,
-     -34,   104,   105,   108,   -34,   -34,   -34,    73,   -34,   -34,
-     -34,   -34,   -34,   -34,   -34
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const yysigned_char yypgoto[] =
-{
-     -34,   -34,   -34,   -34,   -34,   -34,    50,   -34,    53,   -34,
-      59,    13,   -34,   -34,   -34,   -34,   -34,   -34,   -34,   -34,
-     -34,    44,   -34,   -34,   -34,   -33,   -34,   -34,   -34
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -83
-static const yysigned_char yytable[] =
-{
-      59,    39,    63,   105,   102,    73,    23,    78,    51,   103,
-      51,    30,    52,    32,    52,   -53,    17,   -53,   -53,   -53,
-      40,    34,    66,    19,    59,    41,   -82,    74,    63,    79,
-      83,    21,    31,    51,    33,    24,    18,    52,    26,    76,
-      81,    86,    35,    20,    91,    36,    64,    95,    97,   114,
-      99,    22,    84,    37,   115,    25,    38,   116,    27,    77,
-      82,    87,     3,    29,   -80,    65,    96,    98,   113,   100,
-      -2,     4,    50,   118,   123,    51,   119,     5,   124,    52,
-       6,     7,     8,     9,    10,    56,    11,    60,    51,    67,
-      51,    69,    52,   110,    52,    68,   111,    43,    44,    45,
-     112,    88,    89,    90,   101,   107,   117,   120,   121,   122,
-      80,    85,    75,   109,    93
-};
-
-static const unsigned char yycheck[] =
-{
-      33,     1,    35,     1,     1,     1,    21,     1,     4,     6,
-       4,     1,     8,     1,     8,    15,     1,    17,    18,    19,
-      20,     1,    21,     1,    57,    25,    24,    23,    61,    23,
-       1,     1,    22,     4,    22,     1,    21,     8,     1,     1,
-       1,     1,    22,    21,     1,    20,     1,     1,     1,     1,
-       1,    21,    23,     1,     6,    21,     4,     9,    21,    21,
-      21,    21,     0,     7,    21,    20,    20,    20,   101,    20,
-       0,     1,     1,     1,     1,     4,     4,     7,     5,     8,
-      10,    11,    12,    13,    14,     1,    16,     1,     4,    21,
-       4,    15,     8,     1,     8,    21,     4,    17,    18,    19,
-       8,     8,     8,     4,    21,    24,    24,     3,     3,     1,
-      57,    61,    53,   100,    70
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
-{
-       0,    27,    28,     0,     1,     7,    10,    11,    12,    13,
-      14,    16,    29,    30,    38,    40,    49,     1,    21,     1,
-      21,     1,    21,    21,     1,    21,     1,    21,    42,     7,
-       1,    22,     1,    22,     1,    22,    20,     1,     4,     1,
-      20,    25,    41,    17,    18,    19,    39,    43,    44,    45,
-       1,     4,     8,    35,    36,    51,     1,    33,    34,    51,
-       1,    31,    32,    51,     1,    20,    21,    21,    21,    15,
-      46,    47,    50,     1,    23,    36,     1,    21,     1,    23,
-      34,     1,    21,     1,    23,    32,     1,    21,     8,     8,
-       4,     1,    52,    47,    53,     1,    20,     1,    20,     1,
-      20,    21,     1,     6,    48,     1,    54,    24,    37,    37,
-       1,     4,     8,    51,     1,     6,     9,    24,     1,     4,
-       3,     3,     1,     1,     5
-};
-
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-
-#define YYFAIL		goto yyerrlab
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
-      YYERROR;							\
-    }								\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
-
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
-#endif
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
-#endif
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (0)
-
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
-
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_stack_print (short *bottom, short *top)
-#else
-static void
-yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
-#endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (0)
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_reduce_print (int yyrule)
-#else
-static void
-yy_reduce_print (yyrule)
-    int yyrule;
-#endif
-{
-  int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
-yystrlen (const char *yystr)
-#   else
-yystrlen (yystr)
-     const char *yystr;
-#   endif
-{
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
-    continue;
-
-  return yys - yystr - 1;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-#   if defined (__STDC__) || defined (__cplusplus)
-yystpcpy (char *yydest, const char *yysrc)
-#   else
-yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
-{
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-#endif /* !YYERROR_VERBOSE */
-
-
-
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  if (yytype < YYNTOKENS)
-    {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-  switch (yytype)
-    {
-      default:
-        break;
-    }
-  YYFPRINTF (yyoutput, ")");
-}
-
-#endif /* ! YYDEBUG */
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yydestruct (yytype, yyvaluep)
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  switch (yytype)
-    {
-
-      default:
-        break;
-    }
-}
-
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM);
-# else
-int yyparse ();
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-
-/* The lookahead symbol.  */
-int yychar;
-
-/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int
-yyparse (void)
-#else
-int
-yyparse ()
-
-#endif
-#endif
-{
-  
-  register int yystate;
-  register int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss;
-  yyvsp = yyvs;
-
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-	/* Give user a chance to reallocate the stack. Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
-
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-
-		    &yystacksize);
-
-	yyss = yyss1;
-	yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
-      {
-	short *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyoverflowlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
-    {
-        case 7:
-#line 77 "mcparse.y"
-    {
-	    cur_node = mc_add_node ();
-	    cur_node->user_text = yyvsp[0].ustr;
-	  }
-    break;
-
-  case 8:
-#line 81 "mcparse.y"
-    { mc_fatal ("syntax error"); }
-    break;
-
-  case 10:
-#line 86 "mcparse.y"
-    { mc_fatal ("missing ')' in SeverityNames"); }
-    break;
-
-  case 11:
-#line 87 "mcparse.y"
-    { mc_fatal ("missing '(' in SeverityNames"); }
-    break;
-
-  case 12:
-#line 88 "mcparse.y"
-    { mc_fatal ("missing '=' for SeverityNames"); }
-    break;
-
-  case 14:
-#line 90 "mcparse.y"
-    { mc_fatal ("missing ')' in LanguageNames"); }
-    break;
-
-  case 15:
-#line 91 "mcparse.y"
-    { mc_fatal ("missing '(' in LanguageNames"); }
-    break;
-
-  case 16:
-#line 92 "mcparse.y"
-    { mc_fatal ("missing '=' for LanguageNames"); }
-    break;
-
-  case 18:
-#line 94 "mcparse.y"
-    { mc_fatal ("missing ')' in FacilityNames"); }
-    break;
-
-  case 19:
-#line 95 "mcparse.y"
-    { mc_fatal ("missing '(' in FacilityNames"); }
-    break;
-
-  case 20:
-#line 96 "mcparse.y"
-    { mc_fatal ("missing '=' for FacilityNames"); }
-    break;
-
-  case 21:
-#line 98 "mcparse.y"
-    {
-	    if (yyvsp[0].ival != 10 && yyvsp[0].ival != 16)
-	      mc_fatal ("OutputBase allows 10 or 16 as value");
-	    mcset_out_values_are_decimal = (yyvsp[0].ival == 10 ? 1 : 0);
-	  }
-    break;
-
-  case 22:
-#line 104 "mcparse.y"
-    {
-	    mcset_msg_id_typedef = yyvsp[0].ustr;
-	  }
-    break;
-
-  case 23:
-#line 108 "mcparse.y"
-    {
-	    mc_fatal ("MessageIdTypedef expects an identifier");
-	  }
-    break;
-
-  case 24:
-#line 112 "mcparse.y"
-    {
-	    mc_fatal ("missing '=' for MessageIdTypedef");
-	  }
-    break;
-
-  case 27:
-#line 120 "mcparse.y"
-    { mc_fatal ("severity ident missing"); }
-    break;
-
-  case 28:
-#line 125 "mcparse.y"
-    {
-	    mc_add_keyword (yyvsp[-3].ustr, MCTOKEN, "severity", yyvsp[-1].ival, yyvsp[0].ustr);
-	  }
-    break;
-
-  case 29:
-#line 128 "mcparse.y"
-    { mc_fatal ("severity number missing"); }
-    break;
-
-  case 30:
-#line 129 "mcparse.y"
-    { mc_fatal ("severity missing '='"); }
-    break;
-
-  case 33:
-#line 135 "mcparse.y"
-    { mc_fatal ("missing ident in FacilityNames"); }
-    break;
-
-  case 34:
-#line 140 "mcparse.y"
-    {
-	    mc_add_keyword (yyvsp[-3].ustr, MCTOKEN, "facility", yyvsp[-1].ival, yyvsp[0].ustr);
-	  }
-    break;
-
-  case 35:
-#line 143 "mcparse.y"
-    { mc_fatal ("facility number missing"); }
-    break;
-
-  case 36:
-#line 144 "mcparse.y"
-    { mc_fatal ("facility missing '='"); }
-    break;
-
-  case 39:
-#line 150 "mcparse.y"
-    { mc_fatal ("missing ident in LanguageNames"); }
-    break;
-
-  case 40:
-#line 155 "mcparse.y"
-    {
-	    mc_add_keyword (yyvsp[-5].ustr, MCTOKEN, "language", yyvsp[-3].ival, yyvsp[0].ustr);
-	  }
-    break;
-
-  case 41:
-#line 158 "mcparse.y"
-    { mc_fatal ("missing filename in LanguageNames"); }
-    break;
-
-  case 42:
-#line 159 "mcparse.y"
-    { mc_fatal ("missing ':' in LanguageNames"); }
-    break;
-
-  case 43:
-#line 160 "mcparse.y"
-    { mc_fatal ("missing language code in LanguageNames"); }
-    break;
-
-  case 44:
-#line 161 "mcparse.y"
-    { mc_fatal ("missing '=' for LanguageNames"); }
-    break;
-
-  case 45:
-#line 166 "mcparse.y"
-    {
-	    yyval.ustr = NULL;
-	  }
-    break;
-
-  case 46:
-#line 170 "mcparse.y"
-    {
-	    yyval.ustr = yyvsp[0].ustr;
-	  }
-    break;
-
-  case 47:
-#line 173 "mcparse.y"
-    { mc_fatal ("illegal token in identifier"); yyval.ustr = NULL; }
-    break;
-
-  case 48:
-#line 178 "mcparse.y"
-    {
-	    cur_node = mc_add_node ();
-	    cur_node->symbol = mc_last_symbol;
-	    cur_node->facility = mc_cur_facility;
-	    cur_node->severity = mc_cur_severity;
-	    cur_node->id = (yyvsp[-1].ival & 0xffffUL);
-	    cur_node->vid = (yyvsp[-1].ival & 0xffffUL) | mc_sefa_val;
-	    mc_last_id = yyvsp[-1].ival;
-	  }
-    break;
-
-  case 50:
-#line 190 "mcparse.y"
-    { yyval.ival = yyvsp[0].ival; }
-    break;
-
-  case 51:
-#line 191 "mcparse.y"
-    { mc_fatal ("missing number in MessageId"); yyval.ival = 0; }
-    break;
-
-  case 52:
-#line 192 "mcparse.y"
-    { mc_fatal ("missing '=' for MessageId"); yyval.ival = 0; }
-    break;
-
-  case 53:
-#line 196 "mcparse.y"
-    {
-	    yyval.ival = ++mc_last_id;
-	  }
-    break;
-
-  case 54:
-#line 200 "mcparse.y"
-    {
-	    yyval.ival = yyvsp[0].ival;
-	  }
-    break;
-
-  case 55:
-#line 204 "mcparse.y"
-    {
-	    yyval.ival = mc_last_id + yyvsp[0].ival;
-	  }
-    break;
-
-  case 56:
-#line 207 "mcparse.y"
-    { mc_fatal ("missing number after MessageId '+'"); }
-    break;
-
-  case 57:
-#line 212 "mcparse.y"
-    {
-	    yyval.ival = 0;
-	    mc_sefa_val = (mcset_custom_bit ? 1 : 0) << 29;
-	    mc_last_symbol = NULL;
-	    mc_cur_severity = NULL;
-	    mc_cur_facility = NULL;
-	  }
-    break;
-
-  case 58:
-#line 220 "mcparse.y"
-    {
-	    if (yyvsp[-1].ival & 1)
-	      mc_warn (_("duplicate definition of Severity"));
-	    yyval.ival = yyvsp[-1].ival | 1;
-	  }
-    break;
-
-  case 59:
-#line 226 "mcparse.y"
-    {
-	    if (yyvsp[-1].ival & 2)
-	      mc_warn (_("duplicate definition of Facility"));
-	    yyval.ival = yyvsp[-1].ival | 2;
-	  }
-    break;
-
-  case 60:
-#line 232 "mcparse.y"
-    {
-	    if (yyvsp[-1].ival & 4)
-	      mc_warn (_("duplicate definition of SymbolicName"));
-	    yyval.ival = yyvsp[-1].ival | 4;
-	  }
-    break;
-
-  case 61:
-#line 240 "mcparse.y"
-    {
-	    mc_sefa_val &= ~ (0x3UL << 30);
-	    mc_sefa_val |= ((yyvsp[0].tok->nval & 0x3UL) << 30);
-	    mc_cur_severity = yyvsp[0].tok;
-	  }
-    break;
-
-  case 62:
-#line 248 "mcparse.y"
-    {
-	    mc_sefa_val &= ~ (0xfffUL << 16);
-	    mc_sefa_val |= ((yyvsp[0].tok->nval & 0xfffUL) << 16);
-	    mc_cur_facility = yyvsp[0].tok;
-	  }
-    break;
-
-  case 63:
-#line 256 "mcparse.y"
-    {
-	  mc_last_symbol = yyvsp[0].ustr;
-	}
-    break;
-
-  case 66:
-#line 268 "mcparse.y"
-    {
-	    mc_node_lang *h;
-	    h = mc_add_node_lang (cur_node, yyvsp[-3].tok, cur_node->vid);
-	    h->message = yyvsp[-1].ustr;
-	    if (mcset_max_message_length != 0 && unichar_len (h->message) > mcset_max_message_length)
-	      mc_warn ("message length to long");
-	  }
-    break;
-
-  case 67:
-#line 278 "mcparse.y"
-    {
-	    yyval.ustr = yyvsp[0].ustr;
-	  }
-    break;
-
-  case 68:
-#line 282 "mcparse.y"
-    {
-	    unichar *h;
-	    rc_uint_type l1,l2;
-	    l1 = unichar_len (yyvsp[-1].ustr);
-	    l2 = unichar_len (yyvsp[0].ustr);
-	    h = (unichar *) res_alloc ((l1 + l2 + 1) * sizeof (unichar));
-	    if (l1) memcpy (h, yyvsp[-1].ustr, l1 * sizeof (unichar));
-	    if (l2) memcpy (&h[l1], yyvsp[0].ustr, l2 * sizeof (unichar));
-	    h[l1 + l2] = 0;
-	    yyval.ustr = h;
-	  }
-    break;
-
-  case 69:
-#line 293 "mcparse.y"
-    { mc_fatal ("missing end of message text"); yyval.ustr = NULL; }
-    break;
-
-  case 70:
-#line 294 "mcparse.y"
-    { mc_fatal ("missing end of message text"); yyval.ustr = yyvsp[-1].ustr; }
-    break;
-
-  case 71:
-#line 297 "mcparse.y"
-    { yyval.ustr = yyvsp[0].ustr; }
-    break;
-
-  case 72:
-#line 299 "mcparse.y"
-    {
-	    unichar *h;
-	    rc_uint_type l1,l2;
-	    l1 = unichar_len (yyvsp[-1].ustr);
-	    l2 = unichar_len (yyvsp[0].ustr);
-	    h = (unichar *) res_alloc ((l1 + l2 + 1) * sizeof (unichar));
-	    if (l1) memcpy (h, yyvsp[-1].ustr, l1 * sizeof (unichar));
-	    if (l2) memcpy (&h[l1], yyvsp[0].ustr, l2 * sizeof (unichar));
-	    h[l1 + l2] = 0;
-	    yyval.ustr = h;
-	  }
-    break;
-
-  case 73:
-#line 313 "mcparse.y"
-    {
-	    yyval.tok = yyvsp[-1].tok;
-	  }
-    break;
-
-  case 74:
-#line 317 "mcparse.y"
-    {
-	    yyval.tok = NULL;
-	    mc_fatal (_("undeclared language identifier"));
-	  }
-    break;
-
-  case 75:
-#line 322 "mcparse.y"
-    {
-	    yyval.tok = NULL;
-	    mc_fatal ("missing newline after Language");
-	  }
-    break;
-
-  case 76:
-#line 327 "mcparse.y"
-    {
-	    yyval.tok = NULL;
-	    mc_fatal ("missing ident for Language");
-	  }
-    break;
-
-  case 77:
-#line 332 "mcparse.y"
-    {
-	    yyval.tok = NULL;
-	    mc_fatal ("missing '=' for Language");
-	  }
-    break;
-
-  case 78:
-#line 338 "mcparse.y"
-    { yyval.ustr = yyvsp[0].ustr; }
-    break;
-
-  case 79:
-#line 339 "mcparse.y"
-    { yyval.ustr = yyvsp[0].tok->usz; }
-    break;
-
-  case 80:
-#line 343 "mcparse.y"
-    { mclex_want_nl = 1; }
-    break;
-
-  case 81:
-#line 347 "mcparse.y"
-    { mclex_want_line = 1; }
-    break;
-
-  case 82:
-#line 351 "mcparse.y"
-    { mclex_want_filename = 1; }
-    break;
-
-
-    }
-
-/* Line 1000 of yacc.c.  */
-#line 1607 "mcparse.c"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
-	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
-
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
-	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
-      else
-	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
-	  yychar = YYEMPTY;
-
-	}
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
-     goto yyerrorlab;
-#endif
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-	YYABORT;
-
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
-  *++yyvsp = yylval;
-
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-yyreturn:
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-  return yyresult;
-}
-
-
-#line 354 "mcparse.y"
-
-
-/* Something else.  */
-
diff -r -N -u binutils-2.21.51/binutils/mcparse.h binutils/binutils/mcparse.h
--- binutils-2.21.51/binutils/mcparse.h	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/mcparse.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,92 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     NL = 258,
-     MCIDENT = 259,
-     MCFILENAME = 260,
-     MCLINE = 261,
-     MCCOMMENT = 262,
-     MCTOKEN = 263,
-     MCENDLINE = 264,
-     MCLANGUAGENAMES = 265,
-     MCFACILITYNAMES = 266,
-     MCSEVERITYNAMES = 267,
-     MCOUTPUTBASE = 268,
-     MCMESSAGEIDTYPEDEF = 269,
-     MCLANGUAGE = 270,
-     MCMESSAGEID = 271,
-     MCSEVERITY = 272,
-     MCFACILITY = 273,
-     MCSYMBOLICNAME = 274,
-     MCNUMBER = 275
-   };
-#endif
-#define NL 258
-#define MCIDENT 259
-#define MCFILENAME 260
-#define MCLINE 261
-#define MCCOMMENT 262
-#define MCTOKEN 263
-#define MCENDLINE 264
-#define MCLANGUAGENAMES 265
-#define MCFACILITYNAMES 266
-#define MCSEVERITYNAMES 267
-#define MCOUTPUTBASE 268
-#define MCMESSAGEIDTYPEDEF 269
-#define MCLANGUAGE 270
-#define MCMESSAGEID 271
-#define MCSEVERITY 272
-#define MCFACILITY 273
-#define MCSYMBOLICNAME 274
-#define MCNUMBER 275
-
-
-
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 45 "mcparse.y"
-typedef union YYSTYPE {
-  rc_uint_type ival;
-  unichar *ustr;
-  const mc_keyword *tok;
-  mc_node *nod;
-} YYSTYPE;
-/* Line 1275 of yacc.c.  */
-#line 84 "mcparse.h"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-extern YYSTYPE yylval;
-
-
-
diff -r -N -u binutils-2.21.51/binutils/nlmheader.c binutils/binutils/nlmheader.c
--- binutils-2.21.51/binutils/nlmheader.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/nlmheader.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2377 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     CHECK = 258,
-     CODESTART = 259,
-     COPYRIGHT = 260,
-     CUSTOM = 261,
-     DATE = 262,
-     DEBUG_K = 263,
-     DESCRIPTION = 264,
-     EXIT = 265,
-     EXPORT = 266,
-     FLAG_ON = 267,
-     FLAG_OFF = 268,
-     FULLMAP = 269,
-     HELP = 270,
-     IMPORT = 271,
-     INPUT = 272,
-     MAP = 273,
-     MESSAGES = 274,
-     MODULE = 275,
-     MULTIPLE = 276,
-     OS_DOMAIN = 277,
-     OUTPUT = 278,
-     PSEUDOPREEMPTION = 279,
-     REENTRANT = 280,
-     SCREENNAME = 281,
-     SHARELIB = 282,
-     STACK = 283,
-     START = 284,
-     SYNCHRONIZE = 285,
-     THREADNAME = 286,
-     TYPE = 287,
-     VERBOSE = 288,
-     VERSIONK = 289,
-     XDCDATA = 290,
-     STRING = 291,
-     QUOTED_STRING = 292
-   };
-#endif
-#define CHECK 258
-#define CODESTART 259
-#define COPYRIGHT 260
-#define CUSTOM 261
-#define DATE 262
-#define DEBUG_K 263
-#define DESCRIPTION 264
-#define EXIT 265
-#define EXPORT 266
-#define FLAG_ON 267
-#define FLAG_OFF 268
-#define FULLMAP 269
-#define HELP 270
-#define IMPORT 271
-#define INPUT 272
-#define MAP 273
-#define MESSAGES 274
-#define MODULE 275
-#define MULTIPLE 276
-#define OS_DOMAIN 277
-#define OUTPUT 278
-#define PSEUDOPREEMPTION 279
-#define REENTRANT 280
-#define SCREENNAME 281
-#define SHARELIB 282
-#define STACK 283
-#define START 284
-#define SYNCHRONIZE 285
-#define THREADNAME 286
-#define TYPE 287
-#define VERBOSE 288
-#define VERSIONK 289
-#define XDCDATA 290
-#define STRING 291
-#define QUOTED_STRING 292
-
-
-
-
-/* Copy the first part of user declarations.  */
-#line 1 "nlmheader.y"
-/* nlmheader.y - parse NLM header specification keywords.
-     Copyright 1993, 1994, 1995, 1997, 1998, 2001, 2002, 2003, 2005, 2007,
-     2010 Free Software Foundation, Inc.
-
-     This file is part of GNU Binutils.
-
-     This program is free software; you can redistribute it and/or modify
-     it under the terms of the GNU General Public License as published by
-     the Free Software Foundation; either version 3 of the License, or
-     (at your option) any later version.
-
-     This program is distributed in the hope that it will be useful,
-     but WITHOUT ANY WARRANTY; without even the implied warranty of
-     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-     GNU General Public License for more details.
-
-     You should have received a copy of the GNU General Public License
-     along with this program; if not, write to the Free Software
-     Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-     MA 02110-1301, USA.  */
-
-/* Written by Ian Lance Taylor <ian@cygnus.com>.
-
-   This bison file parses the commands recognized by the NetWare NLM
-   linker, except for lists of object files.  It stores the
-   information in global variables.
-
-   This implementation is based on the description in the NetWare Tool
-   Maker Specification manual, edition 1.0.  */
-
-#include "sysdep.h"
-#include "safe-ctype.h"
-#include "bfd.h"
-#include "nlm/common.h"
-#include "nlm/internal.h"
-#include "bucomm.h"
-#include "nlmconv.h"
-
-/* Information is stored in the structures pointed to by these
-   variables.  */
-
-Nlm_Internal_Fixed_Header *fixed_hdr;
-Nlm_Internal_Variable_Header *var_hdr;
-Nlm_Internal_Version_Header *version_hdr;
-Nlm_Internal_Copyright_Header *copyright_hdr;
-Nlm_Internal_Extended_Header *extended_hdr;
-
-/* Procedure named by CHECK.  */
-char *check_procedure;
-/* File named by CUSTOM.  */
-char *custom_file;
-/* Whether to generate debugging information (DEBUG).  */
-bfd_boolean debug_info;
-/* Procedure named by EXIT.  */
-char *exit_procedure;
-/* Exported symbols (EXPORT).  */
-struct string_list *export_symbols;
-/* List of files from INPUT.  */
-struct string_list *input_files;
-/* Map file name (MAP, FULLMAP).  */
-char *map_file;
-/* Whether a full map has been requested (FULLMAP).  */
-bfd_boolean full_map;
-/* File named by HELP.  */
-char *help_file;
-/* Imported symbols (IMPORT).  */
-struct string_list *import_symbols;
-/* File named by MESSAGES.  */
-char *message_file;
-/* Autoload module list (MODULE).  */
-struct string_list *modules;
-/* File named by OUTPUT.  */
-char *output_file;
-/* File named by SHARELIB.  */
-char *sharelib_file;
-/* Start procedure name (START).  */
-char *start_procedure;
-/* VERBOSE.  */
-bfd_boolean verbose;
-/* RPC description file (XDCDATA).  */
-char *rpc_file;
-
-/* The number of serious errors that have occurred.  */
-int parse_errors;
-
-/* The current symbol prefix when reading a list of import or export
-   symbols.  */
-static char *symbol_prefix;
-
-/* Parser error message handler.  */
-#define yyerror(msg) nlmheader_error (msg);
-
-/* Local functions.  */
-static int yylex (void);
-static void nlmlex_file_push (const char *);
-static bfd_boolean nlmlex_file_open (const char *);
-static int nlmlex_buf_init (void);
-static char nlmlex_buf_add (int);
-static long nlmlex_get_number (const char *);
-static void nlmheader_identify (void);
-static void nlmheader_warn (const char *, int);
-static void nlmheader_error (const char *);
-static struct string_list * string_list_cons (char *, struct string_list *);
-static struct string_list * string_list_append (struct string_list *,
-						struct string_list *);
-static struct string_list * string_list_append1 (struct string_list *,
-						 char *);
-static char *xstrdup (const char *);
-
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 113 "nlmheader.y"
-typedef union YYSTYPE {
-  char *string;
-  struct string_list *list;
-} YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 266 "nlmheader.c"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 214 of yacc.c.  */
-#line 278 "nlmheader.c"
-
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
-
-# ifndef YYFREE
-#  define YYFREE free
-# endif
-# ifndef YYMALLOC
-#  define YYMALLOC malloc
-# endif
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
-#  endif
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-# endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
-
-
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  short yyss;
-  YYSTYPE yyvs;
-  };
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAXIMUM)
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  register YYSIZE_T yyi;		\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (0)
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (0)
-
-#endif
-
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
-#define YYFINAL  64
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   73
-
-/* YYNTOKENS -- Number of terminals. */
-#define YYNTOKENS  40
-/* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  11
-/* YYNRULES -- Number of rules. */
-#define YYNRULES  52
-/* YYNRULES -- Number of states. */
-#define YYNSTATES  82
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   292
-
-#define YYTRANSLATE(YYX) 						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-      38,    39,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      35,    36,    37
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const unsigned char yyprhs[] =
-{
-       0,     0,     3,     5,     6,     9,    12,    15,    18,    21,
-      26,    28,    31,    34,    35,    39,    42,    45,    47,    50,
-      53,    54,    58,    61,    63,    66,    69,    72,    74,    76,
-      79,    81,    83,    86,    89,    92,    95,    97,   100,   103,
-     105,   110,   114,   117,   118,   120,   122,   124,   127,   130,
-     134,   136,   137
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
-{
-      41,     0,    -1,    42,    -1,    -1,    43,    42,    -1,     3,
-      36,    -1,     4,    36,    -1,     5,    37,    -1,     6,    36,
-      -1,     7,    36,    36,    36,    -1,     8,    -1,     9,    37,
-      -1,    10,    36,    -1,    -1,    11,    44,    46,    -1,    12,
-      36,    -1,    13,    36,    -1,    14,    -1,    14,    36,    -1,
-      15,    36,    -1,    -1,    16,    45,    46,    -1,    17,    50,
-      -1,    18,    -1,    18,    36,    -1,    19,    36,    -1,    20,
-      50,    -1,    21,    -1,    22,    -1,    23,    36,    -1,    24,
-      -1,    25,    -1,    26,    37,    -1,    27,    36,    -1,    28,
-      36,    -1,    29,    36,    -1,    30,    -1,    31,    37,    -1,
-      32,    36,    -1,    33,    -1,    34,    36,    36,    36,    -1,
-      34,    36,    36,    -1,    35,    36,    -1,    -1,    47,    -1,
-      49,    -1,    48,    -1,    47,    49,    -1,    47,    48,    -1,
-      38,    36,    39,    -1,    36,    -1,    -1,    36,    50,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
-{
-       0,   144,   144,   149,   151,   157,   161,   166,   183,   187,
-     205,   209,   225,   230,   229,   237,   242,   247,   252,   257,
-     262,   261,   269,   273,   277,   281,   285,   289,   293,   297,
-     304,   308,   312,   328,   332,   337,   341,   345,   361,   366,
-     370,   394,   410,   420,   423,   434,   438,   442,   446,   455,
-     466,   483,   486
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "CHECK", "CODESTART", "COPYRIGHT",
-  "CUSTOM", "DATE", "DEBUG_K", "DESCRIPTION", "EXIT", "EXPORT", "FLAG_ON",
-  "FLAG_OFF", "FULLMAP", "HELP", "IMPORT", "INPUT", "MAP", "MESSAGES",
-  "MODULE", "MULTIPLE", "OS_DOMAIN", "OUTPUT", "PSEUDOPREEMPTION",
-  "REENTRANT", "SCREENNAME", "SHARELIB", "STACK", "START", "SYNCHRONIZE",
-  "THREADNAME", "TYPE", "VERBOSE", "VERSIONK", "XDCDATA", "STRING",
-  "QUOTED_STRING", "'('", "')'", "$accept", "file", "commands", "command",
-  "@1", "@2", "symbol_list_opt", "symbol_list", "symbol_prefix", "symbol",
-  "string_list", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,   287,   288,   289,   290,   291,   292,    40,    41
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
-{
-       0,    40,    41,    42,    42,    43,    43,    43,    43,    43,
-      43,    43,    43,    44,    43,    43,    43,    43,    43,    43,
-      45,    43,    43,    43,    43,    43,    43,    43,    43,    43,
-      43,    43,    43,    43,    43,    43,    43,    43,    43,    43,
-      43,    43,    43,    46,    46,    47,    47,    47,    47,    48,
-      49,    50,    50
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
-{
-       0,     2,     1,     0,     2,     2,     2,     2,     2,     4,
-       1,     2,     2,     0,     3,     2,     2,     1,     2,     2,
-       0,     3,     2,     1,     2,     2,     2,     1,     1,     2,
-       1,     1,     2,     2,     2,     2,     1,     2,     2,     1,
-       4,     3,     2,     0,     1,     1,     1,     2,     2,     3,
-       1,     0,     2
-};
-
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const unsigned char yydefact[] =
-{
-       3,     0,     0,     0,     0,     0,    10,     0,     0,    13,
-       0,     0,    17,     0,    20,    51,    23,     0,    51,    27,
-      28,     0,    30,    31,     0,     0,     0,     0,    36,     0,
-       0,    39,     0,     0,     0,     2,     3,     5,     6,     7,
-       8,     0,    11,    12,    43,    15,    16,    18,    19,    43,
-      51,    22,    24,    25,    26,    29,    32,    33,    34,    35,
-      37,    38,     0,    42,     1,     4,     0,    50,     0,    14,
-      44,    46,    45,    21,    52,    41,     9,     0,    48,    47,
-      40,    49
-};
-
-/* YYDEFGOTO[NTERM-NUM]. */
-static const yysigned_char yydefgoto[] =
-{
-      -1,    34,    35,    36,    44,    49,    69,    70,    71,    72,
-      51
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -20
-static const yysigned_char yypact[] =
-{
-      -3,    -1,     1,     2,     4,     5,   -20,     6,     8,   -20,
-       9,    10,    11,    12,   -20,    13,    14,    16,    13,   -20,
-     -20,    17,   -20,   -20,    18,    20,    21,    22,   -20,    23,
-      25,   -20,    26,    27,    38,   -20,    -3,   -20,   -20,   -20,
-     -20,    28,   -20,   -20,    -2,   -20,   -20,   -20,   -20,    -2,
-      13,   -20,   -20,   -20,   -20,   -20,   -20,   -20,   -20,   -20,
-     -20,   -20,    30,   -20,   -20,   -20,    31,   -20,    32,   -20,
-      -2,   -20,   -20,   -20,   -20,    33,   -20,     3,   -20,   -20,
-     -20,   -20
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const yysigned_char yypgoto[] =
-{
-     -20,   -20,    34,   -20,   -20,   -20,    24,   -20,   -19,   -16,
-      15
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -1
-static const unsigned char yytable[] =
-{
-       1,     2,     3,     4,     5,     6,     7,     8,     9,    10,
-      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    54,    67,    37,    68,    38,    64,    39,
-      40,    41,    81,    42,    43,    45,    46,    47,    48,    50,
-      52,    78,    53,    55,    79,    56,    57,    58,    59,     0,
-      60,    61,    62,    63,    66,    74,    75,    76,    77,    80,
-      65,     0,     0,    73
-};
-
-static const yysigned_char yycheck[] =
-{
-       3,     4,     5,     6,     7,     8,     9,    10,    11,    12,
-      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    35,    18,    36,    36,    38,    36,     0,    37,
-      36,    36,    39,    37,    36,    36,    36,    36,    36,    36,
-      36,    70,    36,    36,    70,    37,    36,    36,    36,    -1,
-      37,    36,    36,    36,    36,    50,    36,    36,    36,    36,
-      36,    -1,    -1,    49
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
-{
-       0,     3,     4,     5,     6,     7,     8,     9,    10,    11,
-      12,    13,    14,    15,    16,    17,    18,    19,    20,    21,
-      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
-      32,    33,    34,    35,    41,    42,    43,    36,    36,    37,
-      36,    36,    37,    36,    44,    36,    36,    36,    36,    45,
-      36,    50,    36,    36,    50,    36,    37,    36,    36,    36,
-      37,    36,    36,    36,     0,    42,    36,    36,    38,    46,
-      47,    48,    49,    46,    50,    36,    36,    36,    48,    49,
-      36,    39
-};
-
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-
-#define YYFAIL		goto yyerrlab
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
-      YYERROR;							\
-    }								\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
-
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
-#endif
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
-#endif
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (0)
-
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
-
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_stack_print (short *bottom, short *top)
-#else
-static void
-yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
-#endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (0)
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_reduce_print (int yyrule)
-#else
-static void
-yy_reduce_print (yyrule)
-    int yyrule;
-#endif
-{
-  int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
-yystrlen (const char *yystr)
-#   else
-yystrlen (yystr)
-     const char *yystr;
-#   endif
-{
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
-    continue;
-
-  return yys - yystr - 1;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-#   if defined (__STDC__) || defined (__cplusplus)
-yystpcpy (char *yydest, const char *yysrc)
-#   else
-yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
-{
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-#endif /* !YYERROR_VERBOSE */
-
-
-
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  if (yytype < YYNTOKENS)
-    {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-  switch (yytype)
-    {
-      default:
-        break;
-    }
-  YYFPRINTF (yyoutput, ")");
-}
-
-#endif /* ! YYDEBUG */
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yydestruct (yytype, yyvaluep)
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  switch (yytype)
-    {
-
-      default:
-        break;
-    }
-}
-
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM);
-# else
-int yyparse ();
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-
-/* The lookahead symbol.  */
-int yychar;
-
-/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int
-yyparse (void)
-#else
-int
-yyparse ()
-
-#endif
-#endif
-{
-  
-  register int yystate;
-  register int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss;
-  yyvsp = yyvs;
-
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-	/* Give user a chance to reallocate the stack. Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
-
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-
-		    &yystacksize);
-
-	yyss = yyss1;
-	yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
-      {
-	short *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyoverflowlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
-    {
-        case 5:
-#line 158 "nlmheader.y"
-    {
-	    check_procedure = yyvsp[0].string;
-	  }
-    break;
-
-  case 6:
-#line 162 "nlmheader.y"
-    {
-	    nlmheader_warn (_("CODESTART is not implemented; sorry"), -1);
-	    free (yyvsp[0].string);
-	  }
-    break;
-
-  case 7:
-#line 167 "nlmheader.y"
-    {
-	    int len;
-
-	    strncpy (copyright_hdr->stamp, "CoPyRiGhT=", 10);
-	    len = strlen (yyvsp[0].string);
-	    if (len >= NLM_MAX_COPYRIGHT_MESSAGE_LENGTH)
-	      {
-		nlmheader_warn (_("copyright string is too long"),
-				NLM_MAX_COPYRIGHT_MESSAGE_LENGTH - 1);
-		len = NLM_MAX_COPYRIGHT_MESSAGE_LENGTH - 1;
-	      }
-	    copyright_hdr->copyrightMessageLength = len;
-	    strncpy (copyright_hdr->copyrightMessage, yyvsp[0].string, len);
-	    copyright_hdr->copyrightMessage[len] = '\0';
-	    free (yyvsp[0].string);
-	  }
-    break;
-
-  case 8:
-#line 184 "nlmheader.y"
-    {
-	    custom_file = yyvsp[0].string;
-	  }
-    break;
-
-  case 9:
-#line 188 "nlmheader.y"
-    {
-	    /* We don't set the version stamp here, because we use the
-	       version stamp to detect whether the required VERSION
-	       keyword was given.  */
-	    version_hdr->month = nlmlex_get_number (yyvsp[-2].string);
-	    version_hdr->day = nlmlex_get_number (yyvsp[-1].string);
-	    version_hdr->year = nlmlex_get_number (yyvsp[0].string);
-	    free (yyvsp[-2].string);
-	    free (yyvsp[-1].string);
-	    free (yyvsp[0].string);
-	    if (version_hdr->month < 1 || version_hdr->month > 12)
-	      nlmheader_warn (_("illegal month"), -1);
-	    if (version_hdr->day < 1 || version_hdr->day > 31)
-	      nlmheader_warn (_("illegal day"), -1);
-	    if (version_hdr->year < 1900 || version_hdr->year > 3000)
-	      nlmheader_warn (_("illegal year"), -1);
-	  }
-    break;
-
-  case 10:
-#line 206 "nlmheader.y"
-    {
-	    debug_info = TRUE;
-	  }
-    break;
-
-  case 11:
-#line 210 "nlmheader.y"
-    {
-	    int len;
-
-	    len = strlen (yyvsp[0].string);
-	    if (len > NLM_MAX_DESCRIPTION_LENGTH)
-	      {
-		nlmheader_warn (_("description string is too long"),
-				NLM_MAX_DESCRIPTION_LENGTH);
-		len = NLM_MAX_DESCRIPTION_LENGTH;
-	      }
-	    var_hdr->descriptionLength = len;
-	    strncpy (var_hdr->descriptionText, yyvsp[0].string, len);
-	    var_hdr->descriptionText[len] = '\0';
-	    free (yyvsp[0].string);
-	  }
-    break;
-
-  case 12:
-#line 226 "nlmheader.y"
-    {
-	    exit_procedure = yyvsp[0].string;
-	  }
-    break;
-
-  case 13:
-#line 230 "nlmheader.y"
-    {
-	    symbol_prefix = NULL;
-	  }
-    break;
-
-  case 14:
-#line 234 "nlmheader.y"
-    {
-	    export_symbols = string_list_append (export_symbols, yyvsp[0].list);
-	  }
-    break;
-
-  case 15:
-#line 238 "nlmheader.y"
-    {
-	    fixed_hdr->flags |= nlmlex_get_number (yyvsp[0].string);
-	    free (yyvsp[0].string);
-	  }
-    break;
-
-  case 16:
-#line 243 "nlmheader.y"
-    {
-	    fixed_hdr->flags &=~ nlmlex_get_number (yyvsp[0].string);
-	    free (yyvsp[0].string);
-	  }
-    break;
-
-  case 17:
-#line 248 "nlmheader.y"
-    {
-	    map_file = "";
-	    full_map = TRUE;
-	  }
-    break;
-
-  case 18:
-#line 253 "nlmheader.y"
-    {
-	    map_file = yyvsp[0].string;
-	    full_map = TRUE;
-	  }
-    break;
-
-  case 19:
-#line 258 "nlmheader.y"
-    {
-	    help_file = yyvsp[0].string;
-	  }
-    break;
-
-  case 20:
-#line 262 "nlmheader.y"
-    {
-	    symbol_prefix = NULL;
-	  }
-    break;
-
-  case 21:
-#line 266 "nlmheader.y"
-    {
-	    import_symbols = string_list_append (import_symbols, yyvsp[0].list);
-	  }
-    break;
-
-  case 22:
-#line 270 "nlmheader.y"
-    {
-	    input_files = string_list_append (input_files, yyvsp[0].list);
-	  }
-    break;
-
-  case 23:
-#line 274 "nlmheader.y"
-    {
-	    map_file = "";
-	  }
-    break;
-
-  case 24:
-#line 278 "nlmheader.y"
-    {
-	    map_file = yyvsp[0].string;
-	  }
-    break;
-
-  case 25:
-#line 282 "nlmheader.y"
-    {
-	    message_file = yyvsp[0].string;
-	  }
-    break;
-
-  case 26:
-#line 286 "nlmheader.y"
-    {
-	    modules = string_list_append (modules, yyvsp[0].list);
-	  }
-    break;
-
-  case 27:
-#line 290 "nlmheader.y"
-    {
-	    fixed_hdr->flags |= 0x2;
-	  }
-    break;
-
-  case 28:
-#line 294 "nlmheader.y"
-    {
-	    fixed_hdr->flags |= 0x10;
-	  }
-    break;
-
-  case 29:
-#line 298 "nlmheader.y"
-    {
-	    if (output_file == NULL)
-	      output_file = yyvsp[0].string;
-	    else
-	      nlmheader_warn (_("ignoring duplicate OUTPUT statement"), -1);
-	  }
-    break;
-
-  case 30:
-#line 305 "nlmheader.y"
-    {
-	    fixed_hdr->flags |= 0x8;
-	  }
-    break;
-
-  case 31:
-#line 309 "nlmheader.y"
-    {
-	    fixed_hdr->flags |= 0x1;
-	  }
-    break;
-
-  case 32:
-#line 313 "nlmheader.y"
-    {
-	    int len;
-
-	    len = strlen (yyvsp[0].string);
-	    if (len >= NLM_MAX_SCREEN_NAME_LENGTH)
-	      {
-		nlmheader_warn (_("screen name is too long"),
-				NLM_MAX_SCREEN_NAME_LENGTH);
-		len = NLM_MAX_SCREEN_NAME_LENGTH;
-	      }
-	    var_hdr->screenNameLength = len;
-	    strncpy (var_hdr->screenName, yyvsp[0].string, len);
-	    var_hdr->screenName[NLM_MAX_SCREEN_NAME_LENGTH] = '\0';
-	    free (yyvsp[0].string);
-	  }
-    break;
-
-  case 33:
-#line 329 "nlmheader.y"
-    {
-	    sharelib_file = yyvsp[0].string;
-	  }
-    break;
-
-  case 34:
-#line 333 "nlmheader.y"
-    {
-	    var_hdr->stackSize = nlmlex_get_number (yyvsp[0].string);
-	    free (yyvsp[0].string);
-	  }
-    break;
-
-  case 35:
-#line 338 "nlmheader.y"
-    {
-	    start_procedure = yyvsp[0].string;
-	  }
-    break;
-
-  case 36:
-#line 342 "nlmheader.y"
-    {
-	    fixed_hdr->flags |= 0x4;
-	  }
-    break;
-
-  case 37:
-#line 346 "nlmheader.y"
-    {
-	    int len;
-
-	    len = strlen (yyvsp[0].string);
-	    if (len >= NLM_MAX_THREAD_NAME_LENGTH)
-	      {
-		nlmheader_warn (_("thread name is too long"),
-				NLM_MAX_THREAD_NAME_LENGTH);
-		len = NLM_MAX_THREAD_NAME_LENGTH;
-	      }
-	    var_hdr->threadNameLength = len;
-	    strncpy (var_hdr->threadName, yyvsp[0].string, len);
-	    var_hdr->threadName[len] = '\0';
-	    free (yyvsp[0].string);
-	  }
-    break;
-
-  case 38:
-#line 362 "nlmheader.y"
-    {
-	    fixed_hdr->moduleType = nlmlex_get_number (yyvsp[0].string);
-	    free (yyvsp[0].string);
-	  }
-    break;
-
-  case 39:
-#line 367 "nlmheader.y"
-    {
-	    verbose = TRUE;
-	  }
-    break;
-
-  case 40:
-#line 371 "nlmheader.y"
-    {
-	    long val;
-
-	    strncpy (version_hdr->stamp, "VeRsIoN#", 8);
-	    version_hdr->majorVersion = nlmlex_get_number (yyvsp[-2].string);
-	    val = nlmlex_get_number (yyvsp[-1].string);
-	    if (val < 0 || val > 99)
-	      nlmheader_warn (_("illegal minor version number (must be between 0 and 99)"),
-			      -1);
-	    else
-	      version_hdr->minorVersion = val;
-	    val = nlmlex_get_number (yyvsp[0].string);
-	    if (val < 0)
-	      nlmheader_warn (_("illegal revision number (must be between 0 and 26)"),
-			      -1);
-	    else if (val > 26)
-	      version_hdr->revision = 0;
-	    else
-	      version_hdr->revision = val;
-	    free (yyvsp[-2].string);
-	    free (yyvsp[-1].string);
-	    free (yyvsp[0].string);
-	  }
-    break;
-
-  case 41:
-#line 395 "nlmheader.y"
-    {
-	    long val;
-
-	    strncpy (version_hdr->stamp, "VeRsIoN#", 8);
-	    version_hdr->majorVersion = nlmlex_get_number (yyvsp[-1].string);
-	    val = nlmlex_get_number (yyvsp[0].string);
-	    if (val < 0 || val > 99)
-	      nlmheader_warn (_("illegal minor version number (must be between 0 and 99)"),
-			      -1);
-	    else
-	      version_hdr->minorVersion = val;
-	    version_hdr->revision = 0;
-	    free (yyvsp[-1].string);
-	    free (yyvsp[0].string);
-	  }
-    break;
-
-  case 42:
-#line 411 "nlmheader.y"
-    {
-	    rpc_file = yyvsp[0].string;
-	  }
-    break;
-
-  case 43:
-#line 420 "nlmheader.y"
-    {
-	    yyval.list = NULL;
-	  }
-    break;
-
-  case 44:
-#line 424 "nlmheader.y"
-    {
-	    yyval.list = yyvsp[0].list;
-	  }
-    break;
-
-  case 45:
-#line 435 "nlmheader.y"
-    {
-	    yyval.list = string_list_cons (yyvsp[0].string, NULL);
-	  }
-    break;
-
-  case 46:
-#line 439 "nlmheader.y"
-    {
-	    yyval.list = NULL;
-	  }
-    break;
-
-  case 47:
-#line 443 "nlmheader.y"
-    {
-	    yyval.list = string_list_append1 (yyvsp[-1].list, yyvsp[0].string);
-	  }
-    break;
-
-  case 48:
-#line 447 "nlmheader.y"
-    {
-	    yyval.list = yyvsp[-1].list;
-	  }
-    break;
-
-  case 49:
-#line 456 "nlmheader.y"
-    {
-	    if (symbol_prefix != NULL)
-	      free (symbol_prefix);
-	    symbol_prefix = yyvsp[-1].string;
-	  }
-    break;
-
-  case 50:
-#line 467 "nlmheader.y"
-    {
-	    if (symbol_prefix == NULL)
-	      yyval.string = yyvsp[0].string;
-	    else
-	      {
-		yyval.string = xmalloc (strlen (symbol_prefix) + strlen (yyvsp[0].string) + 2);
-		sprintf (yyval.string, "%s@%s", symbol_prefix, yyvsp[0].string);
-		free (yyvsp[0].string);
-	      }
-	  }
-    break;
-
-  case 51:
-#line 483 "nlmheader.y"
-    {
-	    yyval.list = NULL;
-	  }
-    break;
-
-  case 52:
-#line 487 "nlmheader.y"
-    {
-	    yyval.list = string_list_cons (yyvsp[-1].string, yyvsp[0].list);
-	  }
-    break;
-
-
-    }
-
-/* Line 1000 of yacc.c.  */
-#line 1683 "nlmheader.c"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
-	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
-
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
-	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
-      else
-	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
-	  yychar = YYEMPTY;
-
-	}
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
-     goto yyerrorlab;
-#endif
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-	YYABORT;
-
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
-  *++yyvsp = yylval;
-
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-yyreturn:
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-  return yyresult;
-}
-
-
-#line 492 "nlmheader.y"
-
-
-/* If strerror is just a macro, we want to use the one from libiberty
-   since it will handle undefined values.  */
-#undef strerror
-extern char *strerror PARAMS ((int));
-
-/* The lexer is simple, too simple for flex.  Keywords are only
-   recognized at the start of lines.  Everything else must be an
-   argument.  A comma is treated as whitespace.  */
-
-/* The states the lexer can be in.  */
-
-enum lex_state
-{
-  /* At the beginning of a line.  */
-  BEGINNING_OF_LINE,
-  /* In the middle of a line.  */
-  IN_LINE
-};
-
-/* We need to keep a stack of files to handle file inclusion.  */
-
-struct input
-{
-  /* The file to read from.  */
-  FILE *file;
-  /* The name of the file.  */
-  char *name;
-  /* The current line number.  */
-  int lineno;
-  /* The current state.  */
-  enum lex_state state;
-  /* The next file on the stack.  */
-  struct input *next;
-};
-
-/* The current input file.  */
-
-static struct input current;
-
-/* The character which introduces comments.  */
-#define COMMENT_CHAR '#'
-
-/* Start the lexer going on the main input file.  */
-
-bfd_boolean
-nlmlex_file (const char *name)
-{
-  current.next = NULL;
-  return nlmlex_file_open (name);
-}
-
-/* Start the lexer going on a subsidiary input file.  */
-
-static void
-nlmlex_file_push (const char *name)
-{
-  struct input *push;
-
-  push = (struct input *) xmalloc (sizeof (struct input));
-  *push = current;
-  if (nlmlex_file_open (name))
-    current.next = push;
-  else
-    {
-      current = *push;
-      free (push);
-    }
-}
-
-/* Start lexing from a file.  */
-
-static bfd_boolean
-nlmlex_file_open (const char *name)
-{
-  current.file = fopen (name, "r");
-  if (current.file == NULL)
-    {
-      fprintf (stderr, "%s:%s: %s\n", program_name, name, strerror (errno));
-      ++parse_errors;
-      return FALSE;
-    }
-  current.name = xstrdup (name);
-  current.lineno = 1;
-  current.state = BEGINNING_OF_LINE;
-  return TRUE;
-}
-
-/* Table used to turn keywords into tokens.  */
-
-struct keyword_tokens_struct
-{
-  const char *keyword;
-  int token;
-};
-
-static struct keyword_tokens_struct keyword_tokens[] =
-{
-  { "CHECK", CHECK },
-  { "CODESTART", CODESTART },
-  { "COPYRIGHT", COPYRIGHT },
-  { "CUSTOM", CUSTOM },
-  { "DATE", DATE },
-  { "DEBUG", DEBUG_K },
-  { "DESCRIPTION", DESCRIPTION },
-  { "EXIT", EXIT },
-  { "EXPORT", EXPORT },
-  { "FLAG_ON", FLAG_ON },
-  { "FLAG_OFF", FLAG_OFF },
-  { "FULLMAP", FULLMAP },
-  { "HELP", HELP },
-  { "IMPORT", IMPORT },
-  { "INPUT", INPUT },
-  { "MAP", MAP },
-  { "MESSAGES", MESSAGES },
-  { "MODULE", MODULE },
-  { "MULTIPLE", MULTIPLE },
-  { "OS_DOMAIN", OS_DOMAIN },
-  { "OUTPUT", OUTPUT },
-  { "PSEUDOPREEMPTION", PSEUDOPREEMPTION },
-  { "REENTRANT", REENTRANT },
-  { "SCREENNAME", SCREENNAME },
-  { "SHARELIB", SHARELIB },
-  { "STACK", STACK },
-  { "STACKSIZE", STACK },
-  { "START", START },
-  { "SYNCHRONIZE", SYNCHRONIZE },
-  { "THREADNAME", THREADNAME },
-  { "TYPE", TYPE },
-  { "VERBOSE", VERBOSE },
-  { "VERSION", VERSIONK },
-  { "XDCDATA", XDCDATA }
-};
-
-#define KEYWORD_COUNT (sizeof (keyword_tokens) / sizeof (keyword_tokens[0]))
-
-/* The lexer accumulates strings in these variables.  */
-static char *lex_buf;
-static int lex_size;
-static int lex_pos;
-
-/* Start accumulating strings into the buffer.  */
-#define BUF_INIT() \
-  ((void) (lex_buf != NULL ? lex_pos = 0 : nlmlex_buf_init ()))
-
-static int
-nlmlex_buf_init (void)
-{
-  lex_size = 10;
-  lex_buf = xmalloc (lex_size + 1);
-  lex_pos = 0;
-  return 0;
-}
-
-/* Finish a string in the buffer.  */
-#define BUF_FINISH() ((void) (lex_buf[lex_pos] = '\0'))
-
-/* Accumulate a character into the buffer.  */
-#define BUF_ADD(c) \
-  ((void) (lex_pos < lex_size \
-	   ? lex_buf[lex_pos++] = (c) \
-	   : nlmlex_buf_add (c)))
-
-static char
-nlmlex_buf_add (int c)
-{
-  if (lex_pos >= lex_size)
-    {
-      lex_size *= 2;
-      lex_buf = xrealloc (lex_buf, lex_size + 1);
-    }
-
-  return lex_buf[lex_pos++] = c;
-}
-
-/* The lexer proper.  This is called by the bison generated parsing
-   code.  */
-
-static int
-yylex (void)
-{
-  int c;
-
-tail_recurse:
-
-  c = getc (current.file);
-
-  /* Commas are treated as whitespace characters.  */
-  while (ISSPACE (c) || c == ',')
-    {
-      current.state = IN_LINE;
-      if (c == '\n')
-	{
-	  ++current.lineno;
-	  current.state = BEGINNING_OF_LINE;
-	}
-      c = getc (current.file);
-    }
-
-  /* At the end of the file we either pop to the previous file or
-     finish up.  */
-  if (c == EOF)
-    {
-      fclose (current.file);
-      free (current.name);
-      if (current.next == NULL)
-	return 0;
-      else
-	{
-	  struct input *next;
-
-	  next = current.next;
-	  current = *next;
-	  free (next);
-	  goto tail_recurse;
-	}
-    }
-
-  /* A comment character always means to drop everything until the
-     next newline.  */
-  if (c == COMMENT_CHAR)
-    {
-      do
-	{
-	  c = getc (current.file);
-	}
-      while (c != '\n');
-      ++current.lineno;
-      current.state = BEGINNING_OF_LINE;
-      goto tail_recurse;
-    }
-
-  /* An '@' introduces an include file.  */
-  if (c == '@')
-    {
-      do
-	{
-	  c = getc (current.file);
-	  if (c == '\n')
-	    ++current.lineno;
-	}
-      while (ISSPACE (c));
-      BUF_INIT ();
-      while (! ISSPACE (c) && c != EOF)
-	{
-	  BUF_ADD (c);
-	  c = getc (current.file);
-	}
-      BUF_FINISH ();
-
-      ungetc (c, current.file);
-
-      nlmlex_file_push (lex_buf);
-      goto tail_recurse;
-    }
-
-  /* A non-space character at the start of a line must be the start of
-     a keyword.  */
-  if (current.state == BEGINNING_OF_LINE)
-    {
-      BUF_INIT ();
-      while (ISALNUM (c) || c == '_')
-	{
-	  BUF_ADD (TOUPPER (c));
-	  c = getc (current.file);
-	}
-      BUF_FINISH ();
-
-      if (c != EOF && ! ISSPACE (c) && c != ',')
-	{
-	  nlmheader_identify ();
-	  fprintf (stderr, _("%s:%d: illegal character in keyword: %c\n"),
-		   current.name, current.lineno, c);
-	}
-      else
-	{
-	  unsigned int i;
-
-	  for (i = 0; i < KEYWORD_COUNT; i++)
-	    {
-	      if (lex_buf[0] == keyword_tokens[i].keyword[0]
-		  && strcmp (lex_buf, keyword_tokens[i].keyword) == 0)
-		{
-		  /* Pushing back the final whitespace avoids worrying
-		     about \n here.  */
-		  ungetc (c, current.file);
-		  current.state = IN_LINE;
-		  return keyword_tokens[i].token;
-		}
-	    }
-
-	  nlmheader_identify ();
-	  fprintf (stderr, _("%s:%d: unrecognized keyword: %s\n"),
-		   current.name, current.lineno, lex_buf);
-	}
-
-      ++parse_errors;
-      /* Treat the rest of this line as a comment.  */
-      ungetc (COMMENT_CHAR, current.file);
-      goto tail_recurse;
-    }
-
-  /* Parentheses just represent themselves.  */
-  if (c == '(' || c == ')')
-    return c;
-
-  /* Handle quoted strings.  */
-  if (c == '"' || c == '\'')
-    {
-      int quote;
-      int start_lineno;
-
-      quote = c;
-      start_lineno = current.lineno;
-
-      c = getc (current.file);
-      BUF_INIT ();
-      while (c != quote && c != EOF)
-	{
-	  BUF_ADD (c);
-	  if (c == '\n')
-	    ++current.lineno;
-	  c = getc (current.file);
-	}
-      BUF_FINISH ();
-
-      if (c == EOF)
-	{
-	  nlmheader_identify ();
-	  fprintf (stderr, _("%s:%d: end of file in quoted string\n"),
-		   current.name, start_lineno);
-	  ++parse_errors;
-	}
-
-      /* FIXME: Possible memory leak.  */
-      yylval.string = xstrdup (lex_buf);
-      return QUOTED_STRING;
-    }
-
-  /* Gather a generic argument.  */
-  BUF_INIT ();
-  while (! ISSPACE (c)
-	 && c != ','
-	 && c != COMMENT_CHAR
-	 && c != '('
-	 && c != ')')
-    {
-      BUF_ADD (c);
-      c = getc (current.file);
-    }
-  BUF_FINISH ();
-
-  ungetc (c, current.file);
-
-  /* FIXME: Possible memory leak.  */
-  yylval.string = xstrdup (lex_buf);
-  return STRING;
-}
-
-/* Get a number from a string.  */
-
-static long
-nlmlex_get_number (const char *s)
-{
-  long ret;
-  char *send;
-
-  ret = strtol (s, &send, 10);
-  if (*send != '\0')
-    nlmheader_warn (_("bad number"), -1);
-  return ret;
-}
-
-/* Prefix the nlmconv warnings with a note as to where they come from.
-   We don't use program_name on every warning, because then some
-   versions of the emacs next-error function can't recognize the line
-   number.  */
-
-static void
-nlmheader_identify (void)
-{
-  static int done;
-
-  if (! done)
-    {
-      fprintf (stderr, _("%s: problems in NLM command language input:\n"),
-	       program_name);
-      done = 1;
-    }
-}
-
-/* Issue a warning.  */
-
-static void
-nlmheader_warn (const char *s, int imax)
-{
-  nlmheader_identify ();
-  fprintf (stderr, "%s:%d: %s", current.name, current.lineno, s);
-  if (imax != -1)
-    fprintf (stderr, " (max %d)", imax);
-  fprintf (stderr, "\n");
-}
-
-/* Report an error.  */
-
-static void
-nlmheader_error (const char *s)
-{
-  nlmheader_warn (s, -1);
-  ++parse_errors;
-}
-
-/* Add a string to a string list.  */
-
-static struct string_list *
-string_list_cons (char *s, struct string_list *l)
-{
-  struct string_list *ret;
-
-  ret = (struct string_list *) xmalloc (sizeof (struct string_list));
-  ret->next = l;
-  ret->string = s;
-  return ret;
-}
-
-/* Append a string list to another string list.  */
-
-static struct string_list *
-string_list_append (struct string_list *l1, struct string_list *l2)
-{
-  register struct string_list **pp;
-
-  for (pp = &l1; *pp != NULL; pp = &(*pp)->next)
-    ;
-  *pp = l2;
-  return l1;
-}
-
-/* Append a string to a string list.  */
-
-static struct string_list *
-string_list_append1 (struct string_list *l, char *s)
-{
-  struct string_list *n;
-  register struct string_list **pp;
-
-  n = (struct string_list *) xmalloc (sizeof (struct string_list));
-  n->next = NULL;
-  n->string = s;
-  for (pp = &l; *pp != NULL; pp = &(*pp)->next)
-    ;
-  *pp = n;
-  return l;
-}
-
-/* Duplicate a string in memory.  */
-
-static char *
-xstrdup (const char *s)
-{
-  unsigned long len;
-  char *ret;
-
-  len = strlen (s);
-  ret = xmalloc (len + 1);
-  strcpy (ret, s);
-  return ret;
-}
-
diff -r -N -u binutils-2.21.51/binutils/nlmheader.h binutils/binutils/nlmheader.h
--- binutils-2.21.51/binutils/nlmheader.h	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/nlmheader.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,124 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     CHECK = 258,
-     CODESTART = 259,
-     COPYRIGHT = 260,
-     CUSTOM = 261,
-     DATE = 262,
-     DEBUG_K = 263,
-     DESCRIPTION = 264,
-     EXIT = 265,
-     EXPORT = 266,
-     FLAG_ON = 267,
-     FLAG_OFF = 268,
-     FULLMAP = 269,
-     HELP = 270,
-     IMPORT = 271,
-     INPUT = 272,
-     MAP = 273,
-     MESSAGES = 274,
-     MODULE = 275,
-     MULTIPLE = 276,
-     OS_DOMAIN = 277,
-     OUTPUT = 278,
-     PSEUDOPREEMPTION = 279,
-     REENTRANT = 280,
-     SCREENNAME = 281,
-     SHARELIB = 282,
-     STACK = 283,
-     START = 284,
-     SYNCHRONIZE = 285,
-     THREADNAME = 286,
-     TYPE = 287,
-     VERBOSE = 288,
-     VERSIONK = 289,
-     XDCDATA = 290,
-     STRING = 291,
-     QUOTED_STRING = 292
-   };
-#endif
-#define CHECK 258
-#define CODESTART 259
-#define COPYRIGHT 260
-#define CUSTOM 261
-#define DATE 262
-#define DEBUG_K 263
-#define DESCRIPTION 264
-#define EXIT 265
-#define EXPORT 266
-#define FLAG_ON 267
-#define FLAG_OFF 268
-#define FULLMAP 269
-#define HELP 270
-#define IMPORT 271
-#define INPUT 272
-#define MAP 273
-#define MESSAGES 274
-#define MODULE 275
-#define MULTIPLE 276
-#define OS_DOMAIN 277
-#define OUTPUT 278
-#define PSEUDOPREEMPTION 279
-#define REENTRANT 280
-#define SCREENNAME 281
-#define SHARELIB 282
-#define STACK 283
-#define START 284
-#define SYNCHRONIZE 285
-#define THREADNAME 286
-#define TYPE 287
-#define VERBOSE 288
-#define VERSIONK 289
-#define XDCDATA 290
-#define STRING 291
-#define QUOTED_STRING 292
-
-
-
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 113 "nlmheader.y"
-typedef union YYSTYPE {
-  char *string;
-  struct string_list *list;
-} YYSTYPE;
-/* Line 1275 of yacc.c.  */
-#line 116 "nlmheader.h"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-extern YYSTYPE yylval;
-
-
-
diff -r -N -u binutils-2.21.51/binutils/objcopy.c binutils/binutils/objcopy.c
--- binutils-2.21.51/binutils/objcopy.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/binutils/objcopy.c	2011-07-06 12:44:26.137253000 +0100
@@ -34,6 +34,9 @@
 #include "libbfd.h"
 #include "coff/internal.h"
 #include "libcoff.h"
+#if defined (__ST200__)
+#include "elf32-lx.h"
+#endif /* __ST200__ */
 
 /* FIXME: See bfd/peXXigen.c for why we include an architecture specific
    header in generic PE code.  */
@@ -88,6 +91,10 @@
 static bfd_boolean verbose;		/* Print file and target names.  */
 static bfd_boolean preserve_dates;	/* Preserve input file timestamp.  */
 static int status = 0;		/* Exit status.  */
+static bfd_boolean sec_compress = 0;
+static bfd_boolean sec_decompress = 0;
+static bfd_boolean sec_compress_second_phase = 0;
+static char * library_name = NULL;
 
 enum strip_action
   {
@@ -102,6 +109,9 @@
 /* Which symbols to remove.  */
 static enum strip_action strip_symbols;
 
+/* TB: */
+static bfd_boolean strip_relocs = FALSE;
+
 enum locals_action
   {
     LOCALS_UNDEF,
@@ -314,7 +324,10 @@
     OPTION_SECTION_ALIGNMENT,
     OPTION_STACK,
     OPTION_INTERLEAVE_WIDTH,
-    OPTION_SUBSYSTEM
+    OPTION_SUBSYSTEM,
+    OPTION_SEC_COMPRESS,
+    OPTION_SEC_DECOMPRESS,
+    OPTION_STRIP_PCREL_RELOCS
   };
 
 /* Options to handle if running as "strip".  */
@@ -344,6 +357,7 @@
   {"verbose", no_argument, 0, 'v'},
   {"version", no_argument, 0, 'V'},
   {"wildcard", no_argument, 0, 'w'},
+  {"strip-pcrel-relocs", no_argument, 0, OPTION_STRIP_PCREL_RELOCS},
   {0, no_argument, 0, 0}
 };
 
@@ -437,6 +451,9 @@
   {"section-alignment", required_argument, 0, OPTION_SECTION_ALIGNMENT},
   {"stack", required_argument, 0, OPTION_STACK},
   {"subsystem", required_argument, 0, OPTION_SUBSYSTEM},
+  {"compress-sections", optional_argument, 0, OPTION_SEC_COMPRESS},
+  {"decompress-sections", optional_argument, 0, OPTION_SEC_DECOMPRESS},
+  {"strip-pcrel-relocs", no_argument, 0, OPTION_STRIP_PCREL_RELOCS},
   {0, no_argument, 0, 0}
 };
 
@@ -565,6 +582,9 @@
                                    Set PE subsystem to <name> [& <version>]\n\
      --compress-debug-sections     Compress DWARF debug sections using zlib\n\
      --decompress-debug-sections   Decompress DWARF debug sections using zlib\n\
+The two following options must be used alone! :\n\
+     --compress-sections[=<compress_lib>]   Compress sections using optional compression library\n\
+     --decompress-sections[=<compress_lib>] Decompression sections using optional compression library\n\
   -v --verbose                     List all object files modified\n\
   @<file>                          Read options from <file>\n\
   -V --version                     Display this program's version number\n\
@@ -1971,6 +1991,31 @@
 	}
     }
 
+  if (sec_compress) {  
+#if defined(__ST200__)
+    elf_lx_secinit_compress_or_decompress(obfd, 1, library_name);
+#endif /* __ST200__ */
+  } else if (sec_decompress) {  
+#if defined(__ST200__)
+    elf_lx_secinit_compress_or_decompress(obfd, 0, library_name);
+#endif /* __ST200__ */
+  }
+  
+  /*
+   * Start the second phase of compression, to update the lma
+   * addresses and section sizes taking into account the
+   * the compression effects
+   */
+  if (sec_compress_second_phase) {
+    /* Break the recursion */
+    sec_compress_second_phase = 0;
+  }
+  
+  if (sec_compress) {
+    /* Request the second phase */
+    sec_compress_second_phase = 1;
+  }
+
   return TRUE;
 }
 
@@ -2412,6 +2457,13 @@
   const char * name;
   char *prefix = NULL;
   bfd_boolean make_nobits;
+  bfd_boolean sec_compress_update = 0;
+  bfd_vma sec_compress_lma = 0;
+  bfd_size_type sec_compress_size = 0;
+#if defined(__ST200__) /* DFE: No more supported. To be investigated */
+  bfd_vma initial_lma = 0;
+  bfd_size_type initial_size = 0;
+#endif /* __ST200__ */
 
   if (is_strip_section (ibfd, isection))
     return;
@@ -2472,7 +2524,34 @@
   if (make_nobits)
     elf_section_type (osection) = SHT_NOBITS;
 
-  size = bfd_section_size (ibfd, isection);
+  /*
+   * Second phase of compression processing:
+   * Perform updates of sizes and lma addresses to take into account
+   * compression effects computed during the first phase.
+   */
+  if (sec_compress_second_phase) {
+    
+#if defined(__ST200__)
+    if (elf_lx_get_compact_info(ibfd, isection, 
+				&initial_lma, &sec_compress_lma,
+				&initial_size, &sec_compress_size) == 0) {
+      /* this section may need adjustment */
+      sec_compress_update = 1;
+      
+    } else {
+      /* this section has not been impacted by compression */
+      sec_compress_update = 0;
+    }
+#else /* __ST200__ */
+    sec_compress_update = 0;
+#endif /* __ST200__ */
+  }
+  
+  if (sec_compress_update)
+    size = sec_compress_size;
+  else
+    size = bfd_section_size (ibfd, isection);
+
   if (copy_byte >= 0)
     size = (size + interleave - 1) / interleave * copy_width;
   else if (extract_symbol)
@@ -2497,7 +2576,11 @@
       goto loser;
     }
 
-  lma = isection->lma;
+  if (sec_compress_update)
+    lma = sec_compress_lma;
+  else
+    lma = isection->lma;
+
   if ((p != NULL) && p->change_lma != CHANGE_IGNORE)
     {
       if (p->change_lma == CHANGE_MODIFY)
@@ -2595,6 +2678,19 @@
   osection = isection->output_section;
   size = bfd_get_section_size (isection);
 
+  /*
+   * Second phase of compression processing:
+   * Perform updates of sizes and lma addresses to take into account
+   * compression effects computed during the first phase.
+   */
+  if (sec_compress_second_phase) {
+    /* We trust the size of the output section correctly set 
+       by setup_section() */
+    size = bfd_get_section_size (osection);
+  } else {
+    size = bfd_get_section_size (isection);
+  }
+
   if (size == 0 || osection == 0)
     return;
 
@@ -2638,6 +2734,27 @@
 	  return;
 	}
 
+      if (strip_relocs == TRUE) {
+	/* TB: removes pc relative relocation on local symbol */
+	arelent **temp_relpp;
+	long temp_relcount = 0;
+	long i;
+	
+	temp_relpp = (arelent **) xmalloc (relsize);
+	for (i = 0; i < relcount; i++) {
+	  asymbol *sym = (*relpp[i]->sym_ptr_ptr);
+	  if (!((sym->flags & BSF_LOCAL) &&  (relpp[i]->howto->pc_relative))) {
+	    temp_relpp [temp_relcount++] = relpp [i];
+	  } 
+	  /* else { 
+	     printf ("%s against %s is removed \n",relpp[i]->howto->name, sym->name);
+	  } */
+	}
+	relcount = temp_relcount;
+	free (relpp);
+	relpp = temp_relpp;
+      }
+
       if (strip_symbols == STRIP_ALL)
 	{
 	  /* Remove relocations which are not in
@@ -2982,6 +3099,9 @@
 	case OPTION_KEEP_FILE_SYMBOLS:
 	  keep_file_symbols = 1;
 	  break;
+	case OPTION_STRIP_PCREL_RELOCS:
+	  strip_relocs = TRUE;
+	  break;
 	case 0:
 	  /* We've been given a long option.  */
 	  break;
@@ -3698,6 +3818,34 @@
 	    fatal (_("unable to parse alternative machine code"));
 	  break;
 
+	case OPTION_SEC_COMPRESS:
+          {
+            int len;
+            sec_compress = 1;
+            if (optarg != NULL) {
+              len = strlen(optarg);
+              library_name = (char *) xmalloc (len + 1);
+              strcpy (library_name, optarg);
+            } else {
+	      library_name = NULL;
+	    }
+          }
+	  break;
+	  
+	case OPTION_SEC_DECOMPRESS:
+          {
+            int len;
+            sec_decompress = 1;
+            if (optarg != NULL) {
+              len = strlen(optarg);
+              library_name = (char *) xmalloc (len + 1);
+              strcpy (library_name, optarg);
+            } else {
+	      library_name = NULL;
+	    }
+          }
+	  break;
+
 	case OPTION_PREFIX_SYMBOLS:
 	  prefix_symbols_string = optarg;
 	  break;
@@ -3730,6 +3878,10 @@
 	  bfd_flags_to_set &= ~D_PAGED;
 	  break;
 
+	case OPTION_STRIP_PCREL_RELOCS:
+	  strip_relocs = TRUE;
+	  break;
+
 	case OPTION_EXTRACT_SYMBOL:
 	  extract_symbol = TRUE;
 	  break;
@@ -3965,6 +4117,31 @@
 	}
     }
 
+  /*
+   * Second phase of compression, to update the lma
+   * addresses and section sizes taking into account the
+   * the compression effects
+   */
+  if (sec_compress_second_phase) {
+    int new_argc = 2;
+    char *new_argv[2];
+
+    new_argv[0] = argv[0];
+    if (output_filename != (char *) NULL) {
+      new_argv[1] = (char *) xmalloc(strlen(output_filename) + 1 );
+      strcpy(new_argv[1], output_filename);
+    } else {
+      new_argv[1] = (char *) xmalloc(strlen(input_filename) + 1);
+      strcpy(new_argv[1], input_filename);
+    }
+
+    /* Initialize actions for second phase */
+    optind = 0;
+    sec_compress = 0;
+
+    copy_main(new_argc, new_argv);
+  }
+
   return 0;
 }
 
diff -r -N -u binutils-2.21.51/binutils/rcparse.c binutils/binutils/rcparse.c
--- binutils-2.21.51/binutils/rcparse.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/rcparse.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,4276 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     BEG = 258,
-     END = 259,
-     ACCELERATORS = 260,
-     VIRTKEY = 261,
-     ASCII = 262,
-     NOINVERT = 263,
-     SHIFT = 264,
-     CONTROL = 265,
-     ALT = 266,
-     BITMAP = 267,
-     CURSOR = 268,
-     DIALOG = 269,
-     DIALOGEX = 270,
-     EXSTYLE = 271,
-     CAPTION = 272,
-     CLASS = 273,
-     STYLE = 274,
-     AUTO3STATE = 275,
-     AUTOCHECKBOX = 276,
-     AUTORADIOBUTTON = 277,
-     CHECKBOX = 278,
-     COMBOBOX = 279,
-     CTEXT = 280,
-     DEFPUSHBUTTON = 281,
-     EDITTEXT = 282,
-     GROUPBOX = 283,
-     LISTBOX = 284,
-     LTEXT = 285,
-     PUSHBOX = 286,
-     PUSHBUTTON = 287,
-     RADIOBUTTON = 288,
-     RTEXT = 289,
-     SCROLLBAR = 290,
-     STATE3 = 291,
-     USERBUTTON = 292,
-     BEDIT = 293,
-     HEDIT = 294,
-     IEDIT = 295,
-     FONT = 296,
-     ICON = 297,
-     ANICURSOR = 298,
-     ANIICON = 299,
-     DLGINCLUDE = 300,
-     DLGINIT = 301,
-     FONTDIR = 302,
-     HTML = 303,
-     MANIFEST = 304,
-     PLUGPLAY = 305,
-     VXD = 306,
-     TOOLBAR = 307,
-     BUTTON = 308,
-     LANGUAGE = 309,
-     CHARACTERISTICS = 310,
-     VERSIONK = 311,
-     MENU = 312,
-     MENUEX = 313,
-     MENUITEM = 314,
-     SEPARATOR = 315,
-     POPUP = 316,
-     CHECKED = 317,
-     GRAYED = 318,
-     HELP = 319,
-     INACTIVE = 320,
-     MENUBARBREAK = 321,
-     MENUBREAK = 322,
-     MESSAGETABLE = 323,
-     RCDATA = 324,
-     STRINGTABLE = 325,
-     VERSIONINFO = 326,
-     FILEVERSION = 327,
-     PRODUCTVERSION = 328,
-     FILEFLAGSMASK = 329,
-     FILEFLAGS = 330,
-     FILEOS = 331,
-     FILETYPE = 332,
-     FILESUBTYPE = 333,
-     BLOCKSTRINGFILEINFO = 334,
-     BLOCKVARFILEINFO = 335,
-     VALUE = 336,
-     BLOCK = 337,
-     MOVEABLE = 338,
-     FIXED = 339,
-     PURE = 340,
-     IMPURE = 341,
-     PRELOAD = 342,
-     LOADONCALL = 343,
-     DISCARDABLE = 344,
-     NOT = 345,
-     QUOTEDUNISTRING = 346,
-     QUOTEDSTRING = 347,
-     STRING = 348,
-     NUMBER = 349,
-     SIZEDUNISTRING = 350,
-     SIZEDSTRING = 351,
-     IGNORED_TOKEN = 352,
-     NEG = 353
-   };
-#endif
-#define BEG 258
-#define END 259
-#define ACCELERATORS 260
-#define VIRTKEY 261
-#define ASCII 262
-#define NOINVERT 263
-#define SHIFT 264
-#define CONTROL 265
-#define ALT 266
-#define BITMAP 267
-#define CURSOR 268
-#define DIALOG 269
-#define DIALOGEX 270
-#define EXSTYLE 271
-#define CAPTION 272
-#define CLASS 273
-#define STYLE 274
-#define AUTO3STATE 275
-#define AUTOCHECKBOX 276
-#define AUTORADIOBUTTON 277
-#define CHECKBOX 278
-#define COMBOBOX 279
-#define CTEXT 280
-#define DEFPUSHBUTTON 281
-#define EDITTEXT 282
-#define GROUPBOX 283
-#define LISTBOX 284
-#define LTEXT 285
-#define PUSHBOX 286
-#define PUSHBUTTON 287
-#define RADIOBUTTON 288
-#define RTEXT 289
-#define SCROLLBAR 290
-#define STATE3 291
-#define USERBUTTON 292
-#define BEDIT 293
-#define HEDIT 294
-#define IEDIT 295
-#define FONT 296
-#define ICON 297
-#define ANICURSOR 298
-#define ANIICON 299
-#define DLGINCLUDE 300
-#define DLGINIT 301
-#define FONTDIR 302
-#define HTML 303
-#define MANIFEST 304
-#define PLUGPLAY 305
-#define VXD 306
-#define TOOLBAR 307
-#define BUTTON 308
-#define LANGUAGE 309
-#define CHARACTERISTICS 310
-#define VERSIONK 311
-#define MENU 312
-#define MENUEX 313
-#define MENUITEM 314
-#define SEPARATOR 315
-#define POPUP 316
-#define CHECKED 317
-#define GRAYED 318
-#define HELP 319
-#define INACTIVE 320
-#define MENUBARBREAK 321
-#define MENUBREAK 322
-#define MESSAGETABLE 323
-#define RCDATA 324
-#define STRINGTABLE 325
-#define VERSIONINFO 326
-#define FILEVERSION 327
-#define PRODUCTVERSION 328
-#define FILEFLAGSMASK 329
-#define FILEFLAGS 330
-#define FILEOS 331
-#define FILETYPE 332
-#define FILESUBTYPE 333
-#define BLOCKSTRINGFILEINFO 334
-#define BLOCKVARFILEINFO 335
-#define VALUE 336
-#define BLOCK 337
-#define MOVEABLE 338
-#define FIXED 339
-#define PURE 340
-#define IMPURE 341
-#define PRELOAD 342
-#define LOADONCALL 343
-#define DISCARDABLE 344
-#define NOT 345
-#define QUOTEDUNISTRING 346
-#define QUOTEDSTRING 347
-#define STRING 348
-#define NUMBER 349
-#define SIZEDUNISTRING 350
-#define SIZEDSTRING 351
-#define IGNORED_TOKEN 352
-#define NEG 353
-
-
-
-
-/* Copy the first part of user declarations.  */
-#line 1 "rcparse.y"
- /* rcparse.y -- parser for Windows rc files
-   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2007, 2008
-   Free Software Foundation, Inc.
-   Written by Ian Lance Taylor, Cygnus Support.
-   Extended by Kai Tietz, Onevision.
-
-   This file is part of GNU Binutils.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-   02110-1301, USA.  */
-
-
-/* This is a parser for Windows rc files.  It is based on the parser
-   by Gunther Ebert <gunther.ebert@ixos-leipzig.de>.  */
-
-#include "sysdep.h"
-#include "bfd.h"
-#include "bucomm.h"
-#include "libiberty.h"
-#include "windres.h"
-#include "safe-ctype.h"
-
-/* The current language.  */
-
-static unsigned short language;
-
-/* The resource information during a sub statement.  */
-
-static rc_res_res_info sub_res_info;
-
-/* Dialog information.  This is built by the nonterminals styles and
-   controls.  */
-
-static rc_dialog dialog;
-
-/* This is used when building a style.  It is modified by the
-   nonterminal styleexpr.  */
-
-static unsigned long style;
-
-/* These are used when building a control.  They are set before using
-   control_params.  */
-
-static rc_uint_type base_style;
-static rc_uint_type default_style;
-static rc_res_id class;
-static rc_res_id res_text_field;
-static unichar null_unichar;
-
-/* This is used for COMBOBOX, LISTBOX and EDITTEXT which
-   do not allow resource 'text' field in control definition. */
-static const rc_res_id res_null_text = { 1, {{0, &null_unichar}}};
-
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 69 "rcparse.y"
-typedef union YYSTYPE {
-  rc_accelerator acc;
-  rc_accelerator *pacc;
-  rc_dialog_control *dialog_control;
-  rc_menuitem *menuitem;
-  struct
-  {
-    rc_rcdata_item *first;
-    rc_rcdata_item *last;
-  } rcdata;
-  rc_rcdata_item *rcdata_item;
-  rc_fixed_versioninfo *fixver;
-  rc_ver_info *verinfo;
-  rc_ver_stringinfo *verstring;
-  rc_ver_varinfo *vervar;
-  rc_toolbar_item *toobar_item;
-  rc_res_id id;
-  rc_res_res_info res_info;
-  struct
-  {
-    rc_uint_type on;
-    rc_uint_type off;
-  } memflags;
-  struct
-  {
-    rc_uint_type val;
-    /* Nonzero if this number was explicitly specified as long.  */
-    int dword;
-  } i;
-  rc_uint_type il;
-  rc_uint_type is;
-  const char *s;
-  struct
-  {
-    rc_uint_type length;
-    const char *s;
-  } ss;
-  unichar *uni;
-  struct
-  {
-    rc_uint_type length;
-    const unichar *s;
-  } suni;
-} YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 384 "rcparse.c"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 214 of yacc.c.  */
-#line 396 "rcparse.c"
-
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
-
-# ifndef YYFREE
-#  define YYFREE free
-# endif
-# ifndef YYMALLOC
-#  define YYMALLOC malloc
-# endif
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
-#  endif
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-# endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
-
-
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  short yyss;
-  YYSTYPE yyvs;
-  };
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAXIMUM)
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  register YYSIZE_T yyi;		\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (0)
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (0)
-
-#endif
-
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
-#define YYFINAL  2
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   835
-
-/* YYNTOKENS -- Number of terminals. */
-#define YYNTOKENS  112
-/* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  99
-/* YYNRULES -- Number of rules. */
-#define YYNRULES  270
-/* YYNRULES -- Number of states. */
-#define YYNSTATES  515
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   353
-
-#define YYTRANSLATE(YYX) 						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,   105,   100,     2,
-     110,   111,   103,   101,   108,   102,     2,   104,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,   109,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,    99,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,    98,     2,   106,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
-      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
-      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
-      65,    66,    67,    68,    69,    70,    71,    72,    73,    74,
-      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,
-      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
-      95,    96,    97,   107
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const unsigned short yyprhs[] =
-{
-       0,     0,     3,     4,     7,    10,    13,    16,    19,    22,
-      25,    28,    31,    34,    37,    40,    43,    46,    49,    56,
-      57,    60,    63,    68,    70,    72,    74,    78,    81,    83,
-      85,    87,    89,    91,    93,    98,   103,   104,   118,   119,
-     133,   134,   149,   150,   154,   155,   159,   163,   167,   171,
-     175,   181,   188,   196,   205,   209,   213,   218,   222,   223,
-     226,   227,   232,   233,   238,   239,   244,   245,   250,   251,
-     256,   257,   261,   273,   286,   287,   292,   293,   298,   299,
-     303,   304,   309,   310,   315,   322,   331,   342,   354,   355,
-     360,   361,   365,   366,   371,   372,   377,   378,   383,   384,
-     389,   390,   395,   396,   400,   401,   406,   407,   423,   430,
-     439,   449,   452,   453,   456,   458,   460,   461,   465,   466,
-     470,   471,   475,   476,   480,   485,   490,   494,   501,   502,
-     505,   510,   513,   520,   521,   525,   528,   530,   532,   534,
-     536,   538,   540,   547,   548,   551,   554,   558,   564,   567,
-     573,   580,   588,   598,   603,   604,   607,   608,   610,   612,
-     614,   616,   620,   624,   628,   631,   632,   639,   640,   644,
-     649,   652,   654,   656,   658,   660,   662,   664,   666,   668,
-     670,   672,   679,   684,   693,   694,   698,   701,   708,   709,
-     716,   723,   727,   731,   735,   739,   743,   744,   753,   761,
-     762,   768,   769,   773,   775,   777,   779,   781,   784,   786,
-     789,   790,   793,   797,   802,   806,   807,   810,   811,   814,
-     816,   818,   820,   822,   824,   826,   828,   830,   832,   834,
-     837,   839,   841,   843,   846,   848,   851,   853,   856,   860,
-     865,   867,   871,   872,   874,   877,   879,   881,   885,   888,
-     891,   895,   899,   903,   907,   911,   915,   919,   923,   926,
-     928,   930,   934,   937,   941,   945,   949,   953,   957,   961,
-     965
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const short yyrhs[] =
-{
-     113,     0,    -1,    -1,   113,   114,    -1,   113,   120,    -1,
-     113,   121,    -1,   113,   122,    -1,   113,   162,    -1,   113,
-     163,    -1,   113,   164,    -1,   113,   165,    -1,   113,   170,
-      -1,   113,   173,    -1,   113,   178,    -1,   113,   183,    -1,
-     113,   182,    -1,   113,   185,    -1,   113,    97,    -1,   190,
-       5,   193,     3,   115,     4,    -1,    -1,   115,   116,    -1,
-     117,   208,    -1,   117,   208,   108,   118,    -1,    92,    -1,
-     209,    -1,   119,    -1,   118,   108,   119,    -1,   118,   119,
-      -1,     6,    -1,     7,    -1,     8,    -1,     9,    -1,    10,
-      -1,    11,    -1,   190,    12,   195,   197,    -1,   190,    13,
-     194,   197,    -1,    -1,   190,    14,   195,   126,   209,   205,
-     205,   205,   123,   127,     3,   128,     4,    -1,    -1,   190,
-      15,   195,   126,   209,   205,   205,   205,   124,   127,     3,
-     128,     4,    -1,    -1,   190,    15,   195,   126,   209,   205,
-     205,   205,   205,   125,   127,     3,   128,     4,    -1,    -1,
-      16,   109,   206,    -1,    -1,   127,    17,   198,    -1,   127,
-      18,   190,    -1,   127,    19,   202,    -1,   127,    16,   206,
-      -1,   127,    18,   198,    -1,   127,    41,   206,   108,   198,
-      -1,   127,    41,   206,   108,   198,   205,    -1,   127,    41,
-     206,   108,   198,   205,   205,    -1,   127,    41,   206,   108,
-     198,   205,   205,   205,    -1,   127,    57,   190,    -1,   127,
-      55,   206,    -1,   127,    54,   206,   205,    -1,   127,    56,
-     206,    -1,    -1,   128,   129,    -1,    -1,    20,   153,   130,
-     151,    -1,    -1,    21,   153,   131,   151,    -1,    -1,    22,
-     153,   132,   151,    -1,    -1,    38,   153,   133,   151,    -1,
-      -1,    23,   153,   134,   151,    -1,    -1,    24,   135,   151,
-      -1,    10,   153,   206,   152,   156,   205,   205,   205,   205,
-     204,   155,    -1,    10,   153,   206,   152,   156,   205,   205,
-     205,   205,   205,   205,   155,    -1,    -1,    25,   153,   136,
-     151,    -1,    -1,    26,   153,   137,   151,    -1,    -1,    27,
-     138,   151,    -1,    -1,    28,   153,   139,   151,    -1,    -1,
-      39,   153,   140,   151,    -1,    42,   192,   206,   205,   205,
-     155,    -1,    42,   192,   206,   205,   205,   205,   205,   155,
-      -1,    42,   192,   206,   205,   205,   205,   205,   158,   204,
-     155,    -1,    42,   192,   206,   205,   205,   205,   205,   158,
-     205,   205,   155,    -1,    -1,    40,   153,   141,   151,    -1,
-      -1,    29,   142,   151,    -1,    -1,    30,   153,   143,   151,
-      -1,    -1,    31,   153,   144,   151,    -1,    -1,    32,   153,
-     145,   151,    -1,    -1,    33,   153,   146,   151,    -1,    -1,
-      34,   153,   147,   151,    -1,    -1,    35,   148,   151,    -1,
-      -1,    36,   153,   149,   151,    -1,    -1,    37,   192,   206,
-     108,   206,   108,   206,   108,   206,   108,   206,   108,   150,
-     202,   204,    -1,   206,   205,   205,   205,   205,   155,    -1,
-     206,   205,   205,   205,   205,   160,   204,   155,    -1,   206,
-     205,   205,   205,   205,   160,   205,   205,   155,    -1,   108,
-     154,    -1,    -1,   154,   108,    -1,   209,    -1,   198,    -1,
-      -1,     3,   174,     4,    -1,    -1,   108,   157,   202,    -1,
-      -1,   108,   159,   202,    -1,    -1,   108,   161,   202,    -1,
-     190,    41,   194,   197,    -1,   190,    42,   194,   197,    -1,
-      54,   206,   205,    -1,   190,    57,   193,     3,   166,     4,
-      -1,    -1,   166,   167,    -1,    59,   198,   205,   168,    -1,
-      59,    60,    -1,    61,   198,   168,     3,   166,     4,    -1,
-      -1,   168,   108,   169,    -1,   168,   169,    -1,    62,    -1,
-      63,    -1,    64,    -1,    65,    -1,    66,    -1,    67,    -1,
-     190,    58,   193,     3,   171,     4,    -1,    -1,   171,   172,
-      -1,    59,   198,    -1,    59,   198,   205,    -1,    59,   198,
-     205,   205,   204,    -1,    59,    60,    -1,    61,   198,     3,
-     171,     4,    -1,    61,   198,   205,     3,   171,     4,    -1,
-      61,   198,   205,   205,     3,   171,     4,    -1,    61,   198,
-     205,   205,   205,   204,     3,   171,     4,    -1,   190,    68,
-     195,   197,    -1,    -1,   175,   176,    -1,    -1,   177,    -1,
-     200,    -1,   201,    -1,   207,    -1,   177,   108,   200,    -1,
-     177,   108,   201,    -1,   177,   108,   207,    -1,   177,   108,
-      -1,    -1,    70,   193,     3,   179,   180,     4,    -1,    -1,
-     180,   206,   198,    -1,   180,   206,   108,   198,    -1,   180,
-       1,    -1,   190,    -1,    48,    -1,    69,    -1,    49,    -1,
-      50,    -1,    51,    -1,    45,    -1,    46,    -1,    43,    -1,
-      44,    -1,   190,   181,   193,     3,   174,     4,    -1,   190,
-     181,   193,   197,    -1,   190,    52,   193,   206,   205,     3,
-     184,     4,    -1,    -1,   184,    53,   190,    -1,   184,    60,
-      -1,   190,    71,   186,     3,   187,     4,    -1,    -1,   186,
-      72,   206,   205,   205,   205,    -1,   186,    73,   206,   205,
-     205,   205,    -1,   186,    74,   206,    -1,   186,    75,   206,
-      -1,   186,    76,   206,    -1,   186,    77,   206,    -1,   186,
-      78,   206,    -1,    -1,   187,    79,     3,    82,     3,   188,
-       4,     4,    -1,   187,    80,     3,    81,   198,   189,     4,
-      -1,    -1,   188,    81,   198,   108,   198,    -1,    -1,   189,
-     205,   205,    -1,   209,    -1,   191,    -1,   199,    -1,    93,
-      -1,   209,   108,    -1,   191,    -1,   191,   108,    -1,    -1,
-     193,   196,    -1,   193,    55,   206,    -1,   193,    54,   206,
-     205,    -1,   193,    56,   206,    -1,    -1,   194,   196,    -1,
-      -1,   195,   196,    -1,    83,    -1,    84,    -1,    85,    -1,
-      86,    -1,    87,    -1,    88,    -1,    89,    -1,    92,    -1,
-      93,    -1,   199,    -1,   198,   199,    -1,    91,    -1,    92,
-      -1,    96,    -1,   200,    96,    -1,    95,    -1,   201,    95,
-      -1,   203,    -1,    90,   203,    -1,   202,    98,   203,    -1,
-     202,    98,    90,   203,    -1,    94,    -1,   110,   206,   111,
-      -1,    -1,   205,    -1,   108,   206,    -1,   207,    -1,    94,
-      -1,   110,   207,   111,    -1,   106,   207,    -1,   102,   207,
-      -1,   207,   103,   207,    -1,   207,   104,   207,    -1,   207,
-     105,   207,    -1,   207,   101,   207,    -1,   207,   102,   207,
-      -1,   207,   100,   207,    -1,   207,    99,   207,    -1,   207,
-      98,   207,    -1,   108,   209,    -1,   210,    -1,    94,    -1,
-     110,   207,   111,    -1,   106,   207,    -1,   210,   103,   207,
-      -1,   210,   104,   207,    -1,   210,   105,   207,    -1,   210,
-     101,   207,    -1,   210,   102,   207,    -1,   210,   100,   207,
-      -1,   210,    99,   207,    -1,   210,    98,   207,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
-{
-       0,   177,   177,   179,   180,   181,   182,   183,   184,   185,
-     186,   187,   188,   189,   190,   191,   192,   193,   199,   210,
-     213,   234,   239,   251,   271,   281,   285,   290,   297,   301,
-     306,   310,   314,   318,   327,   339,   353,   351,   378,   376,
-     405,   403,   435,   438,   444,   446,   452,   456,   461,   465,
-     469,   482,   497,   512,   527,   531,   535,   539,   545,   547,
-     559,   558,   571,   570,   583,   582,   595,   594,   610,   609,
-     622,   621,   635,   646,   656,   655,   668,   667,   680,   679,
-     692,   691,   704,   703,   718,   723,   729,   735,   742,   741,
-     757,   756,   769,   768,   781,   780,   792,   791,   804,   803,
-     816,   815,   828,   827,   840,   839,   853,   851,   872,   883,
-     894,   906,   917,   920,   924,   929,   939,   942,   952,   951,
-     958,   957,   964,   963,   971,   983,   996,  1005,  1016,  1019,
-    1036,  1040,  1044,  1052,  1055,  1059,  1066,  1070,  1074,  1078,
-    1082,  1086,  1095,  1106,  1109,  1126,  1130,  1134,  1138,  1142,
-    1146,  1150,  1154,  1164,  1177,  1177,  1189,  1193,  1200,  1208,
-    1216,  1224,  1233,  1242,  1251,  1261,  1260,  1265,  1267,  1272,
-    1277,  1285,  1289,  1294,  1299,  1304,  1309,  1314,  1319,  1324,
-    1329,  1340,  1347,  1357,  1363,  1364,  1383,  1408,  1419,  1424,
-    1430,  1436,  1441,  1446,  1451,  1456,  1471,  1474,  1478,  1486,
-    1489,  1497,  1500,  1509,  1514,  1523,  1527,  1537,  1542,  1546,
-    1557,  1563,  1569,  1574,  1579,  1590,  1595,  1607,  1612,  1624,
-    1629,  1634,  1639,  1644,  1649,  1654,  1664,  1668,  1676,  1681,
-    1696,  1700,  1709,  1713,  1725,  1729,  1751,  1755,  1759,  1763,
-    1770,  1774,  1784,  1787,  1796,  1805,  1814,  1818,  1822,  1827,
-    1832,  1837,  1842,  1847,  1852,  1857,  1862,  1867,  1878,  1887,
-    1898,  1902,  1906,  1911,  1916,  1921,  1926,  1931,  1936,  1941,
-    1946
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "BEG", "END", "ACCELERATORS", "VIRTKEY",
-  "ASCII", "NOINVERT", "SHIFT", "CONTROL", "ALT", "BITMAP", "CURSOR",
-  "DIALOG", "DIALOGEX", "EXSTYLE", "CAPTION", "CLASS", "STYLE",
-  "AUTO3STATE", "AUTOCHECKBOX", "AUTORADIOBUTTON", "CHECKBOX", "COMBOBOX",
-  "CTEXT", "DEFPUSHBUTTON", "EDITTEXT", "GROUPBOX", "LISTBOX", "LTEXT",
-  "PUSHBOX", "PUSHBUTTON", "RADIOBUTTON", "RTEXT", "SCROLLBAR", "STATE3",
-  "USERBUTTON", "BEDIT", "HEDIT", "IEDIT", "FONT", "ICON", "ANICURSOR",
-  "ANIICON", "DLGINCLUDE", "DLGINIT", "FONTDIR", "HTML", "MANIFEST",
-  "PLUGPLAY", "VXD", "TOOLBAR", "BUTTON", "LANGUAGE", "CHARACTERISTICS",
-  "VERSIONK", "MENU", "MENUEX", "MENUITEM", "SEPARATOR", "POPUP",
-  "CHECKED", "GRAYED", "HELP", "INACTIVE", "MENUBARBREAK", "MENUBREAK",
-  "MESSAGETABLE", "RCDATA", "STRINGTABLE", "VERSIONINFO", "FILEVERSION",
-  "PRODUCTVERSION", "FILEFLAGSMASK", "FILEFLAGS", "FILEOS", "FILETYPE",
-  "FILESUBTYPE", "BLOCKSTRINGFILEINFO", "BLOCKVARFILEINFO", "VALUE",
-  "BLOCK", "MOVEABLE", "FIXED", "PURE", "IMPURE", "PRELOAD", "LOADONCALL",
-  "DISCARDABLE", "NOT", "QUOTEDUNISTRING", "QUOTEDSTRING", "STRING",
-  "NUMBER", "SIZEDUNISTRING", "SIZEDSTRING", "IGNORED_TOKEN", "'|'", "'^'",
-  "'&'", "'+'", "'-'", "'*'", "'/'", "'%'", "'~'", "NEG", "','", "'='",
-  "'('", "')'", "$accept", "input", "accelerator", "acc_entries",
-  "acc_entry", "acc_event", "acc_options", "acc_option", "bitmap",
-  "cursor", "dialog", "@1", "@2", "@3", "exstyle", "styles", "controls",
-  "control", "@4", "@5", "@6", "@7", "@8", "@9", "@10", "@11", "@12",
-  "@13", "@14", "@15", "@16", "@17", "@18", "@19", "@20", "@21", "@22",
-  "@23", "@24", "control_params", "cresid", "optresidc", "resid",
-  "opt_control_data", "control_styleexpr", "@25", "icon_styleexpr", "@26",
-  "control_params_styleexpr", "@27", "font", "icon", "language", "menu",
-  "menuitems", "menuitem", "menuitem_flags", "menuitem_flag", "menuex",
-  "menuexitems", "menuexitem", "messagetable", "optrcdata_data", "@28",
-  "optrcdata_data_int", "rcdata_data", "stringtable", "@29", "string_data",
-  "rcdata_id", "user", "toolbar", "toolbar_data", "versioninfo",
-  "fixedverinfo", "verblocks", "vervals", "vertrans", "id", "resname",
-  "resref", "suboptions", "memflags_move_discard", "memflags_move",
-  "memflag", "file_name", "res_unicode_string_concat",
-  "res_unicode_string", "sizedstring", "sizedunistring", "styleexpr",
-  "parennumber", "optcnumexpr", "cnumexpr", "numexpr", "sizednumexpr",
-  "cposnumexpr", "posnumexpr", "sizedposnumexpr", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
-     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
-     305,   306,   307,   308,   309,   310,   311,   312,   313,   314,
-     315,   316,   317,   318,   319,   320,   321,   322,   323,   324,
-     325,   326,   327,   328,   329,   330,   331,   332,   333,   334,
-     335,   336,   337,   338,   339,   340,   341,   342,   343,   344,
-     345,   346,   347,   348,   349,   350,   351,   352,   124,    94,
-      38,    43,    45,    42,    47,    37,   126,   353,    44,    61,
-      40,    41
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
-{
-       0,   112,   113,   113,   113,   113,   113,   113,   113,   113,
-     113,   113,   113,   113,   113,   113,   113,   113,   114,   115,
-     115,   116,   116,   117,   117,   118,   118,   118,   119,   119,
-     119,   119,   119,   119,   120,   121,   123,   122,   124,   122,
-     125,   122,   126,   126,   127,   127,   127,   127,   127,   127,
-     127,   127,   127,   127,   127,   127,   127,   127,   128,   128,
-     130,   129,   131,   129,   132,   129,   133,   129,   134,   129,
-     135,   129,   129,   129,   136,   129,   137,   129,   138,   129,
-     139,   129,   140,   129,   129,   129,   129,   129,   141,   129,
-     142,   129,   143,   129,   144,   129,   145,   129,   146,   129,
-     147,   129,   148,   129,   149,   129,   150,   129,   151,   151,
-     151,   152,   153,   153,   154,   154,   155,   155,   157,   156,
-     159,   158,   161,   160,   162,   163,   164,   165,   166,   166,
-     167,   167,   167,   168,   168,   168,   169,   169,   169,   169,
-     169,   169,   170,   171,   171,   172,   172,   172,   172,   172,
-     172,   172,   172,   173,   175,   174,   176,   176,   177,   177,
-     177,   177,   177,   177,   177,   179,   178,   180,   180,   180,
-     180,   181,   181,   181,   181,   181,   181,   181,   181,   181,
-     181,   182,   182,   183,   184,   184,   184,   185,   186,   186,
-     186,   186,   186,   186,   186,   186,   187,   187,   187,   188,
-     188,   189,   189,   190,   190,   191,   191,   192,   192,   192,
-     193,   193,   193,   193,   193,   194,   194,   195,   195,   196,
-     196,   196,   196,   196,   196,   196,   197,   197,   198,   198,
-     199,   199,   200,   200,   201,   201,   202,   202,   202,   202,
-     203,   203,   204,   204,   205,   206,   207,   207,   207,   207,
-     207,   207,   207,   207,   207,   207,   207,   207,   208,   209,
-     210,   210,   210,   210,   210,   210,   210,   210,   210,   210,
-     210
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
-{
-       0,     2,     0,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     6,     0,
-       2,     2,     4,     1,     1,     1,     3,     2,     1,     1,
-       1,     1,     1,     1,     4,     4,     0,    13,     0,    13,
-       0,    14,     0,     3,     0,     3,     3,     3,     3,     3,
-       5,     6,     7,     8,     3,     3,     4,     3,     0,     2,
-       0,     4,     0,     4,     0,     4,     0,     4,     0,     4,
-       0,     3,    11,    12,     0,     4,     0,     4,     0,     3,
-       0,     4,     0,     4,     6,     8,    10,    11,     0,     4,
-       0,     3,     0,     4,     0,     4,     0,     4,     0,     4,
-       0,     4,     0,     3,     0,     4,     0,    15,     6,     8,
-       9,     2,     0,     2,     1,     1,     0,     3,     0,     3,
-       0,     3,     0,     3,     4,     4,     3,     6,     0,     2,
-       4,     2,     6,     0,     3,     2,     1,     1,     1,     1,
-       1,     1,     6,     0,     2,     2,     3,     5,     2,     5,
-       6,     7,     9,     4,     0,     2,     0,     1,     1,     1,
-       1,     3,     3,     3,     2,     0,     6,     0,     3,     4,
-       2,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-       1,     6,     4,     8,     0,     3,     2,     6,     0,     6,
-       6,     3,     3,     3,     3,     3,     0,     8,     7,     0,
-       5,     0,     3,     1,     1,     1,     1,     2,     1,     2,
-       0,     2,     3,     4,     3,     0,     2,     0,     2,     1,
-       1,     1,     1,     1,     1,     1,     1,     1,     1,     2,
-       1,     1,     1,     2,     1,     2,     1,     2,     3,     4,
-       1,     3,     0,     1,     2,     1,     1,     3,     2,     2,
-       3,     3,     3,     3,     3,     3,     3,     3,     2,     1,
-       1,     3,     2,     3,     3,     3,     3,     3,     3,     3,
-       3
-};
-
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const unsigned short yydefact[] =
-{
-       2,     0,     1,     0,   210,   230,   231,   206,   260,    17,
-       0,     0,     3,     4,     5,     6,     7,     8,     9,    10,
-      11,    12,    13,    15,    14,    16,     0,   204,   205,   203,
-     259,   246,     0,     0,     0,     0,   245,     0,   262,     0,
-     210,   217,   215,   217,   217,   215,   215,   179,   180,   177,
-     178,   172,   174,   175,   176,   210,   210,   210,   217,   173,
-     188,   210,   171,     0,     0,     0,     0,     0,     0,     0,
-       0,   249,   248,     0,     0,   126,     0,     0,     0,     0,
-       0,     0,     0,     0,   165,     0,     0,     0,   219,   220,
-     221,   222,   223,   224,   225,   211,   261,     0,     0,     0,
-      42,    42,     0,     0,     0,     0,     0,     0,     0,     0,
-     270,   269,   268,   266,   267,   263,   264,   265,   247,   244,
-     257,   256,   255,   253,   254,   250,   251,   252,   167,     0,
-     212,   214,    19,   226,   227,   218,    34,   216,    35,     0,
-       0,     0,   124,   125,     0,   128,   143,   153,   196,     0,
-       0,     0,     0,     0,     0,     0,   154,   182,     0,   213,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-     191,   192,   193,   194,   195,     0,   156,   170,   166,     0,
-      18,    23,    20,     0,    24,    43,     0,     0,   184,   127,
-       0,     0,   129,   142,     0,     0,   144,   187,     0,     0,
-       0,     0,   181,   234,   232,   155,   157,   158,   159,   160,
-       0,   168,   228,     0,    21,     0,     0,     0,   131,     0,
-     133,   148,   145,     0,     0,     0,     0,     0,   164,   233,
-     235,   169,   229,   258,     0,    36,    38,   183,     0,   186,
-     133,     0,   146,   143,     0,     0,     0,   189,   190,   161,
-     162,   163,    28,    29,    30,    31,    32,    33,    22,    25,
-      44,    44,    40,   185,   130,   128,   136,   137,   138,   139,
-     140,   141,     0,   135,   242,     0,   143,     0,   199,   201,
-       0,    27,     0,     0,    44,     0,   134,   147,   243,   149,
-       0,   143,   242,     0,     0,    26,    58,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,    58,     0,   132,   150,
-       0,     0,     0,     0,   198,     0,     0,    48,    45,    46,
-      49,   205,     0,   240,     0,    47,   236,     0,     0,    55,
-      57,    54,     0,    58,   151,   143,   197,     0,   202,    37,
-     112,   112,   112,   112,   112,    70,   112,   112,    78,   112,
-      90,   112,   112,   112,   112,   112,   102,   112,     0,   112,
-     112,   112,     0,    59,   237,     0,     0,     0,    56,    39,
-       0,     0,     0,     0,     0,   115,   114,    60,    62,    64,
-      68,     0,    74,    76,     0,    80,     0,    92,    94,    96,
-      98,   100,     0,   104,   208,     0,     0,    66,    82,    88,
-       0,   241,     0,   238,    50,    41,   152,   200,     0,   113,
-       0,     0,     0,     0,    71,     0,     0,     0,    79,     0,
-      91,     0,     0,     0,     0,     0,   103,     0,   209,     0,
-     207,     0,     0,     0,     0,   239,    51,     0,     0,    61,
-      63,    65,    69,     0,    75,    77,    81,    93,    95,    97,
-      99,   101,   105,     0,    67,    83,    89,     0,    52,   111,
-     118,     0,     0,     0,   116,    53,     0,     0,     0,     0,
-     154,    84,     0,   119,     0,   116,     0,     0,   116,     0,
-     122,   108,   242,     0,   117,   120,    85,   242,   242,     0,
-     116,   243,     0,     0,   116,   243,   116,   243,   123,   109,
-     116,     0,   121,    86,   116,    72,   116,   110,     0,    87,
-      73,   106,     0,   242,   107
-};
-
-/* YYDEFGOTO[NTERM-NUM]. */
-static const short yydefgoto[] =
-{
-      -1,     1,    12,   160,   182,   183,   258,   259,    13,    14,
-      15,   260,   261,   284,   140,   282,   316,   363,   410,   411,
-     412,   431,   413,   381,   416,   417,   384,   419,   432,   433,
-     386,   421,   422,   423,   424,   425,   392,   427,   512,   414,
-     438,   373,   374,   471,   461,   466,   487,   493,   482,   489,
-      16,    17,    18,    19,   165,   192,   241,   273,    20,   166,
-     196,    21,   175,   176,   205,   206,    22,   128,   158,    61,
-      23,    24,   217,    25,   108,   167,   293,   294,    26,    27,
-     395,    37,    99,    98,    95,   136,   375,   212,   207,   208,
-     325,   326,   287,   288,   415,    36,   214,   376,    30
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -309
-static const short yypact[] =
-{
-    -309,    68,  -309,   338,  -309,  -309,  -309,  -309,  -309,  -309,
-     338,   338,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,
-    -309,  -309,  -309,  -309,  -309,  -309,   458,  -309,  -309,  -309,
-     605,  -309,   338,   338,   338,   -92,   642,   230,  -309,   534,
-    -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,
-    -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,
-    -309,  -309,  -309,   338,   338,   338,   338,   338,   338,   338,
-     338,  -309,  -309,   695,   338,  -309,   338,   338,   338,   338,
-     338,   338,   338,   338,  -309,   338,   338,   338,  -309,  -309,
-    -309,  -309,  -309,  -309,  -309,  -309,  -309,   329,   724,   724,
-     242,   242,   724,   724,   499,   434,   457,   724,   192,   250,
-     392,   718,   318,   174,   174,  -309,  -309,  -309,  -309,  -309,
-     392,   718,   318,   174,   174,  -309,  -309,  -309,  -309,   -92,
-    -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,   -81,
-     263,   263,  -309,  -309,   -92,  -309,  -309,  -309,  -309,   338,
-     338,   338,   338,   338,   338,   338,  -309,  -309,     6,  -309,
-      13,   338,   -92,   -92,    48,     8,   105,    35,   -92,   -92,
-    -309,  -309,  -309,  -309,  -309,    53,   373,  -309,  -309,   -38,
-    -309,  -309,  -309,   -48,  -309,  -309,   -92,   -92,  -309,  -309,
-     -36,     7,  -309,  -309,    80,     7,  -309,  -309,    60,   103,
-     -92,   -92,  -309,  -309,  -309,  -309,    17,    38,    47,   642,
-       7,     7,  -309,   263,    65,   -92,   -92,    -1,  -309,   163,
-       7,  -309,   163,    12,    74,    94,   -92,   -92,   373,  -309,
-    -309,     7,  -309,  -309,   818,  -309,   -92,  -309,   253,  -309,
-    -309,   184,   -92,  -309,     5,   177,     7,  -309,  -309,    38,
-      47,   642,  -309,  -309,  -309,  -309,  -309,  -309,    25,  -309,
-    -309,  -309,  -309,  -309,   155,  -309,  -309,  -309,  -309,  -309,
-    -309,  -309,   768,  -309,   -92,   120,  -309,    10,  -309,     7,
-     818,  -309,   556,   562,  -309,   137,  -309,  -309,  -309,  -309,
-     141,  -309,   -92,    21,     2,  -309,  -309,   338,     7,   253,
-     -46,   338,   338,   338,   338,   253,  -309,   573,  -309,  -309,
-     153,   188,   172,     7,  -309,   -92,   655,  -309,     7,  -309,
-       7,    40,    27,  -309,   338,    99,  -309,    93,   -92,  -309,
-    -309,  -309,   692,  -309,  -309,  -309,  -309,   168,  -309,  -309,
-     258,   258,   258,   258,   258,  -309,   258,   258,  -309,   258,
-    -309,   258,   258,   258,   258,   258,  -309,   258,   253,   258,
-     258,   258,   253,  -309,  -309,    95,    98,     7,  -309,  -309,
-     729,   173,     7,   338,   102,     7,  -309,  -309,  -309,  -309,
-    -309,   338,  -309,  -309,   338,  -309,   338,  -309,  -309,  -309,
-    -309,  -309,   338,  -309,   117,   338,   123,  -309,  -309,  -309,
-     338,  -309,    27,  -309,   163,  -309,  -309,     7,   128,  -309,
-     338,   338,   338,   338,  -309,   -92,   338,   338,  -309,   338,
-    -309,   338,   338,   338,   338,   338,  -309,   338,  -309,   131,
-    -309,   338,   338,   338,   -92,  -309,   -92,   258,   132,  -309,
-    -309,  -309,  -309,   -92,  -309,  -309,  -309,  -309,  -309,  -309,
-    -309,  -309,  -309,   338,  -309,  -309,  -309,   -92,   -92,  -309,
-    -309,   -92,   -92,   149,    18,  -309,   -46,   -92,   -92,   338,
-    -309,  -309,   -92,    99,   -92,    19,   154,   203,    20,   -92,
-    -309,  -309,   -92,   338,  -309,  -309,  -309,   -92,   -92,   -46,
-     225,   -92,   165,   -46,   225,   -92,   225,   -92,    99,  -309,
-     225,   338,    99,  -309,   225,  -309,   225,  -309,   182,  -309,
-    -309,  -309,   -46,   -71,  -309
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const short yypgoto[] =
-{
-    -309,  -309,  -309,  -309,  -309,  -309,  -309,  -240,  -309,  -309,
-    -309,  -309,  -309,  -309,   144,  -235,  -295,  -309,  -309,  -309,
-    -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,
-    -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,   239,
-    -309,   431,  -156,  -100,  -309,  -309,  -309,  -309,  -309,  -309,
-    -309,  -309,  -309,  -309,    26,  -309,    56,    39,  -309,  -196,
-    -309,  -309,  -173,  -309,  -309,  -309,  -309,  -309,  -309,  -309,
-    -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,   -25,  -265,
-     -55,   232,     0,   333,   432,   375,  -129,     4,    82,    84,
-    -237,  -308,  -283,   -33,    -3,     9,  -309,     3,  -309
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -229
-static const short yytable[] =
-{
-      35,    62,    75,   237,    29,    28,   314,   177,   276,   311,
-     178,   332,   189,   291,   364,   243,    74,   180,   281,    38,
-      39,   470,   470,   470,   218,   312,   283,   366,   161,    29,
-      28,   252,   253,   254,   255,   256,   257,    74,   370,   197,
-     295,    71,    72,    73,   322,   102,   103,   275,   323,   307,
-     211,   188,   238,     5,     6,     5,     6,   202,   403,   239,
-     213,   219,   220,   224,   324,   222,   223,   190,     2,   191,
-     210,   119,   110,   111,   112,   113,   114,   115,   116,   117,
-     290,   231,   129,   130,   131,   120,   121,   122,   123,   124,
-     125,   126,   127,   394,   435,   310,   159,   394,     5,     6,
-      31,   144,   313,     5,     6,   181,   225,     8,    32,   193,
-      74,   164,    33,    74,   198,   199,    34,   279,    74,    10,
-      74,   323,     3,    11,   289,   228,    74,   480,   485,   186,
-     187,  -228,  -228,   280,   229,   200,   201,   324,     4,   371,
-     221,   308,   230,   162,   163,   309,   168,   169,   170,   171,
-     172,   173,   174,   215,   216,   179,   245,   334,   185,     5,
-       6,     7,     8,   184,   194,     9,   195,   226,   227,   318,
-     320,     5,     6,   234,    10,   246,   336,   406,    11,   194,
-     278,   195,   235,   236,   337,   209,   240,   265,   402,   242,
-     244,   335,   323,   247,   248,   148,   190,   366,   191,   490,
-     194,   367,   195,   262,   494,   496,   401,   484,   324,   274,
-     409,   277,   194,   263,   195,   232,   233,   266,   267,   268,
-     269,   270,   271,   232,   232,   428,   232,   232,   470,   473,
-     514,   430,   194,    84,   195,   232,   437,   251,   404,   453,
-     460,    29,    28,   407,   292,   141,   266,   267,   268,   269,
-     270,   271,   498,   156,     5,     6,   502,   469,   139,     5,
-       6,   315,   483,   272,   149,   150,   151,   152,   153,   154,
-     155,    74,    97,   501,   319,   513,   372,    81,    82,    83,
-     331,   459,   338,   232,    85,    86,    87,   104,   105,   106,
-     511,   285,   272,   109,   317,   368,   264,   477,   327,   328,
-     329,   330,    29,   321,    85,    86,    87,   400,    29,    28,
-     249,   286,   250,    88,    89,    90,    91,    92,    93,    94,
-       0,   365,   232,     0,   232,    88,    89,    90,    91,    92,
-      93,    94,   132,    88,    89,    90,    91,    92,    93,    94,
-       0,   232,   133,   134,     5,     6,     7,     8,     0,     5,
-       6,     0,     8,     0,     0,     0,     0,     8,     0,    10,
-       0,   396,    28,    11,    10,   396,    28,     0,    11,    10,
-     408,   436,     0,    11,     0,   481,   100,   101,   486,   232,
-       0,     0,   443,    85,    86,    87,     0,     0,     0,     0,
-     499,   107,   429,     0,   503,     0,   505,   434,     0,     0,
-     507,   457,     0,   458,   509,     0,   510,     0,   232,     0,
-     462,   232,    88,    89,    90,    91,    92,    93,    94,    79,
-      80,    81,    82,    83,   464,   465,     0,     0,   467,   468,
-       0,   472,    31,     0,   474,   475,     0,   145,     0,   478,
-      32,   479,     0,     0,    33,     0,   488,     0,    34,   491,
-     463,     0,     0,     0,   495,   497,     0,     0,   500,     0,
-     146,     0,   504,    40,   506,     0,   476,    31,   203,   204,
-      41,    42,    43,    44,   138,    32,     0,   142,   143,    33,
-     492,     0,   147,    34,   157,     0,     0,     0,    85,    86,
-      87,    77,    78,    79,    80,    81,    82,    83,   508,    45,
-      46,    47,    48,    49,    50,     0,    51,    52,    53,    54,
-      55,    85,    86,    87,     0,    56,    57,    88,    89,    90,
-      91,    92,    93,    94,     0,     0,    58,    59,     0,    60,
-     135,   137,   135,   135,   137,   137,     0,     0,     0,   135,
-      88,    89,    90,    91,    92,    93,    94,     0,     0,     5,
-       6,     7,     8,    85,    86,    87,     0,     0,     0,   296,
-       0,     0,     0,     0,    10,   306,     0,     0,    11,     0,
-       0,     0,   297,   298,   299,   300,   333,     0,   297,   298,
-     299,   300,    88,    89,    90,    91,    92,    93,    94,   297,
-     298,   299,   300,    31,     0,     0,     0,   301,     0,     0,
-       0,    32,     0,   301,     0,    33,     0,     0,     0,    34,
-     302,   303,   304,   305,   301,     0,   302,   303,   304,   305,
-       0,     0,     0,   418,     0,   420,     0,   302,   303,   304,
-     305,   426,    76,    77,    78,    79,    80,    81,    82,    83,
-       0,     0,     0,     0,     0,    96,     0,     0,     0,   439,
-     440,   441,   442,     0,     0,   444,   445,     0,   446,   339,
-     447,   448,   449,   450,   451,   340,   452,     0,     0,     0,
-     454,   455,   456,     0,     0,   341,   342,   343,   344,   345,
-     346,   347,   348,   349,   350,   351,   352,   353,   354,   355,
-     356,   357,   358,   359,   360,   361,   369,   362,     0,     0,
-       0,     0,   340,    63,    64,    65,    66,    67,    68,    69,
-      70,     0,   341,   342,   343,   344,   345,   346,   347,   348,
-     349,   350,   351,   352,   353,   354,   355,   356,   357,   358,
-     359,   360,   361,   405,   362,     0,     0,     0,     0,   340,
-      76,    77,    78,    79,    80,    81,    82,    83,     0,   341,
-     342,   343,   344,   345,   346,   347,   348,   349,   350,   351,
-     352,   353,   354,   355,   356,   357,   358,   359,   360,   361,
-       0,   362,   377,   378,   379,   380,     0,   382,   383,     0,
-     385,     0,   387,   388,   389,   390,   391,     0,   393,     0,
-     397,   398,   399,    76,    77,    78,    79,    80,    81,    82,
-      83,     0,     0,     0,     0,     0,   118,    88,    89,    90,
-      91,    92,    93,    94,     0,     0,   133,   134,    78,    79,
-      80,    81,    82,    83,   252,   253,   254,   255,   256,   257,
-     266,   267,   268,   269,   270,   271
-};
-
-static const short yycheck[] =
-{
-       3,    26,    35,     4,     1,     1,     4,     1,     3,   292,
-       4,   306,     4,     3,   322,     3,   108,     4,   258,    10,
-      11,     3,     3,     3,    60,     4,   261,    98,   109,    26,
-      26,     6,     7,     8,     9,    10,    11,   108,   333,     4,
-     280,    32,    33,    34,    90,    45,    46,   243,    94,   284,
-     179,     3,    53,    91,    92,    91,    92,     4,   366,    60,
-     108,   190,   191,     3,   110,   194,   195,    59,     0,    61,
-     108,    74,    63,    64,    65,    66,    67,    68,    69,    70,
-     276,   210,    85,    86,    87,    76,    77,    78,    79,    80,
-      81,    82,    83,   358,   402,   291,   129,   362,    91,    92,
-      94,   104,    81,    91,    92,    92,     3,    94,   102,     4,
-     108,   144,   106,   108,    79,    80,   110,   246,   108,   106,
-     108,    94,    54,   110,     4,   108,   108,   108,   108,   162,
-     163,    91,    92,   108,    96,   168,   169,   110,    70,   335,
-      60,     4,    95,   140,   141,     4,   149,   150,   151,   152,
-     153,   154,   155,   186,   187,   158,    82,     4,   161,    91,
-      92,    93,    94,   160,    59,    97,    61,   200,   201,   298,
-     299,    91,    92,   108,   106,    81,     4,     4,   110,    59,
-       3,    61,   215,   216,   313,   176,   219,     3,    90,   222,
-     223,     3,    94,   226,   227,     3,    59,    98,    61,   482,
-      59,   108,    61,   236,   487,   488,   111,     4,   110,   242,
-     108,   244,    59,   238,    61,   211,   213,    62,    63,    64,
-      65,    66,    67,   219,   220,   108,   222,   223,     3,   466,
-     513,   108,    59,     3,    61,   231,   108,   228,   367,   108,
-     108,   238,   238,   372,   277,   101,    62,    63,    64,    65,
-      66,    67,   489,     3,    91,    92,   493,   108,    16,    91,
-      92,   294,   108,   108,    72,    73,    74,    75,    76,    77,
-      78,   108,    40,   108,   299,   512,   108,   103,   104,   105,
-     305,   437,   315,   279,    54,    55,    56,    55,    56,    57,
-     108,   265,   108,    61,   297,   328,   240,   470,   301,   302,
-     303,   304,   299,   299,    54,    55,    56,   362,   305,   305,
-     228,   272,   228,    83,    84,    85,    86,    87,    88,    89,
-      -1,   324,   318,    -1,   320,    83,    84,    85,    86,    87,
-      88,    89,     3,    83,    84,    85,    86,    87,    88,    89,
-      -1,   337,    92,    93,    91,    92,    93,    94,    -1,    91,
-      92,    -1,    94,    -1,    -1,    -1,    -1,    94,    -1,   106,
-      -1,   358,   358,   110,   106,   362,   362,    -1,   110,   106,
-     373,   404,    -1,   110,    -1,   475,    43,    44,   478,   375,
-      -1,    -1,   415,    54,    55,    56,    -1,    -1,    -1,    -1,
-     490,    58,   395,    -1,   494,    -1,   496,   400,    -1,    -1,
-     500,   434,    -1,   436,   504,    -1,   506,    -1,   404,    -1,
-     443,   407,    83,    84,    85,    86,    87,    88,    89,   101,
-     102,   103,   104,   105,   457,   458,    -1,    -1,   461,   462,
-      -1,   464,    94,    -1,   467,   468,    -1,     3,    -1,   472,
-     102,   474,    -1,    -1,   106,    -1,   479,    -1,   110,   482,
-     453,    -1,    -1,    -1,   487,   488,    -1,    -1,   491,    -1,
-       3,    -1,   495,     5,   497,    -1,   469,    94,    95,    96,
-      12,    13,    14,    15,    99,   102,    -1,   102,   103,   106,
-     483,    -1,   107,   110,   109,    -1,    -1,    -1,    54,    55,
-      56,    99,   100,   101,   102,   103,   104,   105,   501,    41,
-      42,    43,    44,    45,    46,    -1,    48,    49,    50,    51,
-      52,    54,    55,    56,    -1,    57,    58,    83,    84,    85,
-      86,    87,    88,    89,    -1,    -1,    68,    69,    -1,    71,
-      98,    99,   100,   101,   102,   103,    -1,    -1,    -1,   107,
-      83,    84,    85,    86,    87,    88,    89,    -1,    -1,    91,
-      92,    93,    94,    54,    55,    56,    -1,    -1,    -1,     3,
-      -1,    -1,    -1,    -1,   106,     3,    -1,    -1,   110,    -1,
-      -1,    -1,    16,    17,    18,    19,     3,    -1,    16,    17,
-      18,    19,    83,    84,    85,    86,    87,    88,    89,    16,
-      17,    18,    19,    94,    -1,    -1,    -1,    41,    -1,    -1,
-      -1,   102,    -1,    41,    -1,   106,    -1,    -1,    -1,   110,
-      54,    55,    56,    57,    41,    -1,    54,    55,    56,    57,
-      -1,    -1,    -1,   384,    -1,   386,    -1,    54,    55,    56,
-      57,   392,    98,    99,   100,   101,   102,   103,   104,   105,
-      -1,    -1,    -1,    -1,    -1,   111,    -1,    -1,    -1,   410,
-     411,   412,   413,    -1,    -1,   416,   417,    -1,   419,     4,
-     421,   422,   423,   424,   425,    10,   427,    -1,    -1,    -1,
-     431,   432,   433,    -1,    -1,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      35,    36,    37,    38,    39,    40,     4,    42,    -1,    -1,
-      -1,    -1,    10,    98,    99,   100,   101,   102,   103,   104,
-     105,    -1,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    33,    34,    35,    36,    37,
-      38,    39,    40,     4,    42,    -1,    -1,    -1,    -1,    10,
-      98,    99,   100,   101,   102,   103,   104,   105,    -1,    20,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    35,    36,    37,    38,    39,    40,
-      -1,    42,   341,   342,   343,   344,    -1,   346,   347,    -1,
-     349,    -1,   351,   352,   353,   354,   355,    -1,   357,    -1,
-     359,   360,   361,    98,    99,   100,   101,   102,   103,   104,
-     105,    -1,    -1,    -1,    -1,    -1,   111,    83,    84,    85,
-      86,    87,    88,    89,    -1,    -1,    92,    93,   100,   101,
-     102,   103,   104,   105,     6,     7,     8,     9,    10,    11,
-      62,    63,    64,    65,    66,    67
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
-{
-       0,   113,     0,    54,    70,    91,    92,    93,    94,    97,
-     106,   110,   114,   120,   121,   122,   162,   163,   164,   165,
-     170,   173,   178,   182,   183,   185,   190,   191,   199,   209,
-     210,    94,   102,   106,   110,   206,   207,   193,   207,   207,
-       5,    12,    13,    14,    15,    41,    42,    43,    44,    45,
-      46,    48,    49,    50,    51,    52,    57,    58,    68,    69,
-      71,   181,   190,    98,    99,   100,   101,   102,   103,   104,
-     105,   207,   207,   207,   108,   205,    98,    99,   100,   101,
-     102,   103,   104,   105,     3,    54,    55,    56,    83,    84,
-      85,    86,    87,    88,    89,   196,   111,   193,   195,   194,
-     195,   195,   194,   194,   193,   193,   193,   195,   186,   193,
-     207,   207,   207,   207,   207,   207,   207,   207,   111,   206,
-     207,   207,   207,   207,   207,   207,   207,   207,   179,   206,
-     206,   206,     3,    92,    93,   196,   197,   196,   197,    16,
-     126,   126,   197,   197,   206,     3,     3,   197,     3,    72,
-      73,    74,    75,    76,    77,    78,     3,   197,   180,   205,
-     115,   109,   209,   209,   205,   166,   171,   187,   206,   206,
-     206,   206,   206,   206,   206,   174,   175,     1,     4,   206,
-       4,    92,   116,   117,   209,   206,   205,   205,     3,     4,
-      59,    61,   167,     4,    59,    61,   172,     4,    79,    80,
-     205,   205,     4,    95,    96,   176,   177,   200,   201,   207,
-     108,   198,   199,   108,   208,   205,   205,   184,    60,   198,
-     198,    60,   198,   198,     3,     3,   205,   205,   108,    96,
-      95,   198,   199,   209,   108,   205,   205,     4,    53,    60,
-     205,   168,   205,     3,   205,    82,    81,   205,   205,   200,
-     201,   207,     6,     7,     8,     9,    10,    11,   118,   119,
-     123,   124,   205,   190,   168,     3,    62,    63,    64,    65,
-      66,    67,   108,   169,   205,   171,     3,   205,     3,   198,
-     108,   119,   127,   127,   125,   166,   169,   204,   205,     4,
-     171,     3,   205,   188,   189,   119,     3,    16,    17,    18,
-      19,    41,    54,    55,    56,    57,     3,   127,     4,     4,
-     171,   204,     4,    81,     4,   205,   128,   206,   198,   190,
-     198,   199,    90,    94,   110,   202,   203,   206,   206,   206,
-     206,   190,   128,     3,     4,     3,     4,   198,   205,     4,
-      10,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
-      39,    40,    42,   129,   203,   206,    98,   108,   205,     4,
-     128,   171,   108,   153,   154,   198,   209,   153,   153,   153,
-     153,   135,   153,   153,   138,   153,   142,   153,   153,   153,
-     153,   153,   148,   153,   191,   192,   209,   153,   153,   153,
-     192,   111,    90,   203,   198,     4,     4,   198,   206,   108,
-     130,   131,   132,   134,   151,   206,   136,   137,   151,   139,
-     151,   143,   144,   145,   146,   147,   151,   149,   108,   206,
-     108,   133,   140,   141,   206,   203,   205,   108,   152,   151,
-     151,   151,   151,   205,   151,   151,   151,   151,   151,   151,
-     151,   151,   151,   108,   151,   151,   151,   205,   205,   154,
-     108,   156,   205,   206,   205,   205,   157,   205,   205,   108,
-       3,   155,   205,   202,   205,   205,   206,   174,   205,   205,
-     108,   155,   160,   108,     4,   108,   155,   158,   205,   161,
-     204,   205,   206,   159,   204,   205,   204,   205,   202,   155,
-     205,   108,   202,   155,   205,   155,   205,   155,   206,   155,
-     155,   108,   150,   202,   204
-};
-
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-
-#define YYFAIL		goto yyerrlab
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
-      YYERROR;							\
-    }								\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
-
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
-#endif
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
-#endif
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (0)
-
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
-
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_stack_print (short *bottom, short *top)
-#else
-static void
-yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
-#endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (0)
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_reduce_print (int yyrule)
-#else
-static void
-yy_reduce_print (yyrule)
-    int yyrule;
-#endif
-{
-  int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
-yystrlen (const char *yystr)
-#   else
-yystrlen (yystr)
-     const char *yystr;
-#   endif
-{
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
-    continue;
-
-  return yys - yystr - 1;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-#   if defined (__STDC__) || defined (__cplusplus)
-yystpcpy (char *yydest, const char *yysrc)
-#   else
-yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
-{
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-#endif /* !YYERROR_VERBOSE */
-
-
-
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  if (yytype < YYNTOKENS)
-    {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-  switch (yytype)
-    {
-      default:
-        break;
-    }
-  YYFPRINTF (yyoutput, ")");
-}
-
-#endif /* ! YYDEBUG */
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yydestruct (yytype, yyvaluep)
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  switch (yytype)
-    {
-
-      default:
-        break;
-    }
-}
-
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM);
-# else
-int yyparse ();
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-
-/* The lookahead symbol.  */
-int yychar;
-
-/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int
-yyparse (void)
-#else
-int
-yyparse ()
-
-#endif
-#endif
-{
-  
-  register int yystate;
-  register int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss;
-  yyvsp = yyvs;
-
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-	/* Give user a chance to reallocate the stack. Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
-
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-
-		    &yystacksize);
-
-	yyss = yyss1;
-	yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
-      {
-	short *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyoverflowlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
-    {
-        case 18:
-#line 200 "rcparse.y"
-    {
-	    define_accelerator (yyvsp[-5].id, &yyvsp[-3].res_info, yyvsp[-1].pacc);
-	    if (yychar != YYEMPTY)
-	      YYERROR;
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 19:
-#line 210 "rcparse.y"
-    {
-	    yyval.pacc = NULL;
-	  }
-    break;
-
-  case 20:
-#line 214 "rcparse.y"
-    {
-	    rc_accelerator *a;
-
-	    a = (rc_accelerator *) res_alloc (sizeof *a);
-	    *a = yyvsp[0].acc;
-	    if (yyvsp[-1].pacc == NULL)
-	      yyval.pacc = a;
-	    else
-	      {
-		rc_accelerator **pp;
-
-		for (pp = &yyvsp[-1].pacc->next; *pp != NULL; pp = &(*pp)->next)
-		  ;
-		*pp = a;
-		yyval.pacc = yyvsp[-1].pacc;
-	      }
-	  }
-    break;
-
-  case 21:
-#line 235 "rcparse.y"
-    {
-	    yyval.acc = yyvsp[-1].acc;
-	    yyval.acc.id = yyvsp[0].il;
-	  }
-    break;
-
-  case 22:
-#line 240 "rcparse.y"
-    {
-	    yyval.acc = yyvsp[-3].acc;
-	    yyval.acc.id = yyvsp[-2].il;
-	    yyval.acc.flags |= yyvsp[0].is;
-	    if ((yyval.acc.flags & ACC_VIRTKEY) == 0
-		&& (yyval.acc.flags & (ACC_SHIFT | ACC_CONTROL)) != 0)
-	      rcparse_warning (_("inappropriate modifiers for non-VIRTKEY"));
-	  }
-    break;
-
-  case 23:
-#line 252 "rcparse.y"
-    {
-	    const char *s = yyvsp[0].s;
-	    char ch;
-
-	    yyval.acc.next = NULL;
-	    yyval.acc.id = 0;
-	    ch = *s;
-	    if (ch != '^')
-	      yyval.acc.flags = 0;
-	    else
-	      {
-		yyval.acc.flags = ACC_CONTROL | ACC_VIRTKEY;
-		++s;
-		ch = TOUPPER (s[0]);
-	      }
-	    yyval.acc.key = ch;
-	    if (s[1] != '\0')
-	      rcparse_warning (_("accelerator should only be one character"));
-	  }
-    break;
-
-  case 24:
-#line 272 "rcparse.y"
-    {
-	    yyval.acc.next = NULL;
-	    yyval.acc.flags = 0;
-	    yyval.acc.id = 0;
-	    yyval.acc.key = yyvsp[0].il;
-	  }
-    break;
-
-  case 25:
-#line 282 "rcparse.y"
-    {
-	    yyval.is = yyvsp[0].is;
-	  }
-    break;
-
-  case 26:
-#line 286 "rcparse.y"
-    {
-	    yyval.is = yyvsp[-2].is | yyvsp[0].is;
-	  }
-    break;
-
-  case 27:
-#line 291 "rcparse.y"
-    {
-	    yyval.is = yyvsp[-1].is | yyvsp[0].is;
-	  }
-    break;
-
-  case 28:
-#line 298 "rcparse.y"
-    {
-	    yyval.is = ACC_VIRTKEY;
-	  }
-    break;
-
-  case 29:
-#line 302 "rcparse.y"
-    {
-	    /* This is just the absence of VIRTKEY.  */
-	    yyval.is = 0;
-	  }
-    break;
-
-  case 30:
-#line 307 "rcparse.y"
-    {
-	    yyval.is = ACC_NOINVERT;
-	  }
-    break;
-
-  case 31:
-#line 311 "rcparse.y"
-    {
-	    yyval.is = ACC_SHIFT;
-	  }
-    break;
-
-  case 32:
-#line 315 "rcparse.y"
-    {
-	    yyval.is = ACC_CONTROL;
-	  }
-    break;
-
-  case 33:
-#line 319 "rcparse.y"
-    {
-	    yyval.is = ACC_ALT;
-	  }
-    break;
-
-  case 34:
-#line 328 "rcparse.y"
-    {
-	    define_bitmap (yyvsp[-3].id, &yyvsp[-1].res_info, yyvsp[0].s);
-	    if (yychar != YYEMPTY)
-	      YYERROR;
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 35:
-#line 340 "rcparse.y"
-    {
-	    define_cursor (yyvsp[-3].id, &yyvsp[-1].res_info, yyvsp[0].s);
-	    if (yychar != YYEMPTY)
-	      YYERROR;
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 36:
-#line 353 "rcparse.y"
-    {
-	      memset (&dialog, 0, sizeof dialog);
-	      dialog.x = yyvsp[-3].il;
-	      dialog.y = yyvsp[-2].il;
-	      dialog.width = yyvsp[-1].il;
-	      dialog.height = yyvsp[0].il;
-	      dialog.style = WS_POPUP | WS_BORDER | WS_SYSMENU;
-	      dialog.exstyle = yyvsp[-4].il;
-	      dialog.menu.named = 1;
-	      dialog.class.named = 1;
-	      dialog.font = NULL;
-	      dialog.ex = NULL;
-	      dialog.controls = NULL;
-	      sub_res_info = yyvsp[-5].res_info;
-	      style = 0;
-	    }
-    break;
-
-  case 37:
-#line 370 "rcparse.y"
-    {
-	    define_dialog (yyvsp[-12].id, &sub_res_info, &dialog);
-	    if (yychar != YYEMPTY)
-	      YYERROR;
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 38:
-#line 378 "rcparse.y"
-    {
-	      memset (&dialog, 0, sizeof dialog);
-	      dialog.x = yyvsp[-3].il;
-	      dialog.y = yyvsp[-2].il;
-	      dialog.width = yyvsp[-1].il;
-	      dialog.height = yyvsp[0].il;
-	      dialog.style = WS_POPUP | WS_BORDER | WS_SYSMENU;
-	      dialog.exstyle = yyvsp[-4].il;
-	      dialog.menu.named = 1;
-	      dialog.class.named = 1;
-	      dialog.font = NULL;
-	      dialog.ex = ((rc_dialog_ex *)
-			   res_alloc (sizeof (rc_dialog_ex)));
-	      memset (dialog.ex, 0, sizeof (rc_dialog_ex));
-	      dialog.controls = NULL;
-	      sub_res_info = yyvsp[-5].res_info;
-	      style = 0;
-	    }
-    break;
-
-  case 39:
-#line 397 "rcparse.y"
-    {
-	    define_dialog (yyvsp[-12].id, &sub_res_info, &dialog);
-	    if (yychar != YYEMPTY)
-	      YYERROR;
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 40:
-#line 405 "rcparse.y"
-    {
-	      memset (&dialog, 0, sizeof dialog);
-	      dialog.x = yyvsp[-4].il;
-	      dialog.y = yyvsp[-3].il;
-	      dialog.width = yyvsp[-2].il;
-	      dialog.height = yyvsp[-1].il;
-	      dialog.style = WS_POPUP | WS_BORDER | WS_SYSMENU;
-	      dialog.exstyle = yyvsp[-5].il;
-	      dialog.menu.named = 1;
-	      dialog.class.named = 1;
-	      dialog.font = NULL;
-	      dialog.ex = ((rc_dialog_ex *)
-			   res_alloc (sizeof (rc_dialog_ex)));
-	      memset (dialog.ex, 0, sizeof (rc_dialog_ex));
-	      dialog.ex->help = yyvsp[0].il;
-	      dialog.controls = NULL;
-	      sub_res_info = yyvsp[-6].res_info;
-	      style = 0;
-	    }
-    break;
-
-  case 41:
-#line 425 "rcparse.y"
-    {
-	    define_dialog (yyvsp[-13].id, &sub_res_info, &dialog);
-	    if (yychar != YYEMPTY)
-	      YYERROR;
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 42:
-#line 435 "rcparse.y"
-    {
-	    yyval.il = 0;
-	  }
-    break;
-
-  case 43:
-#line 439 "rcparse.y"
-    {
-	    yyval.il = yyvsp[0].il;
-	  }
-    break;
-
-  case 45:
-#line 447 "rcparse.y"
-    {
-	    dialog.style |= WS_CAPTION;
-	    style |= WS_CAPTION;
-	    dialog.caption = yyvsp[0].uni;
-	  }
-    break;
-
-  case 46:
-#line 453 "rcparse.y"
-    {
-	    dialog.class = yyvsp[0].id;
-	  }
-    break;
-
-  case 47:
-#line 458 "rcparse.y"
-    {
-	    dialog.style = style;
-	  }
-    break;
-
-  case 48:
-#line 462 "rcparse.y"
-    {
-	    dialog.exstyle = yyvsp[0].il;
-	  }
-    break;
-
-  case 49:
-#line 466 "rcparse.y"
-    {
-	    res_unistring_to_id (& dialog.class, yyvsp[0].uni);
-	  }
-    break;
-
-  case 50:
-#line 470 "rcparse.y"
-    {
-	    dialog.style |= DS_SETFONT;
-	    style |= DS_SETFONT;
-	    dialog.pointsize = yyvsp[-2].il;
-	    dialog.font = yyvsp[0].uni;
-	    if (dialog.ex != NULL)
-	      {
-		dialog.ex->weight = 0;
-		dialog.ex->italic = 0;
-		dialog.ex->charset = 1;
-	      }
-	  }
-    break;
-
-  case 51:
-#line 483 "rcparse.y"
-    {
-	    dialog.style |= DS_SETFONT;
-	    style |= DS_SETFONT;
-	    dialog.pointsize = yyvsp[-3].il;
-	    dialog.font = yyvsp[-1].uni;
-	    if (dialog.ex == NULL)
-	      rcparse_warning (_("extended FONT requires DIALOGEX"));
-	    else
-	      {
-		dialog.ex->weight = yyvsp[0].il;
-		dialog.ex->italic = 0;
-		dialog.ex->charset = 1;
-	      }
-	  }
-    break;
-
-  case 52:
-#line 498 "rcparse.y"
-    {
-	    dialog.style |= DS_SETFONT;
-	    style |= DS_SETFONT;
-	    dialog.pointsize = yyvsp[-4].il;
-	    dialog.font = yyvsp[-2].uni;
-	    if (dialog.ex == NULL)
-	      rcparse_warning (_("extended FONT requires DIALOGEX"));
-	    else
-	      {
-		dialog.ex->weight = yyvsp[-1].il;
-		dialog.ex->italic = yyvsp[0].il;
-		dialog.ex->charset = 1;
-	      }
-	  }
-    break;
-
-  case 53:
-#line 513 "rcparse.y"
-    {
-	    dialog.style |= DS_SETFONT;
-	    style |= DS_SETFONT;
-	    dialog.pointsize = yyvsp[-5].il;
-	    dialog.font = yyvsp[-3].uni;
-	    if (dialog.ex == NULL)
-	      rcparse_warning (_("extended FONT requires DIALOGEX"));
-	    else
-	      {
-		dialog.ex->weight = yyvsp[-2].il;
-		dialog.ex->italic = yyvsp[-1].il;
-		dialog.ex->charset = yyvsp[0].il;
-	      }
-	  }
-    break;
-
-  case 54:
-#line 528 "rcparse.y"
-    {
-	    dialog.menu = yyvsp[0].id;
-	  }
-    break;
-
-  case 55:
-#line 532 "rcparse.y"
-    {
-	    sub_res_info.characteristics = yyvsp[0].il;
-	  }
-    break;
-
-  case 56:
-#line 536 "rcparse.y"
-    {
-	    sub_res_info.language = yyvsp[-1].il | (yyvsp[0].il << SUBLANG_SHIFT);
-	  }
-    break;
-
-  case 57:
-#line 540 "rcparse.y"
-    {
-	    sub_res_info.version = yyvsp[0].il;
-	  }
-    break;
-
-  case 59:
-#line 548 "rcparse.y"
-    {
-	    rc_dialog_control **pp;
-
-	    for (pp = &dialog.controls; *pp != NULL; pp = &(*pp)->next)
-	      ;
-	    *pp = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 60:
-#line 559 "rcparse.y"
-    {
-	      default_style = BS_AUTO3STATE | WS_TABSTOP;
-	      base_style = BS_AUTO3STATE;
-	      class.named = 0;
-	      class.u.id = CTL_BUTTON;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 61:
-#line 567 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 62:
-#line 571 "rcparse.y"
-    {
-	      default_style = BS_AUTOCHECKBOX | WS_TABSTOP;
-	      base_style = BS_AUTOCHECKBOX;
-	      class.named = 0;
-	      class.u.id = CTL_BUTTON;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 63:
-#line 579 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 64:
-#line 583 "rcparse.y"
-    {
-	      default_style = BS_AUTORADIOBUTTON | WS_TABSTOP;
-	      base_style = BS_AUTORADIOBUTTON;
-	      class.named = 0;
-	      class.u.id = CTL_BUTTON;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 65:
-#line 591 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 66:
-#line 595 "rcparse.y"
-    {
-	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
-	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
-	      class.named = 0;
-	      class.u.id = CTL_EDIT;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 67:
-#line 603 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	    if (dialog.ex == NULL)
-	      rcparse_warning (_("BEDIT requires DIALOGEX"));
-	    res_string_to_id (&yyval.dialog_control->class, "BEDIT");
-	  }
-    break;
-
-  case 68:
-#line 610 "rcparse.y"
-    {
-	      default_style = BS_CHECKBOX | WS_TABSTOP;
-	      base_style = BS_CHECKBOX | WS_TABSTOP;
-	      class.named = 0;
-	      class.u.id = CTL_BUTTON;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 69:
-#line 618 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 70:
-#line 622 "rcparse.y"
-    {
-	      /* This is as per MSDN documentation.  With some (???)
-		 versions of MS rc.exe their is no default style.  */
-	      default_style = CBS_SIMPLE | WS_TABSTOP;
-	      base_style = 0;
-	      class.named = 0;
-	      class.u.id = CTL_COMBOBOX;
-	      res_text_field = res_null_text;	
-	    }
-    break;
-
-  case 71:
-#line 632 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 72:
-#line 637 "rcparse.y"
-    {
-	    yyval.dialog_control = define_control (yyvsp[-9].id, yyvsp[-8].il, yyvsp[-5].il, yyvsp[-4].il, yyvsp[-3].il, yyvsp[-2].il, yyvsp[-7].id, style, yyvsp[-1].il);
-	    if (yyvsp[0].rcdata_item != NULL)
-	      {
-		if (dialog.ex == NULL)
-		  rcparse_warning (_("control data requires DIALOGEX"));
-		yyval.dialog_control->data = yyvsp[0].rcdata_item;
-	      }
-	  }
-    break;
-
-  case 73:
-#line 648 "rcparse.y"
-    {
-	    yyval.dialog_control = define_control (yyvsp[-10].id, yyvsp[-9].il, yyvsp[-6].il, yyvsp[-5].il, yyvsp[-4].il, yyvsp[-3].il, yyvsp[-8].id, style, yyvsp[-2].il);
-	    if (dialog.ex == NULL)
-	      rcparse_warning (_("help ID requires DIALOGEX"));
-	    yyval.dialog_control->help = yyvsp[-1].il;
-	    yyval.dialog_control->data = yyvsp[0].rcdata_item;
-	  }
-    break;
-
-  case 74:
-#line 656 "rcparse.y"
-    {
-	      default_style = SS_CENTER | WS_GROUP;
-	      base_style = SS_CENTER;
-	      class.named = 0;
-	      class.u.id = CTL_STATIC;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 75:
-#line 664 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 76:
-#line 668 "rcparse.y"
-    {
-	      default_style = BS_DEFPUSHBUTTON | WS_TABSTOP;
-	      base_style = BS_DEFPUSHBUTTON | WS_TABSTOP;
-	      class.named = 0;
-	      class.u.id = CTL_BUTTON;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 77:
-#line 676 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 78:
-#line 680 "rcparse.y"
-    {
-	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
-	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
-	      class.named = 0;
-	      class.u.id = CTL_EDIT;
-	      res_text_field = res_null_text;	
-	    }
-    break;
-
-  case 79:
-#line 688 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 80:
-#line 692 "rcparse.y"
-    {
-	      default_style = BS_GROUPBOX;
-	      base_style = BS_GROUPBOX;
-	      class.named = 0;
-	      class.u.id = CTL_BUTTON;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 81:
-#line 700 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 82:
-#line 704 "rcparse.y"
-    {
-	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
-	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
-	      class.named = 0;
-	      class.u.id = CTL_EDIT;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 83:
-#line 712 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	    if (dialog.ex == NULL)
-	      rcparse_warning (_("IEDIT requires DIALOGEX"));
-	    res_string_to_id (&yyval.dialog_control->class, "HEDIT");
-	  }
-    break;
-
-  case 84:
-#line 719 "rcparse.y"
-    {
-	    yyval.dialog_control = define_icon_control (yyvsp[-4].id, yyvsp[-3].il, yyvsp[-2].il, yyvsp[-1].il, 0, 0, 0, yyvsp[0].rcdata_item,
-				      dialog.ex);
-          }
-    break;
-
-  case 85:
-#line 725 "rcparse.y"
-    {
-	    yyval.dialog_control = define_icon_control (yyvsp[-6].id, yyvsp[-5].il, yyvsp[-4].il, yyvsp[-3].il, 0, 0, 0, yyvsp[0].rcdata_item,
-				      dialog.ex);
-          }
-    break;
-
-  case 86:
-#line 731 "rcparse.y"
-    {
-	    yyval.dialog_control = define_icon_control (yyvsp[-8].id, yyvsp[-7].il, yyvsp[-6].il, yyvsp[-5].il, style, yyvsp[-1].il, 0, yyvsp[0].rcdata_item,
-				      dialog.ex);
-          }
-    break;
-
-  case 87:
-#line 737 "rcparse.y"
-    {
-	    yyval.dialog_control = define_icon_control (yyvsp[-9].id, yyvsp[-8].il, yyvsp[-7].il, yyvsp[-6].il, style, yyvsp[-2].il, yyvsp[-1].il, yyvsp[0].rcdata_item,
-				      dialog.ex);
-          }
-    break;
-
-  case 88:
-#line 742 "rcparse.y"
-    {
-	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
-	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
-	      class.named = 0;
-	      class.u.id = CTL_EDIT;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 89:
-#line 750 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	    if (dialog.ex == NULL)
-	      rcparse_warning (_("IEDIT requires DIALOGEX"));
-	    res_string_to_id (&yyval.dialog_control->class, "IEDIT");
-	  }
-    break;
-
-  case 90:
-#line 757 "rcparse.y"
-    {
-	      default_style = LBS_NOTIFY | WS_BORDER;
-	      base_style = LBS_NOTIFY | WS_BORDER;
-	      class.named = 0;
-	      class.u.id = CTL_LISTBOX;
-	      res_text_field = res_null_text;	
-	    }
-    break;
-
-  case 91:
-#line 765 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 92:
-#line 769 "rcparse.y"
-    {
-	      default_style = SS_LEFT | WS_GROUP;
-	      base_style = SS_LEFT;
-	      class.named = 0;
-	      class.u.id = CTL_STATIC;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 93:
-#line 777 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 94:
-#line 781 "rcparse.y"
-    {
-	      default_style = BS_PUSHBOX | WS_TABSTOP;
-	      base_style = BS_PUSHBOX;
-	      class.named = 0;
-	      class.u.id = CTL_BUTTON;
-	    }
-    break;
-
-  case 95:
-#line 788 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 96:
-#line 792 "rcparse.y"
-    {
-	      default_style = BS_PUSHBUTTON | WS_TABSTOP;
-	      base_style = BS_PUSHBUTTON | WS_TABSTOP;
-	      class.named = 0;
-	      class.u.id = CTL_BUTTON;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 97:
-#line 800 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 98:
-#line 804 "rcparse.y"
-    {
-	      default_style = BS_RADIOBUTTON | WS_TABSTOP;
-	      base_style = BS_RADIOBUTTON;
-	      class.named = 0;
-	      class.u.id = CTL_BUTTON;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 99:
-#line 812 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 100:
-#line 816 "rcparse.y"
-    {
-	      default_style = SS_RIGHT | WS_GROUP;
-	      base_style = SS_RIGHT;
-	      class.named = 0;
-	      class.u.id = CTL_STATIC;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 101:
-#line 824 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 102:
-#line 828 "rcparse.y"
-    {
-	      default_style = SBS_HORZ;
-	      base_style = 0;
-	      class.named = 0;
-	      class.u.id = CTL_SCROLLBAR;
-	      res_text_field = res_null_text;	
-	    }
-    break;
-
-  case 103:
-#line 836 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 104:
-#line 840 "rcparse.y"
-    {
-	      default_style = BS_3STATE | WS_TABSTOP;
-	      base_style = BS_3STATE;
-	      class.named = 0;
-	      class.u.id = CTL_BUTTON;
-	      res_text_field = yyvsp[0].id;	
-	    }
-    break;
-
-  case 105:
-#line 848 "rcparse.y"
-    {
-	    yyval.dialog_control = yyvsp[0].dialog_control;
-	  }
-    break;
-
-  case 106:
-#line 853 "rcparse.y"
-    { style = WS_CHILD | WS_VISIBLE; }
-    break;
-
-  case 107:
-#line 855 "rcparse.y"
-    {
-	    rc_res_id cid;
-	    cid.named = 0;
-	    cid.u.id = CTL_BUTTON;
-	    yyval.dialog_control = define_control (yyvsp[-13].id, yyvsp[-12].il, yyvsp[-10].il, yyvsp[-8].il, yyvsp[-6].il, yyvsp[-4].il, cid,
-				 style, yyvsp[0].il);
-	  }
-    break;
-
-  case 108:
-#line 873 "rcparse.y"
-    {
-	    yyval.dialog_control = define_control (res_text_field, yyvsp[-5].il, yyvsp[-4].il, yyvsp[-3].il, yyvsp[-2].il, yyvsp[-1].il, class,
-				 default_style | WS_CHILD | WS_VISIBLE, 0);
-	    if (yyvsp[0].rcdata_item != NULL)
-	      {
-		if (dialog.ex == NULL)
-		  rcparse_warning (_("control data requires DIALOGEX"));
-		yyval.dialog_control->data = yyvsp[0].rcdata_item;
-	      }
-	  }
-    break;
-
-  case 109:
-#line 885 "rcparse.y"
-    {
-	    yyval.dialog_control = define_control (res_text_field, yyvsp[-7].il, yyvsp[-6].il, yyvsp[-5].il, yyvsp[-4].il, yyvsp[-3].il, class, style, yyvsp[-1].il);
-	    if (yyvsp[0].rcdata_item != NULL)
-	      {
-		if (dialog.ex == NULL)
-		  rcparse_warning (_("control data requires DIALOGEX"));
-		yyval.dialog_control->data = yyvsp[0].rcdata_item;
-	      }
-	  }
-    break;
-
-  case 110:
-#line 896 "rcparse.y"
-    {
-	    yyval.dialog_control = define_control (res_text_field, yyvsp[-8].il, yyvsp[-7].il, yyvsp[-6].il, yyvsp[-5].il, yyvsp[-4].il, class, style, yyvsp[-2].il);
-	    if (dialog.ex == NULL)
-	      rcparse_warning (_("help ID requires DIALOGEX"));
-	    yyval.dialog_control->help = yyvsp[-1].il;
-	    yyval.dialog_control->data = yyvsp[0].rcdata_item;
-	  }
-    break;
-
-  case 111:
-#line 907 "rcparse.y"
-    {
-	    if (yyvsp[0].id.named)
-	      res_unistring_to_id (&yyval.id, yyvsp[0].id.u.n.name);
-	    else
-	      yyval.id=yyvsp[0].id;
-	  }
-    break;
-
-  case 112:
-#line 917 "rcparse.y"
-    {
-	    res_string_to_id (&yyval.id, "");
-	  }
-    break;
-
-  case 113:
-#line 920 "rcparse.y"
-    { yyval.id=yyvsp[-1].id; }
-    break;
-
-  case 114:
-#line 925 "rcparse.y"
-    {
-	    yyval.id.named = 0;
-	    yyval.id.u.id = yyvsp[0].il;
-	  }
-    break;
-
-  case 115:
-#line 930 "rcparse.y"
-    {
-	    yyval.id.named = 1;
-	    yyval.id.u.n.name = yyvsp[0].uni;
-	    yyval.id.u.n.length = unichar_len (yyvsp[0].uni);
-	  }
-    break;
-
-  case 116:
-#line 939 "rcparse.y"
-    {
-	    yyval.rcdata_item = NULL;
-	  }
-    break;
-
-  case 117:
-#line 943 "rcparse.y"
-    {
-	    yyval.rcdata_item = yyvsp[-1].rcdata.first;
-	  }
-    break;
-
-  case 118:
-#line 952 "rcparse.y"
-    { style = WS_CHILD | WS_VISIBLE; }
-    break;
-
-  case 120:
-#line 958 "rcparse.y"
-    { style = SS_ICON | WS_CHILD | WS_VISIBLE; }
-    break;
-
-  case 122:
-#line 964 "rcparse.y"
-    { style = base_style | WS_CHILD | WS_VISIBLE; }
-    break;
-
-  case 124:
-#line 972 "rcparse.y"
-    {
-	    define_font (yyvsp[-3].id, &yyvsp[-1].res_info, yyvsp[0].s);
-	    if (yychar != YYEMPTY)
-	      YYERROR;
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 125:
-#line 984 "rcparse.y"
-    {
-	    define_icon (yyvsp[-3].id, &yyvsp[-1].res_info, yyvsp[0].s);
-	    if (yychar != YYEMPTY)
-	      YYERROR;
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 126:
-#line 997 "rcparse.y"
-    {
-	    language = yyvsp[-1].il | (yyvsp[0].il << SUBLANG_SHIFT);
-	  }
-    break;
-
-  case 127:
-#line 1006 "rcparse.y"
-    {
-	    define_menu (yyvsp[-5].id, &yyvsp[-3].res_info, yyvsp[-1].menuitem);
-	    if (yychar != YYEMPTY)
-	      YYERROR;
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 128:
-#line 1016 "rcparse.y"
-    {
-	    yyval.menuitem = NULL;
-	  }
-    break;
-
-  case 129:
-#line 1020 "rcparse.y"
-    {
-	    if (yyvsp[-1].menuitem == NULL)
-	      yyval.menuitem = yyvsp[0].menuitem;
-	    else
-	      {
-		rc_menuitem **pp;
-
-		for (pp = &yyvsp[-1].menuitem->next; *pp != NULL; pp = &(*pp)->next)
-		  ;
-		*pp = yyvsp[0].menuitem;
-		yyval.menuitem = yyvsp[-1].menuitem;
-	      }
-	  }
-    break;
-
-  case 130:
-#line 1037 "rcparse.y"
-    {
-	    yyval.menuitem = define_menuitem (yyvsp[-2].uni, yyvsp[-1].il, yyvsp[0].is, 0, 0, NULL);
-	  }
-    break;
-
-  case 131:
-#line 1041 "rcparse.y"
-    {
-	    yyval.menuitem = define_menuitem (NULL, 0, 0, 0, 0, NULL);
-	  }
-    break;
-
-  case 132:
-#line 1045 "rcparse.y"
-    {
-	    yyval.menuitem = define_menuitem (yyvsp[-4].uni, 0, yyvsp[-3].is, 0, 0, yyvsp[-1].menuitem);
-	  }
-    break;
-
-  case 133:
-#line 1052 "rcparse.y"
-    {
-	    yyval.is = 0;
-	  }
-    break;
-
-  case 134:
-#line 1056 "rcparse.y"
-    {
-	    yyval.is = yyvsp[-2].is | yyvsp[0].is;
-	  }
-    break;
-
-  case 135:
-#line 1060 "rcparse.y"
-    {
-	    yyval.is = yyvsp[-1].is | yyvsp[0].is;
-	  }
-    break;
-
-  case 136:
-#line 1067 "rcparse.y"
-    {
-	    yyval.is = MENUITEM_CHECKED;
-	  }
-    break;
-
-  case 137:
-#line 1071 "rcparse.y"
-    {
-	    yyval.is = MENUITEM_GRAYED;
-	  }
-    break;
-
-  case 138:
-#line 1075 "rcparse.y"
-    {
-	    yyval.is = MENUITEM_HELP;
-	  }
-    break;
-
-  case 139:
-#line 1079 "rcparse.y"
-    {
-	    yyval.is = MENUITEM_INACTIVE;
-	  }
-    break;
-
-  case 140:
-#line 1083 "rcparse.y"
-    {
-	    yyval.is = MENUITEM_MENUBARBREAK;
-	  }
-    break;
-
-  case 141:
-#line 1087 "rcparse.y"
-    {
-	    yyval.is = MENUITEM_MENUBREAK;
-	  }
-    break;
-
-  case 142:
-#line 1096 "rcparse.y"
-    {
-	    define_menu (yyvsp[-5].id, &yyvsp[-3].res_info, yyvsp[-1].menuitem);
-	    if (yychar != YYEMPTY)
-	      YYERROR;
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 143:
-#line 1106 "rcparse.y"
-    {
-	    yyval.menuitem = NULL;
-	  }
-    break;
-
-  case 144:
-#line 1110 "rcparse.y"
-    {
-	    if (yyvsp[-1].menuitem == NULL)
-	      yyval.menuitem = yyvsp[0].menuitem;
-	    else
-	      {
-		rc_menuitem **pp;
-
-		for (pp = &yyvsp[-1].menuitem->next; *pp != NULL; pp = &(*pp)->next)
-		  ;
-		*pp = yyvsp[0].menuitem;
-		yyval.menuitem = yyvsp[-1].menuitem;
-	      }
-	  }
-    break;
-
-  case 145:
-#line 1127 "rcparse.y"
-    {
-	    yyval.menuitem = define_menuitem (yyvsp[0].uni, 0, 0, 0, 0, NULL);
-	  }
-    break;
-
-  case 146:
-#line 1131 "rcparse.y"
-    {
-	    yyval.menuitem = define_menuitem (yyvsp[-1].uni, yyvsp[0].il, 0, 0, 0, NULL);
-	  }
-    break;
-
-  case 147:
-#line 1135 "rcparse.y"
-    {
-	    yyval.menuitem = define_menuitem (yyvsp[-3].uni, yyvsp[-2].il, yyvsp[-1].il, yyvsp[0].il, 0, NULL);
-	  }
-    break;
-
-  case 148:
-#line 1139 "rcparse.y"
-    {
- 	    yyval.menuitem = define_menuitem (NULL, 0, 0, 0, 0, NULL);
- 	  }
-    break;
-
-  case 149:
-#line 1143 "rcparse.y"
-    {
-	    yyval.menuitem = define_menuitem (yyvsp[-3].uni, 0, 0, 0, 0, yyvsp[-1].menuitem);
-	  }
-    break;
-
-  case 150:
-#line 1147 "rcparse.y"
-    {
-	    yyval.menuitem = define_menuitem (yyvsp[-4].uni, yyvsp[-3].il, 0, 0, 0, yyvsp[-1].menuitem);
-	  }
-    break;
-
-  case 151:
-#line 1151 "rcparse.y"
-    {
-	    yyval.menuitem = define_menuitem (yyvsp[-5].uni, yyvsp[-4].il, yyvsp[-3].il, 0, 0, yyvsp[-1].menuitem);
-	  }
-    break;
-
-  case 152:
-#line 1156 "rcparse.y"
-    {
-	    yyval.menuitem = define_menuitem (yyvsp[-7].uni, yyvsp[-6].il, yyvsp[-5].il, yyvsp[-4].il, yyvsp[-3].il, yyvsp[-1].menuitem);
-	  }
-    break;
-
-  case 153:
-#line 1165 "rcparse.y"
-    {
-	    define_messagetable (yyvsp[-3].id, &yyvsp[-1].res_info, yyvsp[0].s);
-	    if (yychar != YYEMPTY)
-	      YYERROR;
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 154:
-#line 1177 "rcparse.y"
-    {
-	    rcparse_rcdata ();
-	  }
-    break;
-
-  case 155:
-#line 1181 "rcparse.y"
-    {
-	    rcparse_normal ();
-	    yyval.rcdata = yyvsp[0].rcdata;
-	  }
-    break;
-
-  case 156:
-#line 1189 "rcparse.y"
-    {
-	    yyval.rcdata.first = NULL;
-	    yyval.rcdata.last = NULL;
-	  }
-    break;
-
-  case 157:
-#line 1194 "rcparse.y"
-    {
-	    yyval.rcdata = yyvsp[0].rcdata;
-	  }
-    break;
-
-  case 158:
-#line 1201 "rcparse.y"
-    {
-	    rc_rcdata_item *ri;
-
-	    ri = define_rcdata_string (yyvsp[0].ss.s, yyvsp[0].ss.length);
-	    yyval.rcdata.first = ri;
-	    yyval.rcdata.last = ri;
-	  }
-    break;
-
-  case 159:
-#line 1209 "rcparse.y"
-    {
-	    rc_rcdata_item *ri;
-
-	    ri = define_rcdata_unistring (yyvsp[0].suni.s, yyvsp[0].suni.length);
-	    yyval.rcdata.first = ri;
-	    yyval.rcdata.last = ri;
-	  }
-    break;
-
-  case 160:
-#line 1217 "rcparse.y"
-    {
-	    rc_rcdata_item *ri;
-
-	    ri = define_rcdata_number (yyvsp[0].i.val, yyvsp[0].i.dword);
-	    yyval.rcdata.first = ri;
-	    yyval.rcdata.last = ri;
-	  }
-    break;
-
-  case 161:
-#line 1225 "rcparse.y"
-    {
-	    rc_rcdata_item *ri;
-
-	    ri = define_rcdata_string (yyvsp[0].ss.s, yyvsp[0].ss.length);
-	    yyval.rcdata.first = yyvsp[-2].rcdata.first;
-	    yyvsp[-2].rcdata.last->next = ri;
-	    yyval.rcdata.last = ri;
-	  }
-    break;
-
-  case 162:
-#line 1234 "rcparse.y"
-    {
-	    rc_rcdata_item *ri;
-
-	    ri = define_rcdata_unistring (yyvsp[0].suni.s, yyvsp[0].suni.length);
-	    yyval.rcdata.first = yyvsp[-2].rcdata.first;
-	    yyvsp[-2].rcdata.last->next = ri;
-	    yyval.rcdata.last = ri;
-	  }
-    break;
-
-  case 163:
-#line 1243 "rcparse.y"
-    {
-	    rc_rcdata_item *ri;
-
-	    ri = define_rcdata_number (yyvsp[0].i.val, yyvsp[0].i.dword);
-	    yyval.rcdata.first = yyvsp[-2].rcdata.first;
-	    yyvsp[-2].rcdata.last->next = ri;
-	    yyval.rcdata.last = ri;
-	  }
-    break;
-
-  case 164:
-#line 1252 "rcparse.y"
-    {
-	    yyval.rcdata=yyvsp[-1].rcdata;
-	  }
-    break;
-
-  case 165:
-#line 1261 "rcparse.y"
-    { sub_res_info = yyvsp[-1].res_info; }
-    break;
-
-  case 168:
-#line 1268 "rcparse.y"
-    {
-	    define_stringtable (&sub_res_info, yyvsp[-1].il, yyvsp[0].uni);
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 169:
-#line 1273 "rcparse.y"
-    {
-	    define_stringtable (&sub_res_info, yyvsp[-2].il, yyvsp[0].uni);
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 170:
-#line 1278 "rcparse.y"
-    {
-	    rcparse_warning (_("invalid stringtable resource."));
-	    abort ();
-	  }
-    break;
-
-  case 171:
-#line 1286 "rcparse.y"
-    {
-	    yyval.id=yyvsp[0].id;
-	  }
-    break;
-
-  case 172:
-#line 1290 "rcparse.y"
-    {
-	  yyval.id.named = 0;
-	  yyval.id.u.id = 23;
-	}
-    break;
-
-  case 173:
-#line 1295 "rcparse.y"
-    {
-          yyval.id.named = 0;
-          yyval.id.u.id = RT_RCDATA;
-        }
-    break;
-
-  case 174:
-#line 1300 "rcparse.y"
-    {
-          yyval.id.named = 0;
-          yyval.id.u.id = RT_MANIFEST;
-        }
-    break;
-
-  case 175:
-#line 1305 "rcparse.y"
-    {
-          yyval.id.named = 0;
-          yyval.id.u.id = RT_PLUGPLAY;
-        }
-    break;
-
-  case 176:
-#line 1310 "rcparse.y"
-    {
-          yyval.id.named = 0;
-          yyval.id.u.id = RT_VXD;
-        }
-    break;
-
-  case 177:
-#line 1315 "rcparse.y"
-    {
-          yyval.id.named = 0;
-          yyval.id.u.id = RT_DLGINCLUDE;
-        }
-    break;
-
-  case 178:
-#line 1320 "rcparse.y"
-    {
-          yyval.id.named = 0;
-          yyval.id.u.id = RT_DLGINIT;
-        }
-    break;
-
-  case 179:
-#line 1325 "rcparse.y"
-    {
-          yyval.id.named = 0;
-          yyval.id.u.id = RT_ANICURSOR;
-        }
-    break;
-
-  case 180:
-#line 1330 "rcparse.y"
-    {
-          yyval.id.named = 0;
-          yyval.id.u.id = RT_ANIICON;
-        }
-    break;
-
-  case 181:
-#line 1341 "rcparse.y"
-    {
-	    define_user_data (yyvsp[-5].id, yyvsp[-4].id, &yyvsp[-3].res_info, yyvsp[-1].rcdata.first);
-	    if (yychar != YYEMPTY)
-	      YYERROR;
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 182:
-#line 1348 "rcparse.y"
-    {
-	    define_user_file (yyvsp[-3].id, yyvsp[-2].id, &yyvsp[-1].res_info, yyvsp[0].s);
-	    if (yychar != YYEMPTY)
-	      YYERROR;
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 183:
-#line 1358 "rcparse.y"
-    {
-	  define_toolbar (yyvsp[-7].id, &yyvsp[-5].res_info, yyvsp[-4].il, yyvsp[-3].il, yyvsp[-1].toobar_item);
-	}
-    break;
-
-  case 184:
-#line 1363 "rcparse.y"
-    { yyval.toobar_item= NULL; }
-    break;
-
-  case 185:
-#line 1365 "rcparse.y"
-    {
-	  rc_toolbar_item *c,*n;
-	  c = yyvsp[-2].toobar_item;
-	  n= (rc_toolbar_item *)
-	      res_alloc (sizeof (rc_toolbar_item));
-	  if (c != NULL)
-	    while (c->next != NULL)
-	      c = c->next;
-	  n->prev = c;
-	  n->next = NULL;
-	  if (c != NULL)
-	    c->next = n;
-	  n->id = yyvsp[0].id;
-	  if (yyvsp[-2].toobar_item == NULL)
-	    yyval.toobar_item = n;
-	  else
-	    yyval.toobar_item = yyvsp[-2].toobar_item;
-	}
-    break;
-
-  case 186:
-#line 1384 "rcparse.y"
-    {
-	  rc_toolbar_item *c,*n;
-	  c = yyvsp[-1].toobar_item;
-	  n= (rc_toolbar_item *)
-	      res_alloc (sizeof (rc_toolbar_item));
-	  if (c != NULL)
-	    while (c->next != NULL)
-	      c = c->next;
-	  n->prev = c;
-	  n->next = NULL;
-	  if (c != NULL)
-	    c->next = n;
-	  n->id.named = 0;
-	  n->id.u.id = 0;
-	  if (yyvsp[-1].toobar_item == NULL)
-	    yyval.toobar_item = n;
-	  else
-	    yyval.toobar_item = yyvsp[-1].toobar_item;
-	}
-    break;
-
-  case 187:
-#line 1409 "rcparse.y"
-    {
-	    define_versioninfo (yyvsp[-5].id, language, yyvsp[-3].fixver, yyvsp[-1].verinfo);
-	    if (yychar != YYEMPTY)
-	      YYERROR;
-	    rcparse_discard_strings ();
-	  }
-    break;
-
-  case 188:
-#line 1419 "rcparse.y"
-    {
-	    yyval.fixver = ((rc_fixed_versioninfo *)
-		  res_alloc (sizeof (rc_fixed_versioninfo)));
-	    memset (yyval.fixver, 0, sizeof (rc_fixed_versioninfo));
-	  }
-    break;
-
-  case 189:
-#line 1425 "rcparse.y"
-    {
-	    yyvsp[-5].fixver->file_version_ms = (yyvsp[-3].il << 16) | yyvsp[-2].il;
-	    yyvsp[-5].fixver->file_version_ls = (yyvsp[-1].il << 16) | yyvsp[0].il;
-	    yyval.fixver = yyvsp[-5].fixver;
-	  }
-    break;
-
-  case 190:
-#line 1431 "rcparse.y"
-    {
-	    yyvsp[-5].fixver->product_version_ms = (yyvsp[-3].il << 16) | yyvsp[-2].il;
-	    yyvsp[-5].fixver->product_version_ls = (yyvsp[-1].il << 16) | yyvsp[0].il;
-	    yyval.fixver = yyvsp[-5].fixver;
-	  }
-    break;
-
-  case 191:
-#line 1437 "rcparse.y"
-    {
-	    yyvsp[-2].fixver->file_flags_mask = yyvsp[0].il;
-	    yyval.fixver = yyvsp[-2].fixver;
-	  }
-    break;
-
-  case 192:
-#line 1442 "rcparse.y"
-    {
-	    yyvsp[-2].fixver->file_flags = yyvsp[0].il;
-	    yyval.fixver = yyvsp[-2].fixver;
-	  }
-    break;
-
-  case 193:
-#line 1447 "rcparse.y"
-    {
-	    yyvsp[-2].fixver->file_os = yyvsp[0].il;
-	    yyval.fixver = yyvsp[-2].fixver;
-	  }
-    break;
-
-  case 194:
-#line 1452 "rcparse.y"
-    {
-	    yyvsp[-2].fixver->file_type = yyvsp[0].il;
-	    yyval.fixver = yyvsp[-2].fixver;
-	  }
-    break;
-
-  case 195:
-#line 1457 "rcparse.y"
-    {
-	    yyvsp[-2].fixver->file_subtype = yyvsp[0].il;
-	    yyval.fixver = yyvsp[-2].fixver;
-	  }
-    break;
-
-  case 196:
-#line 1471 "rcparse.y"
-    {
-	    yyval.verinfo = NULL;
-	  }
-    break;
-
-  case 197:
-#line 1475 "rcparse.y"
-    {
-	    yyval.verinfo = append_ver_stringfileinfo (yyvsp[-7].verinfo, yyvsp[-4].s, yyvsp[-2].verstring);
-	  }
-    break;
-
-  case 198:
-#line 1479 "rcparse.y"
-    {
-	    yyval.verinfo = append_ver_varfileinfo (yyvsp[-6].verinfo, yyvsp[-2].uni, yyvsp[-1].vervar);
-	  }
-    break;
-
-  case 199:
-#line 1486 "rcparse.y"
-    {
-	    yyval.verstring = NULL;
-	  }
-    break;
-
-  case 200:
-#line 1490 "rcparse.y"
-    {
-	    yyval.verstring = append_verval (yyvsp[-4].verstring, yyvsp[-2].uni, yyvsp[0].uni);
-	  }
-    break;
-
-  case 201:
-#line 1497 "rcparse.y"
-    {
-	    yyval.vervar = NULL;
-	  }
-    break;
-
-  case 202:
-#line 1501 "rcparse.y"
-    {
-	    yyval.vervar = append_vertrans (yyvsp[-2].vervar, yyvsp[-1].il, yyvsp[0].il);
-	  }
-    break;
-
-  case 203:
-#line 1510 "rcparse.y"
-    {
-	    yyval.id.named = 0;
-	    yyval.id.u.id = yyvsp[0].il;
-	  }
-    break;
-
-  case 204:
-#line 1515 "rcparse.y"
-    {
-	    res_unistring_to_id (&yyval.id, yyvsp[0].uni);
-	  }
-    break;
-
-  case 205:
-#line 1524 "rcparse.y"
-    {
-	    yyval.uni = yyvsp[0].uni;
-	  }
-    break;
-
-  case 206:
-#line 1528 "rcparse.y"
-    {
-	    unichar *h = NULL;
-	    unicode_from_ascii ((rc_uint_type *) NULL, &h, yyvsp[0].s);
-	    yyval.uni = h;
-	  }
-    break;
-
-  case 207:
-#line 1538 "rcparse.y"
-    {
-	    yyval.id.named = 0;
-	    yyval.id.u.id = yyvsp[-1].il;
-	  }
-    break;
-
-  case 208:
-#line 1543 "rcparse.y"
-    {
-	    res_unistring_to_id (&yyval.id, yyvsp[0].uni);
-	  }
-    break;
-
-  case 209:
-#line 1547 "rcparse.y"
-    {
-	    res_unistring_to_id (&yyval.id, yyvsp[-1].uni);
-	  }
-    break;
-
-  case 210:
-#line 1557 "rcparse.y"
-    {
-	    memset (&yyval.res_info, 0, sizeof (rc_res_res_info));
-	    yyval.res_info.language = language;
-	    /* FIXME: Is this the right default?  */
-	    yyval.res_info.memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE | MEMFLAG_DISCARDABLE;
-	  }
-    break;
-
-  case 211:
-#line 1564 "rcparse.y"
-    {
-	    yyval.res_info = yyvsp[-1].res_info;
-	    yyval.res_info.memflags |= yyvsp[0].memflags.on;
-	    yyval.res_info.memflags &=~ yyvsp[0].memflags.off;
-	  }
-    break;
-
-  case 212:
-#line 1570 "rcparse.y"
-    {
-	    yyval.res_info = yyvsp[-2].res_info;
-	    yyval.res_info.characteristics = yyvsp[0].il;
-	  }
-    break;
-
-  case 213:
-#line 1575 "rcparse.y"
-    {
-	    yyval.res_info = yyvsp[-3].res_info;
-	    yyval.res_info.language = yyvsp[-1].il | (yyvsp[0].il << SUBLANG_SHIFT);
-	  }
-    break;
-
-  case 214:
-#line 1580 "rcparse.y"
-    {
-	    yyval.res_info = yyvsp[-2].res_info;
-	    yyval.res_info.version = yyvsp[0].il;
-	  }
-    break;
-
-  case 215:
-#line 1590 "rcparse.y"
-    {
-	    memset (&yyval.res_info, 0, sizeof (rc_res_res_info));
-	    yyval.res_info.language = language;
-	    yyval.res_info.memflags = MEMFLAG_MOVEABLE | MEMFLAG_DISCARDABLE;
-	  }
-    break;
-
-  case 216:
-#line 1596 "rcparse.y"
-    {
-	    yyval.res_info = yyvsp[-1].res_info;
-	    yyval.res_info.memflags |= yyvsp[0].memflags.on;
-	    yyval.res_info.memflags &=~ yyvsp[0].memflags.off;
-	  }
-    break;
-
-  case 217:
-#line 1607 "rcparse.y"
-    {
-	    memset (&yyval.res_info, 0, sizeof (rc_res_res_info));
-	    yyval.res_info.language = language;
-	    yyval.res_info.memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE | MEMFLAG_DISCARDABLE;
-	  }
-    break;
-
-  case 218:
-#line 1613 "rcparse.y"
-    {
-	    yyval.res_info = yyvsp[-1].res_info;
-	    yyval.res_info.memflags |= yyvsp[0].memflags.on;
-	    yyval.res_info.memflags &=~ yyvsp[0].memflags.off;
-	  }
-    break;
-
-  case 219:
-#line 1625 "rcparse.y"
-    {
-	    yyval.memflags.on = MEMFLAG_MOVEABLE;
-	    yyval.memflags.off = 0;
-	  }
-    break;
-
-  case 220:
-#line 1630 "rcparse.y"
-    {
-	    yyval.memflags.on = 0;
-	    yyval.memflags.off = MEMFLAG_MOVEABLE;
-	  }
-    break;
-
-  case 221:
-#line 1635 "rcparse.y"
-    {
-	    yyval.memflags.on = MEMFLAG_PURE;
-	    yyval.memflags.off = 0;
-	  }
-    break;
-
-  case 222:
-#line 1640 "rcparse.y"
-    {
-	    yyval.memflags.on = 0;
-	    yyval.memflags.off = MEMFLAG_PURE;
-	  }
-    break;
-
-  case 223:
-#line 1645 "rcparse.y"
-    {
-	    yyval.memflags.on = MEMFLAG_PRELOAD;
-	    yyval.memflags.off = 0;
-	  }
-    break;
-
-  case 224:
-#line 1650 "rcparse.y"
-    {
-	    yyval.memflags.on = 0;
-	    yyval.memflags.off = MEMFLAG_PRELOAD;
-	  }
-    break;
-
-  case 225:
-#line 1655 "rcparse.y"
-    {
-	    yyval.memflags.on = MEMFLAG_DISCARDABLE;
-	    yyval.memflags.off = 0;
-	  }
-    break;
-
-  case 226:
-#line 1665 "rcparse.y"
-    {
-	    yyval.s = yyvsp[0].s;
-	  }
-    break;
-
-  case 227:
-#line 1669 "rcparse.y"
-    {
-	    yyval.s = yyvsp[0].s;
-	  }
-    break;
-
-  case 228:
-#line 1677 "rcparse.y"
-    {
-	    yyval.uni = yyvsp[0].uni;
-	  }
-    break;
-
-  case 229:
-#line 1682 "rcparse.y"
-    {
-	    rc_uint_type l1 = unichar_len (yyvsp[-1].uni);
-	    rc_uint_type l2 = unichar_len (yyvsp[0].uni);
-	    unichar *h = (unichar *) res_alloc ((l1 + l2 + 1) * sizeof (unichar));
-	    if (l1 != 0)
-	      memcpy (h, yyvsp[-1].uni, l1 * sizeof (unichar));
-	    if (l2 != 0)
-	      memcpy (h + l1, yyvsp[0].uni, l2  * sizeof (unichar));
-	    h[l1 + l2] = 0;
-	    yyval.uni = h;
-	  }
-    break;
-
-  case 230:
-#line 1697 "rcparse.y"
-    {
-	    yyval.uni = unichar_dup (yyvsp[0].uni);
-	  }
-    break;
-
-  case 231:
-#line 1701 "rcparse.y"
-    {
-	    unichar *h = NULL;
-	    unicode_from_ascii ((rc_uint_type *) NULL, &h, yyvsp[0].s);
-	    yyval.uni = h;
-	  }
-    break;
-
-  case 232:
-#line 1710 "rcparse.y"
-    {
-	    yyval.ss = yyvsp[0].ss;
-	  }
-    break;
-
-  case 233:
-#line 1714 "rcparse.y"
-    {
-	    rc_uint_type l = yyvsp[-1].ss.length + yyvsp[0].ss.length;
-	    char *h = (char *) res_alloc (l);
-	    memcpy (h, yyvsp[-1].ss.s, yyvsp[-1].ss.length);
-	    memcpy (h + yyvsp[-1].ss.length, yyvsp[0].ss.s, yyvsp[0].ss.length);
-	    yyval.ss.s = h;
-	    yyval.ss.length = l;
-	  }
-    break;
-
-  case 234:
-#line 1726 "rcparse.y"
-    {
-	    yyval.suni = yyvsp[0].suni;
-	  }
-    break;
-
-  case 235:
-#line 1730 "rcparse.y"
-    {
-	    rc_uint_type l = yyvsp[-1].suni.length + yyvsp[0].suni.length;
-	    unichar *h = (unichar *) res_alloc (l * sizeof (unichar));
-	    memcpy (h, yyvsp[-1].suni.s, yyvsp[-1].suni.length * sizeof (unichar));
-	    memcpy (h + yyvsp[-1].suni.length, yyvsp[0].suni.s, yyvsp[0].suni.length  * sizeof (unichar));
-	    yyval.suni.s = h;
-	    yyval.suni.length = l;
-	  }
-    break;
-
-  case 236:
-#line 1752 "rcparse.y"
-    {
-	    style |= yyvsp[0].il;
-	  }
-    break;
-
-  case 237:
-#line 1756 "rcparse.y"
-    {
-	    style &=~ yyvsp[0].il;
-	  }
-    break;
-
-  case 238:
-#line 1760 "rcparse.y"
-    {
-	    style |= yyvsp[0].il;
-	  }
-    break;
-
-  case 239:
-#line 1764 "rcparse.y"
-    {
-	    style &=~ yyvsp[0].il;
-	  }
-    break;
-
-  case 240:
-#line 1771 "rcparse.y"
-    {
-	    yyval.il = yyvsp[0].i.val;
-	  }
-    break;
-
-  case 241:
-#line 1775 "rcparse.y"
-    {
-	    yyval.il = yyvsp[-1].il;
-	  }
-    break;
-
-  case 242:
-#line 1784 "rcparse.y"
-    {
-	    yyval.il = 0;
-	  }
-    break;
-
-  case 243:
-#line 1788 "rcparse.y"
-    {
-	    yyval.il = yyvsp[0].il;
-	  }
-    break;
-
-  case 244:
-#line 1797 "rcparse.y"
-    {
-	    yyval.il = yyvsp[0].il;
-	  }
-    break;
-
-  case 245:
-#line 1806 "rcparse.y"
-    {
-	    yyval.il = yyvsp[0].i.val;
-	  }
-    break;
-
-  case 246:
-#line 1815 "rcparse.y"
-    {
-	    yyval.i = yyvsp[0].i;
-	  }
-    break;
-
-  case 247:
-#line 1819 "rcparse.y"
-    {
-	    yyval.i = yyvsp[-1].i;
-	  }
-    break;
-
-  case 248:
-#line 1823 "rcparse.y"
-    {
-	    yyval.i.val = ~ yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 249:
-#line 1828 "rcparse.y"
-    {
-	    yyval.i.val = - yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 250:
-#line 1833 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val * yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 251:
-#line 1838 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val / yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 252:
-#line 1843 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val % yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 253:
-#line 1848 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val + yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 254:
-#line 1853 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val - yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 255:
-#line 1858 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val & yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 256:
-#line 1863 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val ^ yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 257:
-#line 1868 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val | yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 258:
-#line 1879 "rcparse.y"
-    {
-	    yyval.il = yyvsp[0].il;
-	  }
-    break;
-
-  case 259:
-#line 1888 "rcparse.y"
-    {
-	    yyval.il = yyvsp[0].i.val;
-	  }
-    break;
-
-  case 260:
-#line 1899 "rcparse.y"
-    {
-	    yyval.i = yyvsp[0].i;
-	  }
-    break;
-
-  case 261:
-#line 1903 "rcparse.y"
-    {
-	    yyval.i = yyvsp[-1].i;
-	  }
-    break;
-
-  case 262:
-#line 1907 "rcparse.y"
-    {
-	    yyval.i.val = ~ yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 263:
-#line 1912 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val * yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 264:
-#line 1917 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val / yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 265:
-#line 1922 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val % yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 266:
-#line 1927 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val + yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 267:
-#line 1932 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val - yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 268:
-#line 1937 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val & yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 269:
-#line 1942 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val ^ yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-  case 270:
-#line 1947 "rcparse.y"
-    {
-	    yyval.i.val = yyvsp[-2].i.val | yyvsp[0].i.val;
-	    yyval.i.dword = yyvsp[-2].i.dword || yyvsp[0].i.dword;
-	  }
-    break;
-
-
-    }
-
-/* Line 1000 of yacc.c.  */
-#line 4042 "rcparse.c"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
-	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
-
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
-	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
-      else
-	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
-	  yychar = YYEMPTY;
-
-	}
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
-     goto yyerrorlab;
-#endif
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-	YYABORT;
-
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
-  *++yyvsp = yylval;
-
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-yyreturn:
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-  return yyresult;
-}
-
-
-#line 1953 "rcparse.y"
-
-
-/* Set the language from the command line.  */
-
-void
-rcparse_set_language (int lang)
-{
-  language = lang;
-}
-
diff -r -N -u binutils-2.21.51/binutils/rcparse.h binutils/binutils/rcparse.h
--- binutils-2.21.51/binutils/rcparse.h	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/rcparse.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,286 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     BEG = 258,
-     END = 259,
-     ACCELERATORS = 260,
-     VIRTKEY = 261,
-     ASCII = 262,
-     NOINVERT = 263,
-     SHIFT = 264,
-     CONTROL = 265,
-     ALT = 266,
-     BITMAP = 267,
-     CURSOR = 268,
-     DIALOG = 269,
-     DIALOGEX = 270,
-     EXSTYLE = 271,
-     CAPTION = 272,
-     CLASS = 273,
-     STYLE = 274,
-     AUTO3STATE = 275,
-     AUTOCHECKBOX = 276,
-     AUTORADIOBUTTON = 277,
-     CHECKBOX = 278,
-     COMBOBOX = 279,
-     CTEXT = 280,
-     DEFPUSHBUTTON = 281,
-     EDITTEXT = 282,
-     GROUPBOX = 283,
-     LISTBOX = 284,
-     LTEXT = 285,
-     PUSHBOX = 286,
-     PUSHBUTTON = 287,
-     RADIOBUTTON = 288,
-     RTEXT = 289,
-     SCROLLBAR = 290,
-     STATE3 = 291,
-     USERBUTTON = 292,
-     BEDIT = 293,
-     HEDIT = 294,
-     IEDIT = 295,
-     FONT = 296,
-     ICON = 297,
-     ANICURSOR = 298,
-     ANIICON = 299,
-     DLGINCLUDE = 300,
-     DLGINIT = 301,
-     FONTDIR = 302,
-     HTML = 303,
-     MANIFEST = 304,
-     PLUGPLAY = 305,
-     VXD = 306,
-     TOOLBAR = 307,
-     BUTTON = 308,
-     LANGUAGE = 309,
-     CHARACTERISTICS = 310,
-     VERSIONK = 311,
-     MENU = 312,
-     MENUEX = 313,
-     MENUITEM = 314,
-     SEPARATOR = 315,
-     POPUP = 316,
-     CHECKED = 317,
-     GRAYED = 318,
-     HELP = 319,
-     INACTIVE = 320,
-     MENUBARBREAK = 321,
-     MENUBREAK = 322,
-     MESSAGETABLE = 323,
-     RCDATA = 324,
-     STRINGTABLE = 325,
-     VERSIONINFO = 326,
-     FILEVERSION = 327,
-     PRODUCTVERSION = 328,
-     FILEFLAGSMASK = 329,
-     FILEFLAGS = 330,
-     FILEOS = 331,
-     FILETYPE = 332,
-     FILESUBTYPE = 333,
-     BLOCKSTRINGFILEINFO = 334,
-     BLOCKVARFILEINFO = 335,
-     VALUE = 336,
-     BLOCK = 337,
-     MOVEABLE = 338,
-     FIXED = 339,
-     PURE = 340,
-     IMPURE = 341,
-     PRELOAD = 342,
-     LOADONCALL = 343,
-     DISCARDABLE = 344,
-     NOT = 345,
-     QUOTEDUNISTRING = 346,
-     QUOTEDSTRING = 347,
-     STRING = 348,
-     NUMBER = 349,
-     SIZEDUNISTRING = 350,
-     SIZEDSTRING = 351,
-     IGNORED_TOKEN = 352,
-     NEG = 353
-   };
-#endif
-#define BEG 258
-#define END 259
-#define ACCELERATORS 260
-#define VIRTKEY 261
-#define ASCII 262
-#define NOINVERT 263
-#define SHIFT 264
-#define CONTROL 265
-#define ALT 266
-#define BITMAP 267
-#define CURSOR 268
-#define DIALOG 269
-#define DIALOGEX 270
-#define EXSTYLE 271
-#define CAPTION 272
-#define CLASS 273
-#define STYLE 274
-#define AUTO3STATE 275
-#define AUTOCHECKBOX 276
-#define AUTORADIOBUTTON 277
-#define CHECKBOX 278
-#define COMBOBOX 279
-#define CTEXT 280
-#define DEFPUSHBUTTON 281
-#define EDITTEXT 282
-#define GROUPBOX 283
-#define LISTBOX 284
-#define LTEXT 285
-#define PUSHBOX 286
-#define PUSHBUTTON 287
-#define RADIOBUTTON 288
-#define RTEXT 289
-#define SCROLLBAR 290
-#define STATE3 291
-#define USERBUTTON 292
-#define BEDIT 293
-#define HEDIT 294
-#define IEDIT 295
-#define FONT 296
-#define ICON 297
-#define ANICURSOR 298
-#define ANIICON 299
-#define DLGINCLUDE 300
-#define DLGINIT 301
-#define FONTDIR 302
-#define HTML 303
-#define MANIFEST 304
-#define PLUGPLAY 305
-#define VXD 306
-#define TOOLBAR 307
-#define BUTTON 308
-#define LANGUAGE 309
-#define CHARACTERISTICS 310
-#define VERSIONK 311
-#define MENU 312
-#define MENUEX 313
-#define MENUITEM 314
-#define SEPARATOR 315
-#define POPUP 316
-#define CHECKED 317
-#define GRAYED 318
-#define HELP 319
-#define INACTIVE 320
-#define MENUBARBREAK 321
-#define MENUBREAK 322
-#define MESSAGETABLE 323
-#define RCDATA 324
-#define STRINGTABLE 325
-#define VERSIONINFO 326
-#define FILEVERSION 327
-#define PRODUCTVERSION 328
-#define FILEFLAGSMASK 329
-#define FILEFLAGS 330
-#define FILEOS 331
-#define FILETYPE 332
-#define FILESUBTYPE 333
-#define BLOCKSTRINGFILEINFO 334
-#define BLOCKVARFILEINFO 335
-#define VALUE 336
-#define BLOCK 337
-#define MOVEABLE 338
-#define FIXED 339
-#define PURE 340
-#define IMPURE 341
-#define PRELOAD 342
-#define LOADONCALL 343
-#define DISCARDABLE 344
-#define NOT 345
-#define QUOTEDUNISTRING 346
-#define QUOTEDSTRING 347
-#define STRING 348
-#define NUMBER 349
-#define SIZEDUNISTRING 350
-#define SIZEDSTRING 351
-#define IGNORED_TOKEN 352
-#define NEG 353
-
-
-
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 69 "rcparse.y"
-typedef union YYSTYPE {
-  rc_accelerator acc;
-  rc_accelerator *pacc;
-  rc_dialog_control *dialog_control;
-  rc_menuitem *menuitem;
-  struct
-  {
-    rc_rcdata_item *first;
-    rc_rcdata_item *last;
-  } rcdata;
-  rc_rcdata_item *rcdata_item;
-  rc_fixed_versioninfo *fixver;
-  rc_ver_info *verinfo;
-  rc_ver_stringinfo *verstring;
-  rc_ver_varinfo *vervar;
-  rc_toolbar_item *toobar_item;
-  rc_res_id id;
-  rc_res_res_info res_info;
-  struct
-  {
-    rc_uint_type on;
-    rc_uint_type off;
-  } memflags;
-  struct
-  {
-    rc_uint_type val;
-    /* Nonzero if this number was explicitly specified as long.  */
-    int dword;
-  } i;
-  rc_uint_type il;
-  rc_uint_type is;
-  const char *s;
-  struct
-  {
-    rc_uint_type length;
-    const char *s;
-  } ss;
-  unichar *uni;
-  struct
-  {
-    rc_uint_type length;
-    const unichar *s;
-  } suni;
-} YYSTYPE;
-/* Line 1275 of yacc.c.  */
-#line 278 "rcparse.h"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-extern YYSTYPE yylval;
-
-
-
diff -r -N -u binutils-2.21.51/binutils/readelf.c binutils/binutils/readelf.c
--- binutils-2.21.51/binutils/readelf.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/binutils/readelf.c	2011-07-06 12:44:26.137253000 +0100
@@ -115,6 +115,7 @@
 #include "elf/ip2k.h"
 #include "elf/lm32.h"
 #include "elf/iq2000.h"
+#include "elf/lx.h"
 #include "elf/m32c.h"
 #include "elf/m32r.h"
 #include "elf/m68k.h"
@@ -1170,6 +1171,10 @@
 	  rtype = elf_xtensa_reloc_type (type);
 	  break;
 
+	case EM_LX:
+	  rtype = elf_lx_reloc_type (type);
+	  break;
+
 	case EM_LATTICEMICO32:
 	  rtype = elf_lm32_reloc_type (type);
 	  break;
@@ -8837,6 +8842,14 @@
     print_symbol (25, GET_DYNAMIC_NAME (psym->st_name));
   else
     printf (_(" <corrupt: %14ld>"), psym->st_name);
+
+  if (is_STO_MOVEABLE(psym->st_other)) {
+      printf(" (moveable) ");
+  }
+  if (is_STO_USED(psym->st_other)) {
+      printf(" (used) ");
+  }
+
   putchar ('\n');
 }
 
@@ -9153,6 +9166,13 @@
 	      print_symbol (25, psym->st_name < strtab_size
 			    ? strtab + psym->st_name : _("<corrupt>"));
 
+              if (is_STO_MOVEABLE(psym->st_other)) {
+                printf(" (moveable) ");
+              }
+              if (is_STO_USED(psym->st_other)) {
+                printf(" (used) ");
+              }
+
 	      if (section->sh_type == SHT_DYNSYM &&
 		  version_info[DT_VERSIONTAGIDX (DT_VERSYM)] != 0)
 		{
@@ -9701,6 +9721,8 @@
     case EM_XTENSA_OLD:
     case EM_XTENSA:
       return reloc_type == 1; /* R_XTENSA_32.  */
+    case EM_LX:
+      return reloc_type == 2; /* R_LX_32. */
     default:
       error (_("Missing knowledge of 32-bit reloc types used in DWARF sections of machine number %d\n"),
 	     elf_header.e_machine);
@@ -9788,6 +9810,8 @@
       return reloc_type == 22;	/* R_S390_64 */
     case EM_MIPS:
       return reloc_type == 18;	/* R_MIPS_64 */
+    case EM_LX:
+      return reloc_type == 3; /* R_LX_32_PCREL. */
     default:
       return FALSE;
     }
@@ -9875,6 +9899,8 @@
     case EM_XC16X:
     case EM_C166:
       return reloc_type == 2; /* R_XC16C_ABS_16.  */
+    case EM_LX:
+      return reloc_type == 1; /* R_LX_16. */
     default:
       return FALSE;
     }
diff -r -N -u binutils-2.21.51/binutils/sysinfo.c binutils/binutils/sysinfo.c
--- binutils-2.21.51/binutils/sysinfo.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/sysinfo.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1641 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     COND = 258,
-     REPEAT = 259,
-     TYPE = 260,
-     NAME = 261,
-     NUMBER = 262,
-     UNIT = 263
-   };
-#endif
-#define COND 258
-#define REPEAT 259
-#define TYPE 260
-#define NAME 261
-#define NUMBER 262
-#define UNIT 263
-
-
-
-
-/* Copy the first part of user declarations.  */
-#line 21 "sysinfo.y"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-static char writecode;
-static char *it;
-static int code;
-static char * repeat;
-static char *oldrepeat;
-static char *name;
-static int rdepth;
-static char *names[] = {" ","[n]","[n][m]"};
-static char *pnames[]= {"","*","**"};
-
-static int yyerror (char *s);
-extern int yylex (void);
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 40 "sysinfo.y"
-typedef union YYSTYPE {
- int i;
- char *s;
-} YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 115 "sysinfo.c"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 214 of yacc.c.  */
-#line 127 "sysinfo.c"
-
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
-
-# ifndef YYFREE
-#  define YYFREE free
-# endif
-# ifndef YYMALLOC
-#  define YYMALLOC malloc
-# endif
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
-#  endif
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-# endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
-
-
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  short yyss;
-  YYSTYPE yyvs;
-  };
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAXIMUM)
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  register YYSIZE_T yyi;		\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (0)
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (0)
-
-#endif
-
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
-#define YYFINAL  3
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   38
-
-/* YYNTOKENS -- Number of terminals. */
-#define YYNTOKENS  11
-/* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  19
-/* YYNRULES -- Number of rules. */
-#define YYNRULES  27
-/* YYNRULES -- Number of states. */
-#define YYNSTATES  55
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   263
-
-#define YYTRANSLATE(YYX) 						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       5,     6,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       7,     8,     9,    10
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const unsigned char yyprhs[] =
-{
-       0,     0,     3,     4,     7,    10,    11,    12,    19,    22,
-      25,    28,    29,    30,    37,    38,    45,    46,    57,    59,
-      60,    64,    67,    71,    72,    73,    77,    78
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
-{
-      12,     0,    -1,    -1,    13,    14,    -1,    15,    14,    -1,
-      -1,    -1,     5,     8,     9,    16,    17,     6,    -1,    22,
-      17,    -1,    20,    17,    -1,    18,    17,    -1,    -1,    -1,
-       5,     4,     8,    19,    17,     6,    -1,    -1,     5,     3,
-       8,    21,    17,     6,    -1,    -1,     5,    25,     5,    24,
-      26,     6,    27,    23,    28,     6,    -1,     7,    -1,    -1,
-       5,     8,     6,    -1,     9,    10,    -1,     5,     8,     6,
-      -1,    -1,    -1,     5,    29,     6,    -1,    -1,    29,     5,
-       8,     8,     6,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
-{
-       0,    54,    54,    54,    92,    93,    98,    97,   169,   170,
-     171,   172,   176,   175,   223,   222,   250,   249,   357,   358,
-     362,   367,   373,   374,   377,   378,   380,   382
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "COND", "REPEAT", "'('", "')'", "TYPE",
-  "NAME", "NUMBER", "UNIT", "$accept", "top", "@1", "it_list", "it", "@2",
-  "it_field_list", "repeat_it_field", "@3", "cond_it_field", "@4",
-  "it_field", "@5", "attr_type", "attr_desc", "attr_size", "attr_id",
-  "enums", "enum_list", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
-{
-       0,   256,   257,   258,   259,    40,    41,   260,   261,   262,
-     263
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
-{
-       0,    11,    13,    12,    14,    14,    16,    15,    17,    17,
-      17,    17,    19,    18,    21,    20,    23,    22,    24,    24,
-      25,    26,    27,    27,    28,    28,    29,    29
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
-{
-       0,     2,     0,     2,     2,     0,     0,     6,     2,     2,
-       2,     0,     0,     6,     0,     6,     0,    10,     1,     0,
-       3,     2,     3,     0,     0,     3,     0,     5
-};
-
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const unsigned char yydefact[] =
-{
-       2,     0,     5,     1,     0,     3,     5,     0,     4,     6,
-      11,     0,     0,    11,    11,    11,     0,     0,     0,     0,
-       7,    10,     9,     8,    14,    12,     0,    19,    11,    11,
-      20,    18,     0,     0,     0,     0,     0,    15,    13,    21,
-      23,     0,    16,     0,    24,    22,    26,     0,     0,    17,
-       0,    25,     0,     0,    27
-};
-
-/* YYDEFGOTO[NTERM-NUM]. */
-static const yysigned_char yydefgoto[] =
-{
-      -1,     1,     2,     5,     6,    10,    12,    13,    29,    14,
-      28,    15,    44,    32,    19,    36,    42,    47,    48
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -14
-static const yysigned_char yypact[] =
-{
-     -14,     8,     4,   -14,     2,   -14,     4,     3,   -14,   -14,
-       6,     0,     7,     6,     6,     6,     9,    10,    11,    15,
-     -14,   -14,   -14,   -14,   -14,   -14,    16,    14,     6,     6,
-     -14,   -14,     5,    17,    18,    19,    20,   -14,   -14,   -14,
-      22,    23,   -14,    24,    27,   -14,   -14,    28,     1,   -14,
-      25,   -14,    29,    30,   -14
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const yysigned_char yypgoto[] =
-{
-     -14,   -14,   -14,    32,   -14,   -14,   -13,   -14,   -14,   -14,
-     -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -1
-static const unsigned char yytable[] =
-{
-      21,    22,    23,    16,    17,    18,    50,    51,     3,     4,
-       7,    11,     9,    20,    35,    33,    34,    24,    25,    26,
-      27,    31,    30,    37,    38,     0,    40,    41,     0,    39,
-      45,    43,    46,    52,    49,     0,    54,    53,     8
-};
-
-static const yysigned_char yycheck[] =
-{
-      13,    14,    15,     3,     4,     5,     5,     6,     0,     5,
-       8,     5,     9,     6,     9,    28,    29,     8,     8,     8,
-       5,     7,     6,     6,     6,    -1,     6,     5,    -1,    10,
-       6,     8,     5,     8,     6,    -1,     6,     8,     6
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
-{
-       0,    12,    13,     0,     5,    14,    15,     8,    14,     9,
-      16,     5,    17,    18,    20,    22,     3,     4,     5,    25,
-       6,    17,    17,    17,     8,     8,     8,     5,    21,    19,
-       6,     7,    24,    17,    17,     9,    26,     6,     6,    10,
-       6,     5,    27,     8,    23,     6,     5,    28,    29,     6,
-       5,     6,     8,     8,     6
-};
-
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-
-#define YYFAIL		goto yyerrlab
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
-      YYERROR;							\
-    }								\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
-
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
-#endif
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
-#endif
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (0)
-
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
-
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_stack_print (short *bottom, short *top)
-#else
-static void
-yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
-#endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (0)
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_reduce_print (int yyrule)
-#else
-static void
-yy_reduce_print (yyrule)
-    int yyrule;
-#endif
-{
-  int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
-yystrlen (const char *yystr)
-#   else
-yystrlen (yystr)
-     const char *yystr;
-#   endif
-{
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
-    continue;
-
-  return yys - yystr - 1;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-#   if defined (__STDC__) || defined (__cplusplus)
-yystpcpy (char *yydest, const char *yysrc)
-#   else
-yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
-{
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-#endif /* !YYERROR_VERBOSE */
-
-
-
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  if (yytype < YYNTOKENS)
-    {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-  switch (yytype)
-    {
-      default:
-        break;
-    }
-  YYFPRINTF (yyoutput, ")");
-}
-
-#endif /* ! YYDEBUG */
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yydestruct (yytype, yyvaluep)
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  switch (yytype)
-    {
-
-      default:
-        break;
-    }
-}
-
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM);
-# else
-int yyparse ();
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-
-/* The lookahead symbol.  */
-int yychar;
-
-/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int
-yyparse (void)
-#else
-int
-yyparse ()
-
-#endif
-#endif
-{
-  
-  register int yystate;
-  register int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss;
-  yyvsp = yyvs;
-
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-	/* Give user a chance to reallocate the stack. Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
-
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-
-		    &yystacksize);
-
-	yyss = yyss1;
-	yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
-      {
-	short *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyoverflowlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
-    {
-        case 2:
-#line 54 "sysinfo.y"
-    {
-  switch (writecode)
-    {
-    case 'i':
-      printf("#ifdef SYSROFF_SWAP_IN\n");
-      break; 
-    case 'p':
-      printf("#ifdef SYSROFF_p\n");
-      break; 
-    case 'd':
-      break;
-    case 'g':
-      printf("#ifdef SYSROFF_SWAP_OUT\n");
-      break;
-    case 'c':
-      printf("#ifdef SYSROFF_PRINT\n");
-      printf("#include <stdio.h>\n");
-      printf("#include <stdlib.h>\n");
-      printf("#include <ansidecl.h>\n");
-      break;
-    }
- }
-    break;
-
-  case 3:
-#line 76 "sysinfo.y"
-    {
-  switch (writecode) {
-  case 'i':
-  case 'p':
-  case 'g':
-  case 'c':
-    printf("#endif\n");
-    break; 
-  case 'd':
-    break;
-  }
-}
-    break;
-
-  case 6:
-#line 98 "sysinfo.y"
-    {
-	it = yyvsp[-1].s; code = yyvsp[0].i;
-	switch (writecode) 
-	  {
-	  case 'd':
-	    printf("\n\n\n#define IT_%s_CODE 0x%x\n", it,code);
-	    printf("struct IT_%s;\n", it);
-	    printf("extern void sysroff_swap_%s_in (struct IT_%s *);\n",
-		   yyvsp[-1].s, it);
-	    printf("extern void sysroff_swap_%s_out (FILE *, struct IT_%s *);\n",
-		   yyvsp[-1].s, it);
-	    printf("extern void sysroff_print_%s_out (struct IT_%s *);\n",
-		   yyvsp[-1].s, it);
-	    printf("struct IT_%s { \n", it);
-	    break;
-	  case 'i':
-	    printf("void sysroff_swap_%s_in (struct IT_%s * ptr)\n",yyvsp[-1].s,it);
-	    printf("{\n");
-	    printf("\tunsigned char raw[255];\n");
-	    printf("\tint idx = 0;\n");
-	    printf("\tint size;\n");
-	    printf("\tmemset(raw,0,255);\n");	
-	    printf("\tmemset(ptr,0,sizeof(*ptr));\n");
-	    printf("\tsize = fillup(raw);\n");
-	    break;
-	  case 'g':
-	    printf("void sysroff_swap_%s_out (FILE * ffile, struct IT_%s * ptr)\n",yyvsp[-1].s,it);
-	    printf("{\n");
-	    printf("\tunsigned char raw[255];\n");
-	    printf("\tint idx = 16;\n");
-	    printf("\tmemset (raw, 0, 255);\n");
-	    printf("\tcode = IT_%s_CODE;\n", it);
-	    break;
-	  case 'o':
-	    printf("void sysroff_swap_%s_out (bfd * abfd, struct IT_%s * ptr)\n",yyvsp[-1].s, it);
-	    printf("{\n");
-	    printf("\tint idx = 0;\n");
-	    break;
-	  case 'c':
-	    printf("void sysroff_print_%s_out (struct IT_%s *ptr)\n",yyvsp[-1].s,it);
-	    printf("{\n");
-	    printf("itheader(\"%s\", IT_%s_CODE);\n",yyvsp[-1].s,yyvsp[-1].s);
-	    break;
-
-	  case 't':
-	    break;
-	  }
-
-      }
-    break;
-
-  case 7:
-#line 149 "sysinfo.y"
-    {
-  switch (writecode) {
-  case 'd': 
-    printf("};\n");
-    break;
-  case 'g':
-    printf("\tchecksum(ffile,raw, idx, IT_%s_CODE);\n", it);
-    
-  case 'i':
-
-  case 'o':
-  case 'c':
-    printf("}\n");
-  }
-}
-    break;
-
-  case 12:
-#line 176 "sysinfo.y"
-    {
-	  rdepth++;
-	  switch (writecode) 
-	    {
-	    case 'c':
-	      if (rdepth==1)
-	      printf("\tprintf(\"repeat %%d\\n\", %s);\n",yyvsp[0].s);
-	      if (rdepth==2)
-	      printf("\tprintf(\"repeat %%d\\n\", %s[n]);\n",yyvsp[0].s);
-	    case 'i':
-	    case 'g':
-	    case 'o':
-
-	      if (rdepth==1) 
-		{
-	      printf("\t{ int n; for (n = 0; n < %s; n++) {\n",    yyvsp[0].s);
-	    }
-	      if (rdepth == 2) {
-	      printf("\t{ int m; for (m = 0; m < %s[n]; m++) {\n",    yyvsp[0].s);
-	    }		
-
-	      break;
-	    }
-
-	  oldrepeat = repeat;
-         repeat = yyvsp[0].s;
-	}
-    break;
-
-  case 13:
-#line 206 "sysinfo.y"
-    {
-	  repeat = oldrepeat;
-	  oldrepeat =0;
-	  rdepth--;
-	  switch (writecode)
-	    {
-	    case 'i':
-	    case 'g':
-	    case 'o':
-	    case 'c':
-	  printf("\t}}\n");
-	}
-	}
-    break;
-
-  case 14:
-#line 223 "sysinfo.y"
-    {
-	  switch (writecode) 
-	    {
-	    case 'i':
-	    case 'g':
-	    case 'o':
-	    case 'c':
-	      printf("\tif (%s) {\n", yyvsp[0].s);
-	      break;
-	    }
-	}
-    break;
-
-  case 15:
-#line 236 "sysinfo.y"
-    {
-	  switch (writecode)
-	    {
-	    case 'i':
-	    case 'g':
-	    case 'o':
-	    case 'c':
-	  printf("\t}\n");
-	}
-	}
-    break;
-
-  case 16:
-#line 250 "sysinfo.y"
-    {name = yyvsp[0].s; }
-    break;
-
-  case 17:
-#line 252 "sysinfo.y"
-    {
-	  char *desc = yyvsp[-8].s;
-	  char *type = yyvsp[-6].s;
-	  int size = yyvsp[-5].i;
-	  char *id = yyvsp[-3].s;
-char *p = names[rdepth];
-char *ptr = pnames[rdepth];
-	  switch (writecode) 
-	    {
-	    case 'g':
-	      if (size % 8) 
-		{
-		  
-		  printf("\twriteBITS(ptr->%s%s,raw,&idx,%d);\n",
-			 id,
-			 names[rdepth], size);
-
-		}
-	      else {
-		printf("\twrite%s(ptr->%s%s,raw,&idx,%d,ffile);\n",
-		       type,
-		       id,
-		       names[rdepth],size/8);
-		}
-	      break;	      
-	    case 'i':
-	      {
-
-		if (rdepth >= 1)
-
-		  {
-		    printf("if (!ptr->%s) ptr->%s = (%s*)xcalloc(%s, sizeof(ptr->%s[0]));\n", 
-			   id, 
-			   id,
-			   type,
-			   repeat,
-			   id);
-		  }
-
-		if (rdepth == 2)
-		  {
-		    printf("if (!ptr->%s[n]) ptr->%s[n] = (%s**)xcalloc(%s[n], sizeof(ptr->%s[n][0]));\n", 
-			   id, 
-			   id,
-			   type,
-			   repeat,
-			   id);
-		  }
-
-	      }
-
-	      if (size % 8) 
-		{
-		  printf("\tptr->%s%s = getBITS(raw,&idx, %d,size);\n",
-			 id,
-			 names[rdepth], 
-			 size);
-		}
-	      else {
-		printf("\tptr->%s%s = get%s(raw,&idx, %d,size);\n",
-		       id,
-		       names[rdepth],
-		       type,
-		       size/8);
-		}
-	      break;
-	    case 'o':
-	      printf("\tput%s(raw,%d,%d,&idx,ptr->%s%s);\n", type,size/8,size%8,id,names[rdepth]);
-	      break;
-	    case 'd':
-	      if (repeat) 
-		printf("\t/* repeat %s */\n", repeat);
-
-		  if (type[0] == 'I') {
-		  printf("\tint %s%s; \t/* %s */\n",ptr,id, desc);
-		}
-		  else if (type[0] =='C') {
-		  printf("\tchar %s*%s;\t /* %s */\n",ptr,id, desc);
-		}
-	      else {
-		printf("\tbarray %s%s;\t /* %s */\n",ptr,id, desc);
-	      }
-		  break;
-		case 'c':
-	      printf("tabout();\n");
-		  printf("\tprintf(\"/*%-30s*/ ptr->%s = \");\n", desc, id);
-
-		  if (type[0] == 'I')
-		  printf("\tprintf(\"%%d\\n\",ptr->%s%s);\n", id,p);
-		  else   if (type[0] == 'C')
-		  printf("\tprintf(\"%%s\\n\",ptr->%s%s);\n", id,p);
-
-		  else   if (type[0] == 'B') 
-		    {
-		  printf("\tpbarray(&ptr->%s%s);\n", id,p);
-		}
-	      else abort();
-		  break;
-		}
-	}
-    break;
-
-  case 18:
-#line 357 "sysinfo.y"
-    { yyval.s = yyvsp[0].s; }
-    break;
-
-  case 19:
-#line 358 "sysinfo.y"
-    { yyval.s = "INT";}
-    break;
-
-  case 20:
-#line 363 "sysinfo.y"
-    { yyval.s = yyvsp[-1].s; }
-    break;
-
-  case 21:
-#line 368 "sysinfo.y"
-    { yyval.i = yyvsp[-1].i * yyvsp[0].i; }
-    break;
-
-  case 22:
-#line 373 "sysinfo.y"
-    { yyval.s = yyvsp[-1].s; }
-    break;
-
-  case 23:
-#line 374 "sysinfo.y"
-    { yyval.s = "dummy";}
-    break;
-
-  case 27:
-#line 382 "sysinfo.y"
-    { 
-	  switch (writecode) 
-	    {
-	    case 'd':
-	      printf("#define %s %s\n", yyvsp[-2].s,yyvsp[-1].s);
-	      break;
-	    case 'c':
-		printf("if (ptr->%s%s == %s) { tabout(); printf(\"%s\\n\");}\n", name, names[rdepth],yyvsp[-1].s,yyvsp[-2].s);
-	    }
-	}
-    break;
-
-
-    }
-
-/* Line 1000 of yacc.c.  */
-#line 1383 "sysinfo.c"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
-	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
-
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
-	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
-      else
-	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
-	  yychar = YYEMPTY;
-
-	}
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
-     goto yyerrorlab;
-#endif
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-	YYABORT;
-
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
-  *++yyvsp = yylval;
-
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-yyreturn:
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-  return yyresult;
-}
-
-
-#line 397 "sysinfo.y"
-
-/* four modes
-
-   -d write structure definitions for sysroff in host format
-   -i write functions to swap into sysroff format in
-   -o write functions to swap into sysroff format out
-   -c write code to print info in human form */
-
-int yydebug;
-
-int 
-main (int ac, char **av)
-{
-  yydebug=0;
-  if (ac > 1)
-    writecode = av[1][1];
-if (writecode == 'd')
-  {
-    printf("typedef struct { unsigned char *data; int len; } barray; \n");
-    printf("typedef  int INT;\n");
-    printf("typedef  char * CHARS;\n");
-
-  }
-  yyparse();
-return 0;
-}
-
-static int
-yyerror (char *s)
-{
-  fprintf(stderr, "%s\n" , s);
-  return 0;
-}
-
diff -r -N -u binutils-2.21.51/binutils/sysinfo.h binutils/binutils/sysinfo.h
--- binutils-2.21.51/binutils/sysinfo.h	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/sysinfo.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     COND = 258,
-     REPEAT = 259,
-     TYPE = 260,
-     NAME = 261,
-     NUMBER = 262,
-     UNIT = 263
-   };
-#endif
-#define COND 258
-#define REPEAT 259
-#define TYPE 260
-#define NAME 261
-#define NUMBER 262
-#define UNIT 263
-
-
-
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 40 "sysinfo.y"
-typedef union YYSTYPE {
- int i;
- char *s;
-} YYSTYPE;
-/* Line 1275 of yacc.c.  */
-#line 58 "sysinfo.h"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-extern YYSTYPE yylval;
-
-
-
diff -r -N -u binutils-2.21.51/binutils/syslex.c binutils/binutils/syslex.c
--- binutils-2.21.51/binutils/syslex.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/syslex.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1711 +0,0 @@
-/* A lexical scanner generated by flex */
-
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
- */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-
-#include <stdio.h>
-#include <unistd.h>
-
-
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
-
-
-#ifdef __cplusplus
-
-#include <stdlib.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_PROTOS
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yy_start = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yy_start - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#define YY_BUF_SIZE 16384
-
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-
-extern int yyleng;
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
-
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-	};
-
-static YY_BUFFER_STATE yy_current_buffer = 0;
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- */
-#define YY_CURRENT_BUFFER yy_current_buffer
-
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
-
-typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
-
-#define YY_NUM_RULES 25
-#define YY_END_OF_BUFFER 26
-static yyconst short int yy_accept[81] =
-    {   0,
-        0,    0,   26,   25,    7,    8,    5,   25,    1,    2,
-       11,   11,    6,    3,    4,   25,   25,   25,   25,   25,
-       25,   25,    0,    9,   11,    0,    6,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,   10,    0,    0,
-       13,    0,    0,    0,    0,   16,    0,    0,    0,    0,
-        0,   12,   15,    0,   23,    0,    0,    0,    0,    0,
-        0,   14,   18,    0,    0,    0,    0,    0,   17,    0,
-       24,    0,    0,    0,   20,   22,    0,   21,   19,    0
-    } ;
-
-static yyconst int yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    4,    1,    5,    1,    1,    1,    1,    1,    6,
-        7,    1,    1,    1,    1,    1,    1,    8,    9,    9,
-        9,    9,    9,    9,    9,    9,    9,    1,   10,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-       11,    1,   12,    1,    1,    1,   13,   14,   15,   16,
-
-       17,   18,   19,   20,   21,    1,    1,   22,    1,   23,
-       24,   25,    1,   26,   27,   28,   29,   30,    1,   31,
-       32,   33,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst int yy_meta[34] =
-    {   0,
-        1,    1,    2,    1,    1,    1,    1,    3,    3,    1,
-        1,    1,    3,    3,    3,    3,    3,    3,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1
-    } ;
-
-static yyconst short int yy_base[84] =
-    {   0,
-        0,    0,  100,  101,  101,  101,  101,   94,  101,  101,
-       26,   28,    0,  101,  101,   82,   26,   18,   74,   79,
-       78,   81,   88,  101,   32,    0,    0,   76,   65,   62,
-       61,   75,   20,   59,   61,   66,   58,    0,   57,   56,
-       54,   63,   53,   62,   54,  101,   59,   48,   53,   46,
-       59,  101,   44,   43,  101,   41,   55,   46,   53,   44,
-       31,  101,  101,   39,   27,   21,   39,   19,  101,   35,
-      101,   33,   26,   29,  101,  101,   28,  101,  101,  101,
-       58,   61,   41
-    } ;
-
-static yyconst short int yy_def[84] =
-    {   0,
-       80,    1,   80,   80,   80,   80,   80,   81,   80,   80,
-       80,   80,   82,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   81,   80,   80,   83,   82,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   83,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,    0,
-       80,   80,   80
-    } ;
-
-static yyconst short int yy_nxt[135] =
-    {   0,
-        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
-       14,   15,   16,   17,   18,    4,    4,    4,    4,    4,
-       19,    4,    4,    4,    4,   20,   21,    4,    4,   22,
-        4,    4,    4,   25,   25,   25,   25,   32,   29,   25,
-       25,   33,   44,   38,   79,   78,   30,   77,   45,   76,
-       75,   74,   73,   72,   71,   70,   26,   31,   23,   23,
-       23,   27,   69,   27,   68,   67,   66,   65,   64,   63,
-       62,   61,   60,   59,   58,   57,   56,   55,   54,   53,
-       52,   51,   50,   49,   48,   47,   46,   43,   42,   41,
-       40,   39,   24,   37,   36,   35,   34,   28,   24,   80,
-
-        3,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   80
-    } ;
-
-static yyconst short int yy_chk[135] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,   11,   11,   12,   12,   18,   17,   25,
-       25,   18,   33,   83,   77,   74,   17,   73,   33,   72,
-       70,   68,   67,   66,   65,   64,   11,   17,   81,   81,
-       81,   82,   61,   82,   60,   59,   58,   57,   56,   54,
-       53,   51,   50,   49,   48,   47,   45,   44,   43,   42,
-       41,   40,   39,   37,   36,   35,   34,   32,   31,   30,
-       29,   28,   23,   22,   21,   20,   19,   16,    8,    3,
-
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
-       80,   80,   80,   80
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "syslex.l"
-#define INITIAL 0
-#define YY_NO_INPUT 1
-#define YY_NO_UNPUT 1
-#line 4 "syslex.l"
-/* Copyright 2001, 2003, 2005, 2007, 2011 Free Software Foundation, Inc.
-
-   This file is part of GNU Binutils.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with GLD; see the file COPYING.  If not, write to the Free
-   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
-   02110-1301, USA.  */
-
-#include "config.h"
-#ifdef HAVE_STRING_H
-#include <string.h>
-#else
-#ifdef HAVE_STRINGS_H
-#include <strings.h>
-#endif
-#endif
-#include "sysinfo.h"
-
-#ifndef YY_NO_UNPUT
-#define YY_NO_UNPUT
-#endif
-
-#ifndef yywrap
-static int yywrap (void) { return 1; }
-#endif
-
-extern int yylex (void);
-#line 458 "syslex.c"
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
-#else
-extern int yywrap YY_PROTO(( void ));
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
-
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
-#endif
-
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
-		{ \
-		int c = '*', n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-YY_DECL
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp = NULL, *yy_bp = NULL;
-	register int yy_act;
-
-#line 43 "syslex.l"
-
-#line 611 "syslex.c"
-
-	if ( yy_init )
-		{
-		yy_init = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-
-		yy_load_buffer_state();
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yy_start;
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 81 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 101 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-
-do_action:	/* This label is used only to access EOF actions. */
-
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 44 "syslex.l"
-{ return '(';}
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 45 "syslex.l"
-{ return ')';}
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 46 "syslex.l"
-{ return '[';}
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 47 "syslex.l"
-{ return ']';}
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 48 "syslex.l"
-{ ; }
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 49 "syslex.l"
-{ ; } 
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 50 "syslex.l"
-{ ; }
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 51 "syslex.l"
-{ ; }
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 52 "syslex.l"
-{
-	yylval.s = malloc (yyleng - 1);
-	memcpy (yylval.s, yytext + 1, yyleng - 2);
-	yylval.s[yyleng - 2] = '\0';
-        return NAME;
-	}
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 59 "syslex.l"
-{
-        yylval.i = strtol(yytext,0,16);
-	return  NUMBER;
-	}
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 64 "syslex.l"
-{
-        yylval.i = atoi(yytext);
-	return  NUMBER;
-	}
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 70 "syslex.l"
-{ yylval.i =1 ;return UNIT;}
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 71 "syslex.l"
-{ yylval.i = 1; return UNIT;}
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 72 "syslex.l"
-{ yylval.i= 8; return UNIT;}
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 73 "syslex.l"
-{ yylval.i = 8; return UNIT;}
-	YY_BREAK
-case 16:
-YY_RULE_SETUP
-#line 75 "syslex.l"
-{ yylval.s = "INT"; return TYPE;}
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 76 "syslex.l"
-{ yylval.s = "BARRAY"; return TYPE;}
-	YY_BREAK
-case 18:
-YY_RULE_SETUP
-#line 77 "syslex.l"
-{ yylval.s = "CHARS"; return TYPE;}
-	YY_BREAK
-case 19:
-YY_RULE_SETUP
-#line 78 "syslex.l"
-{ yylval.i = 0; return NUMBER;}
-	YY_BREAK
-case 20:
-YY_RULE_SETUP
-#line 79 "syslex.l"
-{ yylval.i = -4; return NUMBER;}
-	YY_BREAK
-case 21:
-YY_RULE_SETUP
-#line 80 "syslex.l"
-{ yylval.i = -2; return NUMBER; }
-	YY_BREAK
-case 22:
-YY_RULE_SETUP
-#line 81 "syslex.l"
-{ yylval.i = -1; return NUMBER; }
-	YY_BREAK
-case 23:
-YY_RULE_SETUP
-#line 82 "syslex.l"
-{ return COND;}
-	YY_BREAK
-case 24:
-YY_RULE_SETUP
-#line 83 "syslex.l"
-{ return REPEAT;}
-	YY_BREAK
-case 25:
-YY_RULE_SETUP
-#line 84 "syslex.l"
-ECHO;
-	YY_BREAK
-#line 830 "syslex.c"
-case YY_STATE_EOF(INITIAL):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state();
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer() )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap() )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of yylex */
-
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
-
-	else
-		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
-
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
-#endif
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
-
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	if ( yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
-
-	return ret_val;
-	}
-
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-static yy_state_type yy_get_previous_state()
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 81 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-	}
-
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 81 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 80);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
-
-
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
-
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
-
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
-
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput()
-#else
-static int input()
-#endif
-	{
-	int c;
-
-	*yy_c_buf_p = yy_hold_char;
-
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
-
-			switch ( yy_get_next_buffer() )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/* fall through */
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap() )
-						return EOF;
-
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
-
-	return c;
-	}
-#endif /* YY_NO_INPUT */
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
-
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
-		return;
-
-	if ( yy_current_buffer )
-		{
-		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
-
-
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
-	if ( ! b )
-		return;
-
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
-
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
-
-	{
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
-	{
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
-	}
-
-
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b );
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
-#endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
-
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
-
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
-
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
-
-
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
-
-
-/* Internal utility routines. */
-
-#ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-	}
-#endif
-
-#ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-	}
-#endif
-
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
-
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 84 "syslex.l"
diff -r -N -u binutils-2.21.51/binutils/testsuite/binutils-all/objcopy.exp binutils/binutils/testsuite/binutils-all/objcopy.exp
--- binutils-2.21.51/binutils/testsuite/binutils-all/objcopy.exp	2011-06-14 09:27:52.000000000 +0100
+++ binutils/binutils/testsuite/binutils-all/objcopy.exp	2011-07-06 12:44:26.137253000 +0100
@@ -535,7 +535,7 @@
 	return 1
     }
     
-    if { $res != "" } {
+    if { $res != "" && ![istarget lx-*-*] } {
 	lappend flags "additional_flags=[lindex $res 1]"
 	set add_libs "testglue.o"
     } else {
@@ -624,7 +624,10 @@
 	setup_xfail "arm*-*-pe"
 	setup_xfail "*-*-mingw*"
 	setup_xfail "*-*-cygwin*"
-    
+
+	# To be fixed : why does it fail with the ST200 backend ?
+	setup_xfail "lx-*-*"
+
 	fail $test1
     }
 
@@ -650,6 +653,7 @@
     global NM
     global NMFLAGS
     global host_triplet
+    global target_alias
 
     remote_file build delete tmpdir/striprog
     remote_download build tmpdir/copyprog tmpdir/striprog
@@ -680,9 +684,24 @@
     }
 
     set exec_output [binutils_run $NM "$NMFLAGS ${copyfile}"]
-    if ![string match "*: no symbols*" $exec_output] {
-	fail $test
-	return
+    switch $target_alias {
+	lx-elf32 {
+	    regsub -lineanchor {^[0-9a-fA-F]+ T __dotsyscall}    $exec_output "" exec_output
+	    regsub -lineanchor {^[0-9a-fA-F]+ D _runtimeversion} $exec_output "" exec_output
+	    regsub -lineanchor {^[0-9a-fA-F]+ T __text_start}    $exec_output "" exec_output
+	    regsub {[[:space:]]+} $exec_output "" exec_output
+
+	    if ![string match "" $exec_output] {
+		fail $test
+		return
+	    }
+	}
+	default {
+	    if ![string match "*: no symbols*" $exec_output] {
+		fail $test
+		return
+	    }
+	}
     }
     pass $test
 }
@@ -730,7 +749,12 @@
 
 	# Using "" not {} to get the \n and \r translated.
 	regsub "^\[0-9a-fA-F\]+\[ \]+T Main\[\n\r\]+" $exec_output "" exec_output
-    }
+    } else { if [istarget lx-*-*] {
+	regsub -lineanchor {^[0-9a-fA-F]+ T __dotsyscall}    $exec_output "" exec_output
+	regsub -lineanchor {^[0-9a-fA-F]+ D _runtimeversion} $exec_output "" exec_output
+	regsub -lineanchor {^[0-9a-fA-F]+ T __text_start}    $exec_output "" exec_output
+	regsub -all {[\n\r]+} $exec_output "" exec_output
+    }}
 
     if {![regexp {^([0-9a-fA-F]+)?[ ]+[TD] main} $exec_output] \
          && ![regexp {^([0-9a-fA-F]+)?[ ]+[TD] _main} $exec_output]} {
diff -r -N -u binutils-2.21.51/binutils/testsuite/binutils-all/objdump.exp binutils/binutils/testsuite/binutils-all/objdump.exp
--- binutils-2.21.51/binutils/testsuite/binutils-all/objdump.exp	2010-02-23 12:32:54.000000000 +0000
+++ binutils/binutils/testsuite/binutils-all/objdump.exp	2010-06-07 14:41:42.080337000 +0100
@@ -42,7 +42,7 @@
 lappend cpus_expected mips mn10200 mn10300 ms1 msp ns32k pj powerpc pyramid
 lappend cpus_expected romp rs6000 s390 sh sparc
 lappend cpus_expected tahoe tic54x tic80 tms320c30 tms320c4x tms320c54x v850
-lappend cpus_expected vax we32k x86-64 xscale xtensa z8k z8001 z8002
+lappend cpus_expected vax we32k x86-64 xscale xtensa z8k z8001 z8002 st220 st231 st240
 
 # Make sure the target CPU shows up in the list.
 lappend cpus_expected ${target_cpu}
diff -r -N -u binutils-2.21.51/binutils/testsuite/binutils-all/readelf.exp binutils/binutils/testsuite/binutils-all/readelf.exp
--- binutils-2.21.51/binutils/testsuite/binutils-all/readelf.exp	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/testsuite/binutils-all/readelf.exp	2011-07-06 12:44:26.137253000 +0100
@@ -188,7 +188,7 @@
 	".*DW_TAG_compile_unit.*"
 	".*DW_TAG_subprogram.*"
 	".*DW_TAG_base_type.*"
-	".*DW_AT_producer.*(GNU C|indirect string).*"
+	".*DW_AT_producer.*(GNU C|indirect string|-D__ST200CC_VERSION__).*"
 	".*DW_AT_language.*ANSI C.*"
 	".*DW_AT_name.*(testprog.c|indirect string).*"
 	".*DW_AT_name.*fn.*"
diff -r -N -u binutils-2.21.51/binutils/testsuite/binutils-all/readelf.s binutils/binutils/testsuite/binutils-all/readelf.s
--- binutils-2.21.51/binutils/testsuite/binutils-all/readelf.s	2010-12-06 09:23:27.000000000 +0000
+++ binutils/binutils/testsuite/binutils-all/readelf.s	2011-07-06 12:44:26.137253000 +0100
@@ -5,12 +5,12 @@
  +\[ 0\] +NULL +00000000 000000 000000 00 +0 +0 +0
 # On the normal MIPS systems, sections must be aligned to 16 byte
 # boundaries. On IA64, text sections are aligned to 16 byte boundaries.
- +\[ 1\] .text +PROGBITS +00000000 0000(34|40) 0000(08|10) 00 +AX +0 +0 +(.|..)
+ +\[ 1\] .text +PROGBITS +00000000 0000(34|38|40) 0000(08|10) 00 +AX +0 +0 +(.|..)
  +\[ 2\] .rel.+text +REL. +0+ 0+.* 00000. 0. +. +1 +4
 # MIPS targets put .rela.text here.
 #...
- +\[ .\] .data +PROGBITS +00000000 0000(3c|48|50) 0000(04|10) 00 +WA +0 +0 +(.|..)
- +\[ .\] .bss +NOBITS +00000000 0000(40|4c|60) 000000 00 +WA +0 +0 +(.|..)
+ +\[ .\] .data +PROGBITS +00000000 0000(3c|40|48|50) 0000(04|10) 00 +WA +0 +0 +(.|..)
+ +\[ .\] .bss +NOBITS +00000000 0000(40|44|4c|60) 000000 00 +WA +0 +0 +(.|..)
 # MIPS targets put .reginfo and .mdebug here.
 # v850 targets put .call_table_data and .call_table_text here.
 #...
diff -r -N -u binutils-2.21.51/binutils/version.c binutils/binutils/version.c
--- binutils-2.21.51/binutils/version.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/binutils/version.c	2011-07-06 12:44:26.137253000 +0100
@@ -23,6 +23,7 @@
 #include "sysdep.h"
 #include "bfd.h"
 #include "bucomm.h"
+#include "ST_version.h"
 
 /* Print the version number and copyright information, and exit.
    This implements the --version option for the various programs.  */
@@ -38,5 +39,7 @@
 This program is free software; you may redistribute it under the terms of\n\
 the GNU General Public License version 3 or (at your option) any later version.\n\
 This program has absolutely no warranty.\n"));
+  printf (_("STMicroelectronics %s: Version %s %s\n"), name,
+	  ST_BINUTILS_VERSION, ST_BINUTILS_VERSION_DATE);
   exit (0);
 }
diff -r -N -u binutils-2.21.51/boards/lx-elf32.exp binutils/boards/lx-elf32.exp
--- binutils-2.21.51/boards/lx-elf32.exp	1970-01-01 01:00:00.000000000 +0100
+++ binutils/boards/lx-elf32.exp	2008-05-23 16:14:35.620793000 +0100
@@ -0,0 +1,38 @@
+
+###############################################################################
+# Set variables used in target.exp:default_target_compile.
+
+if {[info exists CC_FOR_TARGET] && $CC_FOR_TARGET ne ""} {
+	set_board_info compiler $CC_FOR_TARGET
+} else {
+	set_board_info compiler "st200cc"
+}
+
+# Do not append -lm
+set_board_info mathlib  ""
+
+###############################################################################
+# Load the generic configuration for this board. This will define a
+# set of generic routines used by the tool to communicate with the
+# board.
+
+load_generic_config "sim"
+
+###############################################################################
+# Set variables used in sim.exp:sim_spawn
+
+if {[info exists SIM] && $SIM ne ""} {
+	set_board_info sim $SIM
+} else {
+	set_board_info sim "st200run -tsimfast"
+}
+
+###############################################################################
+# Set variables used in sim.exp:sim_load
+
+set_board_info sim_time_limit 600
+
+###############################################################################
+# Set variables used in binutils-all/objcopy.exp:
+
+set STRIPFLAGS "-K __text_start -K _runtimeversion -K __dotsyscall"
\ No newline at end of file
diff -r -N -u binutils-2.21.51/config/mh-mingw binutils/config/mh-mingw
--- binutils-2.21.51/config/mh-mingw	2011-04-13 08:41:36.000000000 +0100
+++ binutils/config/mh-mingw	2011-11-08 16:37:33.766079000 +0000
@@ -4,5 +4,8 @@
 CFLAGS += -D__USE_MINGW_ACCESS
 # Increase stack limit to a figure based on the Linux default, with 4MB added
 # as GCC turns out to need that much more to pass all the limits-* tests.
-LDFLAGS += -Wl,--stack,12582912
-BOOT_LDFLAGS += -Wl,--stack,12582912
+LDFLAGS += -Wl,--stack,0xF00000
+BOOT_LDFLAGS += -Wl,--stack,0xF00000
+# Activation of CYGPATH feature: Support for cygwin pathes in mingwin32 shell
+#   through syscall wrapping at linker level
+LDFLAGS += -Wl,--wrap,open,--wrap,creat,--wrap,fopen,--wrap,freopen,--wrap,remove,--wrap,rename,--wrap,unlink,--wrap,stat,--wrap,chdir,--wrap,rmdir,--wrap,opendir,--wrap,access
diff -r -N -u binutils-2.21.51/config/mt-st200 binutils/config/mt-st200
--- binutils-2.21.51/config/mt-st200	1970-01-01 01:00:00.000000000 +0100
+++ binutils/config/mt-st200	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,42 @@
+CFLAGS+=
+
+### Set LDFLAGS depending on hosts
+LDFLAGS = `				\
+  case "$(host)" in			\
+    *-*-cygwin*)			\
+      echo ""				\
+  ;;					\
+    *-*-linux*)				\
+      echo "-ldl"			\
+  ;;					\
+  *-sun-solaris*)			\
+      echo "-ldl"			\
+  ;;					\
+esac`
+
+EXT_DLL = `				\
+  case "$(host)" in			\
+    *-*-cygwin*)			\
+      echo ".dll"			\
+  ;;					\
+    *-*-linux*)				\
+      echo ".so"			\
+  ;;					\
+  *-sun-solaris*)			\
+      echo ".so"			\
+  ;;					\
+esac`
+
+
+EXT_LIB = `				\
+  case "$(host)" in			\
+    *-*-cygwin*)			\
+      echo ".lib"			\
+  ;;					\
+    *-*-linux*)				\
+      echo ".a"				\
+  ;;					\
+  *-sun-solaris*)			\
+      echo ".a"				\
+  ;;					\
+esac`
diff -r -N -u binutils-2.21.51/config.sub binutils/config.sub
--- binutils-2.21.51/config.sub	2011-04-13 08:41:36.000000000 +0100
+++ binutils/config.sub	2011-07-06 12:44:26.137253000 +0100
@@ -258,6 +258,7 @@
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| i370 | i860 | i960 | ia64 \
 	| ip2k | iq2000 \
+        | lx \
 	| lm32 \
 	| m32c | m32r | m32rle | m68000 | m68k | m88k \
 	| maxq | mb | microblaze | mcore | mep | metag \
@@ -298,6 +299,7 @@
 	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
 	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
 	| spu \
+	| st2[2-4][0-9] \
 	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
 	| ubicom32 \
 	| v850 | v850e \
@@ -367,6 +369,7 @@
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
 	| i*86-* | i860-* | i960-* | ia64-* \
 	| ip2k-* | iq2000-* \
+        | lx-* \
 	| lm32-* \
 	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
@@ -406,6 +409,7 @@
 	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
 	| sparclite-* \
 	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \
+	| st2[2-4][0-9]-* \
 	| tahoe-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
 	| tile-* | tilegx-* \
diff -r -N -u binutils-2.21.51/configure binutils/configure
--- binutils-2.21.51/configure	2011-06-14 09:27:52.000000000 +0100
+++ binutils/configure	2011-07-06 12:44:26.137253000 +0100
@@ -584,6 +584,7 @@
 GCC_FOR_TARGET
 CXX_FOR_TARGET
 CC_FOR_TARGET
+SIM
 OBJDUMP
 OBJCOPY
 WINDMC
@@ -3626,6 +3627,7 @@
 # Work in distributions that contain no compiler tools, like Autoconf.
 host_makefile_frag=/dev/null
 if test -d ${srcdir}/config ; then
+echo "Configuring for host= ${host}..."
 case "${host}" in
   i[3456789]86-*-msdosdjgpp*)
     host_makefile_frag="config/mh-djgpp"
@@ -6752,7 +6754,11 @@
 extra_nmflags_for_target=
 extra_ranlibflags_for_target=
 target_makefile_frag=/dev/null
+echo "Configuring for target= ${target}..."
 case "${target}" in
+  lx-*-elf32)
+    target_makefile_frag="config/mt-st200"
+    ;;
   spu-*-*)
     target_makefile_frag="config/mt-spu"
     ;;
@@ -9613,6 +9619,7 @@
 
 
 
+
 # Target tools.
 
 # Check whether --with-build-time-tools was given.
diff -r -N -u binutils-2.21.51/configure.ac binutils/configure.ac
--- binutils-2.21.51/configure.ac	2011-06-14 09:27:52.000000000 +0100
+++ binutils/configure.ac	2011-07-06 12:44:26.137253000 +0100
@@ -1072,6 +1072,7 @@
 # Work in distributions that contain no compiler tools, like Autoconf.
 host_makefile_frag=/dev/null
 if test -d ${srcdir}/config ; then
+echo "Configuring for host= ${host}..."
 case "${host}" in
   i[[3456789]]86-*-msdosdjgpp*)
     host_makefile_frag="config/mh-djgpp"
@@ -2236,7 +2237,11 @@
 extra_nmflags_for_target=
 extra_ranlibflags_for_target=
 target_makefile_frag=/dev/null
+echo "Configuring for target= ${target}..."
 case "${target}" in
+  lx-*-elf32)
+    target_makefile_frag="config/mt-st200"
+    ;;
   spu-*-*)
     target_makefile_frag="config/mt-spu"
     ;;
@@ -3077,6 +3082,7 @@
 NCN_STRICT_CHECK_TOOLS(OBJCOPY, objcopy)
 NCN_STRICT_CHECK_TOOLS(OBJDUMP, objdump)
 AC_SUBST(CC)
+AC_SUBST(SIM)
 AC_SUBST(CXX)
 AC_SUBST(CFLAGS)
 AC_SUBST(CXXFLAGS)
diff -r -N -u binutils-2.21.51/gas/as.c binutils/gas/as.c
--- binutils-2.21.51/gas/as.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/gas/as.c	2011-07-06 12:44:26.137253000 +0100
@@ -42,6 +42,7 @@
 #include "dwarf2dbg.h"
 #include "dw2gencfi.h"
 #include "bfdver.h"
+#include "ST_version.h"
 
 #ifdef HAVE_ITBL_CPU
 #include "itbl-ops.h"
@@ -223,6 +224,8 @@
 
   fprintf (stderr, _("GNU assembler version %s (%s) using BFD version %s\n"),
 	   VERSION, TARGET_ALIAS, BFD_VERSION_STRING);
+  fprintf (stderr, _("STMicroelectronics assembler: Version %s %s\n"),
+	   ST_BINUTILS_VERSION, ST_BINUTILS_VERSION_DATE);
 }
 
 static void
@@ -630,6 +633,8 @@
 This program has absolutely no warranty.\n"));
 	  printf (_("This assembler was configured for a target of `%s'.\n"),
 		  TARGET_ALIAS);
+	  printf (_("STMicroelectronics assembler: Version %s %s\n"),
+		  ST_BINUTILS_VERSION, ST_BINUTILS_VERSION_DATE);          
 	  exit (EXIT_SUCCESS);
 
 	case OPTION_EMULATION:
diff -r -N -u binutils-2.21.51/gas/config/tc-lx.c binutils/gas/config/tc-lx.c
--- binutils-2.21.51/gas/config/tc-lx.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/config/tc-lx.c	2011-08-25 16:05:17.282764000 +0100
@@ -0,0 +1,3985 @@
+/**
+*** (c) Copyright Hewlett-Packard Company 1999-2003
+***
+*** This program is free software; you can redistribute it and/or
+*** modify it under the terms of the GNU General Public License
+*** as published by the Free Software Foundation; either version
+*** 2 of the License, or (at your option) any later version.
+***
+*** This program is distributed in the hope that it will be useful,
+*** but WITHOUT ANY WARRANTY; without even the implied warranty of
+*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+*** General Public License for more details.
+***
+*** You should have received a copy of the GNU General Public License
+*** along with this program; if not, write to the Free Software
+*** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+**/
+
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
+
+/* Author Geoffrey Brown                */
+/* Modified by Giuseppe Desoli Jul 1999 */
+
+/**
+*** static char sccs_id[] = "@(#)tc-lx.c	1.20 07/18/00 13:19:21";
+**/
+
+#include "as.h"
+#include "obstack.h"
+#include "subsegs.h"
+#include "tc-lx.h"
+#include "opcode/lx.h"
+#include "libiberty.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+
+#ifdef OBJ_ELF
+#include "elf/lx.h"
+#include "dwarf2dbg.h"
+#include "dw2gencfi.h"
+#endif
+
+static void supported_cores (char buf[], size_t buflen);
+
+#define O_pseudo_fixup (O_max + 1)
+
+#define NELEMS(a)	((int) (sizeof (a)/sizeof ((a)[0])))
+
+#define STREQ(x,y) !strcmp((((x) != NULL) ? (x) : ""), (((y) != NULL) ? (y) : ""))
+#define STRNEQ(x,y,n) !strncmp((((x) != NULL) ? (x) : ""), (((y) != NULL) ? (y) : ""),(n))
+
+extern int target_big_endian;
+int emit_all_relocs = 0;
+/*TB begin*/
+int size_type_function = 1;
+/*TB end */
+static int nop_insertion_allowed = 1;
+/* Resource usage checking is disabled by default, because it
+   can produce false positives. */
+static int check_resource_usage = 0; 
+/* Bundle checking includes reordering of operations, and nop
+   insertion to make valid bundles.  Therefore if check_bundles
+   is false, these are both disabled and bundles will be
+   emitted as written, valid or not. */
+static int check_bundles = 1;
+/* Strict operand checking disallows certain operand types that
+   are allowed by the encoding but disallowed by the hardware:
+   for example, r63 as the destination of a multiply.
+   Normally we want strict operand checking, but some
+   verification tests prefer to disable it. */
+static int strict_operand_checking = 1;
+
+/* Core string passed as argument with -mcore option */
+char *mcore= NULL;
+
+/* Default values used if no assume directive is given */
+static const Lx_Core_Info *lx_core_info = NULL;
+
+int lx_cut = ELF_LX_CUT_0;
+int lx_abi = ELF_LX_ABI_NO;
+int lx_osabi = ELFOSABI_NONE;
+int lx_mode = ELF_LX_MODE_USER;
+int lx_core = -1;
+int lx_core_set = 0;
+int lx_cut_set = 0;
+int lx_abi_set = 0;
+int lx_osabi_set = 0;
+int lx_mode_set = 0;
+
+/* ST2xx NOP instruction encodings for alignment in code sections */
+static char const lx_noop_stop_bit[4] = { 0x00, 0x00, 0x00, 0x80 };
+static char const lx_noop[4] = { 0x00, 0x00, 0x00, 0x00 };
+static char const lx_bigend_noop_stop_bit[4] = { 0x80, 0x00, 0x00, 0x00 };
+static char const lx_bigend_noop[4] = { 0x00, 0x00, 0x00, 0x00 };
+
+
+
+/***********************************************/
+/*    Generic Globals for GAS                  */
+/***********************************************/
+
+const char comment_chars[] = "#";
+const char line_comment_chars[] = "#";
+const char line_separator_chars[] = ";";
+const char EXP_CHARS[] = "eE";
+const char FLT_CHARS[] = "dD";
+const int md_short_jump_size = 0;
+const int md_long_jump_size = 0;
+
+/***********************************************/
+/*           Local Types                       */
+/***********************************************/
+
+/* a fix up record                       */
+
+struct lx_fixup_s
+  {
+    expressionS exp;		/* the expression used            */
+    int where;			/* where (byte) in frag this goes */
+    bfd_reloc_code_real_type reloc;
+  };
+
+typedef struct lx_fixup_s lx_fixup_t;
+
+/* a single assembled instruction record */
+/* may include immediate extension word  */
+
+struct lxinsn_s
+  {
+    int cluster;		/* cluster for instruction                 */
+    int written;		/* written out ?                           */
+    const lxopc_t *opdef;	/* Opcode table entry for this insn        */
+    unsigned len;		/* length of instruction in words (1 or 2) */
+    unsigned insn[2];		/* instruction data                        */
+    int nfixups;		/* the number of fixups 0, 1, 2            */
+    lx_fixup_t fixup[2];	/* the actual fixups                       */
+    Bundling bundling;          /* the bundling type                       */
+  };
+
+typedef struct lxinsn_s lxinsn_t;
+
+#define LXCLUSTERS 4
+#define LXLANESPERCLUSTER 4
+
+/* We leave an extra slot in LXMAXINSN in case we need to emit a nop
+   bundle to gain even alignment before emitting a cluster.
+ */
+#define LXMAXINSN ((LXCLUSTERS*LXLANESPERCLUSTER)+1)
+
+/* Constant to tell if branches are required to be
+   emitted as the first syllable in a cluster */
+#define LXBRANCHFIRST 1
+
+static lxinsn_t insbuf[LXMAXINSN];
+static int insncnt = 0;
+
+#define LXLANEALIGNMENT 3 /* Minimal section alignment required to handle
+			     correctly odd/even constraints at link time.
+			     2**3 = 8 */
+/* 
+   Track the current text segment alginment so that syllable
+   alignments are correct (e.g. multiplies must be
+   in odd lanes).
+ */
+/* static int text_alignment = 0; */
+/* There may be several text segments, so we use now_seg->target_index to keep
+   track of the byte counter, because this is a target dependant field only 
+   used in the linker  */
+
+static void set_byte_counter(asection *sec, int value);
+void set_byte_counter(asection *sec, int value)
+{
+  sec->target_index = value;
+}
+
+static int get_byte_counter(asection *sec);
+int get_byte_counter(asection *sec)
+{
+  return sec->target_index;
+}
+
+static int is_code_section(asection *sec);
+int is_code_section(asection *sec)
+{
+  return ((bfd_get_section_flags (abfd, sec) & (SEC_CODE))) ;
+}
+
+static int cluster_size;	/* Size of current cluster, so far. */
+
+/****************************************************/
+/*  Register Table                                  */
+/*     These are used to generate the hash table    */
+/*     for registers                                */
+/****************************************************/
+
+struct lx_regspec_s
+  {
+    char base;
+    int cluster;
+    int number;
+    int step;
+  };
+
+typedef struct lx_regspec_s lx_regspec_t;
+
+static lx_regspec_t lx_regspec[] =
+{
+  {'b', 0, 8,  1},
+  {'b', 1, 8,  1},
+  {'b', 2, 8,  1},
+  {'b', 3, 8,  1},
+  {'r', 0, 64, 1},
+  {'r', 1, 64, 1},
+  {'r', 2, 64, 1},
+  {'r', 3, 64, 1},
+  {'p', 0, 62, 2},
+  {'p', 1, 62, 2},
+  {'p', 2, 62, 2},
+  {'p', 3, 62, 2},
+  {0, 0, 0, 0}
+};
+
+static lx_regspec_t *lx_regtable;
+
+/****************************************************/
+/*             Local Variables                      */
+/****************************************************/
+
+static struct hash_control *lx_opcode_hash;
+
+/****************************************************/
+/*  ASSEMBLER Pseudo-ops.  Some of this just        */
+/*  extends the default definitions                 */
+/*  others are LX specific                          */
+/****************************************************/
+
+enum unwrecord
+  {
+    UNW_HEADER,
+    UNW_PROLOGUE,
+    UNW_BODY,
+    UNW_MEM_STACK_F,
+    UNW_MEM_STACK_V,
+    UNW_PSP_GR,
+    UNW_PSP_SPREL,
+    UNW_RP_WHEN,
+    UNW_RP_GR,
+    UNW_RP_PSPREL,
+    UNW_RP_SPREL,
+    UNW_GR_MEM_S,
+    UNW_GR_MEM_L,
+    UNW_SPILL_BASE,
+    UNW_SPILL_MASK,
+    UNW_EPILOGUE,
+    UNW_LABEL_STATE,
+    UNW_COPY_STATE,
+    UNW_SPILL_PSREL,
+    UNW_SPILL_SPREL
+  };
+
+static void lx_align (int bytes, int is_byte);
+static void lx_align_bytes (int bytes);
+static void lx_align_ptwo (int pow);
+static void lx_skip (int mult);
+static void lx_cons (int size);
+static void lx_set_rta_flags (int);
+static void lx_set_assume_flags (int);
+static void lx_nop_insertion(int);
+static void lx_check_resources(int);
+static void lx_check_bundles(int);
+static void lx_strict_operand_checking(int);
+static void lx_float_cons (int type);
+static void lx_stringer (int append_zero);
+static void lx_ignore (int size);
+static void lx_proc (int start);
+static void lx_endp (int start);
+static void lx_type (int start);
+static void lx_unwind (int r);
+#if 0
+static void md_after_pass (void);
+#endif
+
+const pseudo_typeS md_pseudo_table[] =
+{
+    /* override ones defined in read.c */
+
+  {"ascii", lx_stringer, 0},
+  {"asciz", lx_stringer, 1},
+  {"byte", lx_cons, 1},
+  {"double", lx_float_cons, 'd'},
+  {"float", lx_float_cons, 'f'},
+  {"hword", lx_cons, 2},
+  {"int", lx_cons, 4},
+  {"long", lx_cons, 4},
+  {"octa", lx_cons, 16},
+  {"quad", lx_cons, 8},
+  {"short", lx_cons, 2},
+  {"single", lx_float_cons, 'f'},
+  {"string", lx_stringer, 1},
+  {"word", lx_cons, 4},
+
+    /* override ones defined in obj-elf.c */
+
+  {"2byte", lx_cons, 2},
+  {"4byte", lx_cons, 4},
+  {"8byte", lx_cons, 8},
+
+    /* lx-specific */
+
+  {"assume", lx_set_assume_flags, 0},
+  {"rta", lx_set_rta_flags, 0},
+  {"align", lx_align_bytes, 4},
+  {"balign", lx_align_bytes, 4},
+  {"balignw", lx_align_bytes, -2},
+  {"balignl", lx_align_bytes, -4},
+  {"data1", lx_cons, 1},
+  {"data2", lx_cons, 2},
+  {"data4", lx_cons, 4},
+  {"real4", lx_cons, 4},
+  {"data8", lx_cons, 8},	/* uncertain syntax */
+  {"real8", lx_cons, 8},	/* uncertain syntax */
+  {"skip", lx_skip, 0},		/* equiv to GNU .space */
+  {"space", lx_skip, 0},	/* equiv to GNU .space */
+  {"nopinsertion", lx_nop_insertion, 1},
+  {"nonopinsertion", lx_nop_insertion, 0},
+  {"checkresources", lx_check_resources, 1},
+  {"nocheckresources", lx_check_resources, 0},
+  {"checkbundles", lx_check_bundles, 1},
+  {"nocheckbundles", lx_check_bundles, 0},
+  {"strictoperandchecking", lx_strict_operand_checking, 1},
+  {"nostrictoperandchecking", lx_strict_operand_checking, 0},
+
+    /* unwind descriptor directives */
+
+  {"header", lx_unwind, (int) UNW_HEADER},
+  {"prologue", lx_unwind, (int) UNW_PROLOGUE},
+  {"body", lx_unwind, (int) UNW_BODY},
+  {"mem_stack_f", lx_unwind, (int) UNW_MEM_STACK_F},
+  {"mem_stack_v", lx_unwind, (int) UNW_MEM_STACK_V},
+  {"psp_gr", lx_unwind, (int) UNW_PSP_GR},
+  {"psp_sprel", lx_unwind, (int) UNW_PSP_SPREL},
+  {"rp_when", lx_unwind, (int) UNW_RP_WHEN},
+  {"rp_gr", lx_unwind, (int) UNW_RP_GR},
+  {"rp_psrel", lx_unwind, (int) UNW_RP_PSPREL},
+  {"rp_sprel", lx_unwind, (int) UNW_RP_SPREL},
+  {"gr_mem_s", lx_unwind, (int) UNW_GR_MEM_S},
+  {"gr_mem_l", lx_unwind, (int) UNW_GR_MEM_L},
+  {"spill_base", lx_unwind, (int) UNW_SPILL_BASE},
+  {"spill_mask", lx_unwind, (int) UNW_SPILL_MASK},
+  {"epilogue", lx_unwind, (int) UNW_EPILOGUE},
+  {"label_state", lx_unwind, (int) UNW_LABEL_STATE},
+  {"copy_state", lx_unwind, UNW_COPY_STATE},
+  {"spill_psrel", lx_unwind, (int) UNW_SPILL_PSREL},
+  {"spill_sprel", lx_unwind, (int) UNW_SPILL_SPREL},
+
+    /* ignore cs directives */
+
+  {"comment", lx_ignore, 0},
+  {"endp", lx_endp, 0},
+  {"entry", lx_ignore, 0},
+  {"import", lx_ignore, 0},
+  {"proc", lx_proc, 1},
+  {"return", lx_ignore, 0},
+  {"sversion", lx_ignore, 0},
+  {"trace", lx_ignore, 0},
+  {"type", lx_type, 0},
+  {"call", lx_ignore, 0},
+  {"longjmp", lx_ignore, 0},
+  {"_longjmp", lx_ignore, 0},
+  {"__longjmp", lx_ignore, 0},
+  {"siglongjmp", lx_ignore, 0},
+  {"_siglongjmp", lx_ignore, 0},
+  {"setjmp", lx_ignore, 0},
+  {"_setjmp", lx_ignore, 0},
+  {"__setjmp", lx_ignore, 0},
+  {"sigsetjmp", lx_ignore, 0},
+  {"_sigsetjmp", lx_ignore, 0},
+
+    /* ignore some standard ones */
+
+  {"dc", s_ignore, 0},
+  {"dc.b", s_ignore, 0},
+  {"dc.d", s_ignore, 0},
+  {"dc.l", s_ignore, 0},
+  {"dc.s", s_ignore, 0},
+  {"dc.w", s_ignore, 0},
+  {"dc.x", s_ignore, 0},
+  {"dcb", s_ignore, 0},
+  {"dcb.b", s_ignore, 0},
+  {"dcb.d", s_ignore, 0},
+  {"dcb.l", s_ignore, 0},
+  {"dcb.s", s_ignore, 0},
+  {"dcb.w", s_ignore, 0},
+  {"dcb.x", s_ignore, 0},
+  {"ds", s_ignore, 0},
+  {"ds.b", s_ignore, 0},
+  {"ds.d", s_ignore, 0},
+  {"ds.l", s_ignore, 0},
+  {"ds.p", s_ignore, 0},
+  {"ds.s", s_ignore, 0},
+  {"ds.w", s_ignore, 0},
+  {"ds.x", s_ignore, 0},
+  {"lflags", s_ignore, 0},
+  {"mri", s_ignore, 0},
+  {".mri", s_ignore, 0},
+  {"org", s_ignore, 0},
+  {"p2align", lx_align_ptwo, 2},
+  {"p2alignw", lx_align_ptwo, -2},
+  {"p2alignl", lx_align_ptwo, -4},
+#ifdef OBJ_ELF
+  { "file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0},
+  { "loc", dwarf2_directive_loc, 0},
+#endif
+  {NULL, 0, 0}
+};
+
+enum reloc_func
+  {
+    FUNC_FPTR_RELATIVE,
+    FUNC_GP_RELATIVE,
+    FUNC_GOT_RELATIVE,
+    FUNC_GOTX_RELATIVE,
+    FUNC_PLT_RELATIVE,
+    FUNC_SEG_RELATIVE,
+    FUNC_LTV_RELATIVE,
+    FUNC_GOT_FPTR_RELATIVE,
+    FUNC_IPLT_RELOC,
+    FUNC_NEG_GP_RELATIVE,
+    FUNC_TP_RELATIVE,
+    FUNC_DTP_RELATIVE,
+    FUNC_DTP_MODULE,
+    FUNC_DTP_INDEX,
+    FUNC_DTP_LOAD_MODULE,
+    FUNC_GOT_TP_RELATIVE,
+    FUNC_GOT_DTP_INDEX_RELATIVE,
+    FUNC_GOT_DTP_LOAD_MODULE_RELATIVE
+  };
+
+/* Pseudo functions used to indicate relocation types (these functions
+   start with an at sign (@).  */
+static struct
+  {
+    const char *name;
+    enum pseudo_type
+      {
+	PSEUDO_FUNC_NONE,
+	PSEUDO_FUNC_RELOC
+      }
+    type;
+    union
+      {
+	unsigned long ival;
+	symbolS *sym;
+      }
+    u;
+    bfd_reloc_code_real_type reloc_lo, reloc_hi, reloc_32;
+  }
+pseudo_func[] =
+  {
+    /* reloc pseudo functions:  */
+    { "fptr",	PSEUDO_FUNC_RELOC, { 0 }, BFD_RELOC_UNUSED,
+      BFD_RELOC_UNUSED,              BFD_RELOC_LX_FPTR32 },
+    { "gprel",	PSEUDO_FUNC_RELOC, { 0 }, BFD_RELOC_LX_GPREL_LO9,
+      BFD_RELOC_LX_GPREL_HI23,       BFD_RELOC_UNUSED },
+    { "gotoff",	PSEUDO_FUNC_RELOC, { 0 }, BFD_RELOC_LX_GOTOFF_LO9,
+      BFD_RELOC_LX_GOTOFF_HI23,      BFD_RELOC_UNUSED },
+    { "gotoffx",PSEUDO_FUNC_RELOC, { 0 }, BFD_RELOC_LX_GOTOFFX_LO9,
+      BFD_RELOC_LX_GOTOFFX_HI23,     BFD_RELOC_UNUSED },
+    { "pltoff",	PSEUDO_FUNC_RELOC, { 0 }, BFD_RELOC_LX_PLTOFF_LO9,
+      BFD_RELOC_LX_PLTOFF_HI23,      BFD_RELOC_UNUSED },
+    { "segrel",	PSEUDO_FUNC_RELOC, { 0 }, BFD_RELOC_UNUSED,
+      BFD_RELOC_UNUSED,              BFD_RELOC_LX_SEGREL32 },
+    { "ltv",	PSEUDO_FUNC_RELOC, { 0 }, BFD_RELOC_UNUSED,
+      BFD_RELOC_UNUSED,              BFD_RELOC_LX_LTV32},
+    /* placeholder for FUNC_GOT_FPTR_RELATIVE */
+    { "", 0, { 0 }, BFD_RELOC_LX_GOTOFF_FPTR_LO9,
+      BFD_RELOC_LX_GOTOFF_FPTR_HI23, BFD_RELOC_UNUSED },
+    { "iplt",	PSEUDO_FUNC_RELOC, { 0 }, BFD_RELOC_UNUSED,
+      BFD_RELOC_UNUSED,              BFD_RELOC_LX_IPLT },
+    { "neggprel",PSEUDO_FUNC_RELOC,{ 0 }, BFD_RELOC_LX_NEG_GPREL_LO9,
+      BFD_RELOC_LX_NEG_GPREL_HI23,   BFD_RELOC_UNUSED },
+    { "tprel",   PSEUDO_FUNC_RELOC,{ 0 }, BFD_RELOC_LX_TPREL_LO9,
+      BFD_RELOC_LX_TPREL_HI23,       BFD_RELOC_LX_TPREL32 },
+    { "dtprel",  PSEUDO_FUNC_RELOC,{ 0 }, BFD_RELOC_LX_DTPREL_LO9,
+      BFD_RELOC_LX_DTPREL_HI23,      BFD_RELOC_LX_DTPREL32 },
+    { "dtpmod",  PSEUDO_FUNC_RELOC,{ 0 }, BFD_RELOC_UNUSED,
+      BFD_RELOC_UNUSED,              BFD_RELOC_LX_DTPMOD32 },
+    { "dtpndx",  PSEUDO_FUNC_RELOC,{ 0 }, BFD_RELOC_UNUSED,
+      BFD_RELOC_UNUSED,              BFD_RELOC_UNUSED },
+    { "dtpldm",  PSEUDO_FUNC_RELOC,{ 0 }, BFD_RELOC_UNUSED,
+      BFD_RELOC_UNUSED,              BFD_RELOC_UNUSED },
+    /* placeholder for GOTOFF_TPREL */
+    { "",        0,                { 0 }, BFD_RELOC_LX_GOTOFF_TPREL_LO9,
+      BFD_RELOC_LX_GOTOFF_TPREL_HI23,BFD_RELOC_UNUSED },
+    /* placeholder for GOTOFF_DTPNDX */
+    { "" ,       0,                { 0 }, BFD_RELOC_LX_GOTOFF_DTPNDX_LO9,
+      BFD_RELOC_LX_GOTOFF_DTPNDX_HI23, BFD_RELOC_UNUSED },
+    /* placeholder for GOTOFF_DTPLDM */
+    { "",        0,                { 0 }, BFD_RELOC_LX_GOTOFF_DTPLDM_LO9,
+      BFD_RELOC_LX_GOTOFF_DTPLDM_HI23, BFD_RELOC_UNUSED }
+  };
+
+/*****************************************************/
+/*          Unwind information                       */
+/*                                                   */
+/*     unwind_proc_symbol -- frag address            */
+/*                           following proc          */
+/*     unwind_info_symbol -- frag address of         */
+/*                           unwind info block       */
+/*     unwind_bundle_count -- bundles seen since proc */
+/*                                                   */
+/*****************************************************/
+
+#define UNWIND_HEADER_SECTION_NAME ".unwindh"
+#define UNWIND_INFO_SECTION_NAME   ".unwindi"
+#define UNWIND_VERSION             1
+
+static int unwind_bundle_count = 0;
+
+/*****************************************************/
+/*   OPTIONS PROCESSING                              */
+/*****************************************************/
+
+const char *md_shortopts = "hV";	/* catted to std short options */
+
+	  /* added to std long options */
+
+#define OPTION_HEXFILE	(OPTION_MD_BASE + 0)
+#define OPTION_DUMPTABLES (OPTION_MD_BASE + 1)
+#define OPTION_DUMPVERILOG (OPTION_MD_BASE + 2)
+#define OPTION_LITTLE_ENDIAN (OPTION_MD_BASE + 3)
+#define OPTION_BIG_ENDIAN (OPTION_MD_BASE + 4)
+#define OPTION_EMITALLRELOCS (OPTION_MD_BASE + 6)
+#define OPTION_MCORE (OPTION_MD_BASE + 7)
+#define OPTION_CHECK_RESOURCES (OPTION_MD_BASE + 8)
+#define OPTION_NO_CHECK_RESOURCES (OPTION_MD_BASE + 9)
+
+struct option md_longopts[] =
+{
+  {"hex-output", required_argument, NULL, OPTION_HEXFILE},
+  {"EL", no_argument, NULL, OPTION_LITTLE_ENDIAN},
+  {"EB", no_argument, NULL, OPTION_BIG_ENDIAN},
+  {"emit-all-relocs", no_argument, NULL, OPTION_EMITALLRELOCS},
+  {"mcore", required_argument, NULL, OPTION_MCORE},
+  {"check-resources", no_argument, NULL, OPTION_CHECK_RESOURCES},
+  {"no-check-resources", no_argument, NULL, OPTION_NO_CHECK_RESOURCES},
+
+  {NULL, no_argument, NULL, 0}
+};
+
+size_t md_longopts_size = sizeof (md_longopts);
+
+int
+md_parse_option (c, arg)
+     int c;
+     char *arg ATTRIBUTE_UNUSED;
+{
+  int i;
+
+  switch (c)
+    {
+    case 'h':
+      md_show_usage (stdout);
+      exit (EXIT_SUCCESS);
+      break;
+
+      /* -V: SVR4 argument to print version ID.  */
+    case 'V':
+      print_version_id ();
+      break;
+    case OPTION_HEXFILE:
+      /*        hex_file_name = strdup (arg);
+         if (!hex_file_name)
+         as_fatal ("virtual memory exhausted"); */
+      break;
+    case OPTION_LITTLE_ENDIAN:
+      target_big_endian = 0;
+      break;
+    case OPTION_BIG_ENDIAN:
+      target_big_endian = 1;
+      break;
+    case OPTION_EMITALLRELOCS:
+      emit_all_relocs = 1;
+      break;
+    case OPTION_MCORE:
+      mcore = strdup(arg);
+      for (i = 0; i < ST200_NCORES; i++)
+	{
+	  if (strcasecmp(mcore, st200_core_info_table[i]->name) == 0
+	      && st200_core_info_table[i]->supported)
+	    {
+	      lx_core_info = st200_core_info_table[i];
+	      break;
+	    }
+	}
+      if (i == ST200_NCORES)
+	{
+	  char buf[100];
+	  supported_cores (buf, sizeof(buf));
+	  as_fatal("Core specified not supported [%s]", buf);
+	}
+      break;
+    case OPTION_CHECK_RESOURCES:
+      check_resource_usage = 1;
+      break;
+    case OPTION_NO_CHECK_RESOURCES:
+      check_resource_usage = 0;
+      break;
+    default:
+      return 0;
+    }
+  return 1;
+}
+
+void
+md_show_usage (FILE * stream)
+{
+  char buf[100];
+  supported_cores (buf, sizeof(buf));
+
+  fprintf (stream, "\nThe options -M, --mri and -f");
+  fprintf (stream, " are not supported in this assembler.\n");
+  fprintf (stream, "--dump-tables \t\t dump assembler tables \n");
+  fprintf (stream, "--dump-verilog-defines \t dump verilog info \n");
+  fprintf (stream, "--emit-all-relocs \t emit all relocs\n");
+  fprintf (stream, "--mcore [%s] \t select encoding table and ELF flags\n", buf);
+  fprintf (stream, "-V \t\t\t print assembler version number\n");
+}
+
+/**************************************************/
+/*              UTILITIES                         */
+/**************************************************/
+
+/*
+ *  Write a value to the object file (big endian only)
+ */
+
+void
+md_number_to_chars (char *buf, valueT val, int n)
+{
+  if (target_big_endian)
+    number_to_chars_bigendian (buf, val, n);
+  else
+    number_to_chars_littleendian (buf, val, n);
+}
+
+/*
+ * Read a value from to the object file (big endian only)
+ */
+
+static valueT md_chars_to_number (char *buf, int n);
+valueT
+md_chars_to_number (char *buf, int n)
+{
+  valueT val = 0;
+
+  if (n > (int)sizeof (val) || n <= 0)
+    abort ();
+  if (target_big_endian)
+    {
+      while (n--)
+	{
+	  val <<= 8;
+	  val |= (*buf++ & 0xFF);
+	}
+    }
+  else
+    {
+      while (n--)
+	{
+	  val <<= 8;
+	  val |= (buf[n] & 0xff);
+	}
+    }
+  return val;
+}
+
+static void
+real_lx_reloc_type (symbolS *sym, bfd_reloc_code_real_type *reloc_lo,
+		    bfd_reloc_code_real_type *reloc_hi,
+		    bfd_reloc_code_real_type *reloc_32)
+{
+  int i;
+
+  for (i = 0; i < NELEMS(pseudo_func); i++)
+    if (sym == pseudo_func[i].u.sym)
+      {
+	if (reloc_lo)
+	  *reloc_lo = pseudo_func[i].reloc_lo;
+	if (reloc_hi)
+	  *reloc_hi = pseudo_func[i].reloc_hi;
+	if (reloc_32)
+	  *reloc_32 = pseudo_func[i].reloc_32;
+	break;
+      }
+  if (i == NELEMS(pseudo_func))
+    abort ();
+}
+
+static void supported_cores (char buf[], size_t buflen)
+{
+  int i;
+  buf[0] = '\0';
+  for (i = 0; i < ST200_NCORES; i++)
+      if (st200_core_info_table[i]->supported)
+        {
+          if (buf[0] == '\0')
+            strcpy(buf, st200_core_info_table[i]->name);
+          else
+	    {
+	      int l = strlen (buf);
+	      if ((l + 1 + strlen(st200_core_info_table[i]->name) + 1) < buflen)
+		{
+		  strcat (buf, "|");
+		  strcat (buf, st200_core_info_table[i]->name);
+		}
+	    }
+        }
+}
+
+/***************************************************/
+/*   ASSEMBLE AN INSTRUCTION                       */
+/***************************************************/
+
+/* Parse the arguments to an opcode. STR is a C string containing the
+   arguments. TOK is the output array of tokens, which are assembly
+   expressions. NTOK is the size of the array into which the tokens
+   will be placed. The return value is the number of tokens found if
+   no errors were encountered, otherwise -1 is returned.  */
+
+static int
+tokenize_arguments (char *str, expressionS tok[], char *tok_begins[], int ntok)
+{
+  expressionS *end_tok = tok + ntok;
+  char *old_input_line_pointer;
+  int saw_comma = 0, saw_arg = 0;
+  int tokcnt = 0;
+
+  memset (tok, 0, sizeof (*tok) * ntok);
+
+  /* Save and restore input_line_pointer around this function */
+
+  old_input_line_pointer = input_line_pointer;
+
+  input_line_pointer = str;
+
+  while ((tok < end_tok) && *input_line_pointer)
+    {
+      SKIP_WHITESPACE ();
+      if (tok_begins)
+        tok_begins[tokcnt] = input_line_pointer;
+
+      switch (*input_line_pointer)
+	{
+	case '\n':
+	case '\0':
+	  goto fini;
+	case ',':
+	case '=':
+	  ++input_line_pointer;
+	  if (saw_comma || !saw_arg)
+	    goto err;
+	  saw_comma = 1;
+	  break;
+	case '[':
+	  {
+	    /* clarkes: for ldwl/stwl, we allow comma separator
+               before the [, so I have removed this test.
+	    if (saw_comma)
+	      goto err; */
+	    expression (tok);
+	    if (tok->X_op == O_register)
+	      {
+		saw_comma = 0;
+		saw_arg = 1;
+		++tok;
+                ++tokcnt;
+		break;
+	      }
+	    else
+	      {
+		fprintf (stderr, "tok type == %d\n", tok->X_op);
+		as_warn ("expected a register");
+		break;
+	      }
+	  }
+	default:
+	  if (saw_arg && !saw_comma)
+	    goto err;
+	  {
+	    expression (tok);
+	    if (tok->X_op == O_illegal || tok->X_op == O_absent)
+	      goto err;
+
+	    saw_comma = 0;
+	    saw_arg = 1;
+	    ++tok;
+            ++tokcnt;
+	    break;
+	  }
+	}
+    }
+
+fini:
+  if (saw_comma)
+    goto err;
+  if (tok_begins)
+    tok_begins[tokcnt] = input_line_pointer;
+  input_line_pointer = old_input_line_pointer;
+  return ntok - (end_tok - tok);
+
+err:
+  input_line_pointer = old_input_line_pointer;
+  return -1;
+}
+
+/* 
+ * Check input expressions against required operands
+ */
+
+static int
+match_operands (const lxopc_t * op, const expressionS * tok,
+		int ntok)
+{
+  int i;
+  int nop;
+
+  /* First check that number of operands are the same. */
+  for (nop = 0; op && op->format[nop]; nop++);
+  if (ntok != nop)
+    return 0;
+
+  /* Now check for compatiblility of each operand. */
+  for (i = 0; i < ntok; i++)
+    {
+      int operand_type = op->format[i]->type;
+
+      if (! strict_operand_checking
+	  && tok[i].X_op == O_register
+	  && lx_regtable[tok[i].X_add_number].base == 'r') {
+	/* When no strict operand checking, allow any general
+	   register in all these cases. */
+	if (operand_type == RegClass_st200_nolink
+	    || operand_type == RegClass_st200_paired
+	    || operand_type == RegClass_st200_nzpaired)
+	  continue;
+      }
+
+      switch (operand_type)
+	{
+	case RegClass_st200_general:
+	  if ((tok[i].X_op == O_register) &&
+	      (lx_regtable[tok[i].X_add_number].base == 'r'))
+	    break;
+	  else
+	    return 0;
+	case RegClass_st200_nolink:
+	  if ((tok[i].X_op == O_register) &&
+	      (lx_regtable[tok[i].X_add_number].base == 'r') &&
+	      (lx_regtable[tok[i].X_add_number].number != 63))
+	    break;
+	  return 0;
+	case RegClass_st200_paired:
+	  if ((tok[i].X_op == O_register) &&
+	      (lx_regtable[tok[i].X_add_number].base == 'p'))
+	    break;
+	  else
+	    return 0;
+	case RegClass_st200_nzpaired:
+	  if ((tok[i].X_op == O_register) &&
+	      (lx_regtable[tok[i].X_add_number].base == 'p') &&
+	      (! strict_operand_checking
+	       || (lx_regtable[tok[i].X_add_number].number != 0)))
+	    break;
+	  else
+	    return 0;
+	case RegClass_st200_branch:
+	  if ((tok[i].X_op == O_register) &&
+	      (lx_regtable[tok[i].X_add_number].base == 'b'))
+	    break;
+	  else
+	    return 0;
+	case RegClass_st200_predicate:
+	  if ((tok[i].X_op == O_register) &&
+	      (lx_regtable[tok[i].X_add_number].base == 'b') &&
+	      (! strict_operand_checking ||
+	       (lx_regtable[tok[i].X_add_number].number != 0)))
+	    break;
+	  else
+	    return 0;
+	case RegClass_st200_link:
+	  if ((tok[i].X_op == O_register) &&
+	      (lx_regtable[tok[i].X_add_number].base == 'r') &&
+	      (! strict_operand_checking ||
+	       (lx_regtable[tok[i].X_add_number].cluster == 0 &&
+		lx_regtable[tok[i].X_add_number].number == 63)))
+	    break;
+	  return 0;
+	case Immediate_st200_brknum:
+	case Immediate_st200_imm:
+	case Immediate_st200_isrc2:
+	case Immediate_st200_sbrknum:
+	case Immediate_st200_xsrc2:
+	  /* break; *//* maybe we can be more permissive */
+	  if ((tok[i].X_op == O_constant) || (tok[i].X_op == O_symbol)
+	      || (tok[i].X_op == O_pseudo_fixup)
+	      || (tok[i].X_op == O_subtract))
+	    break;
+	  else
+	    return 0;
+	case Immediate_st200_btarg:
+	  if ((tok[i].X_op == O_constant) || (tok[i].X_op == O_symbol)
+	      || (tok[i].X_op == O_pseudo_fixup))
+	    break;
+	  else
+	    return 0;
+	case RegClass_st200_pairedfirst:
+	case RegClass_st200_pairedsecond:
+	default:
+	  return 0;
+	}
+    }
+  return 1;
+}
+
+/*
+ * Given an initial pointer into the opcode table, OPCODE,
+ * find the format that matches the given set of operands. NTOK tells
+ * the number of operands in the operand array pointed to by TOK.
+ * If a matching format is found, a pointer to it is returned,
+ * otherwise a null pointer is returned.
+ */
+
+static const lxopc_t *
+find_format (const lxopc_t * opcode,
+	     const expressionS * tok,
+	     int ntok)
+{
+  char *name = opcode->as_op;
+  const lxopc_t *t = opcode;
+
+  while (STREQ (name, t->as_op))
+    {
+      if (match_operands (t, tok, ntok))
+	return t;
+      t++;
+    }
+  return 0;
+}
+
+/*
+ * Insert an operand into the instruction. Also check for consistency
+ * of cluster information, and inspect registers used to deduce the
+ * cluster if it is not yet known.
+ */
+
+static void
+insert_operand (lxinsn_t * insn,
+		lxbfield * opdef,
+		const expressionS * arg)
+{
+  /*  const struct lx_operand *opdef = lx_operands + optype; */
+  unsigned mask = ~(-1 << opdef->bits);
+  unsigned int op = 0;
+  int max;
+  int min;
+  int clu;
+
+  max = (1 << (opdef->bits - 1)) - 1;
+  min = (-1 << (opdef->bits - 1));
+
+  if (opdef->bits == 0)
+    return;			/* syntactic sugar ? */
+
+  /* try to resolve the value */
+
+  switch (arg->X_op)
+    {
+    case O_register:
+      op = lx_regtable[arg->X_add_number].number;
+
+      /* Check or deduce cluster number. */
+      clu = lx_regtable[arg->X_add_number].cluster;
+      if (insn->cluster != -1)
+	{
+	  /* We know what cluster it is, so check. */
+	  if (clu != insn->cluster)
+	    {
+	      as_bad ("[insert_operand] : inconsistent cluster specifiers: %d %d",
+		      insn->cluster, clu);
+	    }
+	}
+      else
+	{
+	  /* We didn't know cluster before, so use this operand to set 
+	     it. */
+	  insn->cluster = clu;
+	}
+      break;
+    case O_pseudo_fixup:
+      if (insn->nfixups == 0)
+	{
+	  bfd_reloc_code_real_type reloc_lo, reloc_hi;
+	  expressionS reloc_arg;
+
+	  real_lx_reloc_type(arg->X_op_symbol, &reloc_lo, &reloc_hi, 0);
+	  reloc_arg = *arg;
+	  reloc_arg.X_op = O_symbol;
+	  switch(arg->X_lx_imm_op)
+	    {
+	    case O_lx_imm_hi:
+	      if (reloc_hi == BFD_RELOC_UNUSED)
+		as_bad ("Unsupported relocation");
+	      insn->fixup[0].reloc = reloc_hi;
+	      insn->fixup[0].exp = reloc_arg;
+	      insn->fixup[0].where = 0;
+	      insn->nfixups = 1;
+	      break;
+	    case O_lx_imm_lo:
+	      if (reloc_lo == BFD_RELOC_UNUSED)
+		as_bad ("Unsupported relocation");
+	      insn->fixup[0].reloc = reloc_lo;
+	      insn->fixup[0].exp = reloc_arg;
+	      insn->fixup[0].where = 0;
+	      insn->nfixups = 1;
+	      break;
+	    default:
+	      if (reloc_lo == BFD_RELOC_UNUSED || reloc_hi == BFD_RELOC_UNUSED)
+		as_bad ("Unsupported relocation");
+	      if (insn->len > 1)
+		as_fatal ("only one immediate extension allowed !");
+	      insn->len = 2;
+	      insn->insn[1] = LXIMMEXTL (0);
+	      insn->fixup[0].reloc = reloc_lo;
+	      insn->fixup[0].exp = reloc_arg;
+	      insn->fixup[0].where = 0;
+	      insn->fixup[1].reloc = reloc_hi;
+	      insn->fixup[1].exp = reloc_arg;
+	      insn->fixup[1].where = 4;
+	      insn->nfixups = 2;
+	      break;
+	    }
+	}
+	else
+	  {
+	    as_fatal ("No room for fixup ");
+	  }
+      break;
+    case O_constant:		/* we had better generate a fixup if > max */
+      if (!(arg->X_add_symbol))
+	{
+	  op = arg->X_add_number;
+	  break;
+	}
+      /* else falls through to fixup */
+    default:
+      /*      fprintf(stdout, "generate a fixup\n"); */
+      {
+	if (insn->nfixups == 0)
+	  {
+	    switch (opdef->type)
+	      {
+	      case Immediate_st200_btarg:
+		insn->fixup[0].reloc = BFD_RELOC_LX_23_PCREL;
+		insn->fixup[0].exp = *arg;
+		insn->fixup[0].where = 0;
+		insn->nfixups = 1;
+		break;
+	      case Immediate_st200_isrc2:
+	      case Immediate_st200_xsrc2:
+		      /* Check if arg is an explicitly extended immediate */
+		  switch(arg->X_lx_imm_op)
+		  {
+		  case O_lx_imm_hi:
+		      insn->fixup[0].reloc = BFD_RELOC_LX_HI23;
+		      insn->fixup[0].exp = *arg;
+		      insn->fixup[0].where = 0;
+		      insn->nfixups = 1;
+		      break;
+		  case O_lx_imm_lo:
+		      insn->fixup[0].reloc = BFD_RELOC_LX_LO9;
+		      insn->fixup[0].exp = *arg;
+		      insn->fixup[0].where = 0;
+		      insn->nfixups = 1;
+		      break;
+		  default:
+		      if (insn->len > 1)
+			  as_fatal ("only one immediate extension allowed !");
+		      insn->len = 2;
+		      insn->insn[1] = LXIMMEXTL (0);
+		      insn->fixup[0].reloc = BFD_RELOC_LX_LO9;
+		      insn->fixup[0].exp = *arg;
+		      insn->fixup[0].where = 0;
+		      insn->fixup[1].reloc = BFD_RELOC_LX_HI23;
+		      insn->fixup[1].exp = *arg;
+		      insn->fixup[1].where = 4;
+		      insn->nfixups = 2;
+		      break;
+		  }
+		  break;
+	      default:
+		as_fatal ("don't know how to generate a fixup record");
+	      }
+	    return;
+	  }
+	else
+	  {
+	    as_fatal ("No room for fixup ");
+	  }
+      }
+    }
+
+  if ((!(opdef->flags & lxSIGNED)) && ((op & mask) != op))
+    as_fatal ("operand is too large %d %d\n", op, opdef->type);
+
+  if ((opdef->flags & lxSIGNED) &&
+      ((((int) op) < min) || (((int) op) > max)))
+    {
+      /* op too large, can we add immediate extension ? */
+      /*      fprintf(stdout, "extending %d %d %d \n", op, max, min); */
+
+      if (!(opdef->flags & lxCANEXTEND))
+	{
+	  as_fatal ("operand is too large %d %d\n", op, opdef->type);
+	}
+      else if (insn->len > 1)
+	{
+	  as_fatal ("only one immediate extension per instruction");
+	}
+      else
+	{
+
+	  /* we have to possibly swap words after the address
+	   * is assigned -- hence the generation of a fixup here 
+	   */
+	  insn->len = 2;
+	  insn->insn[1] = LXIMMEXTL (op >> opdef->bits);
+	  insn->fixup[0].reloc = BFD_RELOC_LX_LO9;
+	  insn->fixup[0].exp = *arg;
+	  insn->fixup[0].where = 0;
+	  insn->fixup[1].reloc = BFD_RELOC_LX_HI23;
+	  insn->fixup[1].exp = *arg;
+	  insn->fixup[1].where = 4;
+	  insn->nfixups = 2;
+	}
+    }
+  insn->insn[0] |= ((op & mask) << opdef->shift);
+  return;
+}
+
+/* 
+ * Given a set of operands and a matching instruction, 
+ * assemble it
+ *
+ */
+
+static void
+assemble_insn (int cluster,
+	       const lxopc_t * opcode,
+	       const expressionS * tok,
+	       int ntok,
+	       lxinsn_t * insn)
+{
+  int argidx;
+  memset (insn, 0, sizeof (*insn));
+  insn->cluster = cluster;
+  insn->opdef = opcode;
+  insn->insn[0] = opcode->opcode;
+  insn->len = 1;
+  for (argidx = 0; argidx < ntok; argidx++)
+    insert_operand (insn, opcode->format[argidx], &tok[argidx]);
+  return;
+}
+
+#if 0
+// [SC] Unused currently.
+
+/* Duplicate an instruction except put it into the specified
+   cluster.  This is used to make copies of branch instructions that
+   are not in cluster 0.
+ */
+static void
+duplicate_insn (int cluster, int which)
+{
+  if (insncnt >= LXMAXINSN)
+    as_fatal ("too many instructions in bundle ");
+
+  insbuf[insncnt] = insbuf[which];
+  insbuf[insncnt].cluster = cluster;
+  insncnt++;
+}
+#endif
+
+/* Emit an instruction from the instruction array into the object
+   file. INSN points to an element of the instruction array. STOPFLAG
+   is true if this is the last instruction in the bundle.
+   CLUSTER_START is true if this is the first insn in a cluster, and
+   CLUSTER_STOP is true if this is the last insn in a cluster.
+ */
+static void
+emit_insn (lxinsn_t * insn, int stopflag,
+	   int cluster_start ATTRIBUTE_UNUSED,
+	   int cluster_stop ATTRIBUTE_UNUSED)
+{
+  char *f;
+  int i;
+  unsigned image;
+
+  /* if we are listing, attach frag to previous line */
+
+  if (listing)
+    {
+      listing_prev_line ();
+    }
+
+  /* Update text size for lane parity checking */
+
+  set_byte_counter(now_seg, (get_byte_counter(now_seg) + (insn->len * 4)) );
+  cluster_size += insn->len;
+
+  /* allocate space in the fragment      */
+
+  f = frag_more (insn->len * 4);
+
+  /* spit out bits          */
+
+  for (i = 0; i < (int)insn->len; i++)
+    {
+      image = insn->insn[i];
+#if 0
+      /* Use this code when we switch to cluster start bit. */
+      if (i == 0 && cluster_start)
+	{
+	  image |= 0x40000000;
+	}
+#endif
+#if 0
+      /* Use this code with cluster stop bit. */
+      if (i == insn->len - 1 && cluster_stop)
+	{
+	  image |= 0x40000000;
+	}
+#endif
+
+      /* Handle bundle stop bit. */ ;
+      if ((i == (int)insn->len - 1) && stopflag)
+	image |= 0x80000000;
+
+      /* Emit the instruction image. */
+      md_number_to_chars (f + (i * 4), image, 4);
+    }
+
+  /* generate fixup records */
+
+  for (i = 0; i < insn->nfixups; i++)
+    {
+      int size, pcrel;
+      fixS *fixP;
+      reloc_howto_type *reloc_howto
+      = bfd_reloc_type_lookup (stdoutput, insn->fixup[i].reloc);
+      gas_assert (reloc_howto);
+      size = bfd_get_reloc_size (reloc_howto);
+      pcrel = reloc_howto->pc_relative;
+      fixP = fix_new_exp (frag_now,
+			  f - frag_now->fr_literal + insn->fixup[i].where,
+			  size, &(insn->fixup[i].exp),
+			  pcrel,
+			  insn->fixup[i].reloc);
+    }
+}
+
+
+/* Determines if the expression is constant absolute */
+int is_constant_expression(expressionS* exp)
+{
+  int retval=FALSE;
+
+  if ( exp!=NULL )
+    {
+      if ( exp->X_op==O_constant )
+	{
+	  retval=TRUE;
+	}
+      else if ( !(exp->X_add_symbol) )
+	{
+	  retval=TRUE;
+	}
+      else if ( ! symbol_resolved_p (exp->X_add_symbol) )
+	{
+	  retval=FALSE;
+	}
+      else
+	{
+	  if ( exp->X_add_symbol )
+	    {
+	      if ( bfd_is_abs_section(S_GET_SEGMENT(exp->X_add_symbol)) )
+		{
+		  retval=TRUE;
+		}
+	      /* FIXME (lc) rather bad to test if we need another symbol */
+	      if ( exp->X_op>=O_logical_not )
+		{
+		  if ( bfd_is_abs_section(S_GET_SEGMENT(exp->X_op_symbol)) )
+		    {
+		      retval=TRUE;
+		    }
+		  else
+		    {
+		      retval=FALSE;
+		    }
+		} /* if (exp->X_op_symbol) */
+	    } /* if ( exp->X_add_symbol && ...sy_resolved) */
+	} /* else if ( !(exp->X_add_symbol) && !(exp->X_op_symbol) ) */
+    }
+
+  return retval;
+}
+
+/* Called for any expression that can not be recognized.  When the
+   function is called, `input_line_pointer' will point to the start of
+   the expression.  */
+
+void
+md_operand (e)
+     expressionS *e;
+{
+  enum pseudo_type pseudo_type;
+  const char *name;
+  size_t len;
+  int ch, i;
+
+  switch (*input_line_pointer)
+    {
+    case '@':
+      /* Find what relocation pseudo-function we're dealing with. */
+      pseudo_type = 0;
+      ch = *++input_line_pointer;
+      for (i = 0; i < NELEMS (pseudo_func); ++i)
+	if (pseudo_func[i].name && pseudo_func[i].name[0] == ch)
+	  {
+	    len = strlen (pseudo_func[i].name);
+	    if (strncmp (pseudo_func[i].name + 1,
+			 input_line_pointer + 1, len - 1) == 0
+		&& !is_part_of_name (input_line_pointer[len]))
+	      {
+		input_line_pointer += len;
+		pseudo_type = pseudo_func[i].type;
+		break;
+	      }
+	  }
+      switch (pseudo_type)
+	{
+	case PSEUDO_FUNC_RELOC:
+	  SKIP_WHITESPACE ();
+	  if (*input_line_pointer != '(')
+	    {
+	      as_bad ("Expected '('");
+	      goto err;
+	    }
+	  /* Skip '('.  */
+	  ++input_line_pointer;
+	  expression (e);
+	  if (*input_line_pointer++ != ')')
+	    {
+	      as_bad ("Missing ')'");
+	      goto err;
+	    }
+	  if (e->X_op != O_symbol)
+	    {
+	      if (e->X_op != O_pseudo_fixup)
+		{
+		  as_bad ("Not a symbolic expression");
+		  goto err;
+		}
+	      if (i != FUNC_GOT_RELATIVE)
+		{
+		  as_bad ("Illegal combination of relocation functions");
+		  goto err;
+		}
+	      switch (S_GET_VALUE (e->X_op_symbol))
+		{
+		case FUNC_FPTR_RELATIVE:
+		  i = FUNC_GOT_FPTR_RELATIVE; break;
+		case FUNC_TP_RELATIVE:
+		  i = FUNC_GOT_TP_RELATIVE; break;
+		case FUNC_DTP_INDEX:
+		  i = FUNC_GOT_DTP_INDEX_RELATIVE; break;
+		case FUNC_DTP_LOAD_MODULE:
+		  i = FUNC_GOT_DTP_LOAD_MODULE_RELATIVE; break;
+		default:
+		  as_bad ("Illegal combination of relocation functions");
+		  goto err;
+		}
+	    }
+	  /* Make sure gas doesn't get rid of local symbols that are used
+	     in relocs.  */
+	  e->X_op = O_pseudo_fixup;
+	  e->X_op_symbol = pseudo_func[i].u.sym;
+	  break;
+
+	default:
+	  name = input_line_pointer - 1;
+	  get_symbol_end ();
+	  as_bad ("Unknown pseudo function `%s'", name);
+	  goto err;
+	}
+      break;
+    default:
+      break;
+    }
+  return;
+
+ err:
+  ignore_rest_of_line ();
+}
+
+/* Return 1 if it's OK to adjust a reloc by replacing the symbol with
+   a section symbol plus some offset.  For relocs involving @fptr(),
+   directives we don't want such adjustments since we need to have the
+   original symbol's name in the reloc.  */
+int lx_fix_adjustable (fix)
+     fixS *fix;
+{
+  if (emit_all_relocs)
+    return 0;
+
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+  /* Prevent all adjustments to global symbols, or else ELF dynamic
+     linking will not work correctly.  */
+  if (S_IS_EXTERNAL (fix->fx_addsy)
+      || S_IS_WEAK (fix->fx_addsy))
+    return 0;
+#endif
+  switch (fix->fx_r_type)
+    {
+    default:
+      break;
+    case BFD_RELOC_LX_FPTR32:
+    case BFD_RELOC_LX_GOTOFF_FPTR_HI23:
+    case BFD_RELOC_LX_GOTOFF_FPTR_LO9:
+    case BFD_RELOC_LX_GOTOFF_HI23:
+    case BFD_RELOC_LX_GOTOFF_LO9:
+    case BFD_RELOC_LX_GOTOFFX_HI23:
+    case BFD_RELOC_LX_GOTOFFX_LO9:
+    case BFD_RELOC_LX_PLTOFF_HI23:
+    case BFD_RELOC_LX_PLTOFF_LO9:
+    case BFD_RELOC_LX_IPLT:
+    case BFD_RELOC_LX_JMP_SLOT:
+      return 0;
+    }
+
+  return 1;
+}
+
+static void
+assemble_tokens (int cluster, const char *opname,
+		 const expressionS * tok,
+		 int ntok);
+
+/*
+ * Return the Bundling type for an insn.
+ */
+
+static Bundling find_bundling (const lxinsn_t *insn)
+{
+  Bundling bundling;
+  int insn_bundlings = insn->opdef->bundlings;
+  bundling = (Bundling)((insn_bundlings >> (8 * (insn->len - 1))) & 0xff);
+  return bundling;
+}
+
+static int cmp_bundling (const void *a, const void *b)
+{
+  const Bundling *ba = (const Bundling *)a;
+  const Bundling *bb = (const Bundling *)b;
+  return (*bb < *ba) - (*ba < *bb);
+}
+
+/*
+ * Find a bundle type that matches the operations in
+ * bundle_insn.
+ * If found, return the index in bundlematch_table.
+ * If not found, return:
+ *  -2 if operations cannot be bundled on this alignment
+ *  -1 if operations cannot be bundled on any alignment
+ * As a side-effect, reorder the operations in
+ * bundle_insn and add nops to match the required ordering
+ * for the bundle type.
+ * If no bundle type found, the operations
+ * are in the original order.
+ *
+ * clu specifies the cluster we are bundling.
+ * It could be used if different
+ * clusters have different bundling rules.
+ */
+
+static int find_bundle_type (int clu_uses[], int clu,
+			     lxinsn_t *bundle_insn[], int *bundle_insn_cnt)
+{
+  int hash = 0;
+  int i;
+  int canonical_ix;
+  const BundleMatchType *match;
+  Bundling canonical_order[LXMAXBUNDLESIZE];
+
+  if (*bundle_insn_cnt > LXMAXBUNDLESIZE)
+    return -1;
+
+  for (i = 0; i < *bundle_insn_cnt; i++)
+    canonical_order[i] = bundle_insn[i]->bundling;
+  qsort(canonical_order, *bundle_insn_cnt, sizeof(Bundling), cmp_bundling);
+
+  for (i = 0; i < *bundle_insn_cnt; i++)
+    hash = (hash * LXNUMBUNDLINGS) + canonical_order[i];
+
+  if (hash > bundlematch_table_size)
+    return -1;
+  canonical_ix = bundlematch_table[hash];
+
+  if (canonical_ix == -1)
+    /* No match at all for canonical, on any alignment. */
+    return -1;
+
+  match = &canonical_table[canonical_ix];
+  /* Try each bundle type for this canonical. */
+  for (i = 0; i < match->entries; i++)
+    {
+      int bt = match->entry[i];
+      const BundleType *btype = &bundle_types[bt];
+      int sec_align = 1 << bfd_get_section_alignment(stdoutput, now_seg);
+      /* Our known alignment is current pc modulo section align.
+	 That must satisfy the bundle requirements. */
+      int cur_align = get_byte_counter(now_seg) % sec_align;
+
+      if ((btype->nnops == 0 || nop_insertion_allowed)
+	  && sec_align >= btype->base
+	  && (cur_align % btype->base) == btype->bias)
+	{ /* We have a match. Reorder bundle_insn to match it. */
+	  int entry, insn;
+	  int next_nop = 0;
+
+	  for (entry = 0; entry < *bundle_insn_cnt; entry++)
+	    /* Put correct insn in bundle_insn[entry] */
+	    if (entry == btype->nops[next_nop])
+	      {
+		bundle_insn[(*bundle_insn_cnt)++] = bundle_insn[entry];
+		assemble_tokens (clu, "nop", 0, 0);
+		insbuf[insncnt-1].bundling = find_bundling(&insbuf[insncnt-1]);
+		bundle_insn[entry] = &insbuf[insncnt-1];
+		clu_uses[clu]++;
+		next_nop++;
+	      }
+	    else
+	      {
+		for (insn = entry; insn < *bundle_insn_cnt; insn++)
+		  if (bundle_insn[insn]->bundling == btype->bundling[entry])
+		    {
+		      lxinsn_t *t = bundle_insn[entry];
+		      bundle_insn[entry] = bundle_insn[insn];
+		      bundle_insn[insn] = t;
+		      break;
+		    }
+	      }
+	  return canonical_ix;
+	}
+    }
+  /* Here if we matched a canonical, but the alignment was not good for
+     any of the bundle types. */
+  return -2;
+}
+
+/* 
+ * Given an opcode name and a pre-tokenized 
+ * set of arguments, take the
+ * opcode all the way through emission 
+ */
+
+static void
+assemble_tokens (int cluster, const char *opname,
+		 const expressionS * tok,
+		 int ntok)
+{
+  const lxopc_t *opcode;
+  lxinsn_t *insn;
+
+  /* make sure there is room in instruction buffer */
+
+  if (insncnt >= LXMAXINSN)
+    as_fatal ("too many instructions in bundle ");
+  insn = insbuf + insncnt;
+
+  /* find the instruction in the opcode table */
+
+  opcode = (lxopc_t *) hash_find (lx_opcode_hash, opname);
+  if (opcode)
+    {
+      if (!(opcode = find_format (opcode, tok, ntok)))
+	as_bad ("[assemble_tokens] : couldn't find format %s \n",
+		opname);
+      else
+	{
+	  assemble_insn (cluster, opcode, tok, ntok, insn);
+	  insncnt++;
+	}
+    }
+  else
+    {
+      as_bad ("[assemble_tokens] : couldn't find op %s\n", opname);
+    }
+}
+
+   /* called by core to assemble a single line */
+
+void
+md_assemble (char *s)
+{
+  char *t;
+  int i;
+  int tlen;
+  char opname[32];
+  char cluster[32];
+  int clusternum;
+  int clusternum2;
+  expressionS tok[LXMAXOPERANDS];
+  char *tok_begins[2*LXMAXOPERANDS];
+  int ntok;
+  int start_bundle;
+
+  if (get_byte_counter(now_seg) & 3)
+    as_fatal ("code segment not word aligned in md_assemble\n");
+
+  t = s;
+
+  while (t && t[0] && (t[0] == ' '))
+    t++;
+
+  /* ;; was converted to "be" by line hook          */
+  /* here we look for the bundle end                */
+  /* and actually output any instructions in bundle */
+  /* also we need to implement the stop bit         */
+  /* check for bundle end */
+
+  if (strncmp (t, "be", 2) == 0)
+    {
+      int j;
+      int k;
+      int maxclu;		/* Highest cluster used in the bundle */
+      int clu_uses[LXCLUSTERS];
+      int clu;			/* Temp cluster index */
+      int clu_insns[LXCLUSTERS];	/* Number of cluster insns emited so far. */
+      int sec_align;
+      int ct;
+
+      unwind_bundle_count++;	/* count of bundles in current proc */
+      maxclu = 0;		/* We need at least one cluster. */
+
+      /* Clear cluster usage array */
+      for (clu = 0; clu < LXCLUSTERS; clu++)
+	{
+	  clu_uses[clu] = 0;
+	  clu_insns[clu] = 0;
+	}
+
+      /* Scan the instructions for cluster usage so we can emit an
+         appropriate nop if needed. Also scan for branch instructions 
+         in a non-zero cluster. These actually will also emit an
+         instruction in cluster 0. */
+      for (j = 0; j < insncnt; j++)
+	{
+	  clu = insbuf[j].cluster;
+
+	  /* If the instruction hasn't had a cluster assigned to it by 
+	     now, just put it into cluster 0. */
+	  if (clu < 0)
+	    {
+	      clu = 0;
+	      insbuf[j].cluster = clu;
+	    }
+
+	  if (clu > maxclu)
+	    maxclu = clu;
+
+	  /* Tally this syllable for its cluster. */
+	  clu_uses[clu]++;
+
+#if 0
+	  /* [SC] The flow does not provide the information to derive
+	     lxCTL. */
+	  if ((insbuf[j].opdef->flags & lxCTL) && (clu != 0))
+	    {
+	      /* We found a branch not in cluster 0.  These also
+	         need a cluster 0 duplicate. */
+	      duplicate_insn (0, j);
+	    }
+#endif
+	}
+
+      /* Emit a nop for each cluster that has no syllables, up to the
+         highest cluster that we need. */
+
+      for (clu = 0; clu <= maxclu; clu++)
+	{
+	  if (clu_uses[clu] == 0)
+	    {
+	      assemble_tokens (clu, "nop", 0, 0);
+	      if (!nop_insertion_allowed) {
+		as_bad("Assemble NOP (required for empty bundle) at bundle start address : 0x%x", get_byte_counter (now_seg));
+	      }
+
+	      /* Now it has a use. */
+	      clu_uses[clu]++;
+	    }
+	}
+
+      k = 0;
+
+      cluster_size = 0;
+      clu = 0;
+
+      /* Check the bundle validity for each cluster */
+
+      sec_align = bfd_get_section_alignment(stdoutput, now_seg);
+
+      for (clu = 0; clu <= maxclu; clu++)
+	{
+
+	  lxinsn_t *bundle_insn[LXMAXINSN];
+	  int bundle_insn_cnt = 0;
+	  int syllables = 0;
+	  int entry;
+	  int bundle_err_done = 0;
+	  int align_warn_done = 0; /* Alignment contraint warning already
+				      raised for this bundle or not */
+
+	  /* retain bundle start adress for error messages */
+          start_bundle = get_byte_counter(now_seg);
+
+#ifdef OBJ_ELF
+	  /* Emit Dwarf debug line information */
+	  dwarf2_emit_insn (0);
+#endif
+	  /* Put the operations for cluster clu in bundle_insn. */
+
+	  for (j = 0; j < insncnt; j++)
+	    {
+	      if (insbuf[j].cluster == clu)
+		{
+		  Bundling bundling = find_bundling (&insbuf[j]);
+		  insbuf[j].bundling = bundling;
+		  bundle_insn[bundle_insn_cnt++] = &insbuf[j];
+		  syllables += insbuf[j].len;
+		  if (sec_align < LXLANEALIGNMENT && !align_warn_done)
+		    {
+		      if (insbuf[j].len == 2)
+			{
+			  align_warn_done = 1;
+			  as_bad ("Minimum section alignment of %d required due to instruction (%s) requiring extended immediate (current alignment is %d)", (1 << LXLANEALIGNMENT), insbuf[j].opdef->as_op, (1 << sec_align));
+			}
+		    }
+		}
+	    }
+
+	  /* Check that resources are not oversubscribed.
+	     We check only for a single bundle, so resources that are used
+             in multiple cycles will not be fully checked. */
+	  if (check_resource_usage)
+	    {
+	      const int reservation_table_len = (st200_reservation_table_lines
+						 * st200_resource_max); 
+	      const int *resources = lx_core_info->resources;
+	      int *resources_used;
+	      
+	      int ix, jx;
+	      
+	      resources_used = (int *)alloca (reservation_table_len * sizeof (int));
+	      memset (resources_used, 0, reservation_table_len * sizeof (int));
+
+	      for (ix = 0; ix < bundle_insn_cnt; ix++)
+		{
+		  int insn_reservations = bundle_insn[ix]->opdef->reservation;
+		  int reservation = (insn_reservations
+				     >> (8 * (bundle_insn[ix]->len - 1))) & 0xff;
+		  const int *reservation_table =
+		    st200_reservation_table_table[reservation];
+		  for (jx = 0; jx < reservation_table_len; jx++)
+		      resources_used[jx] += reservation_table[jx];
+		}
+	      for (ix = 0; ix < st200_reservation_table_lines; ix++)
+		for (jx = 0; jx < st200_resource_max; jx++)
+		  if (resources_used[(ix * st200_resource_max) + jx] > resources[jx])
+		    {
+		      as_bad ("Resource %s over-used in bundle: %d used, %d available",
+			      st200_resource_names[jx],
+			      resources_used[(ix * st200_resource_max) + jx],
+			      resources[jx]);
+		      bundle_err_done = TRUE;
+		    }
+	    }
+
+	  /* If check_bundles, then check the bundle contents match
+	     a valid bundle, reordering and inserting nops as necessary.
+	     If ! check_bundles, assume the bundle contents are already
+	     valid. */
+	  if (check_bundles)
+	    {
+	      /* Find a bundle type that matches bundle_insn. */
+	      /* It will insert nops as necessary, if nop_insertion_allowed. */
+	      ct = find_bundle_type(clu_uses, clu, bundle_insn, &bundle_insn_cnt);
+
+	      if (ct < 0 && ! bundle_err_done)
+		{
+		  if (syllables > LXLANESPERCLUSTER)
+		    as_bad ("Bundle has too many (%d) syllables", syllables);
+		  else if (ct == -2)
+		    {
+		      int s_align = 1 << sec_align;
+		      int cur_align = get_byte_counter(now_seg) % s_align;
+		      if (s_align != 4 || ! align_warn_done)
+			{
+			  if (cur_align)
+			    as_bad ("Bundle not valid on %d-byte + %d alignment",
+				    s_align, cur_align);
+			  else
+			    as_bad ("Bundle not valid on %d-byte alignment", s_align);
+			}
+		    }
+		  else
+		    as_bad ("Cannot form bundle");
+		  bundle_err_done = TRUE;
+		}
+	    }
+
+	  /* The ordering of the insns has been set correctly
+	     in bundle_insn. */
+	  for (entry = 0; entry < bundle_insn_cnt; entry++)
+	    {
+	      clu_insns[clu]++;
+	      emit_insn (bundle_insn[entry],
+			 (clu == maxclu && entry == (bundle_insn_cnt - 1)),
+			 clu_insns[clu] == 1,
+			 clu_insns[clu] == clu_uses[clu]);
+	      bundle_insn[entry]->written = 1;
+	    }
+	  
+	  /*clu_insns = 0; Reset for next cluster. */
+	  cluster_size = 0;
+	}
+
+      insncnt = 0;
+      return;
+    }
+
+  /* strip cluster info */
+
+  i = 0;
+  if (t && (t[0] == 'c') && isdigit (t[1]))
+    i = strspn (t, "c0123,");
+  tlen = (i < 31) ? i : 31;
+  memcpy (cluster, t, tlen);
+  cluster[tlen] = '\0';
+
+  if (sscanf (cluster, "c%d", &clusternum) != 1)
+    clusternum = -1;		/* No cluster given */
+
+  t += i;			/* Skip over cluster info. */
+
+  /* Check for inter-cluster info. Note that the '=' gets changed
+     to a ',' by lx_md_start_line_hook. */
+  i = 0;
+  if (t && (t[0] == ',') && (t[1] == 'c') && isdigit (t[2]))
+    i = strspn (t, "c0123,");
+  tlen = (i < 31) ? i : 31;
+  memcpy (cluster, t, tlen);
+  cluster[tlen] = '\0';
+
+  if (sscanf (cluster, "=c%d", &clusternum2) != 1)
+    clusternum2 = -1;		/* No cluster given */
+
+  t += i;			/* Skip over cluster info. */
+
+  /* get opcode info    */
+
+  while (t && t[0] && (t[0] == ' '))
+    t++;
+  i = strspn (t, "abcdefghijklmnopqrstuvwxyz.,_0123456789");
+  tlen = (i < 31) ? i : 31;
+  memcpy (opname, t, tlen);
+  opname[tlen] = '\0';
+
+  t += i;
+
+  /* parse arguments             */
+
+  if ((ntok = tokenize_arguments (t, tok, tok_begins, LXMAXOPERANDS)) < 0)
+    {
+      as_bad ("syntax error");
+    }
+
+  /* Do special check for inter-cluster move. */
+  if (ntok == 2
+      && STREQ (opname, "mov")
+      && tok[0].X_op == O_register
+      && tok[1].X_op == O_register
+      && lx_regtable[tok[0].X_add_number].cluster !=
+      lx_regtable[tok[1].X_add_number].cluster)
+    {
+      /* It is inter-cluster move. Expand into a send a receive */
+      int dest_clu, src_clu;	/* The clusters */
+      int dest_reg, src_reg;	/* The registers */
+      char icbuf[100];
+      dest_clu = lx_regtable[tok[0].X_add_number].cluster;
+      src_clu = lx_regtable[tok[1].X_add_number].cluster;
+      dest_reg = lx_regtable[tok[0].X_add_number].number;
+      src_reg = lx_regtable[tok[1].X_add_number].number;
+
+      sprintf (icbuf, "c%d send %d = $r%d.%d",
+	       src_clu, src_clu, src_clu, src_reg);
+      md_assemble (icbuf);
+
+      sprintf (icbuf, "c%d recv $r%d.%d = %d",
+	       dest_clu, dest_clu, dest_reg, src_clu);
+      md_assemble (icbuf);
+
+      return;
+    }
+
+    /* do special check for custom asm,xx opcodes       */
+    /* we need to expand those into multiple asm,xx     */
+    /* according to the number of operands with a       */
+    /* special case if two operands are immediates      */
+    /* N.B. an asm,xx with variable num. of operands    */
+    /* > 2 is recursively split                         */
+
+  if (ntok >= 2 &&
+      (ntok != 3 ||
+      (((tok[1].X_op == O_constant) || (tok[1].X_op == O_symbol)) &&
+      ((tok[2].X_op == O_constant) || (tok[2].X_op == O_symbol))))
+      && STRNEQ (opname, "asm,",4))
+    {
+      /* It is asm,xx dest,op1,op2,...,opn expand it */
+      char icbuf[256];
+      int clust = clusternum >= 0 ? clusternum : 0;
+      char tmp;
+
+
+#if 0
+      unsigned int tc;
+      for(tc=0;tc < ntok; tc++) {
+        tmp = *tok_begins[tc+1];
+        *tok_begins[tc+1] = '\0';
+        fprintf(stderr,"tok %d = \'%s\'\n",tc,tok_begins[tc]);
+        *tok_begins[tc+1] = tmp;
+      }
+#endif
+#if 1
+      if (ntok == 2)  {
+         /* asm,xx rxx = Imm */
+         if ((tok[1].X_op == O_constant) || (tok[1].X_op == O_symbol)) { 
+             tmp = *tok_begins[1];
+             *tok_begins[1] = '\0';
+             sprintf (icbuf, "c%d %s %s $r%d.0, ",clust,opname,tok_begins[0],clust);
+             *tok_begins[1] = tmp;
+
+             tmp = *tok_begins[2];
+             *tok_begins[2] = '\0';
+             strcat(icbuf,tok_begins[1]);
+             *tok_begins[2] = tmp;
+             /* fprintf(stderr,"%s\n",icbuf); */
+         }
+         else { /* asm,xx rxx = ryy */
+             tmp = *tok_begins[1];
+             *tok_begins[1] = '\0';
+             sprintf (icbuf, "c%d %s %s ",clust,opname,tok_begins[0]);
+             *tok_begins[1] = tmp;
+
+             tmp = *tok_begins[2];
+             *tok_begins[2] = '\0';
+             strcat (icbuf, tok_begins[1]);
+             strcat (icbuf, ", ");
+             strcat (icbuf, tok_begins[1]);
+             *tok_begins[2] = tmp;
+             /* fprintf(stderr,"%s\n",icbuf); */
+             }
+           md_assemble (icbuf);
+        }
+      else
+      if (ntok == 3)  {
+        /* asm,xx rxx = Imm1, Imm2 */
+        /* expanded into asm,xx rxx = rx.0, Imm1 */
+        /*               asm,xx rxx = rx.0, Imm2 */
+             tmp = *tok_begins[1];
+             *tok_begins[1] = '\0';
+             sprintf (icbuf, "c%d %s %s $r%d.0, ",clust,opname,tok_begins[0],clust);
+             *tok_begins[1] = tmp;
+
+             tmp = *tok_begins[2];
+             *tok_begins[2] = '\0';
+             strcat(icbuf,tok_begins[1]);
+             /* remove comma */
+             icbuf[strlen(icbuf)-1] = '\0';
+             *tok_begins[2] = tmp;
+             /* fprintf(stderr,"%s\n",icbuf); */
+
+             md_assemble (icbuf);
+
+             tmp = *tok_begins[1];
+             *tok_begins[1] = '\0';
+             sprintf (icbuf, "c%d %s %s $r%d.0, ",clust,opname,tok_begins[0],clust);
+             *tok_begins[1] = tmp;
+
+             tmp = *tok_begins[3];
+             *tok_begins[3] = '\0';
+             strcat(icbuf,tok_begins[2]);
+             *tok_begins[3] = tmp;
+             /* fprintf(stderr,"%s\n",icbuf); */
+
+             md_assemble (icbuf);
+
+      }
+      else {    /* asm,xx rxx = op1, op2, op4 , ... */
+                /* expands into asm,xx rxx = op1, op2       */
+                /*              asm,xx rxx = ......         */
+                /*              asm,xx rxx = op(N-1), op(N) */
+           int op,nop;
+           
+           nop = (ntok - 1)/2 + ((ntok - 1) & 0x1);
+           for(op=0;op < nop; op++) {
+             tmp = *tok_begins[1];
+             *tok_begins[1] = '\0';
+             sprintf (icbuf, "c%d %s %s ",clust,opname,tok_begins[0]);
+             *tok_begins[1] = tmp;
+
+             tmp = *tok_begins[2*op+2];
+             *tok_begins[2*op+2] = '\0';
+             strcat (icbuf,tok_begins[2*op+1]);
+             *tok_begins[2*op+2] = tmp;
+
+             if (ntok >= (2*op + 2)) {
+                 tmp = *tok_begins[2*op+3];
+                 *tok_begins[2*op+3] = '\0';
+                 strcat(icbuf,tok_begins[2*op+2]);
+                 /* remove , from last operand if not last expanded asm */
+                 if (op < (nop - 1))
+                        icbuf[strlen(icbuf)-1] = '\0';
+                 *tok_begins[2*op+3] = tmp;
+                 }
+           /* fprintf(stderr,"%s\n",icbuf); */
+           md_assemble (icbuf);
+           }
+      }
+#endif
+      return;
+    }
+
+  /* build an instruction record */
+
+  assemble_tokens (clusternum, opname, tok, ntok);
+}
+
+static void
+lx_set_cpu (void)
+{
+  int i;
+
+  if (lx_core_info) return;
+
+  for (i = 0; i < ST200_NCORES; i++)
+    {
+      if (strcmp (TARGET_CPU, st200_core_info_table[i]->name) == 0)
+	{
+	  lx_core_info = st200_core_info_table[i];
+	  break;
+	}
+    }
+  if (! lx_core_info)
+    lx_core_info = & st220_core_info;
+}
+
+static int lxop_compar(const void *a, const void *b)
+{
+  const lxopc_t *opa = (const lxopc_t *)a;
+  const lxopc_t *opb = (const lxopc_t *)b;
+  return strcmp(opa->as_op, opb->as_op);
+}
+
+/***************************************************/
+/*    INITIALIZE ASSEMBLER                          */
+/***************************************************/
+
+void
+md_begin ()
+{
+  int i, j, k;
+  j = 0;
+
+  lx_set_cpu ();
+
+  /*
+   * generate register names (symbols)
+   * first decide how many there are
+   * then create symbols
+   */
+
+  for (i = 0; lx_regspec[i].base; i++)
+    {
+      if (lx_regspec[i].cluster < LXCLUSTERS)
+	j += lx_regspec[i].number / lx_regspec[i].step;
+    }
+
+  lx_regtable = (lx_regspec_t *) xmalloc (j * sizeof (lx_regspec_t));
+  if (lx_regtable == NULL)
+    as_fatal ("[md_begin] allocation problem\n");
+  k = 0;
+  for (i = 0; lx_regspec[i].base; i++)
+    {
+      if (lx_regspec[i].cluster < LXCLUSTERS)
+	{
+	  for (j = 0; j < lx_regspec[i].number; j+= lx_regspec[i].step)
+	    {
+              char name[10];
+              char alias[10];
+	      sprintf (name, "$%c%d.%d",
+		       lx_regspec[i].base, lx_regspec[i].cluster, j);
+	      symbol_table_insert (symbol_create (name, reg_section, k,
+						  &zero_address_frag));
+              if (lx_regspec[i].cluster == 0) {
+                sprintf (alias, "$%c%d",lx_regspec[i].base, j); 
+                symbol_table_insert (symbol_create (alias, reg_section, k,
+                                                    &zero_address_frag));
+              }
+	      lx_regtable[k].base = lx_regspec[i].base;
+	      lx_regtable[k].cluster = lx_regspec[i].cluster;
+	      lx_regtable[k].number = j;
+	      k++;
+	    }
+	}
+    }
+
+  /* Sort optab, so that identical mnemonics appear consecutively */
+  {
+    int nel;
+    for (nel = 0; !STREQ ("", lx_core_info->optab[nel].as_op); nel++) ;
+    qsort (lx_core_info->optab, nel, sizeof(lx_core_info->optab[0]), lxop_compar);
+  }
+
+  /* Create the opcode hash table      */
+  /* Each name should appear only once */
+
+  lx_opcode_hash = hash_new ();
+  {
+    lxopc_t *op;
+    const char *name = 0;
+    const char *retval = 0;
+    for (op = lx_core_info->optab; !(STREQ ("", op->as_op)) ; op++)
+      {
+
+	/* enter in hash table if this is a new name */
+
+	if (!(STREQ (name, op->as_op)))
+	  {
+	    name = op->as_op;
+	    retval = hash_insert (lx_opcode_hash, name, (PTR) op);
+	    if (retval)
+	      as_fatal ("internal error: can't hash opcode `%s': %s",
+			name, retval);
+	  }
+      }
+  }
+
+  /* Here we enforce the minimum section alignment.  Remember, in
+   * the linker we can make the boudaries between the linked sections
+   * on larger boundaries.  The text segment is aligned to long words
+   * because of the odd/even constraint on immediate extensions
+   */
+
+  bfd_set_section_alignment (stdoutput, text_section, 3);	/* -- 8 bytes */
+  bfd_set_section_alignment (stdoutput, data_section, 2);	/* -- 4 bytes */
+  bfd_set_section_alignment (stdoutput, bss_section, 2);	/* -- 4 bytes */
+  subseg_set (text_section, 0);
+
+  pseudo_func[FUNC_FPTR_RELATIVE].u.sym =
+    symbol_create (".<fptr>", undefined_section, FUNC_FPTR_RELATIVE,
+		&zero_address_frag);
+
+  pseudo_func[FUNC_GP_RELATIVE].u.sym =
+    symbol_create (".<gprel>", undefined_section, FUNC_GP_RELATIVE,
+		&zero_address_frag);
+
+  pseudo_func[FUNC_GOT_RELATIVE].u.sym =
+    symbol_create (".<gotoff>", undefined_section, FUNC_GOT_RELATIVE,
+		&zero_address_frag);
+
+  pseudo_func[FUNC_GOTX_RELATIVE].u.sym =
+    symbol_create (".<gotoffx>", undefined_section, FUNC_GOTX_RELATIVE,
+		&zero_address_frag);
+
+  pseudo_func[FUNC_PLT_RELATIVE].u.sym =
+    symbol_create (".<pltoff>", undefined_section, FUNC_PLT_RELATIVE,
+		&zero_address_frag);
+
+  pseudo_func[FUNC_SEG_RELATIVE].u.sym =
+    symbol_create (".<segrel>", undefined_section, FUNC_SEG_RELATIVE,
+		&zero_address_frag);
+
+  pseudo_func[FUNC_LTV_RELATIVE].u.sym =
+    symbol_create (".<ltv>", undefined_section, FUNC_LTV_RELATIVE,
+		&zero_address_frag);
+
+  pseudo_func[FUNC_GOT_FPTR_RELATIVE].u.sym =
+    symbol_create (".<gotoff.fptr>", undefined_section, FUNC_GOT_FPTR_RELATIVE,
+		&zero_address_frag);
+
+  pseudo_func[FUNC_IPLT_RELOC].u.sym =
+    symbol_create (".<iplt>", undefined_section, FUNC_IPLT_RELOC,
+		&zero_address_frag);
+
+  pseudo_func[FUNC_NEG_GP_RELATIVE].u.sym =
+    symbol_create (".<neggprel>", undefined_section, FUNC_NEG_GP_RELATIVE,
+		   &zero_address_frag);
+
+  pseudo_func[FUNC_TP_RELATIVE].u.sym =
+    symbol_create (".<tprel>", undefined_section, FUNC_TP_RELATIVE,
+		   &zero_address_frag);
+
+  pseudo_func[FUNC_DTP_RELATIVE].u.sym =
+    symbol_create (".<dtprel>", undefined_section, FUNC_DTP_RELATIVE,
+		   &zero_address_frag);
+
+  pseudo_func[FUNC_DTP_MODULE].u.sym =
+    symbol_create (".<dtpmod>", undefined_section, FUNC_DTP_MODULE,
+		   &zero_address_frag);
+
+  pseudo_func[FUNC_DTP_INDEX].u.sym =
+    symbol_create (".<dtpndx>", undefined_section, FUNC_DTP_INDEX,
+		   &zero_address_frag);
+
+  pseudo_func[FUNC_DTP_LOAD_MODULE].u.sym =
+    symbol_create (".<dtpldm>", undefined_section, FUNC_DTP_LOAD_MODULE,
+		   &zero_address_frag);
+
+  pseudo_func[FUNC_GOT_TP_RELATIVE].u.sym =
+    symbol_create (".<gotoff.tprel>", undefined_section, FUNC_GOT_TP_RELATIVE,
+		   &zero_address_frag);
+
+  pseudo_func[FUNC_GOT_DTP_INDEX_RELATIVE].u.sym =
+    symbol_create (".<gotoff.dtpndx>", undefined_section, FUNC_GOT_DTP_INDEX_RELATIVE,
+		   &zero_address_frag);
+
+  pseudo_func[FUNC_GOT_DTP_LOAD_MODULE_RELATIVE].u.sym =
+    symbol_create (".<gotoff.dtpldm>", undefined_section, FUNC_GOT_DTP_LOAD_MODULE_RELATIVE,
+		   &zero_address_frag);
+
+  /*  bfd_set_private_flags(stdoutput, 0); *//* default flags */
+}
+
+/***************************************************/
+/*          ASSEMBLER CLEANUP STUFF                */
+/***************************************************/
+
+#if 0
+static void 
+md_after_pass (void)		/* called from md_end */
+{
+}
+#endif
+
+/***************************************************/
+/*          ASSEMBLER FIXUP STUFF                  */
+/***************************************************/
+
+/*
+ * attempt to eliminate fixup
+ *   A bit of gross hacking occurs with respect to 
+ *   lx immediate extensions.  The extension can only
+ *   occur on even addresses.  Thus we need to swap
+ *   the two words of an instruction in this case.  To
+ *   prevent confusion, the fixup for the extension does
+ *   all the work.  The short immediate fixup is just here
+ *   as a placeholder for generation of the reloc.  Later,
+ *   if we need a short immediate fixup that acts alone, we'll
+ *   have to fix this.   Also, it is important to check for
+ *   the instruction stop bit when swapping 
+ */
+
+void
+md_apply_fix (fixS * fixP, valueT * valueP,
+	       segT segmentP ATTRIBUTE_UNUSED)
+{
+  char *const fixpos = fixP->fx_frag->fr_literal + fixP->fx_where;
+  char *const fixpos2 = fixP->fx_frag->fr_literal + fixP->fx_where - 4;
+  valueT value = *valueP;
+  valueT value2 = *valueP;
+  unsigned image, image2;
+
+  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
+    fixP->fx_done = 1;
+
+  if (fixP->fx_size > 0)
+    image = md_chars_to_number (fixpos, fixP->fx_size);
+  else
+    image = 0;
+  if (fixP->fx_addsy != NULL)
+    {
+      switch (fixP->fx_r_type)
+	{
+	case BFD_RELOC_LX_TPREL_HI23:
+	case BFD_RELOC_LX_TPREL_LO9:
+	case BFD_RELOC_LX_GOTOFF_TPREL_HI23:
+	case BFD_RELOC_LX_GOTOFF_TPREL_LO9:
+	case BFD_RELOC_LX_GOTOFF_DTPLDM_HI23:
+	case BFD_RELOC_LX_GOTOFF_DTPLDM_LO9:
+	case BFD_RELOC_LX_DTPREL_HI23:
+	case BFD_RELOC_LX_DTPREL_LO9:
+	case BFD_RELOC_LX_GOTOFF_DTPNDX_HI23:
+	case BFD_RELOC_LX_GOTOFF_DTPNDX_LO9:
+	case BFD_RELOC_LX_DTPMOD32:
+	case BFD_RELOC_LX_DTPREL32:
+	case BFD_RELOC_LX_TPREL32:
+	  S_SET_THREAD_LOCAL (fixP->fx_addsy);
+	  break;
+	  
+	default:
+	  break;
+	}
+    }
+  switch (fixP->fx_r_type)
+    {
+    case BFD_RELOC_8:
+    case BFD_RELOC_16:
+    case BFD_RELOC_32:
+    case BFD_RELOC_32_PCREL:
+      image = value;
+      md_number_to_chars (fixpos, image, fixP->fx_size);
+      break;
+    case BFD_RELOC_LX_23_PCREL:
+      if (fixP->fx_pcrel || fixP->fx_addsy)
+	return;
+      value = ((value >> 2) & 0x7fffff);
+      image = (image & ~0x7fffff) | value;
+      md_number_to_chars (fixpos, image, fixP->fx_size);
+      break;
+    case BFD_RELOC_LX_HI23:
+    case BFD_RELOC_LX_GPREL_HI23:
+    case BFD_RELOC_LX_NEG_GPREL_HI23:
+    case BFD_RELOC_LX_GOTOFF_HI23:
+    case BFD_RELOC_LX_GOTOFFX_HI23:
+    case BFD_RELOC_LX_GOTOFF_FPTR_HI23:
+    case BFD_RELOC_LX_PLTOFF_HI23:
+    case BFD_RELOC_LX_TPREL_HI23:
+    case BFD_RELOC_LX_GOTOFF_TPREL_HI23:
+    case BFD_RELOC_LX_GOTOFF_DTPLDM_HI23:
+    case BFD_RELOC_LX_DTPREL_HI23:
+    case BFD_RELOC_LX_GOTOFF_DTPNDX_HI23:
+
+      /* the HI23 does all the heavy work */
+      /* because of the need to swap      */
+
+      value = ((value >> 9) & 0x7fffff);
+      image = (image & ~0x7fffff) | value;
+      value2 = (value2 & 0x1ff);
+      image2 = md_chars_to_number (fixpos2, fixP->fx_size);
+
+      image2 = image2 & (~((0x1ff) << 12));
+      image2 = image2 | (value2 << 12);
+
+      /* check if we need to swap                   */
+      /* we swap if the extension is on an odd word */
+
+      if ((fixP->fx_frag->fr_address + fixP->fx_where) & 4)
+	{
+	  unsigned tmp;
+	  fixP->fx_where -= 4;	/* change this address */
+	  if (image & 0x80000000)	/* fix stop bit ! */
+	    {
+	      image2 |= 0x80000000;
+	      image &= 0x7fffffff;
+	    }
+	  if (image & 0x40000000)	/* fix cluster stop bit ! */
+	    {
+	      image2 |= 0x40000000;
+	      image &= 0xbfffffff;
+	    }
+	  image |= 0x00800000;	/* change immediate assoc. */
+	  tmp = image;
+	  image = image2;
+	  image2 = tmp;
+	}
+      md_number_to_chars (fixpos, image, fixP->fx_size);
+      md_number_to_chars (fixpos2, image2, fixP->fx_size);
+      break;
+    case BFD_RELOC_LX_LO9:
+    case BFD_RELOC_LX_GPREL_LO9:
+    case BFD_RELOC_LX_NEG_GPREL_LO9:
+    case BFD_RELOC_LX_GOTOFF_LO9:
+    case BFD_RELOC_LX_GOTOFFX_LO9:
+    case BFD_RELOC_LX_GOTOFF_FPTR_LO9:
+    case BFD_RELOC_LX_PLTOFF_LO9:
+    case BFD_RELOC_LX_TPREL_LO9:
+    case BFD_RELOC_LX_GOTOFF_TPREL_LO9:
+    case BFD_RELOC_LX_GOTOFF_DTPLDM_LO9:
+    case BFD_RELOC_LX_DTPREL_LO9:
+    case BFD_RELOC_LX_GOTOFF_DTPNDX_LO9:
+
+      /* check if a swap is underway   */
+      /* we are not allowed to have    */
+      /* BFD_RELOC_LX_L09 without      */
+      /* BFD_RELOC_LX_H23              */
+
+      if (!((fixP->fx_frag->fr_address + fixP->fx_where) & 4))
+	fixP->fx_where += 4;
+      break;
+    case BFD_RELOC_LX_REL32:
+    case BFD_RELOC_LX_FPTR32:
+    case BFD_RELOC_LX_IPLT:
+    case BFD_RELOC_LX_LTV32:
+    case BFD_RELOC_LX_SEGREL32:
+    case BFD_RELOC_LX_JMP_SLOT:
+    case BFD_RELOC_LX_DTPMOD32:
+    case BFD_RELOC_LX_DTPREL32:
+    case BFD_RELOC_LX_TPREL32:
+      break;
+    default:
+      as_fatal ("[md_apply_fix] unsupported relocation type");
+    }
+}
+
+void
+lx_validate_fix (fixS *fix)
+{
+  switch (fix->fx_r_type)
+    {
+    case BFD_RELOC_LX_FPTR32:
+    case BFD_RELOC_LX_GOTOFF_FPTR_LO9:
+    case BFD_RELOC_LX_GOTOFF_FPTR_HI23:
+      if (fix->fx_offset != 0)
+	as_bad_where (fix->fx_file, fix->fx_line,
+		      "No addend allowed in @fptr() relocation");
+      break;
+    default:
+      break;
+    }
+
+  return;
+}
+
+/* 
+ * Warning: Can be called only in fixup_segment() after fx_addsy field
+ * has been updated by calling symbol_get_value_expression(...->X_add_symbol)
+ */
+int
+lx_validate_sub_fix (fixS *fixP)
+{
+  segT add_symbol_segment, sub_symbol_segment;
+
+  switch (fixP->fx_r_type)
+    {
+    case BFD_RELOC_16:
+    case BFD_RELOC_32:
+	if (fixP->fx_addsy != NULL)
+	    add_symbol_segment = S_GET_SEGMENT (fixP->fx_addsy);
+	else
+	    return 0;
+	if (fixP->fx_subsy != NULL)  
+	    sub_symbol_segment = S_GET_SEGMENT (fixP->fx_subsy);
+	else
+	    return 0;
+
+	if ((strcmp(S_GET_NAME (fixP->fx_addsy),
+		   S_GET_NAME (fixP->fx_subsy)) == 0) && 
+	    (add_symbol_segment == sub_symbol_segment)) {
+	    return 1;
+	}
+
+      break;
+    default:
+      break;
+    }
+
+  return 0;
+}
+
+/* This is called whenever some data item (not an instruction) needs a
+   fixup.  */
+void
+lx_cons_fix_new (fragS *f, int where, int nbytes, expressionS *exp)
+{
+  bfd_reloc_code_real_type code;
+
+  if (exp->X_op == O_pseudo_fixup)
+    {
+      exp->X_op = O_symbol;
+      real_lx_reloc_type (exp->X_op_symbol, 0, 0, &code);
+      if (code == BFD_RELOC_UNUSED)
+	as_bad ("Unsupported relocation");
+    }
+  else
+    switch (nbytes)
+      {
+	/* [SC] We have no relocation for BFD_RELOC_8, but accept it
+	 * here in case we can later eliminate the fixup (in md_apply_fix).
+	 * This is required to pass the gas test forward.s.
+	 */
+      case 1:
+	code = BFD_RELOC_8;
+	break;
+      case 2:
+	code = BFD_RELOC_16;
+	break;
+      case 4:
+	code = BFD_RELOC_32;
+	break;
+      default:
+	as_bad ("unsupported BFD relocation size %u", nbytes);
+	code = BFD_RELOC_32;
+	break;
+      }
+
+  fix_new_exp (f, where, nbytes, exp, 0, code);
+}
+
+/*
+ * generate a relocation record
+ */
+
+arelent *
+tc_gen_reloc (asection * sec ATTRIBUTE_UNUSED, fixS * fixp)
+{
+  arelent *reloc;
+  bfd_reloc_code_real_type code;
+
+  reloc = (arelent *) xmalloc (sizeof (arelent));
+
+  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+
+  code = fixp->fx_r_type;
+  if (code == BFD_RELOC_32 && fixp->fx_pcrel)
+    {
+      code = BFD_RELOC_32_PCREL;
+    }
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
+
+  if (reloc->howto == NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    "cannot represent `%s' relocation in object file",
+		    bfd_get_reloc_code_name (code));
+      return NULL;
+    }
+
+  if (!fixp->fx_pcrel != !reloc->howto->pc_relative)
+    {
+      as_fatal ("internal error? cannot generate `%s' relocation",
+		bfd_get_reloc_code_name (code));
+    }
+  gas_assert (!fixp->fx_pcrel == !reloc->howto->pc_relative);
+
+  reloc->addend = fixp->fx_offset;
+
+  /*
+   * Ohhh, this is ugly.  The problem is that if this is a local global
+   * symbol, the relocation will entirely be performed at link time, not
+   * at assembly time.  bfd_perform_reloc doesn't know about this sort
+   * of thing, and as a result we need to fake it out here.
+   */
+
+  /* GD I'm not sure what this is used for in the Lx case but it sure  */
+  /* messes up the relocs when emit_all_relocs is used as they are not */
+  /* resolved with respect to a global sysmbol (e.g. .text), and hence */
+  /* they are ALWAYS resolved at link time                             */
+  /* FIXME FIXME                                                       */
+
+  /* clarkes: 030827:  This code (and the other half of the fix in write.c)
+   * have caused problems with the PIC relocations.
+   * The root problem is that bfd_install_relocation adds in to the reloc
+   * addend the section offset of a symbol defined in the current object.
+   * This causes problems on numerous other targets too, and there are
+   * several different methods used to get around it:
+   *   1.  In tc_gen_reloc, subtract off the value that bfd_install_relocation
+   *       added.  That is what we do here, and it is also done the
+   *       same way for alpha.
+   *   2.  In md_apply_fix, subtract off the value that bfd_install_relocation
+   *       will add.  This is done on SH (non-ELF) and sparc targets.
+   *   3.  In the howto structure for the relocations, specify a
+   *       special function that does not return bfd_reloc_continue.
+   *       This causes bfd_install_relocaion to terminate before it
+   *       adds in the symbol offset.  This is done on SH ELF targets.
+   *       Note that on ST200 we specify bfd_elf_generic_reloc as
+   *       the special function.  This will return bfd_reloc_continue
+   *       only in some circumstances, but in particular if the reloc
+   *       is marked as partial_inplace in the bfd howto structure, then
+   *       bfd_elf_generic_reloc will return bfd_reloc_continue.
+   *       Some ST200 relocations are marked as partial_inplace
+   *       (this is an error in my opinion because ST200 always uses
+   *       a separate addend), but some are not.  The PIC relocations
+   *       are not marked as partial_inplace, so for them,
+   *       bfd_elf_generic_reloc returns bfd_reloc_ok, and the addend
+   *       is not modified by bfd_install_relocation.   The relocations
+   *       R_LX_16 and R_LX_32 are marked partial_inplace, and so for
+   *       these we need to correct the addend.
+   * In the code below, the condition in the emit_all_relocs branch
+   * (now moved to write.c) is the inverse of the condition that
+   * bfd_elf_generic_reloc uses to short-circuit the code in
+   * bfd_install_relocation that modifies the addend.  The condition
+   * in the else branch match the condition used in the alpha version
+   * of tc_gen_reloc (see tc-alpha.c).
+   * I do not know why we need to use different conditions in these
+   * two branches, it seems to me that the condition should be the same
+   * whether or not emit_all_relocs is true.
+   * I also do not understand why it was necessary to move the emit_all_relocs
+   * condition to write.c.
+   */
+  if (emit_all_relocs)
+    {
+      /* Thierry Bidault: This is done later in write.c to fix a bug */
+/*       if (!((fixp->fx_addsy->bsym->flags & BSF_SECTION_SYM) == 0 */
+/*        && (!reloc->howto->partial_inplace */
+/*            || reloc->addend == 0))) */
+/*    reloc->addend -= fixp->fx_addsy->bsym->value; */
+    }
+  else
+    {
+      if (S_IS_EXTERNAL (fixp->fx_addsy)  &&
+	  !S_IS_COMMON (fixp->fx_addsy) &&
+          reloc->howto->partial_inplace)
+	reloc->addend -= symbol_get_bfdsym (fixp->fx_addsy)->value;
+    }
+
+  return reloc;
+}
+
+/* Round up segment to appropriate boundary */
+
+valueT
+md_section_align (asection * seg ATTRIBUTE_UNUSED, valueT size)
+{
+#ifndef OBJ_ELF
+  /* This is not right for ELF; a.out wants it, and COFF will force
+     the alignment anyways.  */
+  int align = bfd_get_section_alignment (stdoutput, seg);
+  valueT mask = ((valueT) 1 << align) - 1;
+  return (size + mask) & ~mask;
+#else
+  return size;
+#endif
+}
+
+int
+md_estimate_size_before_relax (register fragS * fragP ATTRIBUTE_UNUSED,
+			       segT segtype ATTRIBUTE_UNUSED)
+{
+  as_fatal ("estimate_size_before_relax called\n");
+}
+
+void
+md_convert_frag (bfd * abfd ATTRIBUTE_UNUSED,
+		 asection * sec ATTRIBUTE_UNUSED,
+		 fragS * fragp ATTRIBUTE_UNUSED)
+{
+  as_fatal ("lx convert_frag\n");
+}
+
+symbolS *
+md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+char *
+md_atof (int type ATTRIBUTE_UNUSED,
+	 char *litp ATTRIBUTE_UNUSED,
+	 int *sizep ATTRIBUTE_UNUSED)
+{
+  /* we'll need this for reading floating point constants */
+  return _("floating-point literals are not supported");
+}
+
+/*
+ * calculate the base for a pcrel fixup 
+ * -- for relocation, we might need to add addend ?
+ */
+
+long
+md_pcrel_from (fixS * fixP)
+{
+  return (fixP->fx_where + fixP->fx_frag->fr_address);
+}
+
+/************************************************************/
+/*   Hooks into standard processing -- we hook into label   */
+/*   handling code to detect double ':' and we hook before  */
+/*   a line of code is processed to do some simple sed style */
+/*   edits.                                                 */
+/************************************************************/
+
+static symbolS *last_proc_sym = NULL;
+static int update_last_proc_sym = 0;
+
+void
+lx_frob_label (symbolS * sym)
+{
+  if (input_line_pointer[1] == ':')	/* second colon => global symbol */
+    {
+      S_SET_EXTERNAL (sym);
+      input_line_pointer++;
+    }
+
+  if (update_last_proc_sym)
+    {
+      last_proc_sym = sym;
+      update_last_proc_sym = 0;
+    }
+
+#ifdef OBJ_ELF
+  dwarf2_emit_label (sym);
+#endif
+}
+
+/*  edit out some syntactic sugar that confuses GAS       */
+/*  input_line_pointer is guaranteed to point to the      */
+/*  the current line but may include text from following  */
+/*  lines.  Thus, '\n' must be scanned for as well as '\0' */
+
+void 
+lx_md_start_line_hook (void)
+{
+  char *t;
+  int i;
+
+  for (t = input_line_pointer; t && t[0] == ' '; t++);
+
+  /* Detect illegal syntax patterns:
+   * - two bundle ends on the same line: ;; ;;
+   * - illegal token: ;;;
+   */
+  if (t && (t[0] == ';') && (t[1] == ';')) {
+      char *tmp_t;
+      bfd_boolean newline_seen = FALSE;
+
+      if (t[2] == ';') {
+	  as_fatal ("Syntax error: Illegal ;;; token");
+      }
+
+      tmp_t = t + 2;
+
+      while (tmp_t && tmp_t[0]) {
+	  while (tmp_t && tmp_t[0] && 
+		 ((tmp_t[0] == ' ') || (tmp_t[0] == '\n'))) {
+	      if (tmp_t[0] == '\n') {
+		  newline_seen = TRUE;
+	      }
+	      tmp_t++;
+	  }
+	  if (tmp_t[0] == ';' && tmp_t[1] == ';') {
+	      /* if there's no newline between the two bundle stops
+	       * then raise a syntax error now, otherwise a strange error
+	       * message from read.c will be raised: "junk at end of line..."
+	       */
+	      if (tmp_t[2] == ';') {
+		  as_fatal ("Syntax error: Illegal ;;; token");
+	      }
+
+	      if (!newline_seen) {
+		  as_fatal ("Syntax error: More than one bundle stop on a line");
+	      }
+	      newline_seen = FALSE; /* reset */
+
+	      /* For cores st231 and onward, empty bundles don't need to cause the
+	       * generation of a NOP instruction. Just ignore them... 
+	       */
+	      if ((lx_core_info->elf_core & ELF_LX_CORE_MASK) != 
+		  ELF_LX_CORE_ST220) {
+		  /* this is an empty bundle, transform it into an 
+		   * empty statement */
+		  tmp_t[0] = ';';
+		  tmp_t[1] = ' ';
+	      }
+	      tmp_t += 2;
+	  } else {
+	      break;
+	  }
+      }
+  }
+
+  /* check for bundle end                             */
+  /* we transform these into a special opcode BE      */
+  /* because gas has ';' hardwired as a statement end */
+  if (t && (t[0] == ';') && (t[1] == ';'))
+    {
+      t[0] = 'B';
+      t[1] = 'E';
+      return;
+    }
+
+  /* It turns out that in read.c, function read_a_source_line, the
+     check for an = is not done correctly and it will mistakenly
+     interpret the multi-cluster sequence 'cn=cm' as an equal
+     directive. We want to avoid changing the standard code as much as 
+     possible, so instead we edit the above to 'cn,cm'.
+   */
+  if (!t || (t[0] != 'c') || !isdigit (t[1]))
+    {
+      /* Not start of cluster number. */
+      return;
+    }
+
+  /* skip over cluster. */
+  i = strspn (t + 1, "0123456789");
+  t += i + 1;			/* Skip over cluster. */
+
+  if (t && (t[0] == '=') && (t[1] == 'c') && isdigit (t[2]))
+    {
+      /* It is a multi-cluster move. Change '=' to a ',' for now. */
+      t[0] = ',';
+    }
+}
+
+/*********************************************************/
+/*     Hooks to handle assembler directives              */
+/*     These override defaults by checking segment       */
+/*     info.                                             */
+/*********************************************************/
+
+static void
+lx_cons (int size)
+{
+  if (is_code_section(now_seg))
+    set_byte_counter(now_seg, (get_byte_counter(now_seg) + size) );
+  cons (size);
+}
+
+static int is_assume_param(char** input, const char* param)
+{    
+  if ( (input!=NULL) && (strncmp(*input, param, strlen(param))==0) )
+    {
+      *input=*input+strlen(param);
+      return TRUE;
+    }
+  else
+    return FALSE;
+}
+
+static void set_assume_param(int* param, int param_value, int* param_set);
+void
+set_assume_param(int* param, int param_value, int* param_set)
+{
+  if (!*param_set) {
+    *param = param_value;
+    *param_set = 1;
+  } else {
+    as_bad("Attempt to redefine .assume or .rta parameter");
+    demand_empty_rest_of_line ();
+  }
+}
+
+#define MAX_STR_LENGTH 20
+static void 
+lx_set_assume_flags (int ignore ATTRIBUTE_UNUSED)
+{
+  char* param;
+  const char *target_name = lx_core_info->name;
+
+  param=input_line_pointer;
+  while ( (input_line_pointer!=NULL)
+	  && ! is_end_of_line [(unsigned char) *input_line_pointer])
+    {
+      int found = FALSE;
+      int i;
+      SKIP_WHITESPACE ();
+
+      /* core */
+      for (i = 0; i < ST200_NCORES; i++)
+        {
+          if (is_assume_param(&input_line_pointer, st200_core_info_table[i]->name))
+            {
+              set_assume_param(&lx_core, st200_core_info_table[i]->elf_core, &lx_core_set);
+	      if (lx_core_info != st200_core_info_table[i])
+                as_warn("ELF flags (%s) inconsistent with encoding table (%s)",
+		        st200_core_info_table[i]->name, target_name);
+	      found = TRUE;
+	      break;
+            }
+        } 
+
+      if (! found)
+        {
+          static const struct
+	  {
+	    const char *name;
+	    int value;
+	    int *variable;
+	    int *set_variable;
+	  } assume_params[] =
+	    {
+	      { "cut0", ELF_LX_CUT_0, &lx_cut, &lx_cut_set },
+	      { "cut1", ELF_LX_CUT_1, &lx_cut, &lx_cut_set },
+	      { "cut2", ELF_LX_CUT_2, &lx_cut, &lx_cut_set },
+	      { "cut3", ELF_LX_CUT_3, &lx_cut, &lx_cut_set },
+	      { "cut4", ELF_LX_CUT_4, &lx_cut, &lx_cut_set },
+	      { "cut5", ELF_LX_CUT_5, &lx_cut, &lx_cut_set },
+              { "no-abi", ELF_LX_ABI_NO, &lx_abi, &lx_abi_set },
+              { "old-multiflow-abi", ELF_LX_ABI_MULTI, &lx_abi, &lx_abi_set },
+              { "lx-embedded-abi", ELF_LX_ABI_EMBED, &lx_abi, &lx_abi_set },
+              { "pic-abi", ELF_LX_ABI_PIC, &lx_abi, &lx_abi_set },
+              { "gcc-abi", ELF_LX_ABI_GCC, &lx_abi, &lx_abi_set },
+              { "bare-machine", ELFOSABI_NONE, &lx_osabi, &lx_osabi_set },
+              { "os21", ELFOSABI_OS21, &lx_osabi, &lx_osabi_set },
+              { "linux", ELFOSABI_LINUX, &lx_osabi, &lx_osabi_set },
+              { "user", ELF_LX_MODE_USER, &lx_mode, &lx_mode_set },
+              { "kernel", ELF_LX_MODE_KERNEL, &lx_mode, &lx_mode_set },
+	    };
+
+	  for (i = 0; i < ((int)(sizeof(assume_params)/sizeof(assume_params[0]))); i++)
+	    {
+	      if (is_assume_param(&input_line_pointer, assume_params[i].name))
+		{
+		  set_assume_param(assume_params[i].variable,
+				   assume_params[i].value,
+				   assume_params[i].set_variable);
+		  found = TRUE;
+		  break;
+		}
+	    }
+	}
+
+      if (! found)
+        {
+          as_bad("Bad assume parameter");
+          demand_empty_rest_of_line ();
+        }
+
+      SKIP_WHITESPACE ();
+      if ( (*input_line_pointer!=',')
+	   && ! is_end_of_line[(unsigned char) *input_line_pointer])
+        {
+          as_bad("Bad assume parameter");
+          demand_empty_rest_of_line ();
+        }
+      if ( *input_line_pointer==',' )
+        {
+          input_line_pointer++;
+          SKIP_WHITESPACE ();
+        }
+    } /* end while */
+}
+
+static void
+lx_nop_insertion (int f)
+{
+  nop_insertion_allowed = f;
+}
+
+static void
+lx_check_resources (int f)
+{
+  check_resource_usage = f;
+}
+
+static void
+lx_check_bundles (int f)
+{
+  check_bundles = f;
+}
+
+static void
+lx_strict_operand_checking (int f)
+{
+  strict_operand_checking = f;
+}
+
+static void
+lx_set_rta_flags (int f ATTRIBUTE_UNUSED)
+{
+  int param_value;
+
+  param_value = get_absolute_expression ();
+/* Ignore .rta directive from know on. */
+/*  set_assume_param(&lx_abi, get_absolute_expression (), &lx_abi_set); */
+}
+
+/** called before write_object_file */
+void 
+lx_end(void)
+{
+  int newflags;
+  Elf_Internal_Ehdr * i_ehdrp;
+
+  if (! lx_core_set)
+    lx_core = lx_core_info->elf_core;
+
+  /* (pp) the flags must be set at once */
+  newflags= lx_core | lx_cut | lx_abi;
+  bfd_set_private_flags (stdoutput, newflags);
+
+  i_ehdrp = elf_elfheader (stdoutput);
+  i_ehdrp->e_ident[EI_ABIVERSION] = lx_abi | lx_mode;
+  i_ehdrp->e_ident[EI_OSABI] = lx_osabi;
+}
+
+
+static void
+lx_float_cons (int type)
+{
+  if (is_code_section(now_seg))
+    {
+      if (type == 'd')
+	set_byte_counter(now_seg, (get_byte_counter(now_seg) + 8) );
+      if (type == 'f')
+	set_byte_counter(now_seg, (get_byte_counter(now_seg) + 4) );
+    }
+  float_cons (type);
+}
+
+static void
+lx_skip (int mult)
+{
+  char * saved_input_line_pointer;
+  int skip;
+
+  if (is_code_section(now_seg))
+    {
+	saved_input_line_pointer = input_line_pointer;
+	/* Get argument of .skip/.space directive */
+	if (is_end_of_line[(unsigned char) *input_line_pointer])
+	    {
+		skip = mult;
+	    }
+	else
+	    {
+		skip = get_absolute_expression ();
+	    }
+	set_byte_counter(now_seg, (get_byte_counter(now_seg) + skip) );
+
+	/* Reset input_line_pointer to its original value in order to be able to run
+	   through the standard s_space procedure */
+	input_line_pointer = saved_input_line_pointer;
+    }
+  s_space (mult);
+}
+
+/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
+   of an rs_align_code fragment.  */
+void
+lx_handle_align (fragP)
+     fragS *fragP;
+{
+  /* Use ST200 NOP instruction with Stop_Bit set */
+
+  int bytes, fix, noop_size;
+  char * p;
+  const char * noop, * noop_stop_bit;
+  /* the bundle size must be a power of 2 otherwise the way 
+     modulo is computed below must be changed */
+  int lx_bundle_size = LXMAXBUNDLESIZE;
+  int pad_counter = 1;
+
+  if (fragP->fr_type != rs_align_code)
+    return;
+
+  bytes = fragP->fr_next->fr_address - fragP->fr_address - fragP->fr_fix;
+  p = fragP->fr_literal + fragP->fr_fix;
+  fix = 0;
+
+#if 0 /* No Max for ST200 */
+  if (bytes > MAX_MEM_FOR_RS_ALIGN_CODE)
+      bytes &= MAX_MEM_FOR_RS_ALIGN_CODE;
+#endif
+
+  if (target_big_endian) {
+      noop = lx_bigend_noop;
+      noop_stop_bit = lx_bigend_noop_stop_bit;
+
+  } else {
+      noop = lx_noop;
+      noop_stop_bit = lx_noop_stop_bit;
+  }
+
+  noop_size = sizeof (lx_noop);
+
+  if (bytes & (noop_size - 1))
+    {
+      fix = bytes & (noop_size - 1);
+      memset (p, 0, fix);
+      p += fix;
+      bytes -= fix;
+    }
+
+  while (bytes >= noop_size)
+    {
+      if (((bytes - noop_size) == 0) || /* Put a stop bit for last nop */
+	  ((pad_counter & (lx_bundle_size - 1)) == 0)) /* or last inst. of bundle */
+	{ 
+	  /* Insert NOP =with= bundle stop bit */
+	  memcpy (p, noop_stop_bit, noop_size);
+	} 
+      else 
+	{
+	  /* Insert NOP =without= bundle stop bit */
+	  memcpy (p, noop, noop_size);
+	}
+      pad_counter++;
+      p += noop_size;
+      bytes -= noop_size;
+      fix += noop_size;
+    }
+
+  fragP->fr_fix += fix;
+  fragP->fr_var = noop_size;
+}
+
+/* Called from md_do_align.  Used to create an alignment
+   frag in a code section.  */
+void
+lx_frag_align_code (n, max)
+     int n;
+     int max;
+{
+  char * p;
+  int alignment = n; /* For MAX_MEM_FOR_RS_ALIGN_CODE macro */
+  
+#if 0 /* No Max for ST200 */
+  /* We assume that there will never be a requirment
+     to support alignments greater than 32 bytes.  */
+  if (max > MAX_MEM_FOR_RS_ALIGN_CODE)
+    as_fatal (_("alignments greater than 32 bytes not supported in .text sections."));
+#endif
+
+  p = frag_var (rs_align_code,
+		MAX_MEM_FOR_RS_ALIGN_CODE,
+		1,
+		(relax_substateT) max,
+		(symbolS *) NULL,
+		(offsetT) n,
+		(char *) NULL);
+  *p = 0;
+
+}
+
+static void
+lx_align_ptwo(int pow)
+{
+    lx_align(pow, 0);
+    return;
+}
+
+static void
+lx_align_bytes(int bytes)
+{
+    lx_align(bytes, 1);
+    return;
+}
+
+/*
+ * arg is default alignment if none spec
+ * is_bytes is 1 if arg is a number of bytes, 0 if it's a power of 2
+ */
+static void
+lx_align (int arg, int is_bytes)
+{
+  char * saved_input_line_pointer = input_line_pointer;
+  int align;
+  offsetT fill = 0;
+  int max;
+
+  if (is_code_section(now_seg))
+    {
+/* Get argument of .align directive */
+    if (is_end_of_line[(unsigned char) *input_line_pointer])
+      {
+	  if (!is_bytes) {
+	      int i;
+
+	      align = 1;
+	      if (arg > 0)
+		  for ( i = 0; i < arg; i++) 
+		      align *= 2;
+	  } else {
+	      align = arg;
+	  }
+      }
+    else
+      {
+        align = get_absolute_expression ();
+	if (!is_bytes) {
+	    int i, tmp = 1;
+	    
+	    if (align > 0) {
+		for ( i = 0; i < align; i ++) 
+		    tmp *= 2;
+	    } else {
+		/* Let later error handling do it's work */
+	    }
+	    align = tmp;
+	}
+
+	SKIP_WHITESPACE ();
+      }
+    /* Check that there's no optional third operand (max bytes to skip).
+       Currently we cannot evaluate the "byte_counter" in this case,
+       as the decision of performing the align or not is postponed 
+       in a later phase */
+    if (*input_line_pointer == ',')
+      {
+	++input_line_pointer;
+	if (*input_line_pointer != ',')
+	  {
+	    fill = get_absolute_expression ();
+	    SKIP_WHITESPACE ();
+	  }
+	if (*input_line_pointer == ',')
+	  {
+	    ++input_line_pointer;
+	    max = get_absolute_expression ();
+	    if (max)
+	      {
+		as_fatal (".align : Third operand (max bytes) not supported on text sections");
+	      }
+	  }
+      }
+    /* Reset counter */
+    set_byte_counter(now_seg, get_byte_counter(now_seg) & ~(align - 1));
+
+    /* Reset input_line_pointer to its original value in order to be able to run 
+       through the standard s_align_bytes procedure */
+    input_line_pointer = saved_input_line_pointer;
+    }
+  if (!is_bytes) 
+      s_align_ptwo(arg);
+  else 
+      s_align_bytes(arg);
+}
+
+/* .ascii, .asciz, .string -  in text segment, we lose track of */
+/* of alignment, so we punt a little -- force to byte alignment */
+
+static void
+lx_stringer (int append_zero)
+{
+  if (is_code_section(now_seg))
+    {
+      set_byte_counter(now_seg, 1);
+    }
+  stringer (8 + append_zero);
+}
+
+static void
+lx_ignore (int arg ATTRIBUTE_UNUSED)
+{
+  /* the cs directives may have ';' in them.  These we must skip ! */
+
+  while (input_line_pointer && (input_line_pointer[0] != '\n'))
+    input_line_pointer++;
+}
+
+/* Handle attribute "moveable" and "used" added at the end of .type directive  for Binopt.
+ * DFE: Must ne kept imn sync with default implementation in bfd/obj-elf.c:obj_elf_type() for new
+ * ELF types.
+ */
+
+static char *
+obj_elf_type_name (char *cp)
+{
+  char *p;
+
+  p = input_line_pointer;
+  if (*input_line_pointer >= '0'
+      && *input_line_pointer <= '9')
+    {
+      while (*input_line_pointer >= '0'
+	     && *input_line_pointer <= '9')
+	++input_line_pointer;
+      *cp = *input_line_pointer;
+      *input_line_pointer = '\0';
+    }
+  else
+    *cp = get_symbol_end ();
+
+  return p;
+}
+
+static void
+lx_type (int ignore ATTRIBUTE_UNUSED)
+{
+  char *name;
+  char c;
+  int type;
+  const char *type_name;
+  symbolS *sym;
+  elf_symbol_type *elfsym;
+
+  name = input_line_pointer;
+  c = get_symbol_end ();
+  sym = symbol_find_or_make (name);
+  elfsym = (elf_symbol_type *) symbol_get_bfdsym (sym);
+  *input_line_pointer = c;
+
+  SKIP_WHITESPACE ();
+  if (*input_line_pointer == ',')
+    ++input_line_pointer;
+
+  SKIP_WHITESPACE ();
+  if (   *input_line_pointer == '#'
+      || *input_line_pointer == '@'
+      || *input_line_pointer == '"'
+      || *input_line_pointer == '%')
+    ++input_line_pointer;
+
+  type_name = obj_elf_type_name (& c);
+
+  type = 0;
+  if (strcmp (type_name, "function") == 0
+      || strcmp (type_name, "2") == 0
+      || strcmp (type_name, "STT_FUNC") == 0)
+    type = BSF_FUNCTION;
+  else if (strcmp (type_name, "object") == 0
+	   || strcmp (type_name, "1") == 0
+	   || strcmp (type_name, "STT_OBJECT") == 0)
+    type = BSF_OBJECT;
+  else if (strcmp (type_name, "tls_object") == 0
+	   || strcmp (type_name, "6") == 0
+	   || strcmp (type_name, "STT_TLS") == 0)
+    type = BSF_OBJECT | BSF_THREAD_LOCAL;
+  else if (strcmp (type_name, "notype") == 0
+	   || strcmp (type_name, "0") == 0
+	   || strcmp (type_name, "STT_NOTYPE") == 0)
+    ;
+  else if (strcmp (type_name, "common") == 0
+	   || strcmp (type_name, "5") == 0
+	   || strcmp (type_name, "STT_COMMON") == 0)
+    {
+      type = BSF_OBJECT;
+
+      if (! S_IS_COMMON (sym))
+	{
+	  if (S_IS_VOLATILE (sym))
+	    {
+	      sym = symbol_clone (sym, 1);
+	      S_SET_SEGMENT (sym, bfd_com_section_ptr);
+	      S_SET_VALUE (sym, 0);
+	      S_SET_EXTERNAL (sym);
+	      symbol_set_frag (sym, &zero_address_frag);
+	      S_CLEAR_VOLATILE (sym);
+	    }
+	  else if (S_IS_DEFINED (sym) || symbol_equated_p (sym))
+	    as_bad (_("symbol '%s' is already defined"), S_GET_NAME (sym));
+	  else
+	    {
+	      /* FIXME: Is it safe to just change the section ?  */
+	      S_SET_SEGMENT (sym, bfd_com_section_ptr);
+	      S_SET_VALUE (sym, 0);
+	      S_SET_EXTERNAL (sym);
+	    }
+	}
+    }
+  else if (strcmp (type_name, "gnu_indirect_function") == 0
+	   || strcmp (type_name, "10") == 0
+	   || strcmp (type_name, "STT_GNU_IFUNC") == 0)
+    {
+      const struct elf_backend_data *bed;
+
+      bed = get_elf_backend_data (stdoutput);
+      if (!(bed->elf_osabi == ELFOSABI_LINUX
+	    /* GNU/Linux is still using the default value 0.  */
+	    || bed->elf_osabi == ELFOSABI_NONE))
+	as_bad (_("symbol type \"%s\" is supported only by GNU targets"),
+		type_name);
+      type = BSF_FUNCTION | BSF_GNU_INDIRECT_FUNCTION;
+    }
+  else if (strcmp (type_name, "gnu_unique_object") == 0)
+    {
+      struct elf_backend_data *bed;
+
+      bed = (struct elf_backend_data *) get_elf_backend_data (stdoutput);
+      if (!(bed->elf_osabi == ELFOSABI_LINUX
+	    /* GNU/Linux is still using the default value 0.  */
+	    || bed->elf_osabi == ELFOSABI_NONE))
+	as_bad (_("symbol type \"%s\" is supported only by GNU targets"),
+		type_name);
+      type = BSF_OBJECT | BSF_GNU_UNIQUE;
+      /* PR 10549: Always set OSABI field to LINUX for objects containing unique symbols.  */
+      bed->elf_osabi = ELFOSABI_LINUX;
+    }
+#ifdef md_elf_symbol_type
+  else if ((type = md_elf_symbol_type (type_name, sym, elfsym)) != -1)
+    ;
+#endif
+  else
+    as_bad (_("unrecognized symbol type \"%s\""), type_name);
+
+  *input_line_pointer = c;
+
+  if (*input_line_pointer == '"')
+    ++input_line_pointer;
+
+  elfsym->symbol.flags |= type;
+  symbol_get_bfdsym (sym)->flags |= type;
+
+  while (*input_line_pointer == ',') {
+    ++input_line_pointer;
+
+  SKIP_WHITESPACE ();
+
+  type_name = input_line_pointer;
+  c = get_symbol_end ();
+  if (strcmp (type_name, "moveable") == 0) {
+    if (emit_all_relocs) {
+      S_SET_OTHER(sym, S_GET_OTHER(sym) | STO_MOVEABLE);
+    }
+  } else if (strcmp (type_name, "used") == 0) {
+    if (emit_all_relocs) {
+      S_SET_OTHER(sym, S_GET_OTHER(sym) | STO_USED);
+    }
+  } else 
+    as_bad (_("unrecognized symbol attribute \"%s\""), type_name);
+  *input_line_pointer = c;
+  }
+  demand_empty_rest_of_line ();
+}
+
+#define ENDPROCEXTENSION	"$endproc"
+#define MINUSEXPR		".-"
+
+static int proc_endp_status = 0;
+
+static void
+lx_endp (int start ATTRIBUTE_UNUSED)
+{
+  char * procname;
+  char c;
+
+/* function name is optionnal and is ignored */
+/* there may be several names separated by commas... */
+  while (1)
+  {
+    SKIP_WHITESPACE ();
+    procname = input_line_pointer;
+    c = get_symbol_end ();
+    *input_line_pointer = c;
+    SKIP_WHITESPACE ();
+    if (*input_line_pointer != ',')
+      break;
+    ++input_line_pointer;
+  }
+  demand_empty_rest_of_line ();
+
+  if (!proc_endp_status)
+    {
+      as_warn (".endp directive doesn't follow .proc -- ignoring ");
+      return;
+    }
+
+  proc_endp_status = 0;
+
+  /* TB begin : add BSF_FUNCTION attribute to last_proc_sym symbol */
+  if (size_type_function) {
+      if (!last_proc_sym) {
+	  as_bad("Cannot set function attributes (bad symbol)");
+	  return;
+      }
+
+/*    last_proc_sym->symbol.flags |= BSF_FUNCTION; */
+    symbol_get_bfdsym (last_proc_sym)->flags |= BSF_FUNCTION;
+    /* Add .size funcname,.-funcname in order to add size
+       attribute to the current function */
+    {
+      char *newdirective = (char *)alloca (strlen (S_GET_NAME (last_proc_sym)) +
+					   strlen(MINUSEXPR) + 1);
+      char *savep = input_line_pointer;
+      expressionS exp;
+
+      *newdirective = '\0';
+      /* BUILD :".-funcname" expression */
+      strcat (newdirective, MINUSEXPR);
+      strcat (newdirective, S_GET_NAME (last_proc_sym));
+      input_line_pointer = newdirective;
+      expression (&exp);
+
+      if (exp.X_op == O_constant)
+      {
+        S_SET_SIZE (last_proc_sym, exp.X_add_number);
+        if (symbol_get_obj (last_proc_sym)->size)
+          {
+            xfree (symbol_get_obj (last_proc_sym)->size);
+            symbol_get_obj (last_proc_sym)->size = NULL;
+          }
+      }
+      else
+      {
+        symbol_get_obj (last_proc_sym)->size =
+          (expressionS *) xmalloc (sizeof (expressionS));
+        *symbol_get_obj (last_proc_sym)->size = exp;
+      }
+
+      /* just restore the real input pointer */
+      input_line_pointer = savep;
+    }
+  }
+  /* TB end */
+
+/* (pp) encode wether a function is moveable by icacheopt in the st_other field of the ELF symbol */
+  if (emit_all_relocs) {
+    S_SET_OTHER(last_proc_sym, S_GET_OTHER(last_proc_sym) | STO_MOVEABLE);
+  }
+
+#if 0
+  /* this code emit a global symbol to mark the end of each function    */
+  /* the symbol emitted has a name formed by the original function name */
+  /* cocatenated with $endproc so if _foo is a function name the symbol */
+  /* marking the end of it is _foo$endproc                              */
+
+
+  if (emit_all_relocs)
+    {
+      char *newlab;
+      char *savep = input_line_pointer;
+
+      if (!last_proc_sym) {
+	  as_bad("Cannot set symbol at end of function (bad symbol)");
+	  return;
+      }
+
+      newlab = (char *) alloca(strlen (S_GET_NAME (last_proc_sym)) +
+			       strlen (ENDPROCEXTENSION) + 1 
+			       + 1);	/* in case of "_" */
+
+#ifdef STRIP_UNDERSCORE
+      strcpy (newlab, "_");
+#else
+      *newlab = '\0';
+#endif
+      strcat (newlab, S_GET_NAME (last_proc_sym));
+      strcat (newlab, ENDPROCEXTENSION);
+
+      colon (newlab);
+
+      /* just make sure nobody did anything to the real input pointer */
+      input_line_pointer = savep;
+
+    }
+
+#endif
+
+    last_proc_sym = NULL;
+
+
+}
+
+static void
+lx_proc (int start ATTRIBUTE_UNUSED)
+{
+  char * procname;
+  char c;
+/* there may be several names separated by commas... */
+  while (1)
+  {
+    SKIP_WHITESPACE ();
+    procname = input_line_pointer;
+    c = get_symbol_end ();
+    *input_line_pointer = c;
+    SKIP_WHITESPACE ();
+    if (*input_line_pointer != ',')
+      break;
+    ++input_line_pointer;
+  }
+  demand_empty_rest_of_line ();
+
+  if (proc_endp_status)
+    {
+      as_warn (".proc follows .proc -- ignoring");
+      return;
+    }
+
+  proc_endp_status = 1;
+
+  /* this code emit a global symbol to mark the end of each function    */
+  /* the symbol emitted has a name formed by the original function name */
+  /* cocatenated with $endproc so if _foo is a function name the symbol */
+  /* marking the end of it is _foo$endproc                              */
+  /* It is also required for generation of .size directive in lx_endp() */
+
+  if ((emit_all_relocs) || (size_type_function))
+    {
+      update_last_proc_sym = 1;
+    }
+}
+
+int
+lx_force_reloc (fixS * fixP)
+{
+  symbolS *sym;
+  asection *symsec;
+
+  if (generic_force_reloc (fixP))
+      return 1;
+
+  if (!emit_all_relocs)
+    {
+      switch (fixP->fx_r_type)
+	{
+	case BFD_RELOC_LX_GOTOFF_HI23:
+	case BFD_RELOC_LX_GOTOFF_LO9:
+	case BFD_RELOC_LX_GOTOFFX_HI23:
+	case BFD_RELOC_LX_GOTOFFX_LO9:
+	case BFD_RELOC_LX_FPTR32:
+	case BFD_RELOC_LX_PLTOFF_HI23:
+	case BFD_RELOC_LX_PLTOFF_LO9:
+	case BFD_RELOC_LX_GOTOFF_FPTR_HI23:
+	case BFD_RELOC_LX_GOTOFF_FPTR_LO9:
+	  return 1;
+	  
+	default:
+	  return 0;
+	}
+    }
+  sym = fixP->fx_addsy;
+  if (sym)
+    {
+      symsec = S_GET_SEGMENT (sym);
+      /* if (bfd_is_abs_section (symsec)) return 0; */
+      if (!SEG_NORMAL (symsec))
+	return 0;      
+    }
+  return 1;
+}
+
+int
+lx_force_reloc_sub_same (fixS * fixP, segT sec)
+{
+  symbolS *sym;
+  asection *symsec;
+  const char *sec_name = NULL;
+
+  if (generic_force_reloc (fixP))
+      return 1;
+
+  if (!emit_all_relocs)
+    {
+      switch (fixP->fx_r_type)
+	{
+	case BFD_RELOC_LX_GOTOFF_HI23:
+	case BFD_RELOC_LX_GOTOFF_LO9:
+	case BFD_RELOC_LX_GOTOFFX_HI23:
+	case BFD_RELOC_LX_GOTOFFX_LO9:
+	case BFD_RELOC_LX_FPTR32:
+	case BFD_RELOC_LX_PLTOFF_HI23:
+	case BFD_RELOC_LX_PLTOFF_LO9:
+	case BFD_RELOC_LX_GOTOFF_FPTR_HI23:
+	case BFD_RELOC_LX_GOTOFF_FPTR_LO9:
+	  return 1;
+	  
+	default:
+	  return 0;
+	}
+    }
+  sym = fixP->fx_addsy;
+  if (sym)
+    {
+      symsec = S_GET_SEGMENT (sym);
+      /* if (bfd_is_abs_section (symsec)) return 0; */
+      if (!SEG_NORMAL (symsec))
+	return 0;      
+
+      /* 
+       * for .debug_arrange, .debug_frame, .eh_frame sections, containing 
+       * expressions of the form "sym2 - sym1 + addend", solve them even when 
+       * --emit-all-relocs is set. Otherwise, a relocation on two symbols
+       * is necessary and fails at elf level. Binopt should not be impacted by
+       * the resolution of this relocatable expression on symbols inside a
+       * function.
+       */
+      sec_name =  segment_name(sec);
+      if ((strcmp(sec_name, ".eh_frame") == 0) || 
+	  (strcmp(sec_name, ".except_table") == 0) ||
+	  (strncmp(sec_name, ".debug_", strlen(".debug_")) == 0)) {
+	  return 0;
+      }
+    }
+  return 1;
+}
+
+/*
+ *    Support for unwind descriptors
+ */
+
+#define LXMAXUNWINDARGS 4
+
+static int
+lx_get_constant (const expressionS arg)
+{
+  if (arg.X_op && !arg.X_add_symbol)
+    {
+      return arg.X_add_number;
+    }
+  else
+    {
+      as_warn ("expected constant argument");
+      return 0;
+    }
+}
+
+static int
+lx_default (char *s, int i)
+{
+  as_warn (s);
+  return i;
+}
+
+static void
+lx_emit_uleb128 (int i)
+{
+  do
+    {
+      int tmp = i & 127;
+      i = (i & 0x1fffffff) >> 7;
+      FRAG_APPEND_1_CHAR ((i != 0) ? (tmp + 1) : tmp);
+    }
+  while (i != 0);
+}
+
+static void
+lx_unwind (int r)
+{
+  int ntok;
+  expressionS tok[LXMAXUNWINDARGS];
+  char *f;
+
+  int tmp;
+
+  if (strcmp (segment_name (now_seg), ".LX.unwind_info") != 0)
+    {
+      as_warn ("unwind directive not in .LX.unwind_info segment\n");
+      return;
+    }
+
+  ntok = tokenize_arguments (input_line_pointer, tok, NULL, LXMAXUNWINDARGS);
+  while (input_line_pointer && (input_line_pointer[0] != '\n'))
+    input_line_pointer++;
+
+#define LXGETCONST(i) (((i)<ntok) ? \
+		       lx_get_constant(tok[(i)]) :  \
+		       lx_default("too few operands", 0))
+
+  switch ((enum unwrecord) r)
+    {
+    case UNW_HEADER:		/* postpone fixup work for now */
+      tmp = (LXGETCONST (0) << 8);
+      tmp += (LXGETCONST (1) & 1);
+      tmp += ((LXGETCONST (2) & 1) << 1);
+      if (target_big_endian)
+	{
+	  f = frag_more (2);
+	  emit_expr (tok + 3, 2);
+
+	}
+      else
+	{
+	  emit_expr (tok + 3, 2);
+	  f = frag_more (2);
+	}
+      md_number_to_chars (f, tmp, 2);
+      break;
+
+    case UNW_PROLOGUE:
+      tmp = LXGETCONST (0);
+      if (tmp < 32)
+	{
+	  FRAG_APPEND_1_CHAR (tmp);
+	}
+      else
+	{
+	  FRAG_APPEND_1_CHAR (0x40);
+	  lx_emit_uleb128 (tmp);
+	}
+      break;
+
+    case UNW_BODY:
+      tmp = LXGETCONST (0);
+      if (tmp < 32)
+	{
+	  FRAG_APPEND_1_CHAR (tmp + 0x20);
+	}
+      else
+	{
+	  FRAG_APPEND_1_CHAR (0x41);
+	  lx_emit_uleb128 (tmp);
+	}
+      break;
+
+    case UNW_MEM_STACK_F:
+      FRAG_APPEND_1_CHAR (0xe0);
+      lx_emit_uleb128 (LXGETCONST (0));
+      lx_emit_uleb128 (LXGETCONST (1));
+      break;
+
+    case UNW_MEM_STACK_V:
+      FRAG_APPEND_1_CHAR (0xe1);
+      lx_emit_uleb128 (LXGETCONST (0));
+      break;
+
+    case UNW_PSP_SPREL:
+      FRAG_APPEND_1_CHAR (0xe2);
+      lx_emit_uleb128 (LXGETCONST (0));
+      break;
+
+    case UNW_RP_WHEN:
+      FRAG_APPEND_1_CHAR (0xe3);
+      lx_emit_uleb128 (LXGETCONST (0));
+      break;
+
+    case UNW_RP_PSPREL:
+      FRAG_APPEND_1_CHAR (0xe4);
+      lx_emit_uleb128 (LXGETCONST (0));
+      break;
+
+    case UNW_RP_SPREL:
+      FRAG_APPEND_1_CHAR (0xe5);
+      lx_emit_uleb128 (LXGETCONST (0));
+      break;
+
+    case UNW_SPILL_BASE:
+      FRAG_APPEND_1_CHAR (0xe6);
+      lx_emit_uleb128 (LXGETCONST (0));
+      break;
+
+    case UNW_PSP_GR:
+      tmp = LXGETCONST (0);
+      FRAG_APPEND_1_CHAR (0xb0);
+      FRAG_APPEND_1_CHAR (tmp & 0x3f);
+      break;
+
+    case UNW_RP_GR:
+      tmp = LXGETCONST (0);
+      FRAG_APPEND_1_CHAR (0xb1);
+      FRAG_APPEND_1_CHAR (tmp & 0x3f);
+      break;
+
+    case UNW_GR_MEM_S:
+      tmp = LXGETCONST (0);
+      FRAG_APPEND_1_CHAR (0xc0 + (tmp & 0x0f));
+      break;
+
+    case UNW_GR_MEM_L:
+      tmp = LXGETCONST (0);
+      FRAG_APPEND_1_CHAR (0x90 + (tmp & 7));
+      lx_emit_uleb128 (LXGETCONST (1));
+      break;
+
+    case UNW_SPILL_MASK:
+      as_warn ("unwind spill mask not interpreted yet \n");
+      break;
+
+    case UNW_EPILOGUE:
+      tmp = LXGETCONST (1);
+      if (tmp < 32)
+	{
+	  FRAG_APPEND_1_CHAR (0xc0 + tmp);
+	  lx_emit_uleb128 (LXGETCONST (0));
+	}
+      else
+	{
+	  FRAG_APPEND_1_CHAR (0xe0);
+	  lx_emit_uleb128 (LXGETCONST (0));
+	  lx_emit_uleb128 (tmp);
+	}
+      break;
+
+    case UNW_LABEL_STATE:
+      tmp = LXGETCONST (0);
+      if (tmp > 32)
+	{
+	  FRAG_APPEND_1_CHAR (0xe1);
+	  lx_emit_uleb128 (tmp);
+	}
+      else
+	{
+	  FRAG_APPEND_1_CHAR (0x80 + tmp);
+	}
+      break;
+
+    case UNW_COPY_STATE:
+      tmp = LXGETCONST (0);
+      if (tmp > 32)
+	{
+	  FRAG_APPEND_1_CHAR (0xe9);
+	  lx_emit_uleb128 (tmp);
+	}
+      else
+	{
+	  FRAG_APPEND_1_CHAR (0xa0 + tmp);
+	}
+      break;
+
+    case UNW_SPILL_PSREL:
+      as_warn ("unw_spill_psrel unimplemented\n");
+      break;
+    case UNW_SPILL_SPREL:
+      as_warn ("unw_spill_sprel unimplemented\n");
+      break;
+    default:
+      as_warn ("unrecognized unwind descriptor\n");
+    }
+}
+
+static void
+print_operand (expressionS * e, FILE * out) ATTRIBUTE_UNUSED;
+
+/*
+ * This is just used for debugging
+ */
+
+static void
+print_operand (expressionS * e, FILE * out)
+{
+  if (e)
+    {
+      switch (e->X_op)
+	{
+	case O_register:
+	  fprintf (out, "$%c%d.%d",
+		   lx_regtable[e->X_add_number].base,
+		   lx_regtable[e->X_add_number].cluster,
+		   lx_regtable[e->X_add_number].number);
+	  break;
+
+	case O_constant:
+	  if (e->X_add_symbol)
+	    {
+	      if (e->X_add_number)
+		fprintf (out, "(%s + %d)", S_GET_NAME (e->X_add_symbol),
+			 (int) e->X_add_number);
+	      else
+		fprintf (out, "%s", S_GET_NAME (e->X_add_symbol));
+	    }
+	  else
+	    fprintf (out, "%d", (int) e->X_add_number);
+	  break;
+
+	case O_symbol:
+	  if (e->X_add_symbol)
+	    {
+	      if (e->X_add_number)
+		fprintf (out, "(%s + %d)", S_GET_NAME (e->X_add_symbol),
+			 (int) e->X_add_number);
+	      else
+		fprintf (out, "%s", S_GET_NAME (e->X_add_symbol));
+	    }
+	  else
+	    fprintf (out, "%d", (int) e->X_add_number);
+	  break;
+
+	default:
+	  fprintf (out, "o,ptype-%d", e->X_op);
+	}
+    }
+}
+
+void
+lx_cfi_frame_initial_instructions (void)
+{
+  cfi_add_CFA_def_cfa (12, 16);
+}
+
+
+int
+lx_regname_to_dw2regnum (const char *regname)
+{
+  unsigned int regnum = -1;
+  const char *p;
+  char *q;
+
+  if (regname[0] == 'r')
+    {
+      p = regname + 1;
+      regnum = strtoul (p, &q, 10);
+      if (p == q || *q || regnum >= 64)
+	return -1;
+    }
+  return regnum;
+}
diff -r -N -u binutils-2.21.51/gas/config/tc-lx.h binutils/gas/config/tc-lx.h
--- binutils-2.21.51/gas/config/tc-lx.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/config/tc-lx.h	2010-07-13 16:25:08.400991000 +0100
@@ -0,0 +1,198 @@
+/**
+*** (c) Copyright Hewlett-Packard Company 1999-2003
+***
+*** This program is free software; you can redistribute it and/or
+*** modify it under the terms of the GNU General Public License
+*** as published by the Free Software Foundation; either version
+*** 2 of the License, or (at your option) any later version.
+***
+*** This program is distributed in the hope that it will be useful,
+*** but WITHOUT ANY WARRANTY; without even the implied warranty of
+*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+*** General Public License for more details.
+***
+*** You should have received a copy of the GNU General Public License
+*** along with this program; if not, write to the Free Software
+*** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+**/
+
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
+
+/* Author Jeff Brown */
+/* Modified by Giuseppe Desoli */
+
+/**
+*** static char sccs_id[] = "@(#)tc-lx.h	1.6 02/11/00 13:59:58";
+**/
+
+#define TC_LX
+#define TARGET_ARCH bfd_arch_lx
+#ifdef TE_LINUX
+#define TARGET_FORMAT (target_big_endian ? "elf32-lx-linux" : "elf32-littlelx-linux")
+#else
+#define TARGET_FORMAT (target_big_endian ? "elf32-lx" : "elf32-littlelx")
+#endif
+
+/* Uncomment this if the compiler prepends an _ to global names */
+/*
+ * #define STRIP_UNDERSCORE 
+ */
+
+/* default little endian */
+
+#define TARGET_BYTES_BIG_ENDIAN 0    
+
+/* for now we have no BFD target */
+
+/* lexing macros */
+
+#define LEX_QM (LEX_BEGIN_NAME | LEX_NAME)
+#define LEX_DOLLAR (LEX_BEGIN_NAME | LEX_NAME)
+#define WORKING_DOT_WORD
+
+#define md_end lx_end
+extern void lx_end (void);
+
+#define TC_FIX_TYPE struct _symbol_struct *
+#define TC_SYMFILED_TYPE struct list_info_struct *
+#define REPEAT_CONS_EXPRESSIONS
+#define TC_INIT_FIX_DATA(FIXP) ((FIXP)->tc_fix_data = NULL)
+
+#define tc_frob_label(sym) lx_frob_label(sym)
+extern void lx_frob_label PARAMS ((struct symbol *));
+/* listings */
+
+int is_constant_expression(expressionS*);
+
+/*
+ *  Make sure that absolute symbols and imported symbols
+ *  that are never used do not get written to .o file
+ */
+
+#ifdef OBJ_ELF
+#define tc_frob_symbol(sym,punt) \
+  { \
+    if ((S_GET_SEGMENT (sym) == &bfd_und_section \
+	 && ! symbol_used_p (sym)\
+	 && ELF_ST_VISIBILITY (S_GET_OTHER (sym)) == STV_DEFAULT) \
+        || (S_GET_SEGMENT (sym) == &bfd_abs_section \
+            && ! S_IS_EXTERNAL (sym) \
+	    && ! (symbol_get_bfdsym (sym)->flags) & BSF_FILE))	\
+      punt = 1; \
+  }
+#endif
+
+
+#define LISTING_HEADER "ST200 GAS LISTING"
+#define LISTING_LHS_CONT_LINES 100
+#define md_start_line_hook lx_md_start_line_hook
+extern void lx_md_start_line_hook (void);
+
+/* Values passed to md_apply_fix3 don't include the symbol value.  */
+#define MD_APPLY_SYM_VALUE(FIX) 0
+
+extern int lx_force_reloc PARAMS ((struct fix *));
+#define TC_FORCE_RELOCATION(fixP)			\
+		lx_force_reloc(fixP)
+
+#define DIFF_EXPR_OK 1
+
+#define TC_LX_ST200
+extern int lx_force_reloc_sub_same (struct fix *, segT);
+#define TC_FORCE_RELOCATION_SUB_SAME(FIX, SEC)		\
+  (! SEG_NORMAL (S_GET_SEGMENT((FIX)->fx_addsy))	\
+   || lx_force_reloc_sub_same(FIX, SEC))
+
+/* This expression evaluates to true if the relocation is for a local object
+   for which we still want to do the relocation at runtime.  False if we
+   are willing to perform this relocation while building the .o file.
+
+   We can't resolve references to the GOT or the PLT when creating the
+   object file, since these tables are only created by the linker.
+   Also, if the symbol is global, weak, common or not defined, the
+   assembler can't compute the appropriate reloc, since its location
+   can only be determined at link time.  */
+
+#define TC_FORCE_RELOCATION_LOCAL(FIX)			\
+  (!(FIX)->fx_pcrel					\
+   || TC_FORCE_RELOCATION (FIX))
+
+extern int emit_all_relocs;
+
+/* This expression evaluates to false if the relocation is for a local object
+   for which we still want to do the relocation at runtime.  True if we
+   are willing to perform this relocation while building the .o file.
+   This is only used for pcrel relocations.
+   Use this to ensure that a branch to a preemptible symbol is not
+   resolved by the assembler. */
+
+#define TC_RELOC_RTSYM_LOC_FIXUP(FIX)				\
+  ((FIX)->fx_r_type != BFD_RELOC_LX_23_PCREL                    \
+   || (FIX)->fx_addsy == NULL					\
+   || (! S_IS_EXTERNAL ((FIX)->fx_addsy)			\
+       && ! S_IS_WEAK ((FIX)->fx_addsy)			        \
+       && S_IS_DEFINED ((FIX)->fx_addsy)			\
+       && ! S_IS_COMMON ((FIX)->fx_addsy)))
+
+#define tc_fix_adjustable(fixP)                         \
+                lx_fix_adjustable (fixP)
+extern int lx_fix_adjustable PARAMS((struct fix *fix));
+
+/* This arranges for gas/write.c to not apply a relocation if
+   tc_fix_adjustable() says it is not adjustable.
+   The "! symbol_used_in_reloc_p" test is there specifically to cover
+   the case of non-global symbols in linkonce sections.  It's the
+   generally correct thing to do though;  If a reloc is going to be
+   emitted against a symbol then we don't want to adjust the fixup by
+   applying the reloc during assembly.  The reloc will be applied by
+   the linker during final link.  */
+#define TC_FIX_ADJUSTABLE(fixP) \
+  (! symbol_used_in_reloc_p ((fixP)->fx_addsy) && tc_fix_adjustable (fixP))
+
+extern void lx_validate_fix (struct fix *);
+#define TC_VALIDATE_FIX(fix,seg,skip)	lx_validate_fix (fix)
+
+/* Force this to avoid -g to fail because of dwarf2 expression .L0 - .L0 */
+extern int lx_validate_sub_fix (struct fix *fix);
+#define TC_VALIDATE_FIX_SUB(FIX, SEG)			\
+  (((FIX)->fx_r_type == BFD_RELOC_32			\
+    || (FIX)->fx_r_type == BFD_RELOC_16) &&		\
+   lx_validate_sub_fix((FIX)))
+
+#define TC_CONS_FIX_NEW(FRAG,OFF,LEN,EXP) lx_cons_fix_new(FRAG,OFF,LEN,EXP)
+extern void lx_cons_fix_new (fragS *f, int where, int nbytes,
+			     expressionS *exp);
+
+/* No post-alignment of sections */
+#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 0
+
+/* No Max for ST200 */
+#  define MAX_MEM_FOR_RS_ALIGN_CODE  ((1 << alignment) - 1)
+
+#define HANDLE_ALIGN(fragp) lx_handle_align (fragp)
+extern void lx_handle_align PARAMS ((struct frag *));
+
+#define md_do_align(N, FILL, LEN, MAX, LABEL)					\
+  if (FILL == NULL && (N) != 0 && ! need_pass_2 && subseg_text_p (now_seg))	\
+    {										\
+      lx_frag_align_code (N, MAX);						\
+      goto LABEL;								\
+    }
+extern void lx_frag_align_code PARAMS ((int, int));
+
+#ifdef OBJ_ELF
+#define TARGET_USE_CFIPOP 1
+#define tc_cfi_frame_initial_instructions lx_cfi_frame_initial_instructions
+extern void lx_cfi_frame_initial_instructions (void);
+
+#define tc_regname_to_dw2regnum lx_regname_to_dw2regnum
+extern int lx_regname_to_dw2regnum (const char *regname);
+
+/* All LX instructions are multiples of 32 bits.  */
+#define DWARF2_LINE_MIN_INSN_LENGTH 1
+#define DWARF2_DEFAULT_RETURN_COLUMN 63
+#define DWARF2_CIE_DATA_ALIGNMENT -4
+#endif
diff -r -N -u binutils-2.21.51/gas/configure binutils/gas/configure
--- binutils-2.21.51/gas/configure	2011-06-14 09:27:52.000000000 +0100
+++ binutils/gas/configure	2011-07-06 12:44:26.137253000 +0100
@@ -629,6 +629,7 @@
 LEX
 YFLAGS
 YACC
+SIM
 OPCODES_LIB
 atof
 install_tooldir
@@ -11187,7 +11188,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11190 "configure"
+#line 11191 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11293,7 +11294,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11296 "configure"
+#line 11297 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -12542,6 +12543,8 @@
 _ACEOF
 
 
+
+
 for ac_prog in 'bison -y' byacc
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
diff -r -N -u binutils-2.21.51/gas/configure.in binutils/gas/configure.in
--- binutils-2.21.51/gas/configure.in	2011-06-14 09:27:52.000000000 +0100
+++ binutils/gas/configure.in	2011-07-06 12:44:26.137253000 +0100
@@ -615,6 +615,8 @@
 AC_DEFINE_UNQUOTED(TARGET_VENDOR,	"${target_vendor}", [Target vendor.])
 AC_DEFINE_UNQUOTED(TARGET_OS,		"${target_os}",    [Target OS.])
 
+AC_SUBST(SIM)
+
 AC_PROG_YACC
 AM_PROG_LEX
 
diff -r -N -u binutils-2.21.51/gas/configure.tgt binutils/gas/configure.tgt
--- binutils-2.21.51/gas/configure.tgt	2011-04-13 08:41:36.000000000 +0100
+++ binutils/gas/configure.tgt	2011-07-06 12:44:26.137253000 +0100
@@ -80,6 +80,7 @@
   sparclet*)		cpu_type=sparc arch=sparclet ;;
   sparclite*)		cpu_type=sparc arch=sparclite ;;
   sparc*)		cpu_type=sparc arch=sparclite ;; # ??? See tc-sparc.c.
+  st2[2-4][0-9]*)	cpu_type=lx ;;
   v850*)		cpu_type=v850 ;;
   x86_64*)		cpu_type=i386 arch=x86_64;;
   xtensa*)		cpu_type=xtensa arch=xtensa ;;
@@ -246,6 +247,9 @@
 
   lm32-*-*)				fmt=elf ;;
 
+  lx-*-*elf*)                           fmt=elf bfd_gas=yes;;
+  lx-*-linux-gnu*)                      fmt=elf em=linux endian=little bfd_gas=yes ;;
+
   m32c-*-elf | m32c-*-rtems*)		fmt=elf ;;
 
   m32r-*-elf* | m32r-*-rtems*)		fmt=elf ;;
diff -r -N -u binutils-2.21.51/gas/doc/as.texinfo binutils/gas/doc/as.texinfo
--- binutils-2.21.51/gas/doc/as.texinfo	2011-04-13 08:41:36.000000000 +0100
+++ binutils/gas/doc/as.texinfo	2011-07-06 12:44:26.137253000 +0100
@@ -26,6 +26,7 @@
 @c ---
 @c man end
 @c ---
+@set ST200
 @c common OR combinations of conditions
 @ifset COFF
 @set COFF-ELF
@@ -6884,6 +6885,9 @@
 @ifset V850
 * V850-Dependent::              V850 Dependent Features
 @end ifset
+@ifset ST200
+* ST200-Dependent::             ST200 Dependent Features
+@end ifset
 @ifset XTENSA
 * Xtensa-Dependent::            Xtensa Dependent Features
 @end ifset
@@ -7088,6 +7092,10 @@
 @include c-vax.texi
 @end ifset
 
+@ifset ST200
+@include c-st200.texi
+@end ifset
+
 @ifset V850
 @include c-v850.texi
 @end ifset
diff -r -N -u binutils-2.21.51/gas/doc/c-st200.texi binutils/gas/doc/c-st200.texi
--- binutils-2.21.51/gas/doc/c-st200.texi	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/doc/c-st200.texi	2010-05-25 12:04:31.134734000 +0100
@@ -0,0 +1,77 @@
+@c Copyright 1997 Free Software Foundation, Inc.
+@c This is part of the GAS manual.
+@c For copying conditions, see the file as.texinfo.
+
+@c THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+
+@node ST200-Dependent
+@chapter st200 Dependent Features
+
+@cindex ST200 support
+@menu
+* ST200 Options::              Options
+* ST200 Directives::           ST200 Machine Directives
+@end menu
+
+@node ST200 Options
+@section Options
+@cindex ST200 options (none)
+@cindex options for ST200 (none)
+@code{@value{AS}} supports the following additional command-line options
+for the ST200 processor family:
+
+@cindex command line options, ST200
+@cindex ST200 command line options
+@table @code
+
+
+@cindex @code{--mcore} command line option, ST200
+@item --mcore [st220|st231|st240]
+Specifies whether the assembler should select the st220, the st231 or the st240 encoding table. The default if no command line option is found is st220. It also encodes the corresponding information in the ELF flags of the object file unless a .assume st2xx directive is found, in which case the ELF flags will be the ones specified by the .assume st2xx directive. 
+
+
+@end table
+
+
+@node ST200 Directives
+@section ST200 Machine Directives
+
+@cindex machine directives, ST200
+@cindex ST200 machine directives
+@table @code
+@cindex @code{.assume} directive, ST200
+@item .assume @var{parameters}
+The .assume directive expects one or more parameters, separated by commas. It is also possible to use several consecutive .assume directives.
+
+The parameters of the .assume directive are encoded in the ELF flags of the object file to identify the basic code generation assumptions taken by the compiler. This allows the linker to detect attempts to link code assembled with different incompatible assumptions.
+
+The .assume directive is generated by the C compiler. The user should only consider writting a .assume directive when mixing assembly code with C code.
+
+The .assume directive accepts five types of parameters. Values within the parameter types are exclusive. 
+
+@table @code
+@item Core identification:
+st220, st231, st240 (if none of the above is set in the assembly file and if the mcore option is not given on the command line, st220 is assumed). Note that this directive does not impact the encoding table used by the assembler, only the ELF flags.
+
+@item Silicon implementation identification:
+cut0, cut1, cut2, cut3, cut4, cut5 (if none of the above is set in the assembly file cut0 is assumed)
+
+@item Software ABI convention:
+no-abi, old-multiflow-abi, lx-embedded-abi, pic-abi, gcc-abi (if none of the above is set in the assembly file no-abi is assumed)
+
+@item OS ABI identification:
+bare-machine, os21, linux (if none of the above is set in the assembly file bare-machine is assumed)
+
+@item Code generation identification:
+user, kernel (if none of the above is set in the assembly file user is assumed)
+@end table
+
+@cindex @code{.proc} directive, ST200
+@item .proc @var{parameters}
+This directive is supported for compatibility reasons with existing code. The parameters are ignored.
+
+@cindex @code{.endp} directive, ST200
+@item .endp @var{parameters}
+This directive is supported for compatibility reasons with existing code. The parameters are ignored.
+
+@end table
diff -r -N -u binutils-2.21.51/gas/doc/Makefile.in binutils/gas/doc/Makefile.in
--- binutils-2.21.51/gas/doc/Makefile.in	2010-12-06 09:23:27.000000000 +0000
+++ binutils/gas/doc/Makefile.in	2011-07-06 12:44:26.137253000 +0100
@@ -179,6 +179,7 @@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SIM = @SIM@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
 VERSION = @VERSION@
diff -r -N -u binutils-2.21.51/gas/expr.c binutils/gas/expr.c
--- binutils-2.21.51/gas/expr.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/gas/expr.c	2011-07-06 12:44:26.137253000 +0100
@@ -725,6 +725,11 @@
   char *name;		/* Points to name of symbol.  */
   segT segment;
 
+#ifdef TC_LX
+  lx_imm_operatorT lx_imm_op;         /* (cl) current immediate operator */
+  char* save_input_line_pointer=NULL; /* (cl) backup for immediate operators */
+#endif /* TC_LX */
+
   /* All integers are regarded as unsigned unless they are negated.
      This is because the only thing which cares whether a number is
      unsigned is the code in emit_expr which extends constants into
@@ -733,6 +738,12 @@
      though it appears negative if valueT is 32 bits.  */
   expressionP->X_unsigned = 1;
 
+#ifdef TC_LX
+  /* (cl) At the very beginning the expression does not have */
+  /*      an immediate operator */
+  expressionP->X_lx_imm_op = O_lx_imm_none;
+#endif /* TC_LX */
+
   /* Digits, assume it is a bignum.  */
 
   SKIP_WHITESPACE ();		/* Leading whitespace is part of operand.  */
@@ -1185,6 +1196,89 @@
       input_line_pointer--;
       break;
 
+#ifdef TC_LX
+    case '%':
+      /* (cl) manage Lx %lo and %hi immediate operators */
+      save_input_line_pointer=input_line_pointer;
+      if ( ((input_line_pointer[0]=='l') || (input_line_pointer[0]=='L')) &&
+	   ((input_line_pointer[1]=='o') || (input_line_pointer[1]=='O')) )
+        {
+	  char* save_p;
+	  input_line_pointer++;input_line_pointer++;
+	  save_p=input_line_pointer;
+	  SKIP_WHITESPACE();    /* to check if the pointer moves */
+	  if ( (save_p!=input_line_pointer) ||
+	       (*input_line_pointer=='(') )
+            {
+	      /* then we have the %lo operator, not a symbol */
+	      lx_imm_op=O_lx_imm_lo;
+            }
+	  else
+            {
+	      input_line_pointer=save_input_line_pointer;
+	      goto de_fault;
+            }
+        }
+      else if ( ((input_line_pointer[0]=='h') || (input_line_pointer[0]=='H'))	&&
+		((input_line_pointer[1]=='i') || (input_line_pointer[1]=='I'))	)
+        {
+	  char* save_p;
+	  input_line_pointer++;input_line_pointer++;
+	  save_p=input_line_pointer;
+	  SKIP_WHITESPACE();    /* to check if the pointer moves */
+	  if ( (save_p!=input_line_pointer) ||
+	       (*input_line_pointer=='(') )
+            {
+	      /* then we have the %hi operator, not a symbol */
+	      lx_imm_op=O_lx_imm_hi;
+            }
+	  else
+            {
+	      input_line_pointer=save_input_line_pointer;
+	      goto de_fault;
+            }
+        }
+      else
+	goto de_fault;
+
+      operand (expressionP, mode);
+
+      if ( is_constant_expression(expressionP) )
+        {
+	  /* (lc) We must calculate the result right now              */
+	  /*      This is mandatory for symbol assignment such as     */
+	  /*      'toto=XXXX', otherwise, we will never get the value */
+	  /*      because there's no reloc on symbols                 */
+
+	  switch ( lx_imm_op )
+            {
+	    case O_lx_imm_lo:
+	      expressionP->X_add_number &= 0x1FF;
+	      /* 9-bits from b0 to b8 */
+	      break;
+            case O_lx_imm_hi:
+	      expressionP->X_add_number=
+		(expressionP->X_add_number & (offsetT)0xFFFFFE00)>>9;
+	      /* 23 bits from b9 to b31 */
+	      break;
+	    default:
+	      break;
+            } /* end switch ( lx_imm_op ) */
+        }
+
+      if ( expressionP->X_lx_imm_op!=O_lx_imm_none )
+	as_bad("(lx) Invalid immediate operator recursion");
+
+      expressionP->X_lx_imm_op=lx_imm_op;
+      lx_imm_op=O_absent;
+
+      /* (lc) allow error checking */
+      c=*input_line_pointer;
+
+      /* end (cl) - immediate operators */
+      break;
+#endif /* TC_LX */
+
 #ifdef TC_M68K
     case '%':
       if (! flag_m68k_mri)
@@ -1218,7 +1312,7 @@
 #endif
 
     default:
-#if defined(md_need_index_operator) || defined(TC_M68K)
+#if defined(md_need_index_operator) || defined(TC_M68K) || defined(TC_LX)
     de_fault:
 #endif
       if (is_name_beginner (c))	/* Here if did not begin with a digit.  */
diff -r -N -u binutils-2.21.51/gas/expr.h binutils/gas/expr.h
--- binutils-2.21.51/gas/expr.h	2010-12-06 09:23:27.000000000 +0000
+++ binutils/gas/expr.h	2011-07-06 12:44:26.137253000 +0100
@@ -113,6 +113,16 @@
   O_max
 } operatorT;
 
+/* do not use #ifdef TC_LX, because it is not yet defined */ 
+/* (cl) immediate operators applied on expressions */
+typedef enum
+{
+    O_lx_imm_none,
+    O_lx_imm_hi,
+    O_lx_imm_lo
+} lx_imm_operatorT;
+/* #endif */
+
 typedef struct expressionS {
   /* The main symbol.  */
   symbolS *X_add_symbol;
@@ -141,6 +151,11 @@
 
   /* Machine dependent field */
   unsigned short X_md;
+
+  /* do not use #ifdef TC_LX, because it is not yet defined */ 
+  /* (cl) lx immediate operator if any */
+  lx_imm_operatorT X_lx_imm_op;
+/* #endif */
 } expressionS;
 
 enum expr_mode
diff -r -N -u binutils-2.21.51/gas/itbl-lex.c binutils/gas/itbl-lex.c
--- binutils-2.21.51/gas/itbl-lex.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/gas/itbl-lex.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1689 +0,0 @@
-/* A lexical scanner generated by flex */
-
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
- */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-
-#include <stdio.h>
-#include <unistd.h>
-
-
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
-
-
-#ifdef __cplusplus
-
-#include <stdlib.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_PROTOS
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yy_start = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yy_start - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#define YY_BUF_SIZE 16384
-
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-
-extern int yyleng;
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
-
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-	};
-
-static YY_BUFFER_STATE yy_current_buffer = 0;
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- */
-#define YY_CURRENT_BUFFER yy_current_buffer
-
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
-
-typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
-
-#define YY_NUM_RULES 15
-#define YY_END_OF_BUFFER 16
-static yyconst short int yy_accept[60] =
-    {   0,
-        0,    0,   16,   14,   13,   12,   11,    8,    8,   10,
-       10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
-       10,    8,    0,   10,   10,   10,   10,   10,   10,   10,
-       10,   10,   10,   10,   10,   10,    7,    9,   10,   10,
-       10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
-        5,    1,    2,    3,   10,    6,   10,    4,    0
-    } ;
-
-static yyconst int yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    4,    1,    1,    5,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    6,    7,    7,
-        7,    7,    7,    7,    7,    7,    7,    1,    8,    1,
-        1,    1,    1,    1,    9,   10,   11,   12,   13,   10,
-       14,   15,   16,   15,   15,   15,   17,   18,   15,   15,
-       15,   19,   20,   15,   15,   15,   15,   15,   15,   15,
-        1,    1,    1,    1,   15,    1,   21,   10,   22,   23,
-
-       24,   10,   25,   15,   26,   15,   15,   15,   27,   28,
-       15,   29,   15,   30,   31,   15,   15,   15,   15,   32,
-       15,   15,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst int yy_meta[33] =
-    {   0,
-        1,    1,    1,    1,    1,    2,    2,    1,    2,    2,
-        2,    2,    2,    3,    3,    3,    3,    3,    3,    3,
-        2,    2,    2,    2,    3,    3,    3,    3,    3,    3,
-        3,    3
-    } ;
-
-static yyconst short int yy_base[62] =
-    {   0,
-        0,    0,   83,   84,   84,   84,   84,   27,   29,   70,
-        0,   62,   61,   60,   20,   55,   47,   46,   45,   12,
-       35,   37,    0,    0,   62,   60,   59,   58,   53,   49,
-       45,   43,   42,   41,   37,   32,    0,    0,   43,   44,
-       43,   42,   42,   36,   23,   27,   26,   25,   25,   20,
-        0,    0,    0,    0,   35,    0,   23,    0,   84,   58,
-       43
-    } ;
-
-static yyconst short int yy_def[62] =
-    {   0,
-       59,    1,   59,   59,   59,   59,   59,   59,   59,   60,
-       60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
-       60,   59,   61,   60,   60,   60,   60,   60,   60,   60,
-       60,   60,   60,   60,   60,   60,   60,   61,   60,   60,
-       60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
-       60,   60,   60,   60,   60,   60,   60,   60,    0,   59,
-       59
-    } ;
-
-static yyconst short int yy_nxt[117] =
-    {   0,
-        4,    5,    6,    5,    7,    8,    9,    7,   10,   11,
-       12,   13,   11,   14,   11,   15,   11,   11,   11,   11,
-       16,   17,   18,   11,   19,   20,   11,   11,   21,   11,
-       11,   11,   22,   22,   22,   22,   29,   30,   35,   36,
-       37,   37,   22,   22,   38,   58,   58,   56,   57,   54,
-       53,   52,   51,   56,   55,   54,   53,   52,   23,   24,
-       24,   51,   50,   49,   48,   47,   46,   45,   44,   43,
-       42,   41,   40,   39,   34,   33,   32,   31,   28,   27,
-       26,   25,   59,    3,   59,   59,   59,   59,   59,   59,
-       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
-
-       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
-       59,   59,   59,   59,   59,   59
-    } ;
-
-static yyconst short int yy_chk[117] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    8,    8,    9,    9,   15,   15,   20,   20,
-       21,   21,   22,   22,   61,   57,   55,   50,   49,   48,
-       47,   46,   45,   44,   43,   42,   41,   40,    8,   60,
-       60,   39,   36,   35,   34,   33,   32,   31,   30,   29,
-       28,   27,   26,   25,   19,   18,   17,   16,   14,   13,
-       12,   10,    3,   59,   59,   59,   59,   59,   59,   59,
-       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
-
-       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
-       59,   59,   59,   59,   59,   59
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "itbl-lex.l"
-#define INITIAL 0
-/* itbl-lex.l
-   Copyright 1997, 1998, 2001, 2002, 2005, 2006, 2007
-   Free Software Foundation, Inc.
-
-   This file is part of GAS, the GNU Assembler.
-
-   GAS is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   GAS is distributed in the hope that it will be useful, 
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with GAS; see the file COPYING.  If not, write to the Free
-   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
-   02110-1301, USA.  */
-#line 23 "itbl-lex.l"
-#include "as.h"
-#include "itbl-lex.h"
-#include <itbl-parse.h>
-
-#ifdef DEBUG
-#define DBG(x) printf x
-#define MDBG(x) printf x
-#else
-#define DBG(x)
-#define MDBG(x)
-#endif
-
-int insntbl_line = 1;
-#line 441 "itbl-lex.c"
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
-#else
-extern int yywrap YY_PROTO(( void ));
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
-
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
-#endif
-
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
-		{ \
-		int c = '*', n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-YY_DECL
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp = NULL, *yy_bp = NULL;
-	register int yy_act;
-
-#line 43 "itbl-lex.l"
-
-
-#line 595 "itbl-lex.c"
-
-	if ( yy_init )
-		{
-		yy_init = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-
-		yy_load_buffer_state();
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yy_start;
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 60 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 84 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-
-do_action:	/* This label is used only to access EOF actions. */
-
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 45 "itbl-lex.l"
-{
-    return CREG;
-  }
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 48 "itbl-lex.l"
-{
-    return DREG;
-  }
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 51 "itbl-lex.l"
-{
-    return GREG;
-  }
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 54 "itbl-lex.l"
-{
-    return IMMED;
-  }
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 57 "itbl-lex.l"
-{
-    return ADDR;
-  }
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 60 "itbl-lex.l"
-{
-    return INSN;
-  }
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 63 "itbl-lex.l"
-{
-    yytext[yyleng] = 0;
-    yylval.processor = strtoul (yytext+1, 0, 0);
-    return PNUM;
-  }
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 68 "itbl-lex.l"
-{
-    yytext[yyleng] = 0;
-    yylval.num = strtoul (yytext, 0, 0);
-    return NUM;
-  }
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 73 "itbl-lex.l"
-{
-    yytext[yyleng] = 0;
-    yylval.num = strtoul (yytext, 0, 0);
-    return NUM;
-  }
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 78 "itbl-lex.l"
-{
-    yytext[yyleng] = 0;
-    yylval.str = strdup (yytext);
-    return ID;
-  }
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 83 "itbl-lex.l"
-{
-    int c;
-    while ((c = input ()) !=  EOF) 
-      {
-        if (c ==  '\n') 
-    	{
-    		unput (c);
-    		break;
-    	}
-      }
-  }
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 94 "itbl-lex.l"
-{ 
-    insntbl_line++; 
-    MDBG (("in lex, NL = %d (x%x)\n", NL, NL));
-    return NL; 
-  }
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 99 "itbl-lex.l"
-{ 
-  }
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 101 "itbl-lex.l"
-{
-    MDBG (("char = %x, %d\n", yytext[0], yytext[0]));
-    return yytext[0];
-  }
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 105 "itbl-lex.l"
-ECHO;
-	YY_BREAK
-#line 799 "itbl-lex.c"
-case YY_STATE_EOF(INITIAL):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state();
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer() )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap() )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of yylex */
-
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
-
-	else
-		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
-
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
-#endif
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
-
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	if ( yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
-
-	return ret_val;
-	}
-
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-static yy_state_type yy_get_previous_state()
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 60 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-	}
-
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 60 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 59);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
-
-
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
-
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
-
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
-
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput()
-#else
-static int input()
-#endif
-	{
-	int c;
-
-	*yy_c_buf_p = yy_hold_char;
-
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
-
-			switch ( yy_get_next_buffer() )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/* fall through */
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap() )
-						return EOF;
-
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
-
-	return c;
-	}
-#endif /* YY_NO_INPUT */
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
-
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
-		return;
-
-	if ( yy_current_buffer )
-		{
-		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
-
-
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
-	if ( ! b )
-		return;
-
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
-
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
-
-	{
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
-	{
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
-	}
-
-
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b );
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
-#endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
-
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
-
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
-
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
-
-
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
-
-
-/* Internal utility routines. */
-
-#ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-	}
-#endif
-
-#ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-	}
-#endif
-
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
-
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 105 "itbl-lex.l"
-
-
-#ifndef yywrap
-int 
-yywrap () 
-  { 
-    return 1; 
-  }
-#endif
diff -r -N -u binutils-2.21.51/gas/itbl-parse.c binutils/gas/itbl-parse.c
--- binutils-2.21.51/gas/itbl-parse.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/gas/itbl-parse.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1685 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     DREG = 258,
-     CREG = 259,
-     GREG = 260,
-     IMMED = 261,
-     ADDR = 262,
-     INSN = 263,
-     NUM = 264,
-     ID = 265,
-     NL = 266,
-     PNUM = 267
-   };
-#endif
-#define DREG 258
-#define CREG 259
-#define GREG 260
-#define IMMED 261
-#define ADDR 262
-#define INSN 263
-#define NUM 264
-#define ID 265
-#define NL 266
-#define PNUM 267
-
-
-
-
-/* Copy the first part of user declarations.  */
-#line 21 "itbl-parse.y"
-
-
-/* 
-
-Yacc grammar for instruction table entries.
-
-=======================================================================
-Original Instruction table specification document:
-
-	    MIPS Coprocessor Table Specification
-	    ====================================
-
-This document describes the format of the MIPS coprocessor table.  The
-table specifies a list of valid functions, data registers and control
-registers that can be used in coprocessor instructions.  This list,
-together with the coprocessor instruction classes listed below,
-specifies the complete list of coprocessor instructions that will
-be recognized and assembled by the GNU assembler.  In effect,
-this makes the GNU assembler table-driven, where the table is
-specified by the programmer.
-
-The table is an ordinary text file that the GNU assembler reads when
-it starts.  Using the information in the table, the assembler
-generates an internal list of valid coprocessor registers and
-functions.  The assembler uses this internal list in addition to the
-standard MIPS registers and instructions which are built-in to the 
-assembler during code generation.
-
-To specify the coprocessor table when invoking the GNU assembler, use
-the command line option "--itbl file", where file is the
-complete name of the table, including path and extension.
-
-Examples:
-
-	    gas -t cop.tbl test.s -o test.o
-	    gas -t /usr/local/lib/cop.tbl test.s -o test.o
-	    gas --itbl d:\gnu\data\cop.tbl test.s -o test.o
-
-Only one table may be supplied during a single invocation of
-the assembler.
-
-
-Instruction classes
-===================
-
-Below is a list of the valid coprocessor instruction classes for
-any given coprocessor "z".  These instructions are already recognized
-by the assembler, and are listed here only for reference.
-
-Class   format	    	    	      instructions
--------------------------------------------------
-Class1:
-	op base rt offset
-	    	    	    	    	    	    	    LWCz rt,offset (base)
-	    	    	    	    	    	    	    SWCz rt,offset (base)
-Class2:
-	COPz sub rt rd 0
-	    	    	    	    	    	    	    MTCz rt,rd
-	    	    	    	    	    	    	    MFCz rt,rd
-	    	    	    	    	    	    	    CTCz rt,rd
-	    	    	    	    	    	    	    CFCz rt,rd
-Class3:
-	COPz CO cofun
-	    	    	    	    	    	    	    COPz cofun
-Class4:
-	COPz BC br offset
-	    	    	    	    	    	    	    BCzT offset
-	    	    	    	    	    	    	    BCzF offset
-Class5:
-	COPz sub rt rd 0
-	    	    	    	    	    	    	    DMFCz rt,rd
-	    	    	    	    	    	    	    DMTCz rt,rd
-Class6:
-	op base rt offset
-	    	    	    	    	    	    	    LDCz rt,offset (base)
-	    	    	    	    	    	    	    SDCz rt,offset (base)
-Class7:
-	COPz BC br offset
-	    	    	    	    	    	    	    BCzTL offset
-	    	    	    	    	    	    	    BCzFL offset
-
-The coprocessor table defines coprocessor-specific registers that can
-be used with all of the above classes of instructions, where
-appropriate.  It also defines additional coprocessor-specific
-functions for Class3 (COPz cofun) instructions, Thus, the table allows
-the programmer to use convenient mnemonics and operands for these
-functions, instead of the COPz mmenmonic and cofun operand.
-
-The names of the MIPS general registers and their aliases are defined
-by the assembler and will be recognized as valid register names by the
-assembler when used (where allowed) in coprocessor instructions.
-However, the names and values of all coprocessor data and control
-register mnemonics must be specified in the coprocessor table.
-
-
-Table Grammar
-=============
-
-Here is the grammar for the coprocessor table:
-
-	    table -> entry*
-
-	    entry -> [z entrydef] [comment] '\n'
-
-	    entrydef -> type name val
-	    entrydef -> 'insn' name val funcdef ; type of entry (instruction)
-
-	    z -> 'p'['0'..'3']	    	     ; processor number 
-	    type -> ['dreg' | 'creg' | 'greg' ]	     ; type of entry (register)
-	; 'dreg', 'creg' or 'greg' specifies a data, control, or general
-	;	    register mnemonic, respectively
-	    name -> [ltr|dec]*	    	     ; mnemonic of register/function
-	    val -> [dec|hex]	    	     ; register/function number (integer constant)
-
-	    funcdef -> frange flags fields
-	    	    	    	; bitfield range for opcode
-	    	    	    	; list of fields' formats
-	    fields -> field*
-	    field -> [','] ftype frange flags
-	    flags -> ['*' flagexpr]
-	    flagexpr -> '[' flagexpr ']'
-	    flagexpr -> val '|' flagexpr 
-	    ftype -> [ type | 'immed' | 'addr' ]
-	; 'immed' specifies an immediate value; see grammar for "val" above
-	    	; 'addr' specifies a C identifier; name of symbol to be resolved at 
-	;	    link time
-	    frange -> ':' val '-' val	; starting to ending bit positions, where
-	    	    	    	; where 0 is least significant bit
-	    frange -> (null)	    	; default range of 31-0 will be assumed
-
-	    comment -> [';'|'#'] [char]*
-	    char -> any printable character
-	    ltr -> ['a'..'z'|'A'..'Z'] 
-	    dec -> ['0'..'9']*	    	    	    	    	     ; value in decimal
-	    hex -> '0x'['0'..'9' | 'a'..'f' | 'A'..'F']*	; value in hexadecimal 
-
-
-Examples
-========
-
-Example 1:
-
-The table:
-
-	    p1 dreg d1 1	     ; data register "d1" for COP1 has value 1
-	    p1 creg c3 3	     ; ctrl register "c3" for COP1 has value 3
-	    p3 func fill 0x1f:24-20	      ; function "fill" for COP3 has value 31 and 
-	    	    	; no fields
-
-will allow the assembler to accept the following coprocessor instructions:
-
-	    LWC1 d1,0x100 ($2)
-	    fill
-
-Here, the general purpose register "$2", and instruction "LWC1", are standard 
-mnemonics built-in to the MIPS assembler.  
-
-
-Example 2:
-
-The table:
-
-	    p3 dreg d3 3	     ; data register "d3" for COP3 has value 3
-	    p3 creg c2 22	     ; control register "c2" for COP3 has value 22
-	    p3 func fee 0x1f:24-20 dreg:17-13 creg:12-8 immed:7-0 
-	    	; function "fee" for COP3 has value 31, and 3 fields 
-	    	; consisting of a data register, a control register, 
-	    	; and an immediate value.
-
-will allow the assembler to accept the following coprocessor instruction:
-
-	    fee d3,c2,0x1
-
-and will emit the object code:
-
-	    31-26  25 24-20 19-18  17-13 12-8  7-0
-	    COPz   CO fun	    	      dreg  creg  immed
-	    010011 1  11111 00	     00011 10110 00000001 
-
-	    0x4ff07601
-
-
-Example 3:
-
-The table:
-
-	    p3 dreg d3 3	     ; data register "d3" for COP3 has value 3
-	    p3 creg c2 22	     ; control register "c2" for COP3 has value 22
-	    p3 func fuu 0x01f00001 dreg:17-13 creg:12-8
-
-will allow the assembler to accept the following coprocessor
-instruction:
-
-	    fuu d3,c2
-
-and will emit the object code:
-
-	    31-26  25 24-20 19-18  17-13 12-8  7-0
-	    COPz   CO fun	    	      dreg  creg  
-	    010011 1  11111 00	     00011 10110 00000001 
-
-	    0x4ff07601
-
-In this way, the programmer can force arbitrary bits of an instruction
-to have predefined values.
-
-=======================================================================
-Additional notes:
-
-Encoding of ranges:
-To handle more than one bit position range within an instruction,
-use 0s to mask out the ranges which don't apply.
-May decide to modify the syntax to allow commas separate multiple 
-ranges within an instruction (range','range).
-
-Changes in grammar:
-	The number of parms argument to the function entry
-was deleted from the original format such that we now count the fields.
-
-----
-FIXME! should really change lexical analyzer 
-to recognize 'dreg' etc. in context sensitive way.
-Currently function names or mnemonics may be incorrectly parsed as keywords
-
-FIXME! hex is ambiguous with any digit
-
-*/
-
-#include "as.h"
-#include "itbl-lex.h"
-#include "itbl-ops.h"
-
-/* #define DEBUG */
-
-#ifdef DEBUG
-#ifndef DBG_LVL
-#define DBG_LVL 1
-#endif
-#else
-#define DBG_LVL 0
-#endif
-
-#if DBG_LVL >= 1
-#define DBG(x) printf x
-#else
-#define DBG(x) 
-#endif
-
-#if DBG_LVL >= 2
-#define DBGL2(x) printf x
-#else
-#define DBGL2(x) 
-#endif
-
-static int sbit, ebit;
-static struct itbl_entry *insn=0;
-static int yyerror (const char *);
-
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 282 "itbl-parse.y"
-typedef union YYSTYPE {
-    char *str;
-    int num;
-    int processor;
-    unsigned long val;
-  } YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 367 "itbl-parse.c"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 214 of yacc.c.  */
-#line 379 "itbl-parse.c"
-
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
-
-# ifndef YYFREE
-#  define YYFREE free
-# endif
-# ifndef YYMALLOC
-#  define YYMALLOC malloc
-# endif
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
-#  endif
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-# endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
-
-
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  short yyss;
-  YYSTYPE yyvs;
-  };
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAXIMUM)
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  register YYSIZE_T yyi;		\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (0)
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (0)
-
-#endif
-
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
-#define YYFINAL  9
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   46
-
-/* YYNTOKENS -- Number of terminals. */
-#define YYNTOKENS  20
-/* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  15
-/* YYNRULES -- Number of rules. */
-#define YYNRULES  29
-/* YYNRULES -- Number of states. */
-#define YYNSTATES  51
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   267
-
-#define YYTRANSLATE(YYX) 						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,    17,     2,    13,    19,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,    18,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,    15,     2,    16,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,    14,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const unsigned char yyprhs[] =
-{
-       0,     0,     3,     5,     8,     9,    15,    16,    26,    28,
-      31,    35,    38,    39,    41,    43,    45,    49,    53,    57,
-      59,    62,    63,    68,    69,    71,    73,    75,    77,    79
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
-{
-      21,     0,    -1,    22,    -1,    23,    22,    -1,    -1,    31,
-      32,    33,    34,    11,    -1,    -1,    31,     8,    33,    34,
-      30,    29,    24,    25,    11,    -1,    11,    -1,     1,    11,
-      -1,    13,    27,    25,    -1,    27,    25,    -1,    -1,    32,
-      -1,     7,    -1,     6,    -1,    26,    30,    29,    -1,     9,
-      14,    28,    -1,    15,    28,    16,    -1,     9,    -1,    17,
-      28,    -1,    -1,    18,     9,    19,     9,    -1,    -1,    12,
-      -1,     3,    -1,     4,    -1,     5,    -1,    10,    -1,     9,
-      -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
-{
-       0,   299,   299,   303,   304,   308,   315,   314,   323,   324,
-     328,   329,   330,   334,   339,   344,   352,   361,   365,   369,
-     376,   382,   388,   395,   402,   410,   415,   420,   428,   444
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "DREG", "CREG", "GREG", "IMMED", "ADDR",
-  "INSN", "NUM", "ID", "NL", "PNUM", "','", "'|'", "'['", "']'", "'*'",
-  "':'", "'-'", "$accept", "insntbl", "entrys", "entry", "@1",
-  "fieldspecs", "ftype", "fieldspec", "flagexpr", "flags", "range", "pnum",
-  "regtype", "name", "value", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,    44,   124,    91,    93,    42,    58,    45
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
-{
-       0,    20,    21,    22,    22,    23,    24,    23,    23,    23,
-      25,    25,    25,    26,    26,    26,    27,    28,    28,    28,
-      29,    29,    30,    30,    31,    32,    32,    32,    33,    34
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
-{
-       0,     2,     1,     2,     0,     5,     0,     9,     1,     2,
-       3,     2,     0,     1,     1,     1,     3,     3,     3,     1,
-       2,     0,     4,     0,     1,     1,     1,     1,     1,     1
-};
-
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const unsigned char yydefact[] =
-{
-       0,     0,     8,    24,     0,     2,     0,     0,     9,     1,
-       3,    25,    26,    27,     0,     0,    28,     0,     0,    29,
-      23,     0,     0,    21,     5,     0,     0,     6,     0,    19,
-       0,    20,    12,    22,     0,     0,    15,    14,     0,     0,
-      23,    12,    13,    17,    18,    12,     7,    21,    11,    10,
-      16
-};
-
-/* YYDEFGOTO[NTERM-NUM]. */
-static const yysigned_char yydefgoto[] =
-{
-      -1,     4,     5,     6,    32,    39,    40,    41,    31,    27,
-      23,     7,    42,    17,    20
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -16
-static const yysigned_char yypact[] =
-{
-       0,    -9,   -16,   -16,    10,   -16,     0,    12,   -16,   -16,
-     -16,   -16,   -16,   -16,     3,     3,   -16,     9,     9,   -16,
-      11,     8,    19,    15,   -16,    14,    -6,   -16,    25,    21,
-      -6,   -16,     1,   -16,    -6,    20,   -16,   -16,    18,    26,
-      11,     1,   -16,   -16,   -16,     1,   -16,    15,   -16,   -16,
-     -16
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const yysigned_char yypgoto[] =
-{
-     -16,   -16,    32,   -16,   -16,   -15,   -16,     2,    -3,    -8,
-       4,   -16,    34,    27,    28
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -5
-static const yysigned_char yytable[] =
-{
-      -4,     1,     8,    29,    11,    12,    13,    36,    37,    30,
-       9,     2,     3,    16,    38,    11,    12,    13,    19,    24,
-      14,    11,    12,    13,    36,    37,    48,    35,    25,    22,
-      49,    43,    26,    28,    33,    34,    44,    46,    10,    50,
-      45,    15,    18,     0,    47,     0,    21
-};
-
-static const yysigned_char yycheck[] =
-{
-       0,     1,    11,     9,     3,     4,     5,     6,     7,    15,
-       0,    11,    12,    10,    13,     3,     4,     5,     9,    11,
-       8,     3,     4,     5,     6,     7,    41,    30,     9,    18,
-      45,    34,    17,    19,     9,    14,    16,    11,     6,    47,
-      38,     7,    15,    -1,    40,    -1,    18
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
-{
-       0,     1,    11,    12,    21,    22,    23,    31,    11,     0,
-      22,     3,     4,     5,     8,    32,    10,    33,    33,     9,
-      34,    34,    18,    30,    11,     9,    17,    29,    19,     9,
-      15,    28,    24,     9,    14,    28,     6,     7,    13,    25,
-      26,    27,    32,    28,    16,    27,    11,    30,    25,    25,
-      29
-};
-
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-
-#define YYFAIL		goto yyerrlab
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
-      YYERROR;							\
-    }								\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
-
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
-#endif
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
-#endif
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (0)
-
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
-
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_stack_print (short *bottom, short *top)
-#else
-static void
-yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
-#endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (0)
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_reduce_print (int yyrule)
-#else
-static void
-yy_reduce_print (yyrule)
-    int yyrule;
-#endif
-{
-  int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
-yystrlen (const char *yystr)
-#   else
-yystrlen (yystr)
-     const char *yystr;
-#   endif
-{
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
-    continue;
-
-  return yys - yystr - 1;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-#   if defined (__STDC__) || defined (__cplusplus)
-yystpcpy (char *yydest, const char *yysrc)
-#   else
-yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
-{
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-#endif /* !YYERROR_VERBOSE */
-
-
-
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  if (yytype < YYNTOKENS)
-    {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-  switch (yytype)
-    {
-      default:
-        break;
-    }
-  YYFPRINTF (yyoutput, ")");
-}
-
-#endif /* ! YYDEBUG */
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yydestruct (yytype, yyvaluep)
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  switch (yytype)
-    {
-
-      default:
-        break;
-    }
-}
-
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM);
-# else
-int yyparse ();
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-
-/* The lookahead symbol.  */
-int yychar;
-
-/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int
-yyparse (void)
-#else
-int
-yyparse ()
-
-#endif
-#endif
-{
-  
-  register int yystate;
-  register int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss;
-  yyvsp = yyvs;
-
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-	/* Give user a chance to reallocate the stack. Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
-
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-
-		    &yystacksize);
-
-	yyss = yyss1;
-	yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
-      {
-	short *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyoverflowlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
-    {
-        case 5:
-#line 309 "itbl-parse.y"
-    {
-	    DBG (("line %d: entry pnum=%d type=%d name=%s value=x%x\n", 
-	    	    insntbl_line, yyvsp[-4].num, yyvsp[-3].num, yyvsp[-2].str, yyvsp[-1].val));
-	    itbl_add_reg (yyvsp[-4].num, yyvsp[-3].num, yyvsp[-2].str, yyvsp[-1].val);
-	  }
-    break;
-
-  case 6:
-#line 315 "itbl-parse.y"
-    {
-	    DBG (("line %d: entry pnum=%d type=INSN name=%s value=x%x",
-	    	    insntbl_line, yyvsp[-5].num, yyvsp[-3].str, yyvsp[-2].val));
-	    DBG ((" sbit=%d ebit=%d flags=0x%x\n", sbit, ebit, yyvsp[0].val));
-	    insn=itbl_add_insn (yyvsp[-5].num, yyvsp[-3].str, yyvsp[-2].val, sbit, ebit, yyvsp[0].val);
-	  }
-    break;
-
-  case 7:
-#line 322 "itbl-parse.y"
-    {}
-    break;
-
-  case 13:
-#line 335 "itbl-parse.y"
-    {
-	    DBGL2 (("ftype\n"));
-	    yyval.num = yyvsp[0].num;
-	  }
-    break;
-
-  case 14:
-#line 340 "itbl-parse.y"
-    {
-	    DBGL2 (("addr\n"));
-	    yyval.num = ADDR;
-	  }
-    break;
-
-  case 15:
-#line 345 "itbl-parse.y"
-    {
-	    DBGL2 (("immed\n"));
-	    yyval.num = IMMED;
-	  }
-    break;
-
-  case 16:
-#line 353 "itbl-parse.y"
-    {
-	    DBG (("line %d: field type=%d sbit=%d ebit=%d, flags=0x%x\n", 
-	    	    insntbl_line, yyvsp[-2].num, sbit, ebit, yyvsp[0].val));
-	    itbl_add_operand (insn, yyvsp[-2].num, sbit, ebit, yyvsp[0].val);
-	  }
-    break;
-
-  case 17:
-#line 362 "itbl-parse.y"
-    {
-	    yyval.val = yyvsp[-2].num | yyvsp[0].val;
-	  }
-    break;
-
-  case 18:
-#line 366 "itbl-parse.y"
-    {
-	    yyval.val = yyvsp[-1].val;
-	  }
-    break;
-
-  case 19:
-#line 370 "itbl-parse.y"
-    {
-	    yyval.val = yyvsp[0].num;
-	  }
-    break;
-
-  case 20:
-#line 377 "itbl-parse.y"
-    {
-	    DBGL2 (("flags=%d\n", yyvsp[0].val));
-	    yyval.val = yyvsp[0].val;
-	  }
-    break;
-
-  case 21:
-#line 382 "itbl-parse.y"
-    {
-	    yyval.val = 0;
-	  }
-    break;
-
-  case 22:
-#line 389 "itbl-parse.y"
-    {
-	    DBGL2 (("range %d %d\n", yyvsp[-2].num, yyvsp[0].num));
-	    sbit = yyvsp[-2].num;
-	    ebit = yyvsp[0].num;
-	  }
-    break;
-
-  case 23:
-#line 395 "itbl-parse.y"
-    {
-	    sbit = 31;
-	    ebit = 0;
-	  }
-    break;
-
-  case 24:
-#line 403 "itbl-parse.y"
-    {
-	    DBGL2 (("pnum=%d\n",yyvsp[0].num));
-	    yyval.num = yyvsp[0].num;
-	  }
-    break;
-
-  case 25:
-#line 411 "itbl-parse.y"
-    {
-	    DBGL2 (("dreg\n"));
-	    yyval.num = DREG;
-	  }
-    break;
-
-  case 26:
-#line 416 "itbl-parse.y"
-    {
-	    DBGL2 (("creg\n"));
-	    yyval.num = CREG;
-	  }
-    break;
-
-  case 27:
-#line 421 "itbl-parse.y"
-    {
-	    DBGL2 (("greg\n"));
-	    yyval.num = GREG;
-	  }
-    break;
-
-  case 28:
-#line 429 "itbl-parse.y"
-    {
-	    DBGL2 (("name=%s\n",yyvsp[0].str));
-	    yyval.str = yyvsp[0].str; 
-	  }
-    break;
-
-  case 29:
-#line 445 "itbl-parse.y"
-    {
-	    DBGL2 (("val=x%x\n",yyvsp[0].num));
-	    yyval.val = yyvsp[0].num;
-	  }
-    break;
-
-
-    }
-
-/* Line 1000 of yacc.c.  */
-#line 1451 "itbl-parse.c"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
-	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
-
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
-	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
-      else
-	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
-	  yychar = YYEMPTY;
-
-	}
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
-     goto yyerrorlab;
-#endif
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-	YYABORT;
-
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
-  *++yyvsp = yylval;
-
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-yyreturn:
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-  return yyresult;
-}
-
-
-#line 450 "itbl-parse.y"
-
-
-static int
-yyerror (msg)
-     const char *msg;
-{
-  printf ("line %d: %s\n", insntbl_line, msg);
-  return 0;
-}
-
diff -r -N -u binutils-2.21.51/gas/itbl-parse.h binutils/gas/itbl-parse.h
--- binutils-2.21.51/gas/itbl-parse.h	2011-04-13 08:41:36.000000000 +0100
+++ binutils/gas/itbl-parse.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     DREG = 258,
-     CREG = 259,
-     GREG = 260,
-     IMMED = 261,
-     ADDR = 262,
-     INSN = 263,
-     NUM = 264,
-     ID = 265,
-     NL = 266,
-     PNUM = 267
-   };
-#endif
-#define DREG 258
-#define CREG 259
-#define GREG 260
-#define IMMED 261
-#define ADDR 262
-#define INSN 263
-#define NUM 264
-#define ID 265
-#define NL 266
-#define PNUM 267
-
-
-
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 282 "itbl-parse.y"
-typedef union YYSTYPE {
-    char *str;
-    int num;
-    int processor;
-    unsigned long val;
-  } YYSTYPE;
-/* Line 1275 of yacc.c.  */
-#line 68 "itbl-parse.h"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-extern YYSTYPE yylval;
-
-
-
diff -r -N -u binutils-2.21.51/gas/Makefile.am binutils/gas/Makefile.am
--- binutils-2.21.51/gas/Makefile.am	2010-12-06 09:23:27.000000000 +0000
+++ binutils/gas/Makefile.am	2011-07-06 12:44:26.137253000 +0100
@@ -102,7 +102,8 @@
 	subsegs.h \
 	symbols.h \
 	tc.h \
-	write.h
+	write.h \
+	ST_version.h
 
 # CPU files in config.
 
@@ -130,6 +131,7 @@
 	config/tc-ip2k.c \
 	config/tc-iq2000.c \
 	config/tc-lm32.c \
+	config/tc-lx.c \
 	config/tc-m32c.c \
 	config/tc-m32r.c \
 	config/tc-m68hc11.c \
@@ -194,6 +196,7 @@
 	config/tc-ip2k.h \
 	config/tc-iq2000.h \
 	config/tc-lm32.h \
+	config/tc-lx.h \
 	config/tc-m32c.h \
 	config/tc-m32r.h \
 	config/tc-m68hc11.h \
@@ -391,6 +394,30 @@
 	else echo "WARNING: could not find \`runtest'" 1>&2; :;\
 	fi
 
+site.exp: Makefile
+	@echo 'Making a new site.exp file...'
+	@echo '## these variables are automatically generated by make ##' >site.tmp
+	@echo '# Do not edit here.  If you wish to override these values' >>site.tmp
+	@echo '# edit the last section' >>site.tmp
+	@echo 'set srcdir $(srcdir)' >>site.tmp
+	@echo "set objdir `pwd`" >>site.tmp
+	@echo 'set build_alias "$(build_alias)"' >>site.tmp
+	@echo 'set build_triplet $(build_triplet)' >>site.tmp
+	@echo 'set host_alias "$(host_alias)"' >>site.tmp
+	@echo 'set host_triplet $(host_triplet)' >>site.tmp
+	@echo 'set target_alias "$(target_alias)"' >>site.tmp
+	@echo 'set target_triplet $(target_triplet)' >>site.tmp
+	@echo 'set target_list ${target_alias}' >>site.tmp
+	@echo 'set boards_dir ${srcdir}/../boards' >>site.tmp
+	@echo 'set SIM "$(SIM)"' >>site.tmp
+	@echo 'set CC_FOR_TARGET "$(CC_FOR_TARGET)"' >>site.tmp
+	@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp
+	@test ! -f site.exp || \
+	  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp
+	@-rm -f site.bak
+	@test ! -f site.exp || mv site.exp site.bak
+	@mv site.tmp site.exp
+
 # The m68k operand parser.
 
 EXTRA_as_new_SOURCES += config/m68k-parse.y config/bfin-parse.y
diff -r -N -u binutils-2.21.51/gas/Makefile.in binutils/gas/Makefile.in
--- binutils-2.21.51/gas/Makefile.in	2010-12-06 09:23:27.000000000 +0000
+++ binutils/gas/Makefile.in	2011-07-06 12:44:26.137253000 +0100
@@ -210,6 +210,7 @@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SIM = @SIM@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
 VERSION = @VERSION@
@@ -369,7 +370,8 @@
 	subsegs.h \
 	symbols.h \
 	tc.h \
-	write.h
+	write.h \
+	ST_version.h
 
 
 # CPU files in config.
@@ -397,6 +399,7 @@
 	config/tc-ip2k.c \
 	config/tc-iq2000.c \
 	config/tc-lm32.c \
+	config/tc-lx.c \
 	config/tc-m32c.c \
 	config/tc-m32r.c \
 	config/tc-m68hc11.c \
@@ -461,6 +464,7 @@
 	config/tc-ip2k.h \
 	config/tc-iq2000.h \
 	config/tc-lm32.h \
+	config/tc-lx.h \
 	config/tc-m32c.h \
 	config/tc-m32r.h \
 	config/tc-m68hc11.h \
@@ -804,6 +808,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-ip2k.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-iq2000.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-lm32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-lx.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-m32c.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-m32r.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-m68hc11.Po@am__quote@
@@ -1189,6 +1194,20 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-lm32.obj `if test -f 'config/tc-lm32.c'; then $(CYGPATH_W) 'config/tc-lm32.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-lm32.c'; fi`
 
+tc-lx.o: config/tc-lx.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-lx.o -MD -MP -MF $(DEPDIR)/tc-lx.Tpo -c -o tc-lx.o `test -f 'config/tc-lx.c' || echo '$(srcdir)/'`config/tc-lx.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-lx.Tpo $(DEPDIR)/tc-lx.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-lx.c' object='tc-lx.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-lx.o `test -f 'config/tc-lx.c' || echo '$(srcdir)/'`config/tc-lx.c
+
+tc-lx.obj: config/tc-lx.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-lx.obj -MD -MP -MF $(DEPDIR)/tc-lx.Tpo -c -o tc-lx.obj `if test -f 'config/tc-lx.c'; then $(CYGPATH_W) 'config/tc-lx.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-lx.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-lx.Tpo $(DEPDIR)/tc-lx.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-lx.c' object='tc-lx.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-lx.obj `if test -f 'config/tc-lx.c'; then $(CYGPATH_W) 'config/tc-lx.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-lx.c'; fi`
+
 tc-m32c.o: config/tc-m32c.c
 @am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-m32c.o -MD -MP -MF $(DEPDIR)/tc-m32c.Tpo -c -o tc-m32c.o `test -f 'config/tc-m32c.c' || echo '$(srcdir)/'`config/tc-m32c.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-m32c.Tpo $(DEPDIR)/tc-m32c.Po
@@ -2150,25 +2169,6 @@
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-site.exp: Makefile
-	@echo 'Making a new site.exp file...'
-	@echo '## these variables are automatically generated by make ##' >site.tmp
-	@echo '# Do not edit here.  If you wish to override these values' >>site.tmp
-	@echo '# edit the last section' >>site.tmp
-	@echo 'set srcdir $(srcdir)' >>site.tmp
-	@echo "set objdir `pwd`" >>site.tmp
-	@echo 'set build_alias "$(build_alias)"' >>site.tmp
-	@echo 'set build_triplet $(build_triplet)' >>site.tmp
-	@echo 'set host_alias "$(host_alias)"' >>site.tmp
-	@echo 'set host_triplet $(host_triplet)' >>site.tmp
-	@echo 'set target_alias "$(target_alias)"' >>site.tmp
-	@echo 'set target_triplet $(target_triplet)' >>site.tmp
-	@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp
-	@test ! -f site.exp || \
-	  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp
-	@-rm -f site.bak
-	@test ! -f site.exp || mv site.exp site.bak
-	@mv site.tmp site.exp
 
 distclean-DEJAGNU:
 	-rm -f site.exp site.bak
@@ -2331,6 +2331,30 @@
 	else echo "WARNING: could not find \`runtest'" 1>&2; :;\
 	fi
 
+site.exp: Makefile
+	@echo 'Making a new site.exp file...'
+	@echo '## these variables are automatically generated by make ##' >site.tmp
+	@echo '# Do not edit here.  If you wish to override these values' >>site.tmp
+	@echo '# edit the last section' >>site.tmp
+	@echo 'set srcdir $(srcdir)' >>site.tmp
+	@echo "set objdir `pwd`" >>site.tmp
+	@echo 'set build_alias "$(build_alias)"' >>site.tmp
+	@echo 'set build_triplet $(build_triplet)' >>site.tmp
+	@echo 'set host_alias "$(host_alias)"' >>site.tmp
+	@echo 'set host_triplet $(host_triplet)' >>site.tmp
+	@echo 'set target_alias "$(target_alias)"' >>site.tmp
+	@echo 'set target_triplet $(target_triplet)' >>site.tmp
+	@echo 'set target_list ${target_alias}' >>site.tmp
+	@echo 'set boards_dir ${srcdir}/../boards' >>site.tmp
+	@echo 'set SIM "$(SIM)"' >>site.tmp
+	@echo 'set CC_FOR_TARGET "$(CC_FOR_TARGET)"' >>site.tmp
+	@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp
+	@test ! -f site.exp || \
+	  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp
+	@-rm -f site.bak
+	@test ! -f site.exp || mv site.exp site.bak
+	@mv site.tmp site.exp
+
 # If m68k-parse.y is in a different directory, then ylwrap will use an
 # absolute path when it invokes yacc, which will cause yacc to put the
 # absolute path into the generated file.  That's a pain when it comes
diff -r -N -u binutils-2.21.51/gas/read.c binutils/gas/read.c
--- binutils-2.21.51/gas/read.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/gas/read.c	2011-07-06 12:44:26.137253000 +0100
@@ -2498,6 +2498,10 @@
 	return 0;
     }
 
+#ifdef TC_LX
+  md_start_line_hook ();
+#endif
+  
   eol = _find_end_of_line (input_line_pointer, flag_m68k_mri, 0, in_macro);
   sb_add_buffer (line, input_line_pointer, eol - input_line_pointer);
   input_line_pointer = eol;
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/all/gas.exp binutils/gas/testsuite/gas/all/gas.exp
--- binutils-2.21.51/gas/testsuite/gas/all/gas.exp	2011-06-14 09:27:52.000000000 +0100
+++ binutils/gas/testsuite/gas/all/gas.exp	2011-07-06 12:44:26.137253000 +0100
@@ -19,16 +19,16 @@
 # The test also doesn't work on mep targets, since they use RELC, and it
 # will avoid simplifying the expression since it conservatively assumes
 # ugly expressions can be saved until link-time.
-if { [istarget hppa*-*-*] || [istarget *c54x*-*-*] || [istarget mep*-*-*]} then {
+if { [istarget hppa*-*-*] || [istarget *c54x*-*-*] || [istarget mep*-*-*] || [istarget lx-*-*] } then {
     setup_xfail *-*-*
     fail "simplifiable double subtraction"
 } else {
     gas_test "p1480.s" "" "-a>" "simplifiable double subtraction"
 }
 
-# No floating point support in assembly code for CRIS and Z80.
+# No floating point support in assembly code for CRIS, Z80 and ST200.
 if { ![istarget cris-*-*] && ![istarget crisv32-*-*] 
-     && ![istarget z80-*-*] } then {
+     && ![istarget z80-*-*] && ![istarget lx-*-*] } then {
     gas_test "float.s" ""   "" "simple FP constants"
 }
 
@@ -258,6 +258,11 @@
     { hppa*-*-* } { }
     { *c4x*-*-* } { }
     { *c54x*-*-* } { }
+    { lx-*-* } {
+	run_dump_test struct
+	# align.s:28: Fatal error: .align : Third operand (max bytes) not supported on text sections
+	run_dump_test align2
+    }
     default {
 	run_dump_test struct
 	run_dump_test align
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/elf/pseudo.l binutils/gas/testsuite/gas/elf/pseudo.l
--- binutils-2.21.51/gas/testsuite/gas/elf/pseudo.l	2010-12-06 09:23:27.000000000 +0000
+++ binutils/gas/testsuite/gas/elf/pseudo.l	2011-07-06 12:44:26.137253000 +0100
@@ -8,5 +8,4 @@
 [^:]*:14: Error: Missing symbol name in directive
 [^:]*:14: Error: expected comma after name in .symver
 [^:]*:16: Error: Missing symbol name in directive
-[^:]*:18: Error: Missing symbol name in directive
 [^:]*:18: Error: unrecognized symbol type ""
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lns/lns.exp binutils/gas/testsuite/gas/lns/lns.exp
--- binutils-2.21.51/gas/testsuite/gas/lns/lns.exp	2010-02-23 12:47:14.000000000 +0000
+++ binutils/gas/testsuite/gas/lns/lns.exp	2010-06-07 14:41:42.080337000 +0100
@@ -15,6 +15,8 @@
      && ![istarget or32-*-*]
      && ![istarget rx-*-*]
      && ![istarget s390*-*-*]
+     && ![istarget lx-*-*]
+     && ![istarget st2\[0-9\]\[0-9\]-*-*]
 } {
     # Use alternate file for targets using DW_LNS_fixed_advance_pc opcodes.
     if { [istarget xtensa*-*-*] } {
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/assume-1.d binutils/gas/testsuite/gas/lx/assume-1.d
--- binutils-2.21.51/gas/testsuite/gas/lx/assume-1.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/assume-1.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,12 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -EL -mcore=st220
+#objdump: -dr
+#source: assume-1.s
+#name: Statement separator after assume directive
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+00000000 \<foo\>:
+   0:	00 00 00 b1 	goto 0 \<foo\>;;
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/assume-1.s binutils/gas/testsuite/gas/lx/assume-1.s
--- binutils-2.21.51/gas/testsuite/gas/lx/assume-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/assume-1.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,6 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Check that we can use semi-colon to terminate an assume directive
+
+	.assume st220 		;  .text ; foo:
+	goto foo
+	;;
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/bare-machine.d binutils/gas/testsuite/gas/lx/bare-machine.d
--- binutils-2.21.51/gas/testsuite/gas/lx/bare-machine.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/bare-machine.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume bare-machine
+
+.*:     file format .*lx.*
+eflags : 100 - st220 cut0 no-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/bare-machine.s binutils/gas/testsuite/gas/lx/bare-machine.s
--- binutils-2.21.51/gas/testsuite/gas/lx/bare-machine.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/bare-machine.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,3 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume bare-machine
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/cut0.d binutils/gas/testsuite/gas/lx/cut0.d
--- binutils-2.21.51/gas/testsuite/gas/lx/cut0.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/cut0.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume cut0
+
+.*:     file format .*lx.*
+eflags : 100 - st220 cut0 no-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/cut0.s binutils/gas/testsuite/gas/lx/cut0.s
--- binutils-2.21.51/gas/testsuite/gas/lx/cut0.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/cut0.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume cut0
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/cut1.d binutils/gas/testsuite/gas/lx/cut1.d
--- binutils-2.21.51/gas/testsuite/gas/lx/cut1.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/cut1.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume cut1
+
+.*:     file format .*lx.*
+eflags : 10100 - st220 cut1 no-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/cut1.s binutils/gas/testsuite/gas/lx/cut1.s
--- binutils-2.21.51/gas/testsuite/gas/lx/cut1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/cut1.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume cut1
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/cut2.d binutils/gas/testsuite/gas/lx/cut2.d
--- binutils-2.21.51/gas/testsuite/gas/lx/cut2.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/cut2.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume cut2
+
+.*:     file format .*lx.*
+eflags : 20100 - st220 cut2 no-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/cut2.s binutils/gas/testsuite/gas/lx/cut2.s
--- binutils-2.21.51/gas/testsuite/gas/lx/cut2.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/cut2.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume cut2
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/cut3.d binutils/gas/testsuite/gas/lx/cut3.d
--- binutils-2.21.51/gas/testsuite/gas/lx/cut3.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/cut3.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume cut3
+
+.*:     file format .*lx.*
+eflags : 30100 - st220 cut3 no-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/cut3.s binutils/gas/testsuite/gas/lx/cut3.s
--- binutils-2.21.51/gas/testsuite/gas/lx/cut3.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/cut3.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume cut3
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/cut4.d binutils/gas/testsuite/gas/lx/cut4.d
--- binutils-2.21.51/gas/testsuite/gas/lx/cut4.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/cut4.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume cut4
+
+.*:     file format .*lx.*
+eflags : 40100 - st220 cut4 no-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/cut4.s binutils/gas/testsuite/gas/lx/cut4.s
--- binutils-2.21.51/gas/testsuite/gas/lx/cut4.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/cut4.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume cut4
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/cut5.d binutils/gas/testsuite/gas/lx/cut5.d
--- binutils-2.21.51/gas/testsuite/gas/lx/cut5.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/cut5.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume cut5
+
+.*:     file format .*lx.*
+eflags : 50100 - st220 cut5 no-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/cut5.s binutils/gas/testsuite/gas/lx/cut5.s
--- binutils-2.21.51/gas/testsuite/gas/lx/cut5.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/cut5.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume cut5
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/equal-1.d binutils/gas/testsuite/gas/lx/equal-1.d
--- binutils-2.21.51/gas/testsuite/gas/lx/equal-1.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/equal-1.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,16 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -EL
+#objdump: -t
+#source: equal-1.s
+#name: Symbol assignment
+
+.*:     file format .*lx.*
+
+SYMBOL TABLE:
+00000000 l    d  .text	00000000 \.text
+00000000 l    d  .data	00000000 \.data
+00000000 l    d  .bss	00000000 \.bss
+00000004 l       .text	00000000 foo
+00000004 l       .text	00000000 bar
+
+
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/equal-1.s binutils/gas/testsuite/gas/lx/equal-1.s
--- binutils-2.21.51/gas/testsuite/gas/lx/equal-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/equal-1.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,10 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Check that symbol assignment is not treated as an instruction
+	.text
+	nop
+	;; 
+foo:
+	nop
+	;; 
+	bar = foo
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-bundle10.s binutils/gas/testsuite/gas/lx/err-bundle10.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-bundle10.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-bundle10.s	2007-04-23 14:11:21.700217000 +0100
@@ -0,0 +1,23 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.text
+
+	.nocheckresources
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+        ;;   # { dg-error "Bundle has too many .16. syllables" "" }
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-bundle1.s binutils/gas/testsuite/gas/lx/err-bundle1.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-bundle1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-bundle1.s	2005-12-20 15:56:31.780418000 +0000
@@ -0,0 +1,12 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.text
+
+	.nocheckresources
+	nop
+	nop
+	nop
+	nop
+	nop
+        ;;   # { dg-error "Bundle has too many .5. syllables" "" }
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-bundle2.s binutils/gas/testsuite/gas/lx/err-bundle2.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-bundle2.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-bundle2.s	2005-12-20 15:56:31.780418000 +0000
@@ -0,0 +1,9 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.text
+	.nocheckresources
+wibble:	
+	br $b0, wibble
+	brf $b0, wibble
+	;;   # { dg-error "Cannot form bundle" "" }
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-bundle3.s binutils/gas/testsuite/gas/lx/err-bundle3.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-bundle3.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-bundle3.s	2005-12-20 15:56:31.780418000 +0000
@@ -0,0 +1,12 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.text
+
+	mov $r19 = 1073741823         
+	cmplt $b1 = $r1 , 2           
+	mov $r17 = $r0                
+	pft 32 [ $r3 ]
+	;;   # { dg-error "Bundle has too many .5. syllables" "" }
+	
+	
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-bundle4.s binutils/gas/testsuite/gas/lx/err-bundle4.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-bundle4.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-bundle4.s	2007-02-20 11:58:06.474574000 +0000
@@ -0,0 +1,20 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.text
+	.align 8
+wibble:
+	# This bundle works on even boundary ...
+	br $b0, wibble
+	mulh $r1 = $r2, $r3
+	mov $r4 = 0x12345678
+	;;
+	nop
+	;;
+	# ...but not on odd boundary
+	br $b0, wibble
+	mulh $r1 = $r2, $r3
+	mov $r4 = 0x12345678
+	;;  { dg-error "Bundle not valid on 8.byte . 4 alignment" "" }
+	
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-bundle5.s binutils/gas/testsuite/gas/lx/err-bundle5.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-bundle5.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-bundle5.s	2007-02-20 11:58:06.474574000 +0000
@@ -0,0 +1,18 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.text
+	.align 8
+
+	# This bundle does not work on an even boundary.
+	# When nop insertion is disabled, it cannot be fixed up.
+	.nopinsertion
+	mulh $r1 = $r2, $r3
+	;;
+	.align 8
+	.nonopinsertion
+	mulh $r1 = $r2, $r3
+	;; # { dg-error "Bundle not valid on 8.byte alignment" "" }
+	
+	
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-bundle6.s binutils/gas/testsuite/gas/lx/err-bundle6.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-bundle6.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-bundle6.s	2006-01-04 12:05:47.756432000 +0000
@@ -0,0 +1,16 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.text
+	.align 8
+
+	# This bundle does not work on an even boundary.
+	# When nop insertion is enabled, it can be fixed up
+	# by adding two nops.
+	# so we do NOT expect an error here.
+	.nopinsertion
+	mulh $r1 = $r2, $r3
+	mulh $r4 = $r5, $r6
+	;;
+	
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-bundle7.s binutils/gas/testsuite/gas/lx/err-bundle7.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-bundle7.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-bundle7.s	2007-02-20 11:58:06.474574000 +0000
@@ -0,0 +1,25 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+# { dg-options "-mcore=st240" }
+
+	.assume st240
+	.text
+	
+	nop
+	;;
+	# This bundle is okay on an odd boundary ...
+	goto  foo
+	addf.n $r1 = $r2, $r3
+	mull   $r4 = $r2, $r3
+	addf.n $r5 = $r2, $r3
+	;;
+	nop
+	;; 
+	# ... but it is not okay on an even boundary
+	goto  foo
+	addf.n $r1 = $r2, $r3
+	mull   $r4 = $r2, $r3
+	addf.n $r5 = $r2, $r3
+	;; # { dg-error "Bundle not valid on 8-byte alignment" "" }
+	
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-bundle8.s binutils/gas/testsuite/gas/lx/err-bundle8.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-bundle8.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-bundle8.s	2007-02-20 11:58:06.474574000 +0000
@@ -0,0 +1,19 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2007
+# { dg-do assemble }
+# { dg-options "-mcore=st240" }
+
+	.assume st240
+	.text
+	.align 8
+	
+	# This bundle requires 16-byte alignment
+lab:	
+	br     $b1, lab
+	addf.n $r1 = $r2, $r3
+	ldw    $r4 = 0[$r5]
+	;; # { dg-error "Bundle not valid on 8.byte alignment" "" }
+
+	# This bundle requires 16-byte alignment
+	addf.n $r1 = $r2, $r3
+	ldw    $r4 = 1000[$r5]
+	;; # { dg-error "Bundle not valid on 8.byte . 4 alignment" "" }
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-bundle9.s binutils/gas/testsuite/gas/lx/err-bundle9.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-bundle9.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-bundle9.s	2007-05-29 12:47:25.083813000 +0100
@@ -0,0 +1,1092 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.text
+
+	.nocheckresources
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop    # { dg-error "too many instructions in bundle" "" }
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+        ;;
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err.exp binutils/gas/testsuite/gas/lx/err.exp
--- binutils-2.21.51/gas/testsuite/gas/lx/err.exp	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err.exp	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,29 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Copyright (C) 2000 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# binutils@sources.redhat.com
+
+load_lib gas-dg.exp
+dg-init
+
+if [istarget lx-*-*] then {
+    dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/warn-*.s]] "" ""
+    dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/err-*.s]] "" ""
+}
+
+dg-finish
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-opds1.s binutils/gas/testsuite/gas/lx/err-opds1.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-opds1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-opds1.s	2005-12-23 13:02:25.387454000 +0000
@@ -0,0 +1,18 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+# { dg-options "-mcore=st220" }
+	# Check error messages for illegal operand types, st220 ISA.
+	
+	.text
+
+	mov $r64 = $r1   # r64 does not exist  # { dg-error "couldn\'t find format mov" "" }
+	;;
+	andl $b8 = $r1, $r2 # b8 does not exist  # { dg-error "couldn\'t find format andl" "" }
+	;;
+	ldb $r63 = 0[$r62]  # Cannot do ldb into r63.  # { dg-error "couldn\'t find format ldb" "" }
+	;;
+	sbrk 0x1fffff # Should be okay.
+	;;
+	sbrk 0x200000 # sbrk operand cannot exceed 0x3fffff.  # { dg-error "operand is too large" "" }
+	;;
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-opds2.s binutils/gas/testsuite/gas/lx/err-opds2.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-opds2.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-opds2.s	2006-09-11 14:24:11.021723000 +0100
@@ -0,0 +1,20 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+# { dg-options "-mcore=st240" }
+	# Check error messages for illegal operand types, st240 ISA.
+	
+	.text
+
+	addpc $r1 = $r2, $r3  # Register form of addpc not allowed  # { dg-error "couldn\'t find format addpc" "" }
+	;;
+	ldl $p0 = 0[$r2]  # Cannot use p0 as source for ldp. # { dg-error "couldn\'t find format ldl" "" } 
+	;;
+	ldl $p62 = 0[$r2] # Cannot use p62 as paired register.  # { dg-error "couldn\'t find format ldl" "" }
+	;;
+	ldwc $r1 = $b0, 0[$r2] # Cannot use b0 as predicate.  # { dg-error "couldn\'t find format ldwc" "" }
+	;;
+	sbrk 0xfff # Should be okay.
+	;;
+	sbrk 0x1000 # sbrk operand cannot exceed 0xfff.  # { dg-error "operand is too large" "" }
+	;;
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-resources1.s binutils/gas/testsuite/gas/lx/err-resources1.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-resources1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-resources1.s	2005-12-20 15:56:31.780418000 +0000
@@ -0,0 +1,9 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.text
+	.checkresources
+wibble:	
+	ldw $r1 = 0[$r2]
+	stw 0[$r3] = $r2
+	;;   # { dg-error "Resource MEM over-used in bundle" "" }
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-resources2.s binutils/gas/testsuite/gas/lx/err-resources2.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-resources2.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-resources2.s	2005-12-20 15:56:31.780418000 +0000
@@ -0,0 +1,12 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.text
+	.checkresources
+wibble:
+	# This bundle is LEGAL, but the resource checker incorrectly gives an
+	# error for it.
+	br $b0, wibble
+	mulh $r1 = $r2, $r3
+	add $r4 = $r5, 0x12345678
+	;;   # { dg-error "Resource ODD over-used in bundle" "" }
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-resources3.s binutils/gas/testsuite/gas/lx/err-resources3.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-resources3.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-resources3.s	2005-12-20 15:56:31.780418000 +0000
@@ -0,0 +1,10 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.text
+	.checkresources
+wibble:
+	mulh $r1 = $r2, $r3
+	mulh $r11 = $r12, $r13
+	mulh $r21 = $r22, $r23
+	;;   # { dg-error "Resource ODD over-used in bundle" "" }
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-resources4.s binutils/gas/testsuite/gas/lx/err-resources4.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-resources4.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-resources4.s	2005-12-20 15:56:31.780418000 +0000
@@ -0,0 +1,9 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.text
+	.checkresources
+wibble:
+	br $b0, wibble
+	brf $b0, wibble
+	;;   # { dg-error "Resource CTL over-used in bundle" "" }
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-resources5.s binutils/gas/testsuite/gas/lx/err-resources5.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-resources5.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-resources5.s	2007-02-20 11:58:06.474574000 +0000
@@ -0,0 +1,12 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.text
+	.nocheckresources
+	ldw $r1 = 0[$r2]
+	stw 0[$r3] = $r2
+	;;   # { dg-error "Cannot form bundle" "" }
+	.checkresources
+	ldw $r1 = 0[$r2]
+	stw 0[$r3] = $r2
+	;;   # { dg-error "Resource MEM over-used in bundle" "" }
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-resources6.s binutils/gas/testsuite/gas/lx/err-resources6.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-resources6.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-resources6.s	2005-12-20 15:56:31.780418000 +0000
@@ -0,0 +1,9 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+# { dg-options "--check-resources" }
+
+	.text
+	# Test --check-resources command-line option causes an error for this.
+	ldw $r1 = 0[$r2]
+	stw 0[$r3] = $r2
+	;;   # { dg-error "Resource MEM over-used in bundle" "" }
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/err-resources7.s binutils/gas/testsuite/gas/lx/err-resources7.s
--- binutils-2.21.51/gas/testsuite/gas/lx/err-resources7.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/err-resources7.s	2007-02-20 11:58:06.474574000 +0000
@@ -0,0 +1,10 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+# { dg-options "--no-check-resources" }
+
+	.text
+	# Test --no-check-resources command-line option means no resource
+	# error for this bundle.
+	ldw $r1 = 0[$r2]
+	stw 0[$r3] = $r2
+	;;   # { dg-error "Cannot form bundle" "" }
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/gcc-abi.d binutils/gas/testsuite/gas/lx/gcc-abi.d
--- binutils-2.21.51/gas/testsuite/gas/lx/gcc-abi.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/gcc-abi.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume gcc-abi
+
+.*:     file format .*lx.*
+eflags : 104 - st220 cut0 gcc-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/gcc-abi.s binutils/gas/testsuite/gas/lx/gcc-abi.s
--- binutils-2.21.51/gas/testsuite/gas/lx/gcc-abi.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/gcc-abi.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume gcc-abi
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/kernel.d binutils/gas/testsuite/gas/lx/kernel.d
--- binutils-2.21.51/gas/testsuite/gas/lx/kernel.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/kernel.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume kernel
+
+.*:     file format .*lx.*
+eflags : 100 - st220 cut0 no-abi bare-machine kernel
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/kernel.s binutils/gas/testsuite/gas/lx/kernel.s
--- binutils-2.21.51/gas/testsuite/gas/lx/kernel.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/kernel.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume kernel
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/linux.d binutils/gas/testsuite/gas/lx/linux.d
--- binutils-2.21.51/gas/testsuite/gas/lx/linux.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/linux.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume linux
+
+.*:     file format .*lx.*
+eflags : 100 - st220 cut0 no-abi linux  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/linux.s binutils/gas/testsuite/gas/lx/linux.s
--- binutils-2.21.51/gas/testsuite/gas/lx/linux.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/linux.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume linux
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/lx-embedded-abi.d binutils/gas/testsuite/gas/lx/lx-embedded-abi.d
--- binutils-2.21.51/gas/testsuite/gas/lx/lx-embedded-abi.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/lx-embedded-abi.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume lx-embedded-abi
+
+.*:     file format .*lx.*
+eflags : 102 - st220 cut0 lx-embedded-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/lx-embedded-abi.s binutils/gas/testsuite/gas/lx/lx-embedded-abi.s
--- binutils-2.21.51/gas/testsuite/gas/lx/lx-embedded-abi.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/lx-embedded-abi.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume lx-embedded-abi
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/lx-rd.exp binutils/gas/testsuite/gas/lx/lx-rd.exp
--- binutils-2.21.51/gas/testsuite/gas/lx/lx-rd.exp	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/lx-rd.exp	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,28 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Copyright (C) 2003 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# dejagnu@gnu.org
+
+if [istarget lx-*-*] then {
+    set rd_test_list [lsort [glob -nocomplain $srcdir/$subdir/*.d]]
+    foreach rdtest $rd_test_list {
+	# We need to strip the ".d", but can leave the dirname.
+	verbose [file rootname $rdtest]
+	run_dump_test [file rootname $rdtest]
+    }
+}
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/macrodis.d binutils/gas/testsuite/gas/lx/macrodis.d
--- binutils-2.21.51/gas/testsuite/gas/lx/macrodis.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/macrodis.d	2007-03-07 10:19:15.967958000 +0000
@@ -0,0 +1,37 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2006
+#as: --mcore=st240
+#objdump: -d
+#source: macrodis.s
+#name: macrodis: Disassembly of st240 macros
+
+dump.o.*
+
+Disassembly of section \.text:
+
+00000000 \<start\>:
+   0:	80 10 00 80 	mov \$r1 = \$r2;;
+   4:	00 00 00 80 	nop ;;
+   8:	42 b0 01 9a 	bswap \$r1 = \$r2;;
+   c:	40 10 40 9d 	convbi \$r1 = \$b2;;
+  10:	02 10 80 87 	convib \$b1 = \$r2;;
+  14:	83 10 c0 04 	cmple \$r1 = \$r3, \$r2
+  18:	83 10 c0 86 	cmple \$b1 = \$r3, \$r2;;
+  1c:	83 10 e0 04 	cmpleu \$r1 = \$r3, \$r2
+  20:	83 10 e0 86 	cmpleu \$b1 = \$r3, \$r2;;
+  24:	83 10 00 05 	cmplt \$r1 = \$r3, \$r2
+  28:	83 10 00 87 	cmplt \$b1 = \$r3, \$r2;;
+  2c:	83 10 20 05 	cmpltu \$r1 = \$r3, \$r2
+  30:	83 10 20 87 	cmpltu \$b1 = \$r3, \$r2;;
+  34:	83 10 40 04 	cmpgef.n \$r1 = \$r3, \$r2
+  38:	83 10 40 86 	cmpgef.n \$b1 = \$r3, \$r2;;
+  3c:	83 10 80 04 	cmpgtf.n \$r1 = \$r3, \$r2
+  40:	83 10 80 86 	cmpgtf.n \$b1 = \$r3, \$r2;;
+  44:	c4 10 44 96 	slct \$r1 = \$b2, \$r4, \$r3;;
+  48:	42 80 a0 98 	sxtb \$r1 = \$r2;;
+  4c:	42 00 a1 98 	sxth \$r1 = \$r2;;
+  50:	42 f0 2f 89 	zxtb \$r1 = \$r2;;
+  54:	42 00 c1 98 	zxth \$r1 = \$r2;;
+  58:	c4 10 40 96 	slct.pb \$r1 = \$b2, \$r4, \$r3;;
+  5c:	02 10 04 92 	unpacku.pbh \$r1 = \$r2;;
+  60:	02 10 24 92 	unpacku.pbl \$r1 = \$r2;;
+  64:	c2 10 28 93 	shuff.phl \$r1 = \$r2, \$r3;;
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/macrodis.s binutils/gas/testsuite/gas/lx/macrodis.s
--- binutils-2.21.51/gas/testsuite/gas/lx/macrodis.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/macrodis.s	2007-03-07 10:19:15.967958000 +0000
@@ -0,0 +1,52 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2006
+#  Test recognition of the st240 saturating arithmetic instructions.
+	.assume st240	
+	.text
+start:
+	add $r1 = $r0, $r2  # => mov
+	;;
+	add $r0 = $r0, $r0  # => nop
+	;;
+	perm.pb $r1 = $r2, 27     # => bswap
+	;;
+	slctf $r1 = $b2, $r0, 1    # => convbi
+	;;
+	orl $b1 = $r2, $r0    # => convib
+	;;
+	cmpge $r1 = $r2, $r3 # => cmple
+	cmpge $b1 = $r2, $r3 # => cmple
+	;;
+	cmpgeu $r1 = $r2, $r3 # => cmpleu
+	cmpgeu $b1 = $r2, $r3 # => cmpleu
+	;;
+	cmpgt $r1 = $r2, $r3 # => cmplt
+	cmpgt $b1 = $r2, $r3 # => cmplt
+	;;
+	cmpgtu $r1 = $r2, $r3 # => cmpltu
+	cmpgtu $b1 = $r2, $r3 # => cmpltu
+	;;
+	cmplef.n $r1 = $r2, $r3 # => cmpgef.n
+	cmplef.n $b1 = $r2, $r3 # => cmpgef.n
+	;;
+	cmpltf.n $r1 = $r2, $r3 # => cmpgtf.n
+	cmpltf.n $b1 = $r2, $r3 # => cmpgtf.n
+	;;
+	slctf $r1 = $b2, $r3, $r4 # => slct
+	;;
+	sxt $r1 = $r2, 8 # => sxtb
+	;;
+	sxt $r1 = $r2, 16 # => sxth
+	;;
+	and $r1 = $r2, 255  # => zxtb
+	;;
+	zxt $r1 = $r2, 16  # => zxth
+	;;
+	slctf.pb $r1 = $b2, $r3, $r4 # => slct.pb
+	;;
+	shuff.pbh $r1 = $r2, $r0 # => unpacku.pbh
+	;;
+	shuff.pbl $r1 = $r2, $r0 # => unpacku.pbl
+	;;
+	pack.ph $r1 = $r2, $r3 # => shuff.phl
+	;;
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/no-abi.d binutils/gas/testsuite/gas/lx/no-abi.d
--- binutils-2.21.51/gas/testsuite/gas/lx/no-abi.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/no-abi.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume no-abi
+
+.*:     file format .*lx.*
+eflags : 100 - st220 cut0 no-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/no-abi.s binutils/gas/testsuite/gas/lx/no-abi.s
--- binutils-2.21.51/gas/testsuite/gas/lx/no-abi.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/no-abi.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume no-abi
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/old-multiflow-abi.d binutils/gas/testsuite/gas/lx/old-multiflow-abi.d
--- binutils-2.21.51/gas/testsuite/gas/lx/old-multiflow-abi.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/old-multiflow-abi.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume old-multiflow-abi
+
+.*:     file format .*lx.*
+eflags : 101 - st220 cut0 old-multiflow-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/old-multiflow-abi.s binutils/gas/testsuite/gas/lx/old-multiflow-abi.s
--- binutils-2.21.51/gas/testsuite/gas/lx/old-multiflow-abi.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/old-multiflow-abi.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume old-multiflow-abi
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/opds1a.d binutils/gas/testsuite/gas/lx/opds1a.d
--- binutils-2.21.51/gas/testsuite/gas/lx/opds1a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/opds1a.d	2006-09-20 12:40:51.487882000 +0100
@@ -0,0 +1,17 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+#as: --mcore=st240
+#objdump: -d
+#source: opds1a.s
+#name: opds1a: All operand types, st240 only
+
+dump\.o:.*
+
+Disassembly of section \.text:
+
+00000000 \<start>:
+   0:	81 10 f0 af 	stwl \$b1, \[\$r1\] = \$r2;;
+   4:	ff 9f e0 af 	sbrk 4095 \(0xfff\);;
+   8:	84 00 00 a0 	ldl \$p2 = 0 \(0x0\)\[\$r4\];;
+   c:	81 00 20 a0 	ldlc \$p2 = \$b1, 0 \(0x0\)\[\$r1\];;
+  10:	81 00 00 a8 	stl 0 \(0x0\)\[\$r1\] = \$p2;;
+
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/opds1a.s binutils/gas/testsuite/gas/lx/opds1a.s
--- binutils-2.21.51/gas/testsuite/gas/lx/opds1a.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/opds1a.s	2006-09-11 14:24:11.021723000 +0100
@@ -0,0 +1,22 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+#  Test of all the operand types the assembler can accept.
+#  Part 2:	 st240 and later.
+	
+	.text
+start:	
+
+	# bdest2
+	stwl $b1, [$r1] = $r2
+	;; 
+	# brknum
+	sbrk 0xfff
+	;; 
+	# idestp
+	ldl $p2 = 0[$r4]
+	;; 
+	# pcond
+	ldlc $p2 = $b1, 0[$r1]
+	;; 
+	# src2p
+	stl 0[$r1] = $p2
+	;;
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/opds1.d binutils/gas/testsuite/gas/lx/opds1.d
--- binutils-2.21.51/gas/testsuite/gas/lx/opds1.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/opds1.d	2005-12-23 13:02:25.387454000 +0000
@@ -0,0 +1,27 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+#as: --mcore=st220
+#objdump: -d
+#source: opds1.s
+#name: opds1: All operand types, st220 only
+
+dump.o.*
+
+Disassembly of section \.text:
+
+00000000 \<start\>:
+   0:	00 00 00 b8 	br \$b0, 0 \<start\>;;
+   4:	81 00 00 86 	cmpeq \$b0 = \$r1, \$r2;;
+   8:	fe ff 7f b0 	call \$r63 = 0 \<start\>;;
+   c:	c2 10 00 80 	add \$r1 = \$r2, \$r3;;
+  10:	01 00 00 8e 	cmpeq \$b0 = \$r1, 0 \(0x0\);;
+  14:	40 f0 0f 88 	mov \$r1 = 255 \(0xff\);;
+  18:	ff ff 07 95 	
+  1c:	83 f0 0f 88 	add \$r2 = \$r3, 255 \(0xff\);;
+  20:	83 f0 1f 88 	add \$r2 = \$r3, -1 \(0xffffffff\);;
+  24:	03 21 e0 81 	mullhus \$r2 = \$r3, \$r4;;
+  28:	00 00 00 00 	nop 
+  2c:	83 f0 ef 89 	mullhus \$r2 = \$r3, 255 \(0xff\);;
+  30:	ff ff bf 9f 	sbrk 2097151 \(0x1fffff\);;
+  34:	c2 10 00 90 	slct \$r1 = \$b0, \$r2, \$r3;;
+  38:	c2 10 00 80 	add \$r1 = \$r2, \$r3;;
+  3c:	80 10 00 80 	mov \$r1 = \$r2;;
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/opds1.s binutils/gas/testsuite/gas/lx/opds1.s
--- binutils-2.21.51/gas/testsuite/gas/lx/opds1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/opds1.s	2005-12-23 13:02:25.387454000 +0000
@@ -0,0 +1,57 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+#  Test of all the operand types the assembler can accept.
+# Part 1:	st220 only.
+	
+	.text
+start:	
+	# bcond
+	br $b0, wibble
+	;;
+	# bdest
+	cmpeq $b0 = $r1, $r2
+	;; 
+	# btarg
+	call $r63 = start
+	;; 
+	# dest
+	add $r1 = $r2, $r3
+	;;
+	# destp:	 Unused
+	# ibdest
+	cmpeq $b0, $r1, 0
+	;; 
+	# idest
+	mov $r1 = 255
+	;; 
+	# imm
+	imml 0x7ffff
+	;; 
+	# isrc2
+	add $r2 = $r3, 255
+	;; 
+	# isrc2, extended
+	add $r2 = $r3, 0xffffffff
+	;; 
+	# issrc2:	Unused
+	# nldest
+	mullhus $r2 = $r3, $r4
+	;; 
+	# nlidest
+	mullhus $r2 = $r3, 255
+	;; 
+	# nlsrc1 :	 Unused
+	# nlsrc2 :	 Unused
+	# sbrknum
+	sbrk 0x1fffff
+	;;
+	# scond
+	slct $r1 = $b0, $r2, $r3
+	;; 
+	# src1
+	add $r1 = $r2, $r3
+	;; 
+	# src1p :	 Unused
+	# src2
+	mov $r1 = $r2
+	;; 
+	
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/opds2.d binutils/gas/testsuite/gas/lx/opds2.d
--- binutils-2.21.51/gas/testsuite/gas/lx/opds2.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/opds2.d	2007-05-29 12:47:25.083813000 +0100
@@ -0,0 +1,18 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+#as: --mcore=st240
+#objdump: -d
+#source: opds2.s
+#name: opds2: Operand types allowed by nostrictoperandchecking, st240 or later.
+
+dump\.o:.*
+
+Disassembly of section \.text:
+
+00000000 \<start>:
+   0:	00 00 00 00 	nop 
+   4:	81 f0 c3 82 	mul32 \$r63 = \$r1, \$r2;;
+   8:	c1 0f 00 a8 	stl 0 \(0x0\)\[\$r1\] = \$p63;;
+   c:	c1 0f 00 a0 	ldl \$p63 = 0 \(0x0\)\[\$r1\];;
+  10:	01 00 00 a0 	pft 0 \(0x0\)\[\$r1\];;
+  14:	81 00 00 a0 	ldl \$p2 = 0 \(0x0\)\[\$r1\];;
+  18:	fa ff 7f b0 	call \$r63 = 0 \<start>;;
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/opds2.s binutils/gas/testsuite/gas/lx/opds2.s
--- binutils-2.21.51/gas/testsuite/gas/lx/opds2.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/opds2.s	2007-05-29 12:47:25.083813000 +0100
@@ -0,0 +1,27 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+#  Test operand types allowed by nostrictoperandchecking
+#  	 st240 and later.
+	
+	.text
+start:
+	.nostrictoperandchecking
+
+	# r63 in nolink
+	mul32  $r63 = $r1, $r2
+	;;
+	# r63 in paired
+	stl 0[$r1] = $r63
+	;;
+	# r63 in nzpaired
+	ldl    $r63 = 0[$r1]
+	;; 
+	# p0 in nzpaired
+	ldl	$p0 = 0[$r1]
+	;;
+	# b0 in predicate.
+	ldlc	$p2 = $b0, 0[$r1]
+	;;
+	# r23 in link.
+	call	$r23 = start
+	;;
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/os21.d binutils/gas/testsuite/gas/lx/os21.d
--- binutils-2.21.51/gas/testsuite/gas/lx/os21.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/os21.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume os21
+
+.*:     file format .*lx.*
+eflags : 100 - st220 cut0 no-abi os21  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/os21.s binutils/gas/testsuite/gas/lx/os21.s
--- binutils-2.21.51/gas/testsuite/gas/lx/os21.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/os21.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume os21
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/pic-abi.d binutils/gas/testsuite/gas/lx/pic-abi.d
--- binutils-2.21.51/gas/testsuite/gas/lx/pic-abi.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/pic-abi.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume pic ABI
+
+.*:     file format .*lx.*
+eflags : 103 - st220 cut0 pic-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/pic-abi.s binutils/gas/testsuite/gas/lx/pic-abi.s
--- binutils-2.21.51/gas/testsuite/gas/lx/pic-abi.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/pic-abi.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume pic-abi
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/proc-1.d binutils/gas/testsuite/gas/lx/proc-1.d
--- binutils-2.21.51/gas/testsuite/gas/lx/proc-1.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/proc-1.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,16 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -EL
+#objdump: -dr
+#source: proc-1.s
+#name: .proc directive with symbol list and semi-colon separator
+
+.*:     file format .*lx.*
+
+Disassembly of section .text:
+
+00000000 <foo1>:
+   0:	02 00 00 b1 	goto 8 <foo2>;;
+   4:	00 00 00 80 	nop ;;
+
+00000008 <foo2>:
+   8:	fe ff 7f b1 	goto 0 <foo1>;;
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/proc-1.s binutils/gas/testsuite/gas/lx/proc-1.s
--- binutils-2.21.51/gas/testsuite/gas/lx/proc-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/proc-1.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,11 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Check .proc accepts symbol list, followed by semi-colon separator
+	.text
+	.proc foo1, foo2 ;  foo1: goto foo2
+	;;
+	nop
+	;; 
+foo2:	goto foo1
+	;;
+# Check endp accepts symbol list
+	.endp foo1, foo2
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/rel-1a.d binutils/gas/testsuite/gas/lx/rel-1a.d
--- binutils-2.21.51/gas/testsuite/gas/lx/rel-1a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/rel-1a.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,53 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: --emit-all-relocs -EL
+#objdump: -sr
+#source: rel-1.s
+#name: All relocation types, emit-all-relocs
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   *TYPE              *VALUE 
+00000000 R_LX_23_PCREL     foo
+00000004 R_LX_LO9          y
+00000008 R_LX_HI23         y
+0000000c R_LX_GPREL_LO9    y
+00000010 R_LX_GPREL_HI23   y
+00000014 R_LX_GOTOFF_LO9   y
+00000018 R_LX_GOTOFF_HI23  y
+0000001c R_LX_NEG_GPREL_LO9  y
+00000020 R_LX_NEG_GPREL_HI23  y
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_16           const5a5a
+00000002 R_LX_32           y
+00000006 R_LX_LTV32        y
+0000000a R_LX_SEGREL32     y
+
+
+RELOCATION RECORDS FOR \[moretext\]:
+OFFSET   TYPE              VALUE 
+00000004 R_LX_PLTOFF_LO9   y
+00000000 R_LX_PLTOFF_HI23  y
+0000000c R_LX_GOTOFF_FPTR_LO9  start
+00000008 R_LX_GOTOFF_FPTR_HI23  start
+
+
+RELOCATION RECORDS FOR \[moredata\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_FPTR32       start
+00000004 R_LX_IPLT         start
+
+
+Contents of section \.text:
+ 0000 000000b0 40000020 00000095 4e000020  .*
+ 0010 00000095 4e000020 00000095 4e000020  .*
+ 0020 00000095                             .*
+Contents of section \.data:
+ 0000 00000000 00000000 00000000 0000      .*
+Contents of section moretext:
+ 0000 00008015 4e0000a0 00008015 4e0000a0  .*
+Contents of section moredata:
+ 0000 00000000 00000000 00000000           .*
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/rel-1b.d binutils/gas/testsuite/gas/lx/rel-1b.d
--- binutils-2.21.51/gas/testsuite/gas/lx/rel-1b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/rel-1b.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,53 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -EL
+#objdump: -sr
+#source: rel-1.s
+#name: All relocation types
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   *TYPE              *VALUE 
+00000000 R_LX_23_PCREL     foo
+00000004 R_LX_LO9          \.data
+00000008 R_LX_HI23         \.data
+0000000c R_LX_GPREL_LO9    \.data
+00000010 R_LX_GPREL_HI23   \.data
+00000014 R_LX_GOTOFF_LO9   y
+00000018 R_LX_GOTOFF_HI23  y
+0000001c R_LX_NEG_GPREL_LO9  \.data
+00000020 R_LX_NEG_GPREL_HI23  \.data
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_16           const5a5a
+00000002 R_LX_32           \.data
+00000006 R_LX_LTV32        \.data
+0000000a R_LX_SEGREL32     \.data
+
+
+RELOCATION RECORDS FOR \[moretext\]:
+OFFSET   TYPE              VALUE 
+00000004 R_LX_PLTOFF_LO9   y
+00000000 R_LX_PLTOFF_HI23  y
+0000000c R_LX_GOTOFF_FPTR_LO9  start
+00000008 R_LX_GOTOFF_FPTR_HI23  start
+
+
+RELOCATION RECORDS FOR \[moredata\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_FPTR32       start
+00000004 R_LX_IPLT         start
+
+
+Contents of section \.text:
+ 0000 000000b0 40000020 00000095 4e000020  .*
+ 0010 00000095 4e000020 00000095 4e000020  .*
+ 0020 00000095                             .*
+Contents of section \.data:
+ 0000 00000000 00000000 00000000 0000      .*
+Contents of section moretext:
+ 0000 00008015 4e0000a0 00008015 4e0000a0  .*
+Contents of section moredata:
+ 0000 00000000 00000000 00000000           .*
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/rel-1c.d binutils/gas/testsuite/gas/lx/rel-1c.d
--- binutils-2.21.51/gas/testsuite/gas/lx/rel-1c.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/rel-1c.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,53 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -EB
+#objdump: -sr
+#source: rel-1.s
+#name: All relocation types, big endian
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   *TYPE              *VALUE 
+00000000 R_LX_23_PCREL     foo
+00000004 R_LX_LO9          \.data
+00000008 R_LX_HI23         \.data
+0000000c R_LX_GPREL_LO9    \.data
+00000010 R_LX_GPREL_HI23   \.data
+00000014 R_LX_GOTOFF_LO9   y
+00000018 R_LX_GOTOFF_HI23  y
+0000001c R_LX_NEG_GPREL_LO9  \.data
+00000020 R_LX_NEG_GPREL_HI23  \.data
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_16           const5a5a
+00000002 R_LX_32           \.data
+00000006 R_LX_LTV32        \.data
+0000000a R_LX_SEGREL32     \.data
+
+
+RELOCATION RECORDS FOR \[moretext\]:
+OFFSET   TYPE              VALUE 
+00000004 R_LX_PLTOFF_LO9   y
+00000000 R_LX_PLTOFF_HI23  y
+0000000c R_LX_GOTOFF_FPTR_LO9  start
+00000008 R_LX_GOTOFF_FPTR_HI23  start
+
+
+RELOCATION RECORDS FOR \[moredata\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_FPTR32       start
+00000004 R_LX_IPLT         start
+
+
+Contents of section \.text:
+ 0000 b0000000 20000040 95000000 2000004e  .*
+ 0010 95000000 2000004e 95000000 2000004e  .*
+ 0020 95000000                             .*
+Contents of section \.data:
+ 0000 00000000 00000000 00000000 0000      .*
+Contents of section moretext:
+ 0000 15800000 a000004e 15800000 a000004e  .*
+Contents of section moredata:
+ 0000 00000000 00000000 00000000           .*
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/rel-1.s binutils/gas/testsuite/gas/lx/rel-1.s
--- binutils-2.21.51/gas/testsuite/gas/lx/rel-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/rel-1.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,37 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#  Test to generate all the relocation types the assembler can generate
+#  TLS relocation types are in rel-2.s
+	
+	.text
+start:
+	call $r63=foo		# R_LX_23_PCREL
+	;; 
+	ldw  $r1=y[$r0]		# R_LX_HI23/R_LX_LO9
+	;;
+	ldw $r1=@gprel(y)[$r14] # R_LX_GPREL_HI23/R_LX_GPREL_LO9
+	;;
+	ldw $r1=@gotoff(y)[$r14] # R_LX_GOTOFF_HI23/R_LX_GOTOFF_LO9
+	;;
+	ldw $r1=@neggprel(y)[$r14] # R_LX_NEGGPREL_HI23/R_LX_NEGGPREL_LO9
+	;;
+	.data
+y:
+	.data2 const5a5a	# R_LX_16
+	.long y   		# R_LX_32
+	.long @ltv(y)		# R_LX_LTV32
+	.long @segrel(y)	# R_LX_SEGREL32
+#	.long x - .             # R_LX_32_PCREL
+
+#  The following tests relocation types not used by MCDT tools
+	.section moretext, "ax"
+	.align 8
+	ldw $r1=@pltoff(y)[$r14] # R_LX_PLTOFF_HI23/R_LX_PLTOFF_LO9
+	;;
+	ldw $r1=@gotoff(@fptr(start))[$r14] # R_LX_GOTOFF_FPTR_HI23/LO9
+	;; 
+	
+	.section moredata,"aw"
+	.long @fptr(start)	# R_LX_FPTR32
+	.long @iplt(start)	# R_LX_IPLT
+	.long 0
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/rel-2a.d binutils/gas/testsuite/gas/lx/rel-2a.d
--- binutils-2.21.51/gas/testsuite/gas/lx/rel-2a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/rel-2a.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,37 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: --emit-all-relocs -EL
+#objdump: -sr
+#source: rel-2.s
+#name: rel-2a: TLS relocation types, emit-all-relocs
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   *TYPE              *VALUE 
+00000004 R_LX_GOTOFF_TPREL_LO9  ty
+00000000 R_LX_GOTOFF_TPREL_HI23  ty
+0000000c R_LX_TPREL_LO9    ty
+00000008 R_LX_TPREL_HI23   ty
+00000014 R_LX_GOTOFF_DTPLDM_LO9  ty
+00000010 R_LX_GOTOFF_DTPLDM_HI23  ty
+0000001c R_LX_DTPREL_LO9   ty
+00000018 R_LX_DTPREL_HI23  ty
+00000024 R_LX_GOTOFF_DTPNDX_LO9  ty
+00000020 R_LX_GOTOFF_DTPNDX_HI23  ty
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_TPREL32      y
+00000004 R_LX_DTPMOD32     y
+00000008 R_LX_DTPREL32     y
+
+
+Contents of section \.text:
+ 0000 00008015 4e0000a0 00008015 4e0000a0  .*
+ 0010 00008015 4e0000a0 00008015 4e0000a0  .*
+ 0020 00008015 4e0000a0                    .*
+Contents of section \.data:
+ 0000 00000000 00000000 00000000           .*
+Contents of section \.tdata:
+ 0000 01000000                             .*
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/rel-2b.d binutils/gas/testsuite/gas/lx/rel-2b.d
--- binutils-2.21.51/gas/testsuite/gas/lx/rel-2b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/rel-2b.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,37 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -EL
+#objdump: -sr
+#source: rel-2.s
+#name: rel-2b: TLS relocation types
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   *TYPE            *VALUE 
+00000004 R_LX_GOTOFF_TPREL_LO9  ty
+00000000 R_LX_GOTOFF_TPREL_HI23  ty
+0000000c R_LX_TPREL_LO9    ty
+00000008 R_LX_TPREL_HI23   ty
+00000014 R_LX_GOTOFF_DTPLDM_LO9  ty
+00000010 R_LX_GOTOFF_DTPLDM_HI23  ty
+0000001c R_LX_DTPREL_LO9   ty
+00000018 R_LX_DTPREL_HI23  ty
+00000024 R_LX_GOTOFF_DTPNDX_LO9  ty
+00000020 R_LX_GOTOFF_DTPNDX_HI23  ty
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_TPREL32      y
+00000004 R_LX_DTPMOD32     y
+00000008 R_LX_DTPREL32     y
+
+
+Contents of section \.text:
+ 0000 00008015 4e0000a0 00008015 4e0000a0  .*
+ 0010 00008015 4e0000a0 00008015 4e0000a0  .*
+ 0020 00008015 4e0000a0                    .*
+Contents of section \.data:
+ 0000 00000000 00000000 00000000           .*
+Contents of section \.tdata:
+ 0000 01000000                             .*
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/rel-2c.d binutils/gas/testsuite/gas/lx/rel-2c.d
--- binutils-2.21.51/gas/testsuite/gas/lx/rel-2c.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/rel-2c.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,37 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -EB
+#objdump: -sr
+#source: rel-2.s
+#name: rel-2c: TLS relocation types, big-endian
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET  *TYPE             *VALUE 
+00000004 R_LX_GOTOFF_TPREL_LO9  ty
+00000000 R_LX_GOTOFF_TPREL_HI23  ty
+0000000c R_LX_TPREL_LO9    ty
+00000008 R_LX_TPREL_HI23   ty
+00000014 R_LX_GOTOFF_DTPLDM_LO9  ty
+00000010 R_LX_GOTOFF_DTPLDM_HI23  ty
+0000001c R_LX_DTPREL_LO9   ty
+00000018 R_LX_DTPREL_HI23  ty
+00000024 R_LX_GOTOFF_DTPNDX_LO9  ty
+00000020 R_LX_GOTOFF_DTPNDX_HI23  ty
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_TPREL32      y
+00000004 R_LX_DTPMOD32     y
+00000008 R_LX_DTPREL32     y
+
+
+Contents of section \.text:
+ 0000 15800000 a000004e 15800000 a000004e  .*
+ 0010 15800000 a000004e 15800000 a000004e  .*
+ 0020 15800000 a000004e                    .*
+Contents of section \.data:
+ 0000 00000000 00000000 00000000           .*
+Contents of section \.tdata:
+ 0000 00000001                             .*
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/rel-2.s binutils/gas/testsuite/gas/lx/rel-2.s
--- binutils-2.21.51/gas/testsuite/gas/lx/rel-2.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/rel-2.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,26 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#  Test to generate all the relocation types the assembler can generate
+
+	.text
+start:
+	ldw $r1=@gotoff(@tprel(ty))[$r14] # R_LX_GOTOFF_TPREL_HI23/R_LX_GOTOFF_TPREL_LO9
+	;;
+	ldw $r1=@tprel(ty)[$r14]          # R_LX_TPREL_HI23/R_LX_TPREL_LO9
+	;;
+	ldw $r1=@gotoff(@dtpldm(ty))[$r14] # R_LX_GOTOFF_DTPLDM_HI23/R_LX_GOTOFF_DTPLDM_LO9
+	;;
+	ldw $r1=@dtprel(ty)[$r14]         # R_LX_DTPREL_HI23/R_LX_DTPREL_LO9
+	;;
+	ldw $r1=@gotoff(@dtpndx(ty))[$r14] # R_LX_GOTOFF_DTPNDX_HI23/R_LX_GOTOFF_DTPNDX_LO9
+	;;
+	
+	.section .tdata, "waT", @progbits
+ty:
+	.word 1
+	.global ty
+	.size ty, 4
+
+	.data
+	.long @tprel(y)		# R_LX_TPREL32
+	.long @dtpmod(y)	# R_LX_DTPMOD
+	.long @dtprel(y)	# R_LX_DTPREL
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/satops.d binutils/gas/testsuite/gas/lx/satops.d
--- binutils-2.21.51/gas/testsuite/gas/lx/satops.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/satops.d	2006-11-14 13:36:17.782494000 +0000
@@ -0,0 +1,26 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2006
+#as: --mcore=st240
+#objdump: -d
+#source: satops.s
+#name: satops: ST240 saturated arithmetic operations
+
+dump.o.*
+
+Disassembly of section \.text:
+
+00000000 \<start\>:
+   0:	c2 10 10 83 	addso \$r1 = \$r2, \$r3;;
+   4:	c2 10 b0 82 	adds\.ph \$r1 = \$r2, \$r3;;
+   8:	c2 10 10 82 	adds \$r1 = \$r2, \$r3;;
+   c:	02 10 90 83 	satso \$r1 = \$r2;;
+  10:	02 10 90 82 	sats \$r1 = \$r2;;
+  14:	83 10 50 83 	sh1addso \$r1 = \$r2, \$r3;;
+  18:	83 10 50 82 	sh1adds \$r1 = \$r2, \$r3;;
+  1c:	83 10 70 83 	sh1subso \$r1 = \$r2, \$r3;;
+  20:	83 10 70 82 	sh1subs \$r1 = \$r2, \$r3;;
+  24:	83 10 30 83 	subso \$r1 = \$r2, \$r3;;
+  28:	83 10 d0 82 	subs\.ph \$r1 = \$r2, \$r3;;
+  2c:	83 10 30 82 	subs \$r1 = \$r2, \$r3;;
+  30:	01 30 60 af 	prginsset 3 \(0x3\)\[\$r1\];;
+  34:	01 10 70 2f 	prginsset 257 \(0x101\)\[\$r1\];;
+  38:	00 00 00 95 	
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/satops.s binutils/gas/testsuite/gas/lx/satops.s
--- binutils-2.21.51/gas/testsuite/gas/lx/satops.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/satops.s	2006-11-14 13:36:17.782494000 +0000
@@ -0,0 +1,35 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2006
+#  Test recognition of the st240 saturating arithmetic instructions.
+	.assume st240	
+	.text
+start:
+	addso	$r1=$r2,$r3
+	;; 
+	adds.ph	$r1=$r2,$r3
+	;; 
+	adds	$r1=$r2,$r3
+	;; 
+	satso	$r1=$r2
+	;; 
+	sats	$r1=$r2
+	;; 
+	sh1addso $r1=$r2,$r3
+	;; 
+	sh1adds	$r1=$r2,$r3
+	;; 
+	sh1subso $r1=$r2,$r3
+	;; 
+	sh1subs	$r1=$r2,$r3
+	;; 
+	subso	$r1=$r2,$r3
+	;; 
+	subs.ph	$r1=$r2,$r3
+	;; 
+	subs	$r1=$r2,$r3
+	;; 
+	prginsset 3[$r1]
+	;; 
+	prginsset 257[$r1]
+	;;
+	
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/size-1.d binutils/gas/testsuite/gas/lx/size-1.d
--- binutils-2.21.51/gas/testsuite/gas/lx/size-1.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/size-1.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,15 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -EL
+#objdump: -t
+#source: size-1.s
+#name: Size of large function set in ELF symbol table
+
+.*:     file format .*lx.*
+
+SYMBOL TABLE:
+00000000 l    d  .text	00000000 \.text
+00000000 l    d  .data	00000000 \.data
+00000000 l    d  .bss	00000000 \.bss
+00000000 g     F .text	00040000 foo
+
+
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/size-1.s binutils/gas/testsuite/gas/lx/size-1.s
--- binutils-2.21.51/gas/testsuite/gas/lx/size-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/size-1.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,13 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Check that the size of a very large function is calculated correctly
+	.text
+	.proc foo
+foo:
+	.global foo
+	.rept 0xffff
+	nop
+	;;
+	.endr
+	;;
+	.endp foo
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/st210.d binutils/gas/testsuite/gas/lx/st210.d
--- binutils-2.21.51/gas/testsuite/gas/lx/st210.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/st210.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,8 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as:
+#warning : Warning: ELF flags \(st210\) inconsistent with encoding table \(st220\)
+#objdump: -p
+#name: Assume st210
+
+.*:     file format .*lx.*
+eflags : 0 - st210 cut0 no-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/st210.s binutils/gas/testsuite/gas/lx/st210.s
--- binutils-2.21.51/gas/testsuite/gas/lx/st210.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/st210.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume st210
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/st220.d binutils/gas/testsuite/gas/lx/st220.d
--- binutils-2.21.51/gas/testsuite/gas/lx/st220.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/st220.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume st220
+
+.*:     file format .*lx.*
+eflags : 100 - st220 cut0 no-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/st220.s binutils/gas/testsuite/gas/lx/st220.s
--- binutils-2.21.51/gas/testsuite/gas/lx/st220.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/st220.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume st220
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/syms-1.d binutils/gas/testsuite/gas/lx/syms-1.d
--- binutils-2.21.51/gas/testsuite/gas/lx/syms-1.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/syms-1.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,15 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -EL
+#objdump: -t
+#source: syms-1.s
+#name: Dummy symbols
+
+.*:     file format .*lx.*
+
+SYMBOL TABLE:
+00000000 l    d  \.text	00000000 \.text
+00000000 l    d  \.data	00000000 \.data
+00000000 l    d  \.bss	00000000 \.bss
+00000000 g       \.text	00000000 foo
+
+
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/syms-1.s binutils/gas/testsuite/gas/lx/syms-1.s
--- binutils-2.21.51/gas/testsuite/gas/lx/syms-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/syms-1.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Check that we do not put dummy symbols in the symbol table.x
+	.text
+foo:
+	.global foo
+	nop
+	;;
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/user.d binutils/gas/testsuite/gas/lx/user.d
--- binutils-2.21.51/gas/testsuite/gas/lx/user.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/user.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#as: -mcore=st220
+#objdump: -p
+#name: Assume user
+
+.*:     file format .*lx.*
+eflags : 100 - st220 cut0 no-abi bare-machine  user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/user.s binutils/gas/testsuite/gas/lx/user.s
--- binutils-2.21.51/gas/testsuite/gas/lx/user.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/user.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,2 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.assume user
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/warn-align2.s binutils/gas/testsuite/gas/lx/warn-align2.s
--- binutils-2.21.51/gas/testsuite/gas/lx/warn-align2.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/warn-align2.s	2007-02-20 11:58:06.474574000 +0000
@@ -0,0 +1,10 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.section freda, "ax", @progbits
+	.align 4
+
+	nop
+	;; 
+	mulh $r1 = $r2, $r3
+	;;   # { dg-error "Bundle not valid on 4-byte alignment" "" }
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/warn-align3.s binutils/gas/testsuite/gas/lx/warn-align3.s
--- binutils-2.21.51/gas/testsuite/gas/lx/warn-align3.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/warn-align3.s	2007-02-20 11:58:06.474574000 +0000
@@ -0,0 +1,9 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+# { dg-options "-mcore=st240" }
+
+	.section freda, "ax", @progbits
+	.align 4
+
+	addf.n $r1 = $r2, $r3
+	;;   # { dg-error "Bundle not valid on 4-byte alignment" "" }
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/warn-align.s binutils/gas/testsuite/gas/lx/warn-align.s
--- binutils-2.21.51/gas/testsuite/gas/lx/warn-align.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/warn-align.s	2007-02-20 11:58:06.474574000 +0000
@@ -0,0 +1,13 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+
+	.section freda, "ax", @progbits
+	.align 4
+
+	mov $r1 = 0x12345678
+	;;   # { dg-error "Minimum section alignment of 8 required .* extended immediate" "" }
+	
+	
+	
+	
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/warn-calltest.s binutils/gas/testsuite/gas/lx/warn-calltest.s
--- binutils-2.21.51/gas/testsuite/gas/lx/warn-calltest.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/warn-calltest.s	2006-09-28 12:07:00.359719000 +0100
@@ -0,0 +1,960 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+# { dg-options "-mcore=st231" }
+
+	.text
+	.align 8
+
+
+prgaddSdiLdAsm::
+        prgadd 0[$r0.17]
+        ;;
+        ldw $r0.16 = 0[$r0.16]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        return $r0.63
+        ;;
+
+ldSdiLdAsm::
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        ldw $r0.16 = 0[$r0.16]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        return $r0.63
+        ;;
+
+ldSdiRfiAsm::
+        mov $r0.9 = after_rfi
+        ldw $r0.10 = (0xffff0000 + 0xfff8)[$r0.0]
+        ;;
+        stw (0xffff0000 + 0xffe8)[$r0.0] = $r0.9
+        ;;
+        stw (0xffff0000 + 0xffb8)[$r0.0] = $r0.9
+        ;;
+        stw (0xffff0000 + 0xfff0)[$r0.0] = $r0.10
+        ;;
+        stw (0xffff0000 + 0xffc0)[$r0.0] = $r0.10
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+
+        ldw $r0.16 = 0[$r0.16]
+        ;;
+        rfi
+        ;;
+after_rfi:
+        nop
+        ;;
+        nop
+        ;;
+        return $r0.63
+        ;;
+
+fullSdiAsm::
+
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        ldw $r0.10 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        ldw $r0.11 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        ldw $r0.24 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        mov $r0.16 = $r0.24
+        ;;
+        return $r0.63
+        ;;
+
+timingSdiAsm::
+
+
+
+        stw 0[$r0.16] = $r0.18
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+
+
+        stw 0[$r0.16] = $r0.18
+        ;;
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        ldw $r0.10 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        ldw $r0.11 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        ldw $r0.24 = 0[$r0.17]
+        ;;
+
+
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        ldw $r0.10 = 0[$r0.17]
+        ;;
+        ldw $r0.11 = 0[$r0.17]
+        ;;
+        ldw $r0.24 = 0[$r0.17]
+        ;;
+
+
+        stw 0[$r0.16] = $r0.18
+        ;;
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        ldw $r0.10 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        ldw $r0.11 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        ldw $r0.24 = 0[$r0.17]
+        ;;
+
+
+
+
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+
+
+        stw 0[$r0.16] = $r0.19
+        ;;
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.19
+        ;;
+        ldw $r0.10 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.19
+        ;;
+        ldw $r0.11 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.19
+        ;;
+        ldw $r0.24 = 0[$r0.17]
+        ;;
+
+
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        ldw $r0.10 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        ldw $r0.11 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        ldw $r0.24 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+
+
+        stw 0[$r0.16] = $r0.19
+        ;;
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.19
+        ;;
+        ldw $r0.10 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.19
+        ;;
+        ldw $r0.11 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.19
+        ;;
+        ldw $r0.24 = 0[$r0.17]
+        ;;
+
+
+
+
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+
+
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        ldw $r0.10 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        ldw $r0.11 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        ldw $r0.24 = 0[$r0.17]
+        ;;
+
+
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.10 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.11 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.24 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+
+
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        ldw $r0.10 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        ldw $r0.11 = 0[$r0.17]
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        ldw $r0.24 = 0[$r0.17]
+        ;;
+
+
+
+
+
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+
+
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.10 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.11 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.24 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+
+
+
+
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+
+
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.10 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.11 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.24 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+
+
+
+
+
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+
+
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.10 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.11 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.24 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+
+
+
+
+
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw 0[$r0.16] = $r0.18
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+
+
+        ldw $r0.9 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.10 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.11 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        ldw $r0.24 = 0[$r0.17]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+
+        return $r0.63
+        ;;
+
+
+
+back2BackSdiStAsm::
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        return $r0.63
+        ;;
+
+back2BackSdiLdAsm::
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.9 = 0[$r0.16]
+        ;;
+        ldw $r0.16 = 0[$r0.16]
+        ;;
+
+
+        nop
+        ;;
+        nop
+        ;;
+        return $r0.63
+        ;;
+
+timeoutHandlerAsm::
+        stw g_savedReg0[$r0.0] = $r0.8
+        ;;
+        ldw $r0.8 = (0xffff0000 + 0xffb0)[$r0.0]
+        ;;
+        stw g_savedReg1[$r0.0] = $r0.9
+        ;;
+        nop
+        ;;
+        ldw $r0.9 = LXTIMECONTROL0_REL[$r0.8]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        or $r0.9 = $r0.9, 1
+        ;;
+        stw 4[$r0.8] = $r0.9 ## Clear timer 0
+        ;;
+
+        ldw $r0.8 = g_sdiAddr[$r0.0] ## Address of SDI passed in here
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        cmpeq $r0.9 = $r0.8, (0xffff0000 + 0xe800) ## Check whether it was an output
+        cmpeq $r0.10 = $r0.8, (0xffff0000 + 0xec00)
+        ;;
+        or $r0.9 = $r0.9, $r0.10
+        add $r0.10 = $r0.8, 0x20 ## Address of timeout
+        ;;
+        ldw $r0.10 = 0[$r0.10] ## Timeout value
+        cmpeq $b0.0 = $r0.9, $r0.0
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw g_sdiTimeout[$r0.0] = $r0.10
+        br $b0.0, MyUnblockInputSDIAsm
+        ;;
+        add $r0.8 = $r0.8, (0xffff0000 + 0xe000) - (0xffff0000 + 0xe800) ## Unblock an output
+        ;;
+        ldw $r0.9 = 0[$r0.8]
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        stw g_sdiVal[$r0.0] = $r0.9
+        ;;
+        goto EndAsm
+        ;;
+
+MyUnblockInputSDIAsm::
+        ldw $r0.9 = g_sdiVal[$r0.0]
+        ;;
+        add $r0.8 = $r0.8, (0xffff0000 + 0xe800) - (0xffff0000 + 0xe000) ## Unblock an input
+        ;;
+        nop
+        ;;
+        stw 0[$r0.8] = $r0.9
+        ;;
+
+EndAsm::
+        ldw $r0.8 = g_savedReg0[$r0.0]
+        ;;
+        ldw $r0.9 = g_savedReg1[$r0.0]
+        ;;
+        sync
+        ;;
+        return $r0.63
+        ;;
+
+
+illSdiLoadAsm::
+	.nocheckbundles
+        ldw $r0.16 = 0[$r0.16]
+        syscall 0
+        nop
+        ;;
+	.checkbundles
+        nop
+        ;;
+        return $r0.63
+        ;;
+
+illSdiStoreAsm::
+	.nocheckbundles
+        stw 0[$r0.16] = $r0.17
+        syscall 0
+        nop
+        ;;
+	.checkbundles
+        nop
+        ;;
+        return $r0.63
+        ;;
+
+WakeUpSdiAsm::
+        stw 0xdddd0000[$r0.0] = $r0.0
+        ;;
+        stw 0[$r0.16] = $r0.17
+        ;;
+        sync
+        ;;
+        return $r0.63
+        ;;
diff -r -N -u binutils-2.21.51/gas/testsuite/gas/lx/warn-priority.s binutils/gas/testsuite/gas/lx/warn-priority.s
--- binutils-2.21.51/gas/testsuite/gas/lx/warn-priority.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/gas/testsuite/gas/lx/warn-priority.s	2006-09-28 12:07:00.359719000 +0100
@@ -0,0 +1,234 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+# { dg-do assemble }
+# { dg-options "-mcore=st231" }
+
+	.text
+	.align 8
+
+
+
+DtlbSbrkAsm::
+        ;;
+        stw 0x5000[$r0.0] = $r0.16
+        ;;
+        sbrk 0
+        ;;
+        nop
+        ;;
+        return $r0.63
+        ;;
+
+DtlbSyscallAsm::
+        ;;
+        stw 0x5000[$r0.0] = $r0.16
+        ;;
+        syscall 0
+        ;;
+        nop
+        ;;
+        return $r0.63
+        ;;
+
+SDISyscallAsm::
+        ;;
+        ldw $r0.8 = (0xffff0000 + 0xe000)[$r0.0]
+        ;;
+        syscall 0
+        ;;
+        nop
+        ;;
+        return $r0.63
+        ;;
+
+MyCodeAsm::
+        nop
+        ;;
+        ldw $r0.8 = (0xffff0000 + 0xe000)[$r0.0]
+        ;;
+MyBadBundleAsm::
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        return $r0.63
+        ;;
+
+MyCode1Asm::
+        nop
+        ;;
+        stw 0x5000[$r0.0] = $r0.8
+        ;;
+MyBadBundle1Asm::
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        return $r0.63
+        ;;
+
+MyCodeIbreakSysAsm::
+        nop
+        ;;
+        nop
+        ;;
+MyIbreakSysAsm::
+	.nocheckbundles
+        nop
+        syscall 0
+        ;;
+	.checkbundles
+        nop
+        ;;
+        nop
+        ;;
+        return $r0.63
+        ;;
+
+	.nostrictoperandchecking
+	call $r23 = $r42
+	;;
+	.strictoperandchecking
+MyCodeIbreakIllAsm::
+        nop
+        ;;
+        nop
+        ;;
+MyExpectIbreakIllAsm::
+	.nostrictoperandchecking
+        nop
+        ldh $r0.63 = 0x0[$r0.8]
+        nop
+        nop
+        ;;
+	.strictoperandchecking
+        nop
+        ;;
+        nop
+        ;;
+        return $r0.63
+        ;;
+
+.align 0x02000
+SafeCallAsm::
+.skip 0x1ff8
+        stw 0x5000[$r0.0] = $r0.16
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        nop
+        ;;
+        return $r0.63
+        ;;
+
+ExceptionIcDtlbAsm::
+        mov $r0.63 = $r0.63
+        ;;
+        stw g_SavedLR[$r0.0] = $r0.63 ## Save Link Register Value
+        ;;
+        pswset $r0.10
+        ;;
+        ;;
+        ;;
+        ;;
+        ## Copy the two instructions at begintest to the last two words in memory
+        ## then sync and wait a few cycles for good measure
+        mov $r0.9 = begintest
+        ;;
+        ldw $r0.10 = 0x00[$r0.9]
+        ;;
+        stw Addr_Bus[$r0.0] = $r0.10
+        ;;
+        ldw $r0.10 = 0x04[$r0.9]
+        ;;
+        stw (Addr_Bus + 0x4)[$r0.0] = $r0.10
+        ;;
+        sync
+        ;;
+        ;;
+        ;;
+        ;;
+        ;;
+        ;;
+        mov $r0.41 = Addr ## an address in real memory that's already setup in tlb'
+        mov $r0.44 = $r0.18 ## An address that will give a dtlb exception
+        ;;
+        mov $r0.25 = 0x12345678
+        ;;
+        mov $r0.63 = Addr_Bus
+        ;;
+        goto $r0.63
+        ;;
+return_from_exception:
+        ldw $r0.9 = 0x0[$r0.24] ## test that store happened OK after tlb miss serviced
+        ;;
+        ldw $r0.63 = g_SavedLR[$r0.0]
+        ;;
+        goto $r0.63
+        ;;
+begintest:
+        ## do long stall so that when the store in the next bundle excepts, the following
+        ## iside bus error has got to e2i
+        ldw $r0.8 = 0x0[$r0.41]
+        ;;
+        ## this store will give rise to the FEC condition that this test is targeted at.
+        ## there will be a dtlb exception. tiny_handler will establish a mapping for this
+        ## address and then after the handler rfi's, we'll get an iside bus-error on the
+        ## the next instruction.
+        stw 0x0[$r0.44] = $r0.25
+        ;;
+        ;;
+
+
+tiny_handler::
+        ldw $r0.9 = LXEXCAUSENO[$r0.0]
+        ;;
+        cmpeq $b0.0 = $r0.9, 0xc ## is it a dtlb exception
+        ;;
+        brf $b0.0, not_dtlb
+        ;;
+        mov $r0.16 = $r0.9
+        ;;
+        ## setup TLB entry 0x3b for data at 0x9000000 with pagesize 8K
+        ## This is the top of memory
+        mov $r0.9 = 0x3b
+        mov $r0.10 = 0x11ff00
+        ;;
+        mov $r0.11 = 0x050001
+        ;;
+        mov $r0.24 = 0x04400
+        ;;
+        stw LXTLB_INDEX[$r0.0] = $r0.9
+        ;;
+        stw LXTLB_ENTRY0[$r0.0] = $r0.10
+        ;;
+        stw LXTLB_ENTRY1[$r0.0] = $r0.11
+        ;;
+        stw LXTLB_ENTRY2[$r0.0] = $r0.24
+        ;;
+        goto tiny_handler_exit
+        ;;
+not_dtlb:
+        mov $r0.17 = $r0.9
+        ;;
+        mov $r0.9 = return_from_exception
+        ;;
+        stw (0xffff0000 + 0xffe8)[$r0.0] = $r0.9
+        ;;
+        ;;
+        ;;
+        ;;
+        ;;
+tiny_handler_exit:
+        mov $r0.63 = $r0.63
+        ;;
+        ;;
+        ;;
+        ;;
+        rfi
+        ;;
diff -r -N -u binutils-2.21.51/gas/testsuite/lib/gas-defs.exp binutils/gas/testsuite/lib/gas-defs.exp
--- binutils-2.21.51/gas/testsuite/lib/gas-defs.exp	2011-06-14 09:27:52.000000000 +0100
+++ binutils/gas/testsuite/lib/gas-defs.exp	2011-07-06 12:44:26.137253000 +0100
@@ -427,7 +427,10 @@
 #   section-subst: no
 #       Means that the section substitution for objdump is disabled.
 #
-# Each option may occur at most once.
+#   comment: COMMENT
+#      Ignore COMMENT string.
+#
+# Each option (except for comment) may occur at most once.
 #
 # After the option lines come regexp lines.  `run_dump_test' calls
 # `regexp_diff' to compare the output of the dumping tool against the
@@ -465,6 +468,7 @@
     set opts(source) {}
     set opts(dump) {}
     set opts(stderr) {}
+    set opts(comment) {}
     set opts(error) {}
     set opts(error-output) {}
     set opts(warning) {}
@@ -540,6 +544,7 @@
 		nm	{ set program nm }
 		objcopy	{ set program objcopy }
 		readelf	{ set program readelf }
+		comment { }
 		default	{
 		    perror "unrecognized program option $opts(PROG) in $file.d"
 		    unresolved $testname
diff -r -N -u binutils-2.21.51/gas/write.c binutils/gas/write.c
--- binutils-2.21.51/gas/write.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/gas/write.c	2011-07-06 12:44:26.137253000 +0100
@@ -934,7 +934,12 @@
 	      && sub_symbol_segment == add_symbol_segment
 	      && !S_FORCE_RELOC (fixP->fx_addsy, 0)
 	      && !S_FORCE_RELOC (fixP->fx_subsy, 0)
-	      && !TC_FORCE_RELOCATION_SUB_SAME (fixP, add_symbol_segment))
+#if !defined(TC_LX_ST200)
+             && !TC_FORCE_RELOCATION_SUB_SAME (fixP, add_symbol_segment)
+#else
+             && !TC_FORCE_RELOCATION_SUB_SAME (fixP, this_segment)
+#endif /* TC_LX_ST200 */
+	     )
 	    {
 	      add_number += S_GET_VALUE (fixP->fx_addsy);
 	      add_number -= S_GET_VALUE (fixP->fx_subsy);
diff -r -N -u binutils-2.21.51/gprof/cg_print.c binutils/gprof/cg_print.c
--- binutils-2.21.51/gprof/cg_print.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/gprof/cg_print.c	2011-07-06 12:44:26.137253000 +0100
@@ -1293,3 +1293,60 @@
       last = symbol_map[sym_index].file_name;
     }
 }
+
+#ifdef CALLGRIND
+static void
+callgrind_children (parent)
+     Sym *parent;
+{
+  Sym *child;
+  Arc *arc;
+  
+  sort_children (parent);
+  arc = parent->cg.children;
+
+  for (arc = parent->cg.children; arc; arc = arc->next_child)
+    {
+      child = arc->child;
+      if (child->file) {
+	printf("cfl=%s\n", child->file->name);
+      }
+      printf("cfn=");
+      print_name_only(child);
+      printf("\ncalls=%ld %d\n", arc->count, child->line_num);
+      if (child == parent) {
+       printf("0 %lld\n", (long long)child->hist.time);
+      } else {
+	printf("0 %lld\n", (long long)(arc->time+arc->child_time));
+      }
+    }
+}
+
+
+void
+cg_print_callgrind (timesortsym)
+     Sym ** timesortsym;
+{
+  unsigned int index;
+  Sym *parent;
+  
+  printf ("events: cycles\n");
+  
+  for (index = 0; index < symtab.len + num_cycles; ++index)
+    {
+      parent = timesortsym[index];
+
+      if ((ignore_zeros && parent->ncalls == 0
+	   && parent->cg.self_calls == 0 && parent->cg.prop.self == 0
+	   && parent->cg.prop.child == 0)
+	  || !parent->cg.print_flag
+	  || (line_granularity && ! parent->is_func))
+	continue;
+      
+      callgrind_line (parent);
+      callgrind_children (parent);
+      
+      printf ("\n");
+    }
+}
+#endif /* CALLGRIND */
diff -r -N -u binutils-2.21.51/gprof/cg_print.h binutils/gprof/cg_print.h
--- binutils-2.21.51/gprof/cg_print.h	2007-09-24 11:42:14.000000000 +0100
+++ binutils/gprof/cg_print.h	2009-08-11 10:14:24.859968000 +0100
@@ -28,5 +28,8 @@
 extern void cg_print_index              (void);
 extern void cg_print_file_ordering      (void);
 extern void cg_print_function_ordering  (void);
+#ifdef CALLGRIND
+extern void cg_print_callgrind          PARAMS ((Sym **));
+#endif
 
 #endif /* cg_print_h */
diff -r -N -u binutils-2.21.51/gprof/corefile.c binutils/gprof/corefile.c
--- binutils-2.21.51/gprof/corefile.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/gprof/corefile.c	2011-07-06 12:44:26.137253000 +0100
@@ -384,7 +384,8 @@
 
   for (name = sym->name; *name; ++name)
     {
-      if (*name == '$')
+      /* [TB] Add symbol containing '?' as uninterested symbol */
+      if (*name == '$' || *name == '?')
         return 0;
 
       if (*name == '.')
diff -r -N -u binutils-2.21.51/gprof/gprof.c binutils/gprof/gprof.c
--- binutils-2.21.51/gprof/gprof.c	2009-08-14 07:58:38.000000000 +0100
+++ binutils/gprof/gprof.c	2010-06-07 14:41:42.080337000 +0100
@@ -44,6 +44,7 @@
 #include "sym_ids.h"
 #include "demangle.h"
 #include "getopt.h"
+#include "ST_version.h"
 
 static void usage (FILE *, int) ATTRIBUTE_NORETURN;
 
@@ -115,6 +116,9 @@
   {"file-ordering", required_argument, 0, 'R'},
   {"file-info", no_argument, 0, 'i'},
   {"sum", no_argument, 0, 's'},
+#ifdef CALLGRIND
+  {"callgrind", no_argument, 0, 0xCA},
+#endif
 
     /* various options to affect output: */
 
@@ -156,6 +160,7 @@
 static void
 usage (FILE *stream, int status)
 {
+#ifdef CALLGRIND
   fprintf (stream, _("\
 Usage: %s [-[abcDhilLsTvwxyz]] [-[ACeEfFJnNOpPqSQZ][name]] [-I dirs]\n\
 	[-d[num]] [-k from/to] [-m min-count] [-t table-length]\n\
@@ -169,7 +174,24 @@
 	[--static-call-graph] [--sum] [--table-length=len] [--traditional]\n\
 	[--version] [--width=n] [--ignore-non-functions]\n\
 	[--demangle[=STYLE]] [--no-demangle] [--external-symbol-table=name] [@FILE]\n\
+        [--callgrind]\n\
+	[image-file] [profile-file...]\n"),
+#else
+  fprintf (stream, _("\
+Usage: %s [-[abcDhilLsTvwxyz]] [-[ACeEfFJnNOpPqQZ][name]] [-I dirs]\n\
+	[-d[num]] [-k from/to] [-m min-count] [-t table-length]\n\
+	[--[no-]annotated-source[=name]] [--[no-]exec-counts[=name]]\n\
+	[--[no-]flat-profile[=name]] [--[no-]graph[=name]]\n\
+	[--[no-]time=name] [--all-lines] [--brief] [--debug[=level]]\n\
+	[--function-ordering] [--file-ordering]\n\
+	[--directory-path=dirs] [--display-unused-functions]\n\
+	[--file-format=name] [--file-info] [--help] [--line] [--min-count=n]\n\
+	[--no-static] [--print-path] [--separate-files]\n\
+	[--static-call-graph] [--sum] [--table-length=len] [--traditional]\n\
+	[--version] [--width=n] [--ignore-non-functions]\n\
+	[--demangle[=STYLE]] [--no-demangle] [@FILE]\n\
 	[image-file] [profile-file...]\n"),
+#endif /* CALLGRIND */
 	   whoami);
   if (REPORT_BUGS_TO[0] && status == 0)
     fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
@@ -420,6 +442,8 @@
 	  printf (_("Based on BSD gprof, copyright 1983 Regents of the University of California.\n"));
 	  printf (_("\
 This program is free software.  This program has absolutely no warranty.\n"));
+	  printf (_("STMicroelectronics gprof: Version %s %s\n"),
+		  ST_BINUTILS_VERSION, ST_BINUTILS_VERSION_DATE);
 	  done (0);
 	case 'w':
 	  output_width = atoi (optarg);
@@ -470,6 +494,11 @@
 	case OPTION_NO_DEMANGLE:
 	  demangle = FALSE;
 	  break;
+#ifdef CALLGRIND
+	case 0xCA:
+	  output_style = STYLE_CALLGRIND;
+	  break;
+#endif
 	default:
 	  usage (stderr, 1);
 	}
@@ -597,6 +626,15 @@
     }
 
   /* Output whatever user whishes to see.  */
+
+#ifdef CALLGRIND
+  /* If the user asked for callgrind profile, print only this one */
+  if (output_style & STYLE_CALLGRIND)
+    {
+      cg_print_callgrind(cg);
+    }
+#endif
+
   if (cg && (output_style & STYLE_CALL_GRAPH) && bsd_style_output)
     {
       /* Print the dynamic profile.  */
diff -r -N -u binutils-2.21.51/gprof/gprof.h binutils/gprof/gprof.h
--- binutils-2.21.51/gprof/gprof.h	2009-08-14 07:58:38.000000000 +0100
+++ binutils/gprof/gprof.h	2010-06-07 14:41:42.080337000 +0100
@@ -80,6 +80,9 @@
 #define STYLE_GMON_INFO		(1<<5)
 #define STYLE_FUNCTION_ORDER	(1<<6)
 #define STYLE_FILE_ORDER	(1<<7)
+#ifdef CALLGRIND
+#define STYLE_CALLGRIND         (1<<8)
+#endif
 
 #define	ANYDEBUG	(1<<0)	/*    1 */
 #define	DFNDEBUG	(1<<1)	/*    2 */
diff -r -N -u binutils-2.21.51/gprof/Makefile.am binutils/gprof/Makefile.am
--- binutils-2.21.51/gprof/Makefile.am	2010-12-06 09:23:27.000000000 +0000
+++ binutils/gprof/Makefile.am	2011-07-06 12:44:26.137253000 +0100
@@ -28,7 +28,7 @@
 	search_list.c symtab.c sym_ids.c utils.c \
 	i386.c alpha.c vax.c tahoe.c sparc.c mips.c
 gprof_SOURCES = $(sources) flat_bl.c bsd_callg_bl.c fsf_callg_bl.c
-gprof_DEPENDENCIES = ../bfd/libbfd.la ../libiberty/libiberty.a $(LIBINTL_DEP)
+gprof_DEPENDENCIES = ../bfd/libbfd.la ../libiberty/libiberty.a $(LIBINTL_DEP) ../include/ST_version.h
 gprof_LDADD = ../bfd/libbfd.la ../libiberty/libiberty.a $(LIBINTL)
 
 noinst_HEADERS = \
diff -r -N -u binutils-2.21.51/gprof/Makefile.in binutils/gprof/Makefile.in
--- binutils-2.21.51/gprof/Makefile.in	2010-12-06 09:23:27.000000000 +0000
+++ binutils/gprof/Makefile.in	2011-07-06 12:44:26.137253000 +0100
@@ -294,7 +294,7 @@
 	i386.c alpha.c vax.c tahoe.c sparc.c mips.c
 
 gprof_SOURCES = $(sources) flat_bl.c bsd_callg_bl.c fsf_callg_bl.c
-gprof_DEPENDENCIES = ../bfd/libbfd.la ../libiberty/libiberty.a $(LIBINTL_DEP)
+gprof_DEPENDENCIES = ../bfd/libbfd.la ../libiberty/libiberty.a $(LIBINTL_DEP) ../include/ST_version.h
 gprof_LDADD = ../bfd/libbfd.la ../libiberty/libiberty.a $(LIBINTL)
 noinst_HEADERS = \
 	basic_blocks.h call_graph.h cg_arcs.h cg_dfn.h cg_print.h \
diff -r -N -u binutils-2.21.51/gprof/search_list.c binutils/gprof/search_list.c
--- binutils-2.21.51/gprof/search_list.c	2009-05-18 13:23:22.000000000 +0100
+++ binutils/gprof/search_list.c	2010-05-25 12:04:31.134734000 +0100
@@ -42,9 +42,25 @@
       else
 	len = strlen (beg);
 
+#ifndef __MINGW32__
       new_el = (Search_List_Elem *) xmalloc (sizeof (*new_el) + len);
       memcpy (new_el->path, beg, len);
       new_el->path[len] = '\0';
+#else
+      {
+	/* The Search_List_Elem string 'optimisation' makes
+	   calling cygpath a little tricky.  Especially combined
+	   with a source path from the middle of a string.  */
+	char *temp = xmalloc (len+1);
+	memcpy (temp, beg, len);
+	temp[len] = '\0';
+	cygpath_replace (&temp);
+	
+	new_el = xmalloc (sizeof (*new_el) + strlen (temp));
+	strcpy (new_el->path, temp);
+	free (temp);
+      }
+#endif /* __MINGW32__ */
 
       /* Append new path at end of list.  */
       new_el->next = 0;
diff -r -N -u binutils-2.21.51/HOWTO_BUILD_ST200 binutils/HOWTO_BUILD_ST200
--- binutils-2.21.51/HOWTO_BUILD_ST200	1970-01-01 01:00:00.000000000 +0100
+++ binutils/HOWTO_BUILD_ST200	2005-10-13 14:47:32.812423000 +0100
@@ -0,0 +1,44 @@
+The typical makefile rules to configure and build the binutils for ST200 are:
+
+PROGRAM_PREFIX=st200-
+BFDDIR=$(installdir)/host
+
+configure: ./build
+        @echo "########## Configure #############"
+        cd ./build ; $(srcdir)/configure                \
+           --program-prefix=$(PROGRAM_PREFIX)           \
+           --prefix=$(installdir)                       \
+           --libdir=$(BFDDIR)/lib                       \
+           --includedir=$(BFDDIR)/include               \
+           --build=$(build)                             \
+           --host=$(host)                               \
+           --target=lx-elf32                            \
+           --enable-install-libbfd="yes"                \
+           --enable-packer="no"                         \
+           --cache-file=""
+
+all: 
+        @echo "########## Build #############"
+        $(MAKE) --directory=./build all
+
+
+install:
+        @echo "########## Install #############"
+        $(MAKE) --directory=./build install
+
+clean: 
+        $(MAKE) --directory=./build clean
+
+
+The build machines are Solaris or Linux:
+build={sparc-sun-solaris2.7 | i686-pc-linux-gnu} 
+
+The host machines are Solaris, Linux or Cygwin:
+host={sparc-sun-solaris2.7 | i686-pc-linux-gnu | i686-pc-cygwin32} 
+
+Note: For cygwin host, only cross-compilation Solaris-Cygwin has been tested using:
+
+> SunOS5.7/gcc/x-cygwin-1.5.9-gcc-2.95.3-10/bin/i686-pc-cygwin-gcc --version
+2.95.3-10
+
+
diff -r -N -u binutils-2.21.51/include/bfdlink.h binutils/include/bfdlink.h
--- binutils-2.21.51/include/bfdlink.h	2011-06-14 09:27:52.000000000 +0100
+++ binutils/include/bfdlink.h	2011-07-06 12:44:26.137253000 +0100
@@ -155,6 +155,14 @@
 	  bfd_size_type size;	/* Common symbol size.  */
 	} c;
     } u;
+
+#ifdef IPA_LINK
+  /* [CL] Remember the bfd associated with this symbol.
+   * For Whirl sections, there is no bfd owner,
+   * so we need to store it here */
+  bfd* ipa_bfd;
+#endif
+
 };
 
 /* This is the link hash table.  It is a derived class of
@@ -464,6 +472,9 @@
   /* May be used to set DT_FLAGS_1 for ELF. */
   bfd_vma flags_1;
 
+  /* TB: true to resolve pc_relative relocation on local symbol*/
+  bfd_boolean relocatable_with_pcrel_resolved;
+
   /* Start and end of RELRO region.  */
   bfd_vma relro_start, relro_end;
 
diff -r -N -u binutils-2.21.51/include/bin-bugs.h binutils/include/bin-bugs.h
--- binutils-2.21.51/include/bin-bugs.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils/include/bin-bugs.h	2005-09-26 11:40:32.253227000 +0100
@@ -0,0 +1,3 @@
+#ifndef REPORT_BUGS_TO
+#define REPORT_BUGS_TO	"bug-binutils@gnu.org"
+#endif
diff -r -N -u binutils-2.21.51/include/dis-asm.h binutils/include/dis-asm.h
--- binutils-2.21.51/include/dis-asm.h	2010-12-06 09:23:27.000000000 +0000
+++ binutils/include/dis-asm.h	2011-07-06 12:44:26.137253000 +0100
@@ -224,6 +224,7 @@
 extern int print_insn_avr		(bfd_vma, disassemble_info *);
 extern int print_insn_bfin		(bfd_vma, disassemble_info *);
 extern int print_insn_big_arm		(bfd_vma, disassemble_info *);
+extern int print_insn_big_lx            (bfd_vma, disassemble_info *);
 extern int print_insn_big_mips		(bfd_vma, disassemble_info *);
 extern int print_insn_big_or32		(bfd_vma, disassemble_info *);
 extern int print_insn_big_powerpc	(bfd_vma, disassemble_info *);
@@ -250,6 +251,7 @@
 extern int print_insn_ip2k		(bfd_vma, disassemble_info *);
 extern int print_insn_iq2000		(bfd_vma, disassemble_info *);
 extern int print_insn_little_arm	(bfd_vma, disassemble_info *);
+extern int print_insn_little_lx         (bfd_vma, disassemble_info *);
 extern int print_insn_little_mips	(bfd_vma, disassemble_info *);
 extern int print_insn_little_or32	(bfd_vma, disassemble_info *);
 extern int print_insn_little_powerpc	(bfd_vma, disassemble_info *);
diff -r -N -u binutils-2.21.51/include/dlfcn_win32.h binutils/include/dlfcn_win32.h
--- binutils-2.21.51/include/dlfcn_win32.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils/include/dlfcn_win32.h	2011-10-20 09:48:19.463637000 +0100
@@ -0,0 +1,39 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+*/
+ /*
+  * dlfcn_win32.h	1.0 2003/01/16
+  *
+  * Emulates the POSIX dlfcn.h
+  *
+  * By Wu Yongwei
+  *
+  */
+ 
+ #ifndef _DLFCN_WIN32_H
+ #define _DLFCN_WIN32_H
+ 
+ #ifdef _WIN32
+ #include <windows.h>
+ #include <errno.h>
+ #define dlopen(P,G) (void*)LoadLibrary(P)
+ #define dlsym(D,F) (void*)GetProcAddress((HMODULE)D,F)
+ #define dlclose(D) FreeLibrary((HMODULE)D)
+ static const char* dlerror(void);
+
+ static const char* dlerror(void)
+ {
+ 	static char szMsgBuf[256];
+ 	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
+ 			NULL,
+ 			GetLastError(),
+ 			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+ 			szMsgBuf,
+ 			sizeof szMsgBuf,
+ 			NULL);
+ 	return szMsgBuf;
+ }
+
+ #endif /* _WIN32 */
+ 
+ #endif /* _DLFCN_WIN32_H */
diff -r -N -u binutils-2.21.51/include/elf/common.h binutils/include/elf/common.h
--- binutils-2.21.51/include/elf/common.h	2011-06-14 09:27:52.000000000 +0100
+++ binutils/include/elf/common.h	2011-07-06 12:44:26.137253000 +0100
@@ -82,6 +82,8 @@
 
 #define EI_ABIVERSION	8	/* ABI version */
 
+#define ELFOSABI_OS21  64       /* OS 21 */
+
 #define EI_PAD		9	/* Start of padding bytes */
 
 
@@ -402,6 +404,9 @@
 
 /* See the above comment before you add a new EM_* value here.  */
 
+#define EM_LX 0x64      
+#define EM_LX_OLD  0x1064
+
 /* Values for e_version.  */
 
 #define EV_NONE		0		/* Invalid ELF version */
diff -r -N -u binutils-2.21.51/include/elf/lx.h binutils/include/elf/lx.h
--- binutils-2.21.51/include/elf/lx.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils/include/elf/lx.h	2010-06-07 14:41:42.080337000 +0100
@@ -0,0 +1,186 @@
+/**
+*** (c) Copyright Hewlett-Packard Company 1999-2003 
+***
+*** This program is free software; you can redistribute it and/or
+*** modify it under the terms of the GNU General Public License
+*** as published by the Free Software Foundation; either version
+*** 2 of the License, or (at your option) any later version.
+*** 
+*** This program is distributed in the hope that it will be useful,
+*** but WITHOUT ANY WARRANTY; without even the implied warranty of
+*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+*** General Public License for more details.
+***
+*** You should have received a copy of the GNU General Public License 
+*** along with this program; if not, write to the Free Software
+*** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+**/
+
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
+/**
+*** static char sccs_id[] = "@(#)lx.h	1.2 02/11/00 21:28:02";
+**/
+
+/* LX ELF support for BFD.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* This file holds definitions specific to the PPC ELF ABI.  Note
+   that most of this is not actually implemented by BFD.  */
+
+#ifndef _ELF_LX_H
+#define _ELF_LX_H
+
+#include "bfd.h"
+
+#include "elf/reloc-macros.h"
+
+/*
+ * Typedef relating to bfd library
+ *
+ *   rta = 0 : catch all
+ *   rta = 1 : multiflow register assignment
+ *   rta = 2 : lxbe embedded
+ *   rta = 3 : lxbe PIC
+ */
+
+typedef union {
+  struct {
+    unsigned rta : 4;  
+  } obj_compat;
+  unsigned int f;
+} lx_bfd_flags;
+
+/* (pp) core */
+#define _ELF_LX_CORE_BIT	(8)                      /* 1st bit position in byte */
+#define ELF_LX_CORE_MASK	(0xff<<_ELF_LX_CORE_BIT)           /* mask */
+#define ELF_LX_CORE_ST210	(0x0<<_ELF_LX_CORE_BIT)
+#define ELF_LX_CORE_ST220	(0x1<<_ELF_LX_CORE_BIT)
+#define ELF_LX_CORE_ST230	(0x2<<_ELF_LX_CORE_BIT)
+#define ELF_LX_CORE_ST231	(0x3<<_ELF_LX_CORE_BIT)
+#define ELF_LX_CORE_ST235	(0x4<<_ELF_LX_CORE_BIT)
+#define ELF_LX_CORE_ST239	(0x5<<_ELF_LX_CORE_BIT)
+#define ELF_LX_CORE_ST240	(0x6<<_ELF_LX_CORE_BIT)
+#define ELF_LX_CORE_UNDEF	(0x7<<_ELF_LX_CORE_BIT)
+#define _ELF_LX_CHECK_CORE(m) ((m&ELF_LX_CORE_MASK)==m)
+
+/* (pp) cut */
+#define _ELF_LX_CUT_BIT	(16)                             /* 1st bit position in byte */
+#define ELF_LX_CUT_MASK		(0xf<<_ELF_LX_CUT_BIT)           /* mask */
+#define ELF_LX_CUT_0		(0x0<<_ELF_LX_CUT_BIT)
+#define ELF_LX_CUT_1		(0x1<<_ELF_LX_CUT_BIT)
+#define ELF_LX_CUT_2		(0x2<<_ELF_LX_CUT_BIT)
+#define ELF_LX_CUT_3		(0x3<<_ELF_LX_CUT_BIT)
+#define ELF_LX_CUT_4		(0x4<<_ELF_LX_CUT_BIT)
+#define ELF_LX_CUT_5		(0x5<<_ELF_LX_CUT_BIT)
+#define ELF_LX_CUT_UNDEF	(0x6<<_ELF_LX_CUT_BIT)
+#define _ELF_LX_CHECK_CUT(m) ((m&ELF_LX_CUT_MASK)==m)
+
+/* (pp) abi */
+#define _ELF_LX_ABI_BIT	(0)                             /* 1st bit position in byte */
+#define ELF_LX_ABI_MASK		(0x7f<<_ELF_LX_ABI_BIT)           /* mask */
+#define ELF_LX_ABI_NO		(0x0<<_ELF_LX_ABI_BIT)
+#define ELF_LX_ABI_MULTI	(0x1<<_ELF_LX_ABI_BIT)
+#define ELF_LX_ABI_EMBED	(0x2<<_ELF_LX_ABI_BIT)
+#define ELF_LX_ABI_PIC		(0x3<<_ELF_LX_ABI_BIT)
+#define ELF_LX_ABI_GCC		(0x4<<_ELF_LX_ABI_BIT)
+#define ELF_LX_ABI_UNDEF	(0x5<<_ELF_LX_ABI_BIT)
+#define ELF_LX_ABI_RELOC_EMBED  (0x6<<_ELF_LX_ABI_BIT)
+#define _ELF_LX_CHECK_ABI(m) ((m&ELF_LX_ABI_MASK)==m)
+
+/* compatibility with rta directive on solaris : rta bits where writen in the bits 28:31 on Solaris */
+#define _ELF_LX_RTA_BIT	(28)                             /* 1st bit position in byte */
+
+/* (pp) code generation mode */
+#define _ELF_LX_MODE_BIT (7)                             /* 1st bit position in byte */
+#define ELF_LX_MODE_MASK	(0x1<<_ELF_LX_MODE_BIT)           /* mask */
+#define ELF_LX_MODE_USER	(0x0<<_ELF_LX_MODE_BIT)
+#define ELF_LX_MODE_KERNEL	(0x1<<_ELF_LX_MODE_BIT)
+#define _ELF_LX_CHECK_MODE(m) ((m&ELF_LX_MODE_MASK)==m)
+
+extern const char * core_printable_name(flagword flags);
+const char * cut_printable_name(flagword flags);
+const char * abi_printable_name(flagword flags, Elf_Internal_Ehdr * i_ehdrp);
+const char * osabi_printable_name(Elf_Internal_Ehdr * i_ehdrp);
+const char * code_generation_mode_printable_name(Elf_Internal_Ehdr * i_ehdrp);
+flagword lx_elf_get_private_flags (bfd* abfd);
+void lx_elf_dump_target_info(bfd *abfd, FILE *writer);
+
+/* (pp) say wether a function can be moved by icacheopt or not */
+#define STO_FUNC_NATURE_BIT (4)
+#define STO_FUNC_NATURE_MASK   (0x1 << STO_FUNC_NATURE_BIT)
+#define STO_MOVEABLE  (0x1 << STO_FUNC_NATURE_BIT)
+#define is_STO_MOVEABLE(o) (((o)&STO_FUNC_NATURE_MASK)==STO_MOVEABLE)
+
+/* (tb) say wether a symbol has used attribute (mean not to be deleted by binopt tool */
+#define STO_SYMB_USED_BIT (5)
+#define STO_SYMB_USED_MASK   (0x1 << STO_SYMB_USED_BIT)
+#define STO_USED  (0x1 << STO_SYMB_USED_BIT)
+#define is_STO_USED(o) (((o)&STO_SYMB_USED_MASK)==STO_USED)
+
+#define ELF_STRING_lx_pltoff ".lx.pltoff"
+
+START_RELOC_NUMBERS (elf_lx_reloc_type)
+     RELOC_NUMBER (R_LX_NONE,                 0)
+     RELOC_NUMBER (R_LX_16,                   1)
+     RELOC_NUMBER (R_LX_32,                   2)
+     RELOC_NUMBER (R_LX_32_PCREL,             3)
+     RELOC_NUMBER (R_LX_23_PCREL,             4)
+     RELOC_NUMBER (R_LX_HI23,                 5)
+     RELOC_NUMBER (R_LX_LO9,                  6)
+     RELOC_NUMBER (R_LX_GPREL_HI23,           7)
+     RELOC_NUMBER (R_LX_GPREL_LO9,            8)
+     RELOC_NUMBER (R_LX_REL32,                9)
+     RELOC_NUMBER (R_LX_GOTOFF_HI23,         10)
+     RELOC_NUMBER (R_LX_GOTOFF_LO9,          11)
+     RELOC_NUMBER (R_LX_GOTOFFX_HI23,        12)
+     RELOC_NUMBER (R_LX_GOTOFFX_LO9,         13)
+     RELOC_NUMBER (R_LX_LTV32,               14)
+     RELOC_NUMBER (R_LX_SEGREL32,            15)
+     RELOC_NUMBER (R_LX_FPTR32,              16)
+     RELOC_NUMBER (R_LX_PLTOFF_HI23,         17)
+     RELOC_NUMBER (R_LX_PLTOFF_LO9,          18)
+     RELOC_NUMBER (R_LX_GOTOFF_FPTR_HI23,    19)
+     RELOC_NUMBER (R_LX_GOTOFF_FPTR_LO9,     20)
+     RELOC_NUMBER (R_LX_IPLT,                21)
+     RELOC_NUMBER (R_LX_NEG_GPREL_HI23,      22)
+     RELOC_NUMBER (R_LX_NEG_GPREL_LO9,       23)
+     RELOC_NUMBER (R_LX_COPY,                24)
+     RELOC_NUMBER (R_LX_JMP_SLOT,            25)
+     RELOC_NUMBER (R_LX_TPREL_HI23,          26)
+     RELOC_NUMBER (R_LX_TPREL_LO9,           27)
+     RELOC_NUMBER (R_LX_TPREL32,             28)
+     RELOC_NUMBER (R_LX_GOTOFF_TPREL_HI23,   29)
+     RELOC_NUMBER (R_LX_GOTOFF_TPREL_LO9,    30)
+     RELOC_NUMBER (R_LX_GOTOFF_DTPLDM_HI23,  31)
+     RELOC_NUMBER (R_LX_GOTOFF_DTPLDM_LO9,   32)
+     RELOC_NUMBER (R_LX_DTPREL_HI23,         33)
+     RELOC_NUMBER (R_LX_DTPREL_LO9,          34)
+     RELOC_NUMBER (R_LX_DTPMOD32,            35)
+     RELOC_NUMBER (R_LX_DTPREL32,            36)
+     RELOC_NUMBER (R_LX_GOTOFF_DTPNDX_HI23,  37)
+     RELOC_NUMBER (R_LX_GOTOFF_DTPNDX_LO9,   38)
+END_RELOC_NUMBERS (R_LX_max)
+
+/* The emulation name is defined in ld/emultempl/elf32.em and used in elf.c.
+   We define it as weak because of libbfd.a that contains elf.c and not
+   the linker emulation.
+*/
+     char *lx_emul_name;
+
+#endif
diff -r -N -u binutils-2.21.51/include/libiberty.h binutils/include/libiberty.h
--- binutils-2.21.51/include/libiberty.h	2011-04-13 08:41:36.000000000 +0100
+++ binutils/include/libiberty.h	2011-07-06 12:44:26.137253000 +0100
@@ -671,9 +671,16 @@
    (char *) memcpy (libiberty_nptr, libiberty_optr, libiberty_len))
 #endif
 
+#ifdef __MINGW32__
+/* Reassign the pointer PATH without freeing anything.  */
+extern char *cygpath (const char *path);
+
+/* Reassign the pointer PATH and free the previous content.  */
+extern void cygpath_replace (char **path);
+#endif
+
 #ifdef __cplusplus
 }
 #endif
 
-
 #endif /* ! defined (LIBIBERTY_H) */
diff -r -N -u binutils-2.21.51/include/opcode/lx.h binutils/include/opcode/lx.h
--- binutils-2.21.51/include/opcode/lx.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils/include/opcode/lx.h	2008-04-17 12:32:41.257944000 +0100
@@ -0,0 +1,2652 @@
+/**
+*** (c) Copyright STMicroelectronics, Inc. 1999-2005.
+***
+*** This program is free software; you can redistribute it and/or
+*** modify it under the terms of the GNU General Public License
+*** as published by the Free Software Foundation; either version
+*** 2 of the License, or (at your option) any later version.
+***
+*** This program is distributed in the hope that it will be useful,
+*** but WITHOUT ANY WARRANTY; without even the implied warranty of
+*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+*** General Public License for more details.
+***
+*** You should have received a copy of the GNU General Public License
+*** along with this program; if not, write to the Free Software
+*** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+***
+*** --------------------------------------------------
+***                *** DO NOT EDIT ***
+***  This file was automatically generated by the
+***  Machine Description System (MDS) of STMicroelectronics, Inc.
+*** --------------------------------------------------
+**/
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+*/
+
+#ifndef OPCODE_LX_H
+#define OPCODE_LX_H
+
+#define LXMAXOPERANDS 5
+
+#define LXMAXBUNDLESIZE 4
+
+#define ST200_NCORES 4
+
+#define LXNUMBUNDLINGS 9
+
+#define st200_RESERVED_30_1_fld(x) (int)(((unsigned int)(x) >> 30) & 0x1)
+#define st200_RESERVED_21_2_fld(x) (int)(((unsigned int)(x) >> 21) & 0x3)
+#define st200_RESERVED_18_3_fld(x) (int)(((unsigned int)(x) >> 18) & 0x7)
+#define st200_RESERVED_12_6_fld(x) (int)(((unsigned int)(x) >> 12) & 0x3f)
+#define st200_RESERVED_9_3_fld(x) (int)(((unsigned int)(x) >> 9) & 0x7)
+#define st200_RESERVED_0_21_fld(x) (int)((unsigned int)(x) & 0x1fffff)
+#define st200_STOPBIT_fld(x) (int)(((unsigned int)(x) >> 31) & 0x1)
+#define st200_CMP_fld(x) (int)(((unsigned int)(x) >> 26) & 0x1)
+#define st200_I_fld(x) (int)(((unsigned int)(x) >> 27) & 0x1)
+#define st200_B_fld(x) (int)(((unsigned int)(x) >> 25) & 0x1)
+#define st200_D_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1)
+#define st200_LNK_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1)
+#define st200_FMT_fld(x) (int)(((unsigned int)(x) >> 28) & 0x3)
+#define st200_INT3_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x1f)
+#define st200_MONADIC_OPCODE_fld(x) (int)(((unsigned int)(x) >> 12) & 0x1ff)
+#define st200_CMP3_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0xf)
+#define st200_IMMX_OPCODE_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1f)
+#define st200_SLCT_OPCODE_fld(x) (int)(((unsigned int)(x) >> 24) & 0x7)
+#define st200_CGEN_OPCODE_fld(x) (int)(((unsigned int)(x) >> 24) & 0xf)
+#define st200_SYSOP_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x7f)
+#define st200_SBREAK_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x7f)
+#define st200_LOAD_OPCODE_fld(x) (int)(((unsigned int)(x) >> 24) & 0xf)
+#define st200_STORE_OPCODE_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1f)
+#define st200_CALL_OPCODE_fld(x) (int)(((unsigned int)(x) >> 24) & 0x7)
+#define st200_BRANCH_OPCODE_fld(x) (int)(((unsigned int)(x) >> 26) & 0x1)
+#define st200_BCOND_fld(x) (int)(((unsigned int)(x) >> 23) & 0x7)
+#define st200_BDEST_fld(x) (int)(((unsigned int)(x) >> 18) & 0x7)
+#define st200_BDEST2_fld(x) (int)(((unsigned int)(x) >> 12) & 0x7)
+#define st200_BTARG_fld(x) (int)((unsigned int)(x) & 0x7fffff)
+#define st200_DEST_fld(x) (int)(((unsigned int)(x) >> 12) & 0x3f)
+#define st200_IBDEST_fld(x) (int)(((unsigned int)(x) >> 6) & 0x7)
+#define st200_IDEST_fld(x) (int)(((unsigned int)(x) >> 6) & 0x3f)
+#define st200_ISRC2_fld(x) (int)(((unsigned int)(x) >> 12) & 0x1ff)
+#define st200_IMM_fld(x) (int)((unsigned int)(x) & 0x7fffff)
+#define st200_SCOND_fld(x) (int)(((unsigned int)(x) >> 21) & 0x7)
+#define st200_SRC1_fld(x) (int)((unsigned int)(x) & 0x3f)
+#define st200_SRC2_fld(x) (int)(((unsigned int)(x) >> 6) & 0x3f)
+#define st200_SBRKNUM_fld(x) (int)((unsigned int)(x) & 0x1fffff)
+#define st200_IMMX_fld(x) (int)((unsigned int)(x) & 0x7fffff)
+#define st200_ENCODE_0_fld(x) (int)((unsigned int)(x) & 0x7fffffff)
+#define st200_STOPBIT_0_fld(x) (int)(((unsigned int)(x) >> 31) & 0x1)
+#define st200_FMT_0_fld(x) (int)(((unsigned int)(x) >> 28) & 0x3)
+#define st200_IMMX_OPCODE_0_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1f)
+#define st200_ENCODE_1_fld(x) (int)((unsigned int)(x) & 0x7fffffff)
+#define st200_STOPBIT_1_fld(x) (int)(((unsigned int)(x) >> 31) & 0x1)
+#define st200_FMT_1_fld(x) (int)(((unsigned int)(x) >> 28) & 0x3)
+#define st200_IMMX_OPCODE_1_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1f)
+#define st200_ENCODE_2_fld(x) (int)((unsigned int)(x) & 0x7fffffff)
+#define st200_STOPBIT_2_fld(x) (int)(((unsigned int)(x) >> 31) & 0x1)
+#define st200_FMT_2_fld(x) (int)(((unsigned int)(x) >> 28) & 0x3)
+#define st200_IMMX_OPCODE_2_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1f)
+#define st200_ENCODE_3_fld(x) (int)((unsigned int)(x) & 0x7fffffff)
+#define st200_STOPBIT_3_fld(x) (int)(((unsigned int)(x) >> 31) & 0x1)
+#define st200_FMT_3_fld(x) (int)(((unsigned int)(x) >> 28) & 0x3)
+#define st200_IMMX_OPCODE_3_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1f)
+#define st200_RESERVED_12_9_fld(x) (int)(((unsigned int)(x) >> 12) & 0x1ff)
+#define st200_LOADL_OPCODE_fld(x) (int)(((unsigned int)(x) >> 12) & 0x1ff)
+#define st200_STOREC_OPCODE_fld(x) (int)(((unsigned int)(x) >> 24) & 0xf)
+#define st200_STOREL_OPCODE_fld(x) (int)(((unsigned int)(x) >> 15) & 0x3f)
+#define st200_LS_SUBOPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x7)
+#define st200_MUL64_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x1f)
+#define st200_SYSTEM_OPCODE_fld(x) (int)(((unsigned int)(x) >> 12) & 0x1ff)
+#define st200_RESERVED_15_3_fld(x) (int)(((unsigned int)(x) >> 15) & 0x7)
+#define st200_RESERVED_12_1_fld(x) (int)(((unsigned int)(x) >> 12) & 0x1)
+#define st200_RESERVED_6_6_fld(x) (int)(((unsigned int)(x) >> 6) & 0x3f)
+#define st200_RESERVED_3_9_fld(x) (int)(((unsigned int)(x) >> 3) & 0x1ff)
+#define st200_RESERVED_3_3_fld(x) (int)(((unsigned int)(x) >> 3) & 0x7)
+#define st200_PACKED_fld(x) (int)(((unsigned int)(x) >> 25) & 0x1)
+#define st200_PACKED_HALF_fld(x) (int)(((unsigned int)(x) >> 24) & 0x1)
+#define st200_FLOAT_FIXED0_fld(x) (int)(((unsigned int)(x) >> 26) & 0x3)
+#define st200_FLOAT_FIXED1_fld(x) (int)(((unsigned int)(x) >> 18) & 0x7)
+#define st200_CMP3R_FIXED_fld(x) (int)(((unsigned int)(x) >> 18) & 0x7)
+#define st200_BREAK_FIXED_fld(x) (int)(((unsigned int)(x) >> 21) & 0x7f)
+#define st200_SLCT_FIXED_fld(x) (int)(((unsigned int)(x) >> 26) & 0x1)
+#define st200_WIDE_OPS_FIXED_fld(x) (int)(((unsigned int)(x) >> 26) & 0x1)
+#define st200_ASM_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x7f)
+#define st200_SIMD_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x7)
+#define st200_INT3R_OPCODE_fld(x) (int)(((unsigned int)(x) >> 18) & 0x7)
+#define st200_BDEST_OPCODE_fld(x) (int)(((unsigned int)(x) >> 15) & 0x3f)
+#define st200_IMMX_ISRIGHT_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1)
+#define st200_SLCT_OPCODE3_fld(x) (int)(((unsigned int)(x) >> 24) & 0x3)
+#define st200_SLCT_OPCODE2_fld(x) (int)(((unsigned int)(x) >> 18) & 0x7)
+#define st200_WIDE_OPS_OPCODE_fld(x) (int)(((unsigned int)(x) >> 24) & 0x3)
+#define st200_BREAK_OPCODE_fld(x) (int)(((unsigned int)(x) >> 18) & 0x7)
+#define st200_MEMSUB_OPCODE_fld(x) (int)(((unsigned int)(x) >> 6) & 0x3f)
+#define st200_FLOAT_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x1f)
+#define st200_BSRC1_fld(x) (int)((unsigned int)(x) & 0x7)
+#define st200_BSRC2_fld(x) (int)(((unsigned int)(x) >> 6) & 0x7)
+#define st200_BRKNUM_fld(x) (int)((unsigned int)(x) & 0xfff)
+
+#define st200_bcond_opd(w) (((unsigned int)(w) >> 23) & 0x7)
+#define st200_bdest_opd(w) (((unsigned int)(w) >> 18) & 0x7)
+#define st200_bdest2_opd(w) (((unsigned int)(w) >> 12) & 0x7)
+#define st200_btarg_opd(w) ((unsigned int)(w) & 0x7fffff)
+#define st200_dest_opd(w) (((unsigned int)(w) >> 12) & 0x3f)
+#define st200_nldest_opd(w) (((unsigned int)(w) >> 12) & 0x3f)
+#define st200_ibdest_opd(w) (((unsigned int)(w) >> 6) & 0x7)
+#define st200_idest_opd(w) (((unsigned int)(w) >> 6) & 0x3f)
+#define st200_nlidest_opd(w) (((unsigned int)(w) >> 6) & 0x3f)
+#define st200_isrc2_opd(w) (((unsigned int)(w) >> 12) & 0x1ff)
+#define st200_imm_opd(w) ((unsigned int)(w) & 0x7fffff)
+#define st200_scond_opd(w) (((unsigned int)(w) >> 21) & 0x7)
+#define st200_src1_opd(w) ((unsigned int)(w) & 0x3f)
+#define st200_src2_opd(w) (((unsigned int)(w) >> 6) & 0x3f)
+#define st200_sbrknum_opd(w) ((unsigned int)(w) & 0x1fffff)
+#define st200_xsrc2_opd(w0,w1) ((((unsigned int)(w1) & 0x7fffff) << 9) | (((unsigned int)(w0) >> 12) & 0x1ff))
+#define st200_bsrc1_opd(w) ((unsigned int)(w) & 0x7)
+#define st200_bsrc2_opd(w) (((unsigned int)(w) >> 6) & 0x7)
+#define st200_idestp_opd(w) (((unsigned int)(w) >> 6) & 0x3f)
+#define st200_pcond_opd(w) (((unsigned int)(w) >> 21) & 0x7)
+#define st200_src2p_opd(w) (((unsigned int)(w) >> 6) & 0x3f)
+#define st200_brknum_opd(w) ((unsigned int)(w) & 0xfff)
+
+#define st220_add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00000000)
+#define st220_add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08000000)
+#define st220_add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08000000)
+#define st220_addcg_dest_bdest_src1_src2_scond_insn(dest,bdest,src1,src2,scond) (unsigned int)(0x12000000 | (((int)(dest) & 0x3f) << 12) | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st220_addcg_dest_bdest_src1_src2_scond_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x12000000)
+#define st220_and_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_and_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01200000)
+#define st220_and_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_and_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09200000)
+#define st220_and_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_and_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_and_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09200000)
+#define st220_andc_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_andc_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01400000)
+#define st220_andc_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_andc_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09400000)
+#define st220_andc_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_andc_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_andc_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09400000)
+#define st220_andl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_andl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05400000)
+#define st220_andl_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07400000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_andl_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07400000)
+#define st220_andl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_andl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d400000)
+#define st220_andl_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_andl_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f400000)
+#define st220_andl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_andl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_andl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d400000)
+#define st220_andl_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_andl_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_andl_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f400000)
+#define st220_asm_0_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_0_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c000000)
+#define st220_asm_1_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_1_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c200000)
+#define st220_asm_2_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_2_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c400000)
+#define st220_asm_3_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_3_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c600000)
+#define st220_asm_4_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_4_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c800000)
+#define st220_asm_5_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2ca00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_5_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2ca00000)
+#define st220_asm_6_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2cc00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_6_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2cc00000)
+#define st220_asm_7_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2ce00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_7_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2ce00000)
+#define st220_asm_8_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_8_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d000000)
+#define st220_asm_9_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_9_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d200000)
+#define st220_asm_10_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_10_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d400000)
+#define st220_asm_11_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_11_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d600000)
+#define st220_asm_12_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_12_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d800000)
+#define st220_asm_13_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2da00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_13_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2da00000)
+#define st220_asm_14_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2dc00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_14_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2dc00000)
+#define st220_asm_15_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2de00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_asm_15_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2de00000)
+#define st220_asm_16_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_16_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e000000)
+#define st220_asm_16_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_16_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_16_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e000000)
+#define st220_asm_17_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_17_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e200000)
+#define st220_asm_17_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_17_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_17_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e200000)
+#define st220_asm_18_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_18_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e400000)
+#define st220_asm_18_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_18_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_18_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e400000)
+#define st220_asm_19_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_19_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e600000)
+#define st220_asm_19_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_19_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_19_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e600000)
+#define st220_asm_20_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_20_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e800000)
+#define st220_asm_20_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_20_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_20_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e800000)
+#define st220_asm_21_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2ea00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_21_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ea00000)
+#define st220_asm_21_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2ea00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_21_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_21_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ea00000)
+#define st220_asm_22_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2ec00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_22_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ec00000)
+#define st220_asm_22_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2ec00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_22_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_22_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ec00000)
+#define st220_asm_23_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2ee00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_23_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ee00000)
+#define st220_asm_23_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2ee00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_23_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_23_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ee00000)
+#define st220_asm_24_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_24_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f000000)
+#define st220_asm_24_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_24_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_24_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f000000)
+#define st220_asm_25_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_25_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f200000)
+#define st220_asm_25_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_25_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_25_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f200000)
+#define st220_asm_26_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_26_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f400000)
+#define st220_asm_26_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_26_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_26_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f400000)
+#define st220_asm_27_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_27_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f600000)
+#define st220_asm_27_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_27_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_27_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f600000)
+#define st220_asm_28_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_28_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f800000)
+#define st220_asm_28_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_28_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_28_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f800000)
+#define st220_asm_29_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2fa00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_29_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fa00000)
+#define st220_asm_29_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2fa00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_29_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_29_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fa00000)
+#define st220_asm_30_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2fc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_30_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fc00000)
+#define st220_asm_30_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2fc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_30_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_30_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fc00000)
+#define st220_asm_31_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2fe00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_asm_31_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fe00000)
+#define st220_asm_31_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2fe00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_asm_31_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_asm_31_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fe00000)
+#define st220_br_bcond_btarg_insn(bcond,btarg) (unsigned int)(0x38000000 | (((int)(bcond) & 0x7) << 23) | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st220_br_bcond_btarg_insn(x) (int)(((unsigned int)(x) & 0x7c000000) == 0x38000000)
+#define is_st220_break_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x1fe00000)
+#define st220_brf_bcond_btarg_insn(bcond,btarg) (unsigned int)(0x3c000000 | (((int)(bcond) & 0x7) << 23) | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st220_brf_bcond_btarg_insn(x) (int)(((unsigned int)(x) & 0x7c000000) == 0x3c000000)
+#define st220_bswap_idest_src1_insn(idest,src1) (unsigned int)(0x09c02000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st220_bswap_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c02000)
+#define st220_call_btarg_insn(btarg) (unsigned int)(0x30000000 | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st220_call_btarg_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x30000000)
+#define is_st220_icall_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x30800000)
+#define st220_clz_idest_src1_insn(idest,src1) (unsigned int)(0x09c04000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st220_clz_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c04000)
+#define st220_cmpeq_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpeq_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04000000)
+#define st220_cmpeq_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06000000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpeq_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06000000)
+#define st220_cmpeq_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpeq_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c000000)
+#define st220_cmpeq_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpeq_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e000000)
+#define st220_cmpeq_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpeq_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpeq_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c000000)
+#define st220_cmpeq_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpeq_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpeq_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e000000)
+#define st220_cmpge_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpge_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04400000)
+#define st220_cmpge_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06400000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpge_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06400000)
+#define st220_cmpge_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpge_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c400000)
+#define st220_cmpge_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpge_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e400000)
+#define st220_cmpge_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpge_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpge_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c400000)
+#define st220_cmpge_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpge_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpge_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e400000)
+#define st220_cmpgeu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpgeu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04600000)
+#define st220_cmpgeu_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06600000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpgeu_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06600000)
+#define st220_cmpgeu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpgeu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c600000)
+#define st220_cmpgeu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpgeu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e600000)
+#define st220_cmpgeu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpgeu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpgeu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c600000)
+#define st220_cmpgeu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpgeu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpgeu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e600000)
+#define st220_cmpgt_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpgt_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04800000)
+#define st220_cmpgt_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpgt_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06800000)
+#define st220_cmpgt_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpgt_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c800000)
+#define st220_cmpgt_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpgt_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e800000)
+#define st220_cmpgt_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpgt_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpgt_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c800000)
+#define st220_cmpgt_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpgt_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpgt_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e800000)
+#define st220_cmpgtu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpgtu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04a00000)
+#define st220_cmpgtu_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06a00000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpgtu_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06a00000)
+#define st220_cmpgtu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0ca00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpgtu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ca00000)
+#define st220_cmpgtu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ea00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpgtu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ea00000)
+#define st220_cmpgtu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0ca00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpgtu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpgtu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ca00000)
+#define st220_cmpgtu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ea00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpgtu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpgtu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ea00000)
+#define st220_cmple_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmple_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04c00000)
+#define st220_cmple_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06c00000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmple_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06c00000)
+#define st220_cmple_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0cc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmple_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0cc00000)
+#define st220_cmple_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ec00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmple_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ec00000)
+#define st220_cmple_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0cc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmple_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmple_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0cc00000)
+#define st220_cmple_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ec00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmple_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmple_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ec00000)
+#define st220_cmpleu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpleu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04e00000)
+#define st220_cmpleu_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06e00000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpleu_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06e00000)
+#define st220_cmpleu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0ce00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpleu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ce00000)
+#define st220_cmpleu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ee00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpleu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ee00000)
+#define st220_cmpleu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0ce00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpleu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpleu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ce00000)
+#define st220_cmpleu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ee00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpleu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpleu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ee00000)
+#define st220_cmplt_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmplt_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05000000)
+#define st220_cmplt_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07000000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmplt_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07000000)
+#define st220_cmplt_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmplt_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d000000)
+#define st220_cmplt_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmplt_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f000000)
+#define st220_cmplt_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmplt_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmplt_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d000000)
+#define st220_cmplt_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmplt_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmplt_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f000000)
+#define st220_cmpltu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpltu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05200000)
+#define st220_cmpltu_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07200000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpltu_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07200000)
+#define st220_cmpltu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpltu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d200000)
+#define st220_cmpltu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpltu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f200000)
+#define st220_cmpltu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpltu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpltu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d200000)
+#define st220_cmpltu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpltu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpltu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f200000)
+#define st220_cmpne_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpne_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04200000)
+#define st220_cmpne_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06200000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_cmpne_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06200000)
+#define st220_cmpne_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpne_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c200000)
+#define st220_cmpne_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_cmpne_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e200000)
+#define st220_cmpne_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpne_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpne_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c200000)
+#define st220_cmpne_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_cmpne_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_cmpne_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e200000)
+#define st220_divs_dest_bdest_src1_src2_scond_insn(dest,bdest,src1,src2,scond) (unsigned int)(0x14000000 | (((int)(dest) & 0x3f) << 12) | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st220_divs_dest_bdest_src1_src2_scond_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x14000000)
+#define st220_goto_btarg_insn(btarg) (unsigned int)(0x31000000 | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st220_goto_btarg_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x31000000)
+#define is_st220_igoto_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x31800000)
+#define st220_imml_imm_insn(imm) (unsigned int)(0x15000000 | ((int)(imm) & 0x7fffff))
+#define is_st220_imml_imm_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x15000000)
+#define st220_immr_imm_insn(imm) (unsigned int)(0x15800000 | ((int)(imm) & 0x7fffff))
+#define is_st220_immr_imm_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x15800000)
+#define st220_ldb_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x23000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st220_ldb_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23000000)
+#define st220_ldb_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x23000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st220_ldb_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_ldb_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23000000)
+#define st220_ldb_d_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x23800000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st220_ldb_d_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23800000)
+#define st220_ldb_d_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x23800000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st220_ldb_d_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_ldb_d_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23800000)
+#define st220_ldbu_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x24000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st220_ldbu_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24000000)
+#define st220_ldbu_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x24000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st220_ldbu_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_ldbu_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24000000)
+#define st220_ldbu_d_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x24800000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st220_ldbu_d_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24800000)
+#define st220_ldbu_d_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x24800000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st220_ldbu_d_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_ldbu_d_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24800000)
+#define st220_ldh_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x21000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st220_ldh_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21000000)
+#define st220_ldh_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x21000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st220_ldh_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_ldh_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21000000)
+#define st220_ldh_d_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x21800000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st220_ldh_d_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21800000)
+#define st220_ldh_d_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x21800000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st220_ldh_d_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_ldh_d_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21800000)
+#define st220_ldhu_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x22000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st220_ldhu_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22000000)
+#define st220_ldhu_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x22000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st220_ldhu_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_ldhu_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22000000)
+#define st220_ldhu_d_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x22800000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st220_ldhu_d_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22800000)
+#define st220_ldhu_d_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x22800000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st220_ldhu_d_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_ldhu_d_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22800000)
+#define st220_ldw_idest_isrc2_src1_insn(idest,isrc2,src1) (unsigned int)(0x20000000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st220_ldw_idest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20000000)
+#define st220_ldw_idest_xsrc2_src1_insn_0(idest,xsrc2,src1) (unsigned int)(0x20000000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st220_ldw_idest_xsrc2_src1_insn_1(idest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_ldw_idest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20000000)
+#define st220_ldw_d_idest_isrc2_src1_insn(idest,isrc2,src1) (unsigned int)(0x20800000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st220_ldw_d_idest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20800000)
+#define st220_ldw_d_idest_xsrc2_src1_insn_0(idest,xsrc2,src1) (unsigned int)(0x20800000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st220_ldw_d_idest_xsrc2_src1_insn_1(idest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_ldw_d_idest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20800000)
+#define st220_max_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_max_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02000000)
+#define st220_max_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_max_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a000000)
+#define st220_max_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_max_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_max_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a000000)
+#define st220_maxu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_maxu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02200000)
+#define st220_maxu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_maxu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a200000)
+#define st220_maxu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_maxu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_maxu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a200000)
+#define st220_min_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_min_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02400000)
+#define st220_min_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_min_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a400000)
+#define st220_min_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_min_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_min_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a400000)
+#define st220_minu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_minu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02600000)
+#define st220_minu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_minu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a600000)
+#define st220_minu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_minu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_minu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a600000)
+#define st220_mulh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_mulh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02e00000)
+#define st220_mulh_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0ae00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_mulh_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ae00000)
+#define st220_mulh_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0ae00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_mulh_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_mulh_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ae00000)
+#define st220_mulhh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03a00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_mulhh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03a00000)
+#define st220_mulhh_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0ba00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_mulhh_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ba00000)
+#define st220_mulhh_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0ba00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_mulhh_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_mulhh_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ba00000)
+#define st220_mulhhs_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02800000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_mulhhs_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02800000)
+#define st220_mulhhs_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0a800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_mulhhs_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a800000)
+#define st220_mulhhs_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0a800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_mulhhs_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_mulhhs_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a800000)
+#define st220_mulhhu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03c00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_mulhhu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03c00000)
+#define st220_mulhhu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0bc00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_mulhhu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0bc00000)
+#define st220_mulhhu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0bc00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_mulhhu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_mulhhu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0bc00000)
+#define st220_mulhs_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_mulhs_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03e00000)
+#define st220_mulhs_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0be00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_mulhs_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0be00000)
+#define st220_mulhs_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0be00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_mulhs_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_mulhs_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0be00000)
+#define st220_mulhu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03000000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_mulhu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03000000)
+#define st220_mulhu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b000000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_mulhu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b000000)
+#define st220_mulhu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b000000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_mulhu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_mulhu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b000000)
+#define st220_mull_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02a00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_mull_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02a00000)
+#define st220_mull_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0aa00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_mull_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0aa00000)
+#define st220_mull_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0aa00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_mull_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_mull_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0aa00000)
+#define st220_mullh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03600000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_mullh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03600000)
+#define st220_mullh_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b600000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_mullh_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b600000)
+#define st220_mullh_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b600000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_mullh_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_mullh_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b600000)
+#define st220_mullhu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03800000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_mullhu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03800000)
+#define st220_mullhu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_mullhu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b800000)
+#define st220_mullhu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_mullhu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_mullhu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b800000)
+#define st220_mullhus_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x01e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_mullhus_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01e00000)
+#define st220_mullhus_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x09e00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_mullhus_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09e00000)
+#define st220_mullhus_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x09e00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_mullhus_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_mullhus_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09e00000)
+#define st220_mulll_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03200000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_mulll_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03200000)
+#define st220_mulll_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_mulll_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b200000)
+#define st220_mulll_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_mulll_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_mulll_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b200000)
+#define st220_mulllu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03400000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_mulllu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03400000)
+#define st220_mulllu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b400000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_mulllu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b400000)
+#define st220_mulllu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b400000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_mulllu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_mulllu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b400000)
+#define st220_mullu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02c00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_mullu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02c00000)
+#define st220_mullu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0ac00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_mullu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ac00000)
+#define st220_mullu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0ac00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_mullu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_mullu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ac00000)
+#define st220_nandl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_nandl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05600000)
+#define st220_nandl_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07600000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_nandl_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07600000)
+#define st220_nandl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_nandl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d600000)
+#define st220_nandl_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_nandl_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f600000)
+#define st220_nandl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_nandl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_nandl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d600000)
+#define st220_nandl_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_nandl_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_nandl_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f600000)
+#define st220_norl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_norl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05a00000)
+#define st220_norl_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07a00000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_norl_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07a00000)
+#define st220_norl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0da00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_norl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0da00000)
+#define st220_norl_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0fa00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_norl_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0fa00000)
+#define st220_norl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0da00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_norl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_norl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0da00000)
+#define st220_norl_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0fa00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_norl_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_norl_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0fa00000)
+#define st220_or_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_or_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01600000)
+#define st220_or_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_or_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09600000)
+#define st220_or_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_or_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_or_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09600000)
+#define st220_orc_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_orc_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01800000)
+#define st220_orc_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_orc_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09800000)
+#define st220_orc_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_orc_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_orc_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09800000)
+#define st220_orl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_orl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05800000)
+#define st220_orl_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_orl_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07800000)
+#define st220_orl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_orl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d800000)
+#define st220_orl_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_orl_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f800000)
+#define st220_orl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_orl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_orl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d800000)
+#define st220_orl_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_orl_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_orl_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f800000)
+#define st220_pft_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x26800000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st220_pft_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x26800000)
+#define st220_pft_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x26800000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st220_pft_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_pft_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x26800000)
+#define st220_prgadd_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x27000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st220_prgadd_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x27000000)
+#define st220_prgadd_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x27000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st220_prgadd_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_prgadd_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x27000000)
+#define st220_prgset_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x27800000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st220_prgset_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x27800000)
+#define st220_prgset_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x27800000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st220_prgset_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_prgset_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x27800000)
+#define is_st220_prgins_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x1f800000)
+#define is_st220_rfi_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x32000000)
+#define st220_sbrk_sbrknum_insn(sbrknum) (unsigned int)(0x9fa00000 | ((int)(sbrknum) & 0x1fffff))
+#define is_st220_sbrk_sbrknum_insn(x) (int)(((unsigned int)(x) & 0xffe00000) == 0x9fa00000)
+#define st220_sh1add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_sh1add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00a00000)
+#define st220_sh1add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_sh1add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08a00000)
+#define st220_sh1add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_sh1add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_sh1add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08a00000)
+#define st220_sh2add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_sh2add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00c00000)
+#define st220_sh2add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_sh2add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08c00000)
+#define st220_sh2add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_sh2add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_sh2add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08c00000)
+#define st220_sh3add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_sh3add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00e00000)
+#define st220_sh3add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08e00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_sh3add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08e00000)
+#define st220_sh3add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08e00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_sh3add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_sh3add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08e00000)
+#define st220_sh4add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_sh4add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01000000)
+#define st220_sh4add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_sh4add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09000000)
+#define st220_sh4add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_sh4add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_sh4add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09000000)
+#define st220_shl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_shl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00400000)
+#define st220_shl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_shl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08400000)
+#define st220_shl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_shl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_shl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08400000)
+#define st220_shr_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_shr_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00600000)
+#define st220_shr_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_shr_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08600000)
+#define st220_shr_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_shr_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_shr_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08600000)
+#define st220_shru_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_shru_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00800000)
+#define st220_shru_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_shru_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08800000)
+#define st220_shru_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_shru_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_shru_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08800000)
+#define st220_slct_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x10000000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_slct_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x10000000)
+#define st220_slct_idest_scond_src1_isrc2_insn(idest,scond,src1,isrc2) (unsigned int)(0x18000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_slct_idest_scond_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x18000000)
+#define st220_slct_idest_scond_src1_xsrc2_insn_0(idest,scond,src1,xsrc2) (unsigned int)(0x18000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_slct_idest_scond_src1_xsrc2_insn_1(idest,scond,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_slct_idest_scond_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x18000000)
+#define st220_slctf_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x11000000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_slctf_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x11000000)
+#define st220_slctf_idest_scond_src1_isrc2_insn(idest,scond,src1,isrc2) (unsigned int)(0x19000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_slctf_idest_scond_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x19000000)
+#define st220_slctf_idest_scond_src1_xsrc2_insn_0(idest,scond,src1,xsrc2) (unsigned int)(0x19000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_slctf_idest_scond_src1_xsrc2_insn_1(idest,scond,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_slctf_idest_scond_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x19000000)
+#define st220_stb_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x26000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_stb_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x26000000)
+#define st220_stb_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x26000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st220_stb_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_stb_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x26000000)
+#define st220_sth_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x25800000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_sth_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25800000)
+#define st220_sth_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x25800000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st220_sth_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_sth_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25800000)
+#define st220_stw_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x25000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_stw_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25000000)
+#define st220_stw_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x25000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st220_stw_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_stw_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25000000)
+#define st220_sub_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x00200000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st220_sub_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00200000)
+#define st220_sub_idest_isrc2_src1_insn(idest,isrc2,src1) (unsigned int)(0x08200000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st220_sub_idest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08200000)
+#define st220_sub_idest_xsrc2_src1_insn_0(idest,xsrc2,src1) (unsigned int)(0x08200000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st220_sub_idest_xsrc2_src1_insn_1(idest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_sub_idest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08200000)
+#define st220_sxtb_idest_src1_insn(idest,src1) (unsigned int)(0x09c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st220_sxtb_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c00000)
+#define st220_sxth_idest_src1_insn(idest,src1) (unsigned int)(0x09c01000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st220_sxth_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c01000)
+#define is_st220_sync_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x28000000)
+#define st220_syscall_sbrknum_insn(sbrknum) (unsigned int)(0x1fc00000 | ((int)(sbrknum) & 0x1fffff))
+#define is_st220_syscall_sbrknum_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1fc00000)
+#define st220_xor_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_xor_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01a00000)
+#define st220_xor_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_xor_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09a00000)
+#define st220_xor_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_xor_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_xor_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09a00000)
+#define st220_zxth_idest_src1_insn(idest,src1) (unsigned int)(0x09c03000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st220_zxth_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c03000)
+#define st220_convbi_idest_scond_insn(idest,scond) (unsigned int)(0x19001000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st220_convbi_idest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1ff03f) == 0x19001000)
+#define st220_convib_bdest_src1_insn(bdest,src1) (unsigned int)(0x07800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f))
+#define is_st220_convib_bdest_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe3ffc0) == 0x07800000)
+#define st220_mov_bsrc_idest_scond_insn(idest,scond) (unsigned int)(0x19001000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st220_mov_bsrc_idest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1ff03f) == 0x19001000)
+#define st220_mov_bdest_bdest_src1_insn(bdest,src1) (unsigned int)(0x07800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f))
+#define is_st220_mov_bdest_bdest_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe3ffc0) == 0x07800000)
+#define is_st220_nop_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x00000000)
+#define st220_mov_dest_src2_insn(dest,src2) (unsigned int)(0x00000000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6))
+#define is_st220_mov_dest_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc003f) == 0x00000000)
+#define st220_mov_idest_isrc2_insn(idest,isrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st220_mov_idest_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe0003f) == 0x08000000)
+#define st220_mov_idest_xsrc2_insn_0(idest,xsrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st220_mov_idest_xsrc2_insn_1(idest,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st220_mov_idest_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe0003f) == 0x08000000)
+#define st220_mtb_bdest_src1_insn(bdest,src1) (unsigned int)(0x07800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f))
+#define is_st220_mtb_bdest_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe3ffc0) == 0x07800000)
+#define st220_mfb_idest_scond_insn(idest,scond) (unsigned int)(0x19001000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st220_mfb_idest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1ff03f) == 0x19001000)
+#define st220_zxtb_idest_src1_insn(idest,src1) (unsigned int)(0x092ff000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st220_zxtb_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x092ff000)
+#define is_st220_syncins_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x31000001)
+#define is_st220_return_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x31800000)
+#define st231_add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00000000)
+#define st231_add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08000000)
+#define st231_add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08000000)
+#define st231_addcg_dest_bdest_src1_src2_scond_insn(dest,bdest,src1,src2,scond) (unsigned int)(0x12000000 | (((int)(dest) & 0x3f) << 12) | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st231_addcg_dest_bdest_src1_src2_scond_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x12000000)
+#define st231_and_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_and_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01200000)
+#define st231_and_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_and_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09200000)
+#define st231_and_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_and_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_and_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09200000)
+#define st231_andc_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_andc_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01400000)
+#define st231_andc_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_andc_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09400000)
+#define st231_andc_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_andc_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_andc_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09400000)
+#define st231_andl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_andl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05400000)
+#define st231_andl_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07400000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_andl_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07400000)
+#define st231_andl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_andl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d400000)
+#define st231_andl_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_andl_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f400000)
+#define st231_andl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_andl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_andl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d400000)
+#define st231_andl_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_andl_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_andl_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f400000)
+#define st231_asm_0_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_0_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c000000)
+#define st231_asm_1_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_1_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c200000)
+#define st231_asm_2_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_2_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c400000)
+#define st231_asm_3_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_3_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c600000)
+#define st231_asm_4_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_4_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c800000)
+#define st231_asm_5_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2ca00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_5_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2ca00000)
+#define st231_asm_6_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2cc00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_6_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2cc00000)
+#define st231_asm_7_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2ce00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_7_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2ce00000)
+#define st231_asm_8_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_8_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d000000)
+#define st231_asm_9_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_9_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d200000)
+#define st231_asm_10_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_10_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d400000)
+#define st231_asm_11_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_11_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d600000)
+#define st231_asm_12_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_12_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d800000)
+#define st231_asm_13_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2da00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_13_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2da00000)
+#define st231_asm_14_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2dc00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_14_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2dc00000)
+#define st231_asm_15_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2de00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_15_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2de00000)
+#define st231_asm_16_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_16_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e000000)
+#define st231_asm_16_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_16_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_16_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e000000)
+#define st231_asm_17_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_17_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e200000)
+#define st231_asm_17_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_17_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_17_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e200000)
+#define st231_asm_18_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_18_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e400000)
+#define st231_asm_18_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_18_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_18_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e400000)
+#define st231_asm_19_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_19_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e600000)
+#define st231_asm_19_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_19_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_19_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e600000)
+#define st231_asm_20_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_20_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e800000)
+#define st231_asm_20_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_20_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_20_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e800000)
+#define st231_asm_21_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2ea00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_21_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ea00000)
+#define st231_asm_21_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2ea00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_21_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_21_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ea00000)
+#define st231_asm_22_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2ec00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_22_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ec00000)
+#define st231_asm_22_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2ec00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_22_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_22_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ec00000)
+#define st231_asm_23_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2ee00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_23_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ee00000)
+#define st231_asm_23_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2ee00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_23_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_23_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ee00000)
+#define st231_asm_24_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_24_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f000000)
+#define st231_asm_24_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_24_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_24_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f000000)
+#define st231_asm_25_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_25_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f200000)
+#define st231_asm_25_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_25_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_25_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f200000)
+#define st231_asm_26_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_26_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f400000)
+#define st231_asm_26_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_26_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_26_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f400000)
+#define st231_asm_27_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_27_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f600000)
+#define st231_asm_27_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_27_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_27_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f600000)
+#define st231_asm_28_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_28_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f800000)
+#define st231_asm_28_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_28_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_28_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f800000)
+#define st231_asm_29_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2fa00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_29_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fa00000)
+#define st231_asm_29_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2fa00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_29_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_29_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fa00000)
+#define st231_asm_30_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2fc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_30_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fc00000)
+#define st231_asm_30_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2fc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_30_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_30_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fc00000)
+#define st231_asm_31_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2be00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_31_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2be00000)
+#define st231_asm_31_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2be00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_31_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_31_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2be00000)
+#define st231_br_bcond_btarg_insn(bcond,btarg) (unsigned int)(0x38000000 | (((int)(bcond) & 0x7) << 23) | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st231_br_bcond_btarg_insn(x) (int)(((unsigned int)(x) & 0x7c000000) == 0x38000000)
+#define is_st231_break_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x1fe00000)
+#define st231_brf_bcond_btarg_insn(bcond,btarg) (unsigned int)(0x3c000000 | (((int)(bcond) & 0x7) << 23) | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st231_brf_bcond_btarg_insn(x) (int)(((unsigned int)(x) & 0x7c000000) == 0x3c000000)
+#define st231_bswap_idest_src1_insn(idest,src1) (unsigned int)(0x09c02000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_bswap_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c02000)
+#define st231_call_btarg_insn(btarg) (unsigned int)(0x30000000 | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st231_call_btarg_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x30000000)
+#define is_st231_icall_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x30800000)
+#define st231_clz_idest_src1_insn(idest,src1) (unsigned int)(0x09c04000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_clz_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c04000)
+#define st231_cmpeq_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpeq_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04000000)
+#define st231_cmpeq_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06000000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpeq_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06000000)
+#define st231_cmpeq_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpeq_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c000000)
+#define st231_cmpeq_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpeq_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e000000)
+#define st231_cmpeq_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpeq_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpeq_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c000000)
+#define st231_cmpeq_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpeq_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpeq_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e000000)
+#define st231_cmpge_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpge_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04400000)
+#define st231_cmpge_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06400000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpge_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06400000)
+#define st231_cmpge_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpge_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c400000)
+#define st231_cmpge_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpge_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e400000)
+#define st231_cmpge_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpge_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpge_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c400000)
+#define st231_cmpge_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpge_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpge_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e400000)
+#define st231_cmpgeu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpgeu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04600000)
+#define st231_cmpgeu_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06600000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpgeu_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06600000)
+#define st231_cmpgeu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpgeu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c600000)
+#define st231_cmpgeu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpgeu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e600000)
+#define st231_cmpgeu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpgeu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpgeu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c600000)
+#define st231_cmpgeu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpgeu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpgeu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e600000)
+#define st231_cmpgt_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpgt_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04800000)
+#define st231_cmpgt_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpgt_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06800000)
+#define st231_cmpgt_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpgt_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c800000)
+#define st231_cmpgt_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpgt_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e800000)
+#define st231_cmpgt_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpgt_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpgt_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c800000)
+#define st231_cmpgt_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpgt_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpgt_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e800000)
+#define st231_cmpgtu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpgtu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04a00000)
+#define st231_cmpgtu_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06a00000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpgtu_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06a00000)
+#define st231_cmpgtu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0ca00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpgtu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ca00000)
+#define st231_cmpgtu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ea00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpgtu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ea00000)
+#define st231_cmpgtu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0ca00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpgtu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpgtu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ca00000)
+#define st231_cmpgtu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ea00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpgtu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpgtu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ea00000)
+#define st231_cmple_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmple_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04c00000)
+#define st231_cmple_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06c00000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmple_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06c00000)
+#define st231_cmple_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0cc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmple_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0cc00000)
+#define st231_cmple_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ec00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmple_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ec00000)
+#define st231_cmple_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0cc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmple_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmple_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0cc00000)
+#define st231_cmple_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ec00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmple_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmple_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ec00000)
+#define st231_cmpleu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpleu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04e00000)
+#define st231_cmpleu_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06e00000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpleu_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06e00000)
+#define st231_cmpleu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0ce00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpleu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ce00000)
+#define st231_cmpleu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ee00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpleu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ee00000)
+#define st231_cmpleu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0ce00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpleu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpleu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ce00000)
+#define st231_cmpleu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ee00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpleu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpleu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ee00000)
+#define st231_cmplt_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmplt_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05000000)
+#define st231_cmplt_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07000000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmplt_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07000000)
+#define st231_cmplt_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmplt_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d000000)
+#define st231_cmplt_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmplt_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f000000)
+#define st231_cmplt_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmplt_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmplt_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d000000)
+#define st231_cmplt_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmplt_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmplt_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f000000)
+#define st231_cmpltu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpltu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05200000)
+#define st231_cmpltu_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07200000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpltu_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07200000)
+#define st231_cmpltu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpltu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d200000)
+#define st231_cmpltu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpltu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f200000)
+#define st231_cmpltu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpltu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpltu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d200000)
+#define st231_cmpltu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpltu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpltu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f200000)
+#define st231_cmpne_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpne_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04200000)
+#define st231_cmpne_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06200000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpne_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06200000)
+#define st231_cmpne_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpne_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c200000)
+#define st231_cmpne_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpne_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e200000)
+#define st231_cmpne_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpne_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpne_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c200000)
+#define st231_cmpne_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpne_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpne_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e200000)
+#define st231_divs_dest_bdest_src1_src2_scond_insn(dest,bdest,src1,src2,scond) (unsigned int)(0x14000000 | (((int)(dest) & 0x3f) << 12) | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st231_divs_dest_bdest_src1_src2_scond_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x14000000)
+#define st231_goto_btarg_insn(btarg) (unsigned int)(0x31000000 | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st231_goto_btarg_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x31000000)
+#define is_st231_igoto_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x31800000)
+#define st231_imml_imm_insn(imm) (unsigned int)(0x15000000 | ((int)(imm) & 0x7fffff))
+#define is_st231_imml_imm_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x15000000)
+#define st231_immr_imm_insn(imm) (unsigned int)(0x15800000 | ((int)(imm) & 0x7fffff))
+#define is_st231_immr_imm_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x15800000)
+#define st231_ldb_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x23000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldb_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23000000)
+#define st231_ldb_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x23000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldb_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldb_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23000000)
+#define st231_ldb_d_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x23800000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldb_d_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23800000)
+#define st231_ldb_d_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x23800000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldb_d_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldb_d_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23800000)
+#define st231_ldbu_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x24000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldbu_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24000000)
+#define st231_ldbu_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x24000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldbu_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldbu_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24000000)
+#define st231_ldbu_d_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x24800000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldbu_d_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24800000)
+#define st231_ldbu_d_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x24800000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldbu_d_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldbu_d_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24800000)
+#define st231_ldh_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x21000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldh_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21000000)
+#define st231_ldh_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x21000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldh_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldh_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21000000)
+#define st231_ldh_d_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x21800000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldh_d_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21800000)
+#define st231_ldh_d_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x21800000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldh_d_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldh_d_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21800000)
+#define st231_ldhu_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x22000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldhu_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22000000)
+#define st231_ldhu_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x22000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldhu_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldhu_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22000000)
+#define st231_ldhu_d_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x22800000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldhu_d_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22800000)
+#define st231_ldhu_d_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x22800000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldhu_d_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldhu_d_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22800000)
+#define st231_ldw_idest_isrc2_src1_insn(idest,isrc2,src1) (unsigned int)(0x20000000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldw_idest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20000000)
+#define st231_ldw_idest_xsrc2_src1_insn_0(idest,xsrc2,src1) (unsigned int)(0x20000000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldw_idest_xsrc2_src1_insn_1(idest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldw_idest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20000000)
+#define st231_ldw_d_idest_isrc2_src1_insn(idest,isrc2,src1) (unsigned int)(0x20800000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldw_d_idest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20800000)
+#define st231_ldw_d_idest_xsrc2_src1_insn_0(idest,xsrc2,src1) (unsigned int)(0x20800000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldw_d_idest_xsrc2_src1_insn_1(idest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldw_d_idest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20800000)
+#define st231_ldwl_idest_src1_insn(idest,src1) (unsigned int)(0x2fe05000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_ldwl_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x2fe05000)
+#define st231_max_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_max_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02000000)
+#define st231_max_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_max_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a000000)
+#define st231_max_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_max_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_max_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a000000)
+#define st231_maxu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_maxu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02200000)
+#define st231_maxu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_maxu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a200000)
+#define st231_maxu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_maxu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_maxu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a200000)
+#define st231_min_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_min_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02400000)
+#define st231_min_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_min_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a400000)
+#define st231_min_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_min_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_min_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a400000)
+#define st231_minu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_minu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02600000)
+#define st231_minu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_minu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a600000)
+#define st231_minu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_minu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_minu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a600000)
+#define st231_mulh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02e00000)
+#define st231_mulh_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0ae00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulh_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ae00000)
+#define st231_mulh_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0ae00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulh_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulh_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ae00000)
+#define st231_mulhh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03a00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulhh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03a00000)
+#define st231_mulhh_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0ba00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulhh_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ba00000)
+#define st231_mulhh_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0ba00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulhh_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulhh_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ba00000)
+#define st231_mulhhs_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02800000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulhhs_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02800000)
+#define st231_mulhhs_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0a800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulhhs_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a800000)
+#define st231_mulhhs_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0a800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulhhs_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulhhs_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a800000)
+#define st231_mulhhu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03c00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulhhu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03c00000)
+#define st231_mulhhu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0bc00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulhhu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0bc00000)
+#define st231_mulhhu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0bc00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulhhu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulhhu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0bc00000)
+#define st231_mulhs_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulhs_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03e00000)
+#define st231_mulhs_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0be00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulhs_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0be00000)
+#define st231_mulhs_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0be00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulhs_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulhs_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0be00000)
+#define st231_mulhu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03000000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulhu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03000000)
+#define st231_mulhu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b000000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulhu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b000000)
+#define st231_mulhu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b000000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulhu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulhu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b000000)
+#define st231_mull_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02a00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mull_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02a00000)
+#define st231_mull_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0aa00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mull_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0aa00000)
+#define st231_mull_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0aa00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mull_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mull_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0aa00000)
+#define st231_mullh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03600000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mullh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03600000)
+#define st231_mullh_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b600000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mullh_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b600000)
+#define st231_mullh_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b600000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mullh_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mullh_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b600000)
+#define st231_mullhu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03800000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mullhu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03800000)
+#define st231_mullhu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mullhu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b800000)
+#define st231_mullhu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mullhu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mullhu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b800000)
+#define st231_mullhus_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x01e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mullhus_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01e00000)
+#define st231_mullhus_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x09e00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mullhus_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09e00000)
+#define st231_mullhus_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x09e00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mullhus_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mullhus_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09e00000)
+#define st231_mulll_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03200000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulll_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03200000)
+#define st231_mulll_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulll_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b200000)
+#define st231_mulll_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulll_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulll_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b200000)
+#define st231_mulllu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03400000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulllu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03400000)
+#define st231_mulllu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b400000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulllu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b400000)
+#define st231_mulllu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b400000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulllu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulllu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b400000)
+#define st231_mullu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02c00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mullu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02c00000)
+#define st231_mullu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0ac00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mullu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ac00000)
+#define st231_mullu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0ac00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mullu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mullu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ac00000)
+#define st231_mul32_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x05c00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mul32_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05c00000)
+#define st231_mul32_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0dc00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mul32_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0dc00000)
+#define st231_mul32_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0dc00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mul32_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mul32_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0dc00000)
+#define st231_mul64h_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x05e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mul64h_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05e00000)
+#define st231_mul64h_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0de00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mul64h_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0de00000)
+#define st231_mul64h_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0de00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mul64h_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mul64h_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0de00000)
+#define st231_mul64hu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x07c00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mul64hu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x07c00000)
+#define st231_mul64hu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0fc00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mul64hu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0fc00000)
+#define st231_mul64hu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0fc00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mul64hu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mul64hu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0fc00000)
+#define st231_mulfrac_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x07e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulfrac_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x07e00000)
+#define st231_mulfrac_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0fe00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulfrac_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0fe00000)
+#define st231_mulfrac_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0fe00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulfrac_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulfrac_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0fe00000)
+#define st231_nandl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_nandl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05600000)
+#define st231_nandl_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07600000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_nandl_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07600000)
+#define st231_nandl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_nandl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d600000)
+#define st231_nandl_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_nandl_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f600000)
+#define st231_nandl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_nandl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_nandl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d600000)
+#define st231_nandl_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_nandl_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_nandl_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f600000)
+#define st231_norl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_norl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05a00000)
+#define st231_norl_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07a00000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_norl_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07a00000)
+#define st231_norl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0da00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_norl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0da00000)
+#define st231_norl_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0fa00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_norl_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0fa00000)
+#define st231_norl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0da00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_norl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_norl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0da00000)
+#define st231_norl_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0fa00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_norl_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_norl_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0fa00000)
+#define st231_or_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_or_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01600000)
+#define st231_or_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_or_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09600000)
+#define st231_or_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_or_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_or_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09600000)
+#define st231_orc_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_orc_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01800000)
+#define st231_orc_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_orc_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09800000)
+#define st231_orc_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_orc_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_orc_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09800000)
+#define st231_orl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_orl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05800000)
+#define st231_orl_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_orl_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07800000)
+#define st231_orl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_orl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d800000)
+#define st231_orl_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_orl_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f800000)
+#define st231_orl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_orl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_orl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d800000)
+#define st231_orl_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_orl_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_orl_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f800000)
+#define st231_pft_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x26800000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_pft_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x26800000)
+#define st231_pft_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x26800000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_pft_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_pft_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x26800000)
+#define st231_prgadd_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x27000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_prgadd_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x27000000)
+#define st231_prgadd_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x27000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_prgadd_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_prgadd_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x27000000)
+#define is_st231_prgins_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x1f800000)
+#define st231_prginspg_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x28800000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_prginspg_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x28800000)
+#define st231_prginspg_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x28800000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_prginspg_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_prginspg_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x28800000)
+#define st231_prgset_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x27800000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_prgset_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x27800000)
+#define st231_prgset_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x27800000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_prgset_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_prgset_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x27800000)
+#define st231_pswclr_src2_insn(src2) (unsigned int)(0x29800000 | (((int)(src2) & 0x3f) << 6))
+#define is_st231_pswclr_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffff03f) == 0x29800000)
+#define st231_pswset_src2_insn(src2) (unsigned int)(0x29000000 | (((int)(src2) & 0x3f) << 6))
+#define is_st231_pswset_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffff03f) == 0x29000000)
+#define is_st231_rfi_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x32000000)
+#define st231_sbrk_sbrknum_insn(sbrknum) (unsigned int)(0x9fa00000 | ((int)(sbrknum) & 0x1fffff))
+#define is_st231_sbrk_sbrknum_insn(x) (int)(((unsigned int)(x) & 0xffe00000) == 0x9fa00000)
+#define st231_sh1add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_sh1add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00a00000)
+#define st231_sh1add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_sh1add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08a00000)
+#define st231_sh1add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_sh1add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_sh1add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08a00000)
+#define st231_sh2add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_sh2add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00c00000)
+#define st231_sh2add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_sh2add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08c00000)
+#define st231_sh2add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_sh2add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_sh2add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08c00000)
+#define st231_sh3add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_sh3add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00e00000)
+#define st231_sh3add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08e00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_sh3add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08e00000)
+#define st231_sh3add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08e00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_sh3add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_sh3add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08e00000)
+#define st231_sh4add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_sh4add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01000000)
+#define st231_sh4add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_sh4add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09000000)
+#define st231_sh4add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_sh4add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_sh4add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09000000)
+#define st231_shl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_shl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00400000)
+#define st231_shl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_shl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08400000)
+#define st231_shl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_shl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_shl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08400000)
+#define st231_shr_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_shr_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00600000)
+#define st231_shr_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_shr_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08600000)
+#define st231_shr_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_shr_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_shr_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08600000)
+#define st231_shru_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_shru_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00800000)
+#define st231_shru_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_shru_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08800000)
+#define st231_shru_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_shru_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_shru_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08800000)
+#define st231_slct_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x10000000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_slct_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x10000000)
+#define st231_slct_idest_scond_src1_isrc2_insn(idest,scond,src1,isrc2) (unsigned int)(0x18000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_slct_idest_scond_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x18000000)
+#define st231_slct_idest_scond_src1_xsrc2_insn_0(idest,scond,src1,xsrc2) (unsigned int)(0x18000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_slct_idest_scond_src1_xsrc2_insn_1(idest,scond,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_slct_idest_scond_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x18000000)
+#define st231_slctf_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x11000000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_slctf_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x11000000)
+#define st231_slctf_idest_scond_src1_isrc2_insn(idest,scond,src1,isrc2) (unsigned int)(0x19000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_slctf_idest_scond_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x19000000)
+#define st231_slctf_idest_scond_src1_xsrc2_insn_0(idest,scond,src1,xsrc2) (unsigned int)(0x19000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_slctf_idest_scond_src1_xsrc2_insn_1(idest,scond,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_slctf_idest_scond_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x19000000)
+#define st231_stb_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x26000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_stb_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x26000000)
+#define st231_stb_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x26000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st231_stb_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_stb_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x26000000)
+#define st231_sth_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x25800000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_sth_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25800000)
+#define st231_sth_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x25800000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st231_sth_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_sth_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25800000)
+#define st231_stw_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x25000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_stw_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25000000)
+#define st231_stw_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x25000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st231_stw_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_stw_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25000000)
+#define st231_stwl_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x2ff00000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_stwl_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x2ff00000)
+#define st231_sub_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x00200000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_sub_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00200000)
+#define st231_sub_idest_isrc2_src1_insn(idest,isrc2,src1) (unsigned int)(0x08200000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_sub_idest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08200000)
+#define st231_sub_idest_xsrc2_src1_insn_0(idest,xsrc2,src1) (unsigned int)(0x08200000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_sub_idest_xsrc2_src1_insn_1(idest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_sub_idest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08200000)
+#define st231_sxtb_idest_src1_insn(idest,src1) (unsigned int)(0x09c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_sxtb_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c00000)
+#define st231_sxth_idest_src1_insn(idest,src1) (unsigned int)(0x09c01000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_sxth_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c01000)
+#define is_st231_sync_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x28000000)
+#define st231_syscall_sbrknum_insn(sbrknum) (unsigned int)(0x1fc00000 | ((int)(sbrknum) & 0x1fffff))
+#define is_st231_syscall_sbrknum_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1fc00000)
+#define is_st231_wmb_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x2fe03000)
+#define st231_xor_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_xor_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01a00000)
+#define st231_xor_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_xor_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09a00000)
+#define st231_xor_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_xor_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_xor_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09a00000)
+#define st231_zxth_idest_src1_insn(idest,src1) (unsigned int)(0x09c03000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_zxth_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c03000)
+#define st231_convbi_idest_scond_insn(idest,scond) (unsigned int)(0x19001000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st231_convbi_idest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1ff03f) == 0x19001000)
+#define st231_convib_bdest_src1_insn(bdest,src1) (unsigned int)(0x07800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f))
+#define is_st231_convib_bdest_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe3ffc0) == 0x07800000)
+#define st231_mov_bsrc_idest_scond_insn(idest,scond) (unsigned int)(0x19001000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st231_mov_bsrc_idest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1ff03f) == 0x19001000)
+#define st231_mov_bdest_bdest_src1_insn(bdest,src1) (unsigned int)(0x07800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f))
+#define is_st231_mov_bdest_bdest_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe3ffc0) == 0x07800000)
+#define is_st231_nop_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x00000000)
+#define st231_mov_dest_src2_insn(dest,src2) (unsigned int)(0x00000000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mov_dest_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc003f) == 0x00000000)
+#define st231_mov_idest_isrc2_insn(idest,isrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mov_idest_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe0003f) == 0x08000000)
+#define st231_mov_idest_xsrc2_insn_0(idest,xsrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mov_idest_xsrc2_insn_1(idest,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mov_idest_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe0003f) == 0x08000000)
+#define st231_mtb_bdest_src1_insn(bdest,src1) (unsigned int)(0x07800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f))
+#define is_st231_mtb_bdest_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe3ffc0) == 0x07800000)
+#define st231_mfb_idest_scond_insn(idest,scond) (unsigned int)(0x19001000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st231_mfb_idest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1ff03f) == 0x19001000)
+#define st231_zxtb_idest_src1_insn(idest,src1) (unsigned int)(0x092ff000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_zxtb_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x092ff000)
+#define is_st231_syncins_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x29000000)
+#define is_st231_idle_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x31000000)
+#define is_st231_return_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x31800000)
+#define st240_add_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13040000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_add_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13040000)
+#define st240_adds_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02b00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_adds_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02b00000)
+#define st240_abss_ph_dest_src1_insn(dest,src1) (unsigned int)(0x13240000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_abss_ph_dest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0fc0) == 0x13240000)
+#define st240_max_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13440000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_max_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13440000)
+#define st240_min_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13640000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_min_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13640000)
+#define st240_mul_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13840000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mul_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13840000)
+#define st240_muladd_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13a40000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_muladd_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13a40000)
+#define st240_mulfracadds_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13680000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulfracadds_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13680000)
+#define st240_mulfracrm_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13c40000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulfracrm_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13c40000)
+#define st240_mulfracrne_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13e40000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulfracrne_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13e40000)
+#define st240_shl_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shl_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13000000)
+#define st240_shl_ph_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x1b000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shl_ph_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b000000)
+#define st240_shl_ph_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x1b000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shl_ph_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shl_ph_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b000000)
+#define st240_shls_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13200000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shls_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13200000)
+#define st240_shls_ph_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x1b200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shls_ph_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b200000)
+#define st240_shls_ph_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x1b200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shls_ph_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shls_ph_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b200000)
+#define st240_shr_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shr_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13400000)
+#define st240_shr_ph_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x1b400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shr_ph_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b400000)
+#define st240_shr_ph_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x1b400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shr_ph_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shr_ph_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b400000)
+#define st240_shrrnp_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13600000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shrrnp_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13600000)
+#define st240_shrrnp_ph_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x1b600000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shrrnp_ph_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b600000)
+#define st240_shrrnp_ph_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x1b600000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shrrnp_ph_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shrrnp_ph_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b600000)
+#define st240_shrrne_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13800000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shrrne_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13800000)
+#define st240_shrrne_ph_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x1b800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shrrne_ph_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b800000)
+#define st240_shrrne_ph_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x1b800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shrrne_ph_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shrrne_ph_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b800000)
+#define st240_sub_ph_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x13480000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sub_ph_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13480000)
+#define st240_subs_ph_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x02d00000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_subs_ph_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02d00000)
+#define st240_shuff_pbh_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12040000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shuff_pbh_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12040000)
+#define st240_shuff_pbl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12240000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shuff_pbl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12240000)
+#define st240_shuff_phh_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13080000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shuff_phh_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13080000)
+#define st240_shuff_phl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13280000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shuff_phl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13280000)
+#define st240_shuffodd_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12440000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shuffodd_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12440000)
+#define st240_shuffeve_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12640000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shuffeve_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12640000)
+#define st240_perm_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_perm_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12000000)
+#define st240_perm_pb_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x1a000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_perm_pb_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1a000000)
+#define st240_perm_pb_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x1a000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_perm_pb_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_perm_pb_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1a000000)
+#define st240_ext1_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12840000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_ext1_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12840000)
+#define st240_ext2_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12a40000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_ext2_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12a40000)
+#define st240_ext3_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12c40000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_ext3_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12c40000)
+#define st240_packsu_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12e40000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_packsu_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12e40000)
+#define st240_pack_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12680000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_pack_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12680000)
+#define st240_packrnp_phh_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13c80000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_packrnp_phh_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13c80000)
+#define st240_packs_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13e80000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_packs_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13e80000)
+#define st240_cmpeq_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05040000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeq_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05040000)
+#define st240_cmpgt_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05240000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgt_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05240000)
+#define st240_sadu_pb_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x12080000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_sadu_pb_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12080000)
+#define st240_absubu_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12280000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_absubu_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12280000)
+#define st240_muladdus_pb_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x12480000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_muladdus_pb_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12480000)
+#define st240_avg4u_pb_nldest_scond_src1_src2_insn(nldest,scond,src1,src2) (unsigned int)(0x17140000 | (((int)(nldest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_avg4u_pb_nldest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x17140000)
+#define st240_avgu_pb_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x17100000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_avgu_pb_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x17100000)
+#define st240_cmpeq_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04040000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeq_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04040000)
+#define st240_cmpgtu_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04440000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgtu_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04440000)
+#define st240_slct_pb_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x16000000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_slct_pb_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x16000000)
+#define st240_slct_pb_idest_scond_src1_isrc2_insn(idest,scond,src1,isrc2) (unsigned int)(0x1e000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_slct_pb_idest_scond_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x1e000000)
+#define st240_slct_pb_idest_scond_src1_xsrc2_insn_0(idest,scond,src1,xsrc2) (unsigned int)(0x1e000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_slct_pb_idest_scond_src1_xsrc2_insn_1(idest,scond,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_slct_pb_idest_scond_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x1e000000)
+#define st240_slctf_pb_idest_scond_src1_isrc2_insn(idest,scond,src1,isrc2) (unsigned int)(0x1f000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_slctf_pb_idest_scond_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x1f000000)
+#define st240_slctf_pb_idest_scond_src1_xsrc2_insn_0(idest,scond,src1,xsrc2) (unsigned int)(0x1f000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_slctf_pb_idest_scond_src1_xsrc2_insn_1(idest,scond,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_slctf_pb_idest_scond_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x1f000000)
+#define st240_cmpeq_ph_bdest_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07040000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeq_ph_bdest_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07040000)
+#define st240_cmpeq_pb_bdest_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06040000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeq_pb_bdest_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06040000)
+#define st240_cmpgt_ph_bdest_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07240000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgt_ph_bdest_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07240000)
+#define st240_cmpgtu_pb_bdest_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06240000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgtu_pb_bdest_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06240000)
+#define st240_mov_bdest_bdest2_src1_insn(bdest2,src1) (unsigned int)(0x07c00000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_mov_bdest_bdest2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8fc0) == 0x07c00000)
+#define st240_mov_bsrc_dest_scond_insn(dest,scond) (unsigned int)(0x17040000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21))
+#define is_st240_mov_bsrc_dest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1c0fff) == 0x17040000)
+#define st240_extl_pb_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x17080000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_extl_pb_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x17080000)
+#define st240_extr_pb_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x170c0000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_extr_pb_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x170c0000)
+#define st240_add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00000000)
+#define st240_add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08000000)
+#define st240_add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08000000)
+#define st240_addcg_dest_bdest_src1_src2_scond_insn(dest,bdest,src1,src2,scond) (unsigned int)(0x14000000 | (((int)(dest) & 0x3f) << 12) | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st240_addcg_dest_bdest_src1_src2_scond_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x14000000)
+#define st240_addf_n_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02080000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_addf_n_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02080000)
+#define st240_addpc_idest_isrc2_insn(idest,isrc2) (unsigned int)(0x09000000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_addpc_idest_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe0003f) == 0x09000000)
+#define st240_addpc_idest_xsrc2_insn_0(idest,xsrc2) (unsigned int)(0x09000000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_addpc_idest_xsrc2_insn_1(idest,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_addpc_idest_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe0003f) == 0x09000000)
+#define st240_adds_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02100000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_adds_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02100000)
+#define st240_addso_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x03100000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_addso_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03100000)
+#define st240_and_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_and_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01200000)
+#define st240_and_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_and_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09200000)
+#define st240_and_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_and_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_and_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09200000)
+#define st240_andl_bdest_bdest2_bsrc1_bsrc2_insn(bdest2,bsrc1,bsrc2) (unsigned int)(0x06008000 | (((int)(bdest2) & 0x7) << 12) | ((int)(bsrc1) & 0x7) | (((int)(bsrc2) & 0x7) << 6))
+#define is_st240_andl_bdest_bdest2_bsrc1_bsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fff8e38) == 0x06008000)
+#define st240_andc_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_andc_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01400000)
+#define st240_andc_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_andc_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09400000)
+#define st240_andc_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_andc_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_andc_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09400000)
+#define st240_andl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_andl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05400000)
+#define st240_andl_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07400000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_andl_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07400000)
+#define st240_asm_0_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_0_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26000000)
+#define st240_asm_1_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_1_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26200000)
+#define st240_asm_2_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_2_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26400000)
+#define st240_asm_3_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_3_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26600000)
+#define st240_asm_4_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_4_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26800000)
+#define st240_asm_5_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_5_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26a00000)
+#define st240_asm_6_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_6_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26c00000)
+#define st240_asm_7_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_7_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26e00000)
+#define st240_asm_8_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_8_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27000000)
+#define st240_asm_9_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_9_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27200000)
+#define st240_asm_10_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_10_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27400000)
+#define st240_asm_11_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_11_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27600000)
+#define st240_asm_12_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_12_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27800000)
+#define st240_asm_13_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_13_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27a00000)
+#define st240_asm_14_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_14_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27c00000)
+#define st240_asm_15_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_15_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27e00000)
+#define st240_asm_16_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2b000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_16_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b000000)
+#define st240_asm_16_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2b000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_16_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_16_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b000000)
+#define st240_asm_17_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2b200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_17_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b200000)
+#define st240_asm_17_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2b200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_17_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_17_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b200000)
+#define st240_asm_18_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2b400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_18_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b400000)
+#define st240_asm_18_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2b400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_18_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_18_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b400000)
+#define st240_asm_19_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2b600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_19_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b600000)
+#define st240_asm_19_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2b600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_19_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_19_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b600000)
+#define st240_asm_20_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2b800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_20_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b800000)
+#define st240_asm_20_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2b800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_20_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_20_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b800000)
+#define st240_asm_21_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2ba00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_21_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ba00000)
+#define st240_asm_21_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2ba00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_21_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_21_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ba00000)
+#define st240_asm_22_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2bc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_22_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2bc00000)
+#define st240_asm_22_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2bc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_22_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_22_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2bc00000)
+#define st240_asm_23_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2be00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_23_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2be00000)
+#define st240_asm_23_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2be00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_23_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_23_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2be00000)
+#define st240_asm_24_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2d000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_24_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d000000)
+#define st240_asm_24_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2d000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_24_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_24_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d000000)
+#define st240_asm_25_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2d200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_25_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d200000)
+#define st240_asm_25_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2d200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_25_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_25_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d200000)
+#define st240_asm_26_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2d400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_26_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d400000)
+#define st240_asm_26_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2d400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_26_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_26_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d400000)
+#define st240_asm_27_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2d600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_27_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d600000)
+#define st240_asm_27_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2d600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_27_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_27_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d600000)
+#define st240_asm_28_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2d800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_28_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d800000)
+#define st240_asm_28_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2d800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_28_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_28_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d800000)
+#define st240_asm_29_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2da00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_29_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2da00000)
+#define st240_asm_29_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2da00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_29_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_29_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2da00000)
+#define st240_asm_30_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2dc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_30_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2dc00000)
+#define st240_asm_30_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2dc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_30_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_30_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2dc00000)
+#define st240_asm_31_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2de00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_31_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2de00000)
+#define st240_asm_31_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2de00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_31_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_31_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2de00000)
+#define st240_br_bcond_btarg_insn(bcond,btarg) (unsigned int)(0x38000000 | (((int)(bcond) & 0x7) << 23) | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st240_br_bcond_btarg_insn(x) (int)(((unsigned int)(x) & 0x7c000000) == 0x38000000)
+#define is_st240_break_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x2fe0b000)
+#define st240_brf_bcond_btarg_insn(bcond,btarg) (unsigned int)(0x3c000000 | (((int)(bcond) & 0x7) << 23) | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st240_brf_bcond_btarg_insn(x) (int)(((unsigned int)(x) & 0x7c000000) == 0x3c000000)
+#define st240_call_btarg_insn(btarg) (unsigned int)(0x30000000 | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st240_call_btarg_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x30000000)
+#define is_st240_icall_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x30800000)
+#define st240_clz_idest_src1_insn(idest,src1) (unsigned int)(0x09c04000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_clz_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c04000)
+#define st240_cmpeq_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeq_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04000000)
+#define st240_cmpeq_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpeq_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c000000)
+#define st240_cmpeq_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06000000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeq_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06000000)
+#define st240_cmpeq_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpeq_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e000000)
+#define st240_cmpeq_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpeq_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpeq_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c000000)
+#define st240_cmpeq_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpeq_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpeq_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e000000)
+#define st240_cmpeqf_n_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeqf_n_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04600000)
+#define st240_cmpeqf_n_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06600000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeqf_n_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06600000)
+#define st240_cmpge_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpge_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c400000)
+#define st240_cmpge_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpge_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e400000)
+#define st240_cmpge_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpge_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpge_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c400000)
+#define st240_cmpge_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpge_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpge_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e400000)
+#define st240_cmpgef_n_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgef_n_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04400000)
+#define st240_cmpgef_n_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06400000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgef_n_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06400000)
+#define st240_cmpgeu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpgeu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c600000)
+#define st240_cmpgeu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpgeu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e600000)
+#define st240_cmpgeu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpgeu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpgeu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c600000)
+#define st240_cmpgeu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpgeu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpgeu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e600000)
+#define st240_cmpgt_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpgt_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c800000)
+#define st240_cmpgt_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpgt_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e800000)
+#define st240_cmpgt_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpgt_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpgt_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c800000)
+#define st240_cmpgt_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpgt_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpgt_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e800000)
+#define st240_cmpgtf_n_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgtf_n_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04800000)
+#define st240_cmpgtf_n_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06800000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgtf_n_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06800000)
+#define st240_cmpgtu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0ca00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpgtu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ca00000)
+#define st240_cmpgtu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ea00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpgtu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ea00000)
+#define st240_cmpgtu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0ca00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpgtu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpgtu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ca00000)
+#define st240_cmpgtu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ea00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpgtu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpgtu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ea00000)
+#define st240_cmple_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmple_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04c00000)
+#define st240_cmple_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0cc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmple_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0cc00000)
+#define st240_cmple_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06c00000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmple_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06c00000)
+#define st240_cmple_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ec00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmple_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ec00000)
+#define st240_cmple_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0cc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmple_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmple_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0cc00000)
+#define st240_cmple_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ec00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmple_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmple_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ec00000)
+#define st240_cmpleu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpleu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04e00000)
+#define st240_cmpleu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0ce00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpleu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ce00000)
+#define st240_cmpleu_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06e00000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpleu_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06e00000)
+#define st240_cmpleu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ee00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpleu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ee00000)
+#define st240_cmpleu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0ce00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpleu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpleu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ce00000)
+#define st240_cmpleu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ee00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpleu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpleu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ee00000)
+#define st240_cmplt_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmplt_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05000000)
+#define st240_cmplt_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmplt_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d000000)
+#define st240_cmplt_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07000000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmplt_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07000000)
+#define st240_cmplt_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmplt_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f000000)
+#define st240_cmplt_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmplt_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmplt_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d000000)
+#define st240_cmplt_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmplt_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmplt_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f000000)
+#define st240_cmpltu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpltu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05200000)
+#define st240_cmpltu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpltu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d200000)
+#define st240_cmpltu_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07200000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpltu_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07200000)
+#define st240_cmpltu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpltu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f200000)
+#define st240_cmpltu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpltu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpltu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d200000)
+#define st240_cmpltu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpltu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpltu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f200000)
+#define st240_cmpne_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpne_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04200000)
+#define st240_cmpne_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpne_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c200000)
+#define st240_cmpne_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06200000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpne_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06200000)
+#define st240_cmpne_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpne_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e200000)
+#define st240_cmpne_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpne_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpne_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c200000)
+#define st240_cmpne_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpne_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpne_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e200000)
+#define st240_convfi_n_nldest_src1_insn(nldest,src1) (unsigned int)(0x02880000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_convfi_n_nldest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0fc0) == 0x02880000)
+#define st240_convif_n_nldest_src1_insn(nldest,src1) (unsigned int)(0x02680000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_convif_n_nldest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0fc0) == 0x02680000)
+#define st240_dbgsbrk_brknum_insn(brknum) (unsigned int)(0xafe08000 | ((int)(brknum) & 0xfff))
+#define is_st240_dbgsbrk_brknum_insn(x) (int)(((unsigned int)(x) & 0xfffff000) == 0xafe08000)
+#define is_st240_dib_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x2fe06000)
+#define st240_div_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03080000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_div_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03080000)
+#define st240_divu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03480000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_divu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03480000)
+#define st240_extract_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x18600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_extract_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18600000)
+#define st240_extract_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x18600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_extract_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_extract_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18600000)
+#define st240_extractu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x18800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_extractu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18800000)
+#define st240_extractu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x18800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_extractu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_extractu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18800000)
+#define st240_extractl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x19600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_extractl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x19600000)
+#define st240_extractl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x19600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_extractl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_extractl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x19600000)
+#define st240_extractlu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x19800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_extractlu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x19800000)
+#define st240_extractlu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x19800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_extractlu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_extractlu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x19800000)
+#define st240_flushadd_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f800000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_flushadd_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f800000)
+#define st240_flushadd_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f800000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_flushadd_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_flushadd_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f800000)
+#define st240_flushadd_l1_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f800040 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_flushadd_l1_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f800040)
+#define st240_flushadd_l1_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f800040 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_flushadd_l1_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_flushadd_l1_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f800040)
+#define st240_goto_btarg_insn(btarg) (unsigned int)(0x31000000 | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st240_goto_btarg_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x31000000)
+#define is_st240_igoto_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x31800000)
+#define st240_imml_imm_insn(imm) (unsigned int)(0x15000000 | ((int)(imm) & 0x7fffff))
+#define is_st240_imml_imm_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x15000000)
+#define st240_immr_imm_insn(imm) (unsigned int)(0x15800000 | ((int)(imm) & 0x7fffff))
+#define is_st240_immr_imm_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x15800000)
+#define st240_invadd_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2fc00000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_invadd_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2fc00000)
+#define st240_invadd_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2fc00000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_invadd_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_invadd_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2fc00000)
+#define st240_invadd_l1_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2fc00040 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_invadd_l1_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2fc00040)
+#define st240_invadd_l1_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2fc00040 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_invadd_l1_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_invadd_l1_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2fc00040)
+#define st240_ldb_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x24000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldb_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24000000)
+#define st240_ldb_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x24000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldb_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldb_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24000000)
+#define st240_ldbc_nlidest_pcond_isrc2_src1_insn(nlidest,pcond,isrc2,src1) (unsigned int)(0x24000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldbc_nlidest_pcond_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x24000000)
+#define st240_ldbc_nlidest_pcond_xsrc2_src1_insn_0(nlidest,pcond,xsrc2,src1) (unsigned int)(0x24000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldbc_nlidest_pcond_xsrc2_src1_insn_1(nlidest,pcond,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldbc_nlidest_pcond_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x24000000)
+#define st240_ldbu_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x25000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldbu_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25000000)
+#define st240_ldbu_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x25000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldbu_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldbu_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25000000)
+#define st240_ldbuc_nlidest_pcond_isrc2_src1_insn(nlidest,pcond,isrc2,src1) (unsigned int)(0x25000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldbuc_nlidest_pcond_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x25000000)
+#define st240_ldbuc_nlidest_pcond_xsrc2_src1_insn_0(nlidest,pcond,xsrc2,src1) (unsigned int)(0x25000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldbuc_nlidest_pcond_xsrc2_src1_insn_1(nlidest,pcond,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldbuc_nlidest_pcond_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x25000000)
+#define st240_ldh_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x22000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldh_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22000000)
+#define st240_ldh_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x22000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldh_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldh_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22000000)
+#define st240_ldhc_nlidest_pcond_isrc2_src1_insn(nlidest,pcond,isrc2,src1) (unsigned int)(0x22000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldhc_nlidest_pcond_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x22000000)
+#define st240_ldhc_nlidest_pcond_xsrc2_src1_insn_0(nlidest,pcond,xsrc2,src1) (unsigned int)(0x22000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldhc_nlidest_pcond_xsrc2_src1_insn_1(nlidest,pcond,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldhc_nlidest_pcond_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x22000000)
+#define st240_ldhu_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x23000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldhu_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23000000)
+#define st240_ldhu_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x23000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldhu_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldhu_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23000000)
+#define st240_ldhuc_nlidest_pcond_isrc2_src1_insn(nlidest,pcond,isrc2,src1) (unsigned int)(0x23000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldhuc_nlidest_pcond_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x23000000)
+#define st240_ldhuc_nlidest_pcond_xsrc2_src1_insn_0(nlidest,pcond,xsrc2,src1) (unsigned int)(0x23000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldhuc_nlidest_pcond_xsrc2_src1_insn_1(nlidest,pcond,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldhuc_nlidest_pcond_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x23000000)
+#define st240_ldl_idestp_isrc2_src1_insn(idestp,isrc2,src1) (unsigned int)(0x20000000 | (((int)(idestp) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldl_idestp_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20000000)
+#define st240_ldl_idestp_xsrc2_src1_insn_0(idestp,xsrc2,src1) (unsigned int)(0x20000000 | (((int)(idestp) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldl_idestp_xsrc2_src1_insn_1(idestp,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldl_idestp_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20000000)
+#define st240_ldlc_idestp_pcond_isrc2_src1_insn(idestp,pcond,isrc2,src1) (unsigned int)(0x20000000 | (((int)(idestp) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldlc_idestp_pcond_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x20000000)
+#define st240_ldlc_idestp_pcond_xsrc2_src1_insn_0(idestp,pcond,xsrc2,src1) (unsigned int)(0x20000000 | (((int)(idestp) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldlc_idestp_pcond_xsrc2_src1_insn_1(idestp,pcond,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldlc_idestp_pcond_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x20000000)
+#define st240_ldw_idest_isrc2_src1_insn(idest,isrc2,src1) (unsigned int)(0x21000000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldw_idest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21000000)
+#define st240_ldw_idest_xsrc2_src1_insn_0(idest,xsrc2,src1) (unsigned int)(0x21000000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldw_idest_xsrc2_src1_insn_1(idest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldw_idest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21000000)
+#define st240_ldwc_idest_pcond_isrc2_src1_insn(idest,pcond,isrc2,src1) (unsigned int)(0x21000000 | (((int)(idest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldwc_idest_pcond_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x21000000)
+#define st240_ldwc_idest_pcond_xsrc2_src1_insn_0(idest,pcond,xsrc2,src1) (unsigned int)(0x21000000 | (((int)(idest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldwc_idest_pcond_xsrc2_src1_insn_1(idest,pcond,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldwc_idest_pcond_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x21000000)
+#define st240_ldwl_idest_src1_insn(idest,src1) (unsigned int)(0x2fe05000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_ldwl_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x2fe05000)
+#define st240_max_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_max_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02000000)
+#define st240_max_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_max_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a000000)
+#define st240_max_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_max_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_max_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a000000)
+#define st240_maxu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_maxu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02200000)
+#define st240_maxu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_maxu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a200000)
+#define st240_maxu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_maxu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_maxu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a200000)
+#define st240_min_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_min_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02400000)
+#define st240_min_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_min_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a400000)
+#define st240_min_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_min_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_min_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a400000)
+#define st240_minu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_minu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02600000)
+#define st240_minu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_minu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a600000)
+#define st240_minu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_minu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_minu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a600000)
+#define st240_mov_bsrc_bdest_bdest2_bsrc1_insn(bdest2,bsrc1) (unsigned int)(0x06010000 | (((int)(bdest2) & 0x7) << 12) | ((int)(bsrc1) & 0x7))
+#define is_st240_mov_bsrc_bdest_bdest2_bsrc1_insn(x) (int)(((unsigned int)(x) & 0x7fff8ff8) == 0x06010000)
+#define st240_mulf_n_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02480000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulf_n_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02480000)
+#define st240_mulfrac_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulfrac_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03e00000)
+#define st240_mulfrac_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0be00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mulfrac_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0be00000)
+#define st240_mulfrac_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0be00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mulfrac_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mulfrac_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0be00000)
+#define st240_mulh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02e00000)
+#define st240_mulhh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03a00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulhh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03a00000)
+#define st240_mulhhu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03c00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulhhu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03c00000)
+#define st240_mull_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02a00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mull_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02a00000)
+#define st240_mullh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03600000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mullh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03600000)
+#define st240_mullhu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03800000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mullhu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03800000)
+#define st240_mulll_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03200000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulll_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03200000)
+#define st240_mulll_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mulll_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b200000)
+#define st240_mulll_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mulll_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mulll_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b200000)
+#define st240_mulllu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03400000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulllu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03400000)
+#define st240_mulllu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b400000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mulllu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b400000)
+#define st240_mulllu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b400000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mulllu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mulllu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b400000)
+#define st240_mul32_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02c00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mul32_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02c00000)
+#define st240_mul32_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0ac00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mul32_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ac00000)
+#define st240_mul32_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0ac00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mul32_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mul32_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ac00000)
+#define st240_mul64h_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x01e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mul64h_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01e00000)
+#define st240_mul64h_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x09e00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mul64h_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09e00000)
+#define st240_mul64h_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x09e00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mul64h_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mul64h_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09e00000)
+#define st240_mul64hu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02800000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mul64hu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02800000)
+#define st240_mul64hu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0a800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mul64hu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a800000)
+#define st240_mul64hu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0a800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mul64hu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mul64hu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a800000)
+#define st240_nandl_bdest_bdest2_bsrc1_bsrc2_insn(bdest2,bsrc1,bsrc2) (unsigned int)(0x06208000 | (((int)(bdest2) & 0x7) << 12) | ((int)(bsrc1) & 0x7) | (((int)(bsrc2) & 0x7) << 6))
+#define is_st240_nandl_bdest_bdest2_bsrc1_bsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fff8e38) == 0x06208000)
+#define st240_nandl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_nandl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05600000)
+#define st240_nandl_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07600000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_nandl_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07600000)
+#define st240_norl_bdest_bdest2_bsrc1_bsrc2_insn(bdest2,bsrc1,bsrc2) (unsigned int)(0x06608000 | (((int)(bdest2) & 0x7) << 12) | ((int)(bsrc1) & 0x7) | (((int)(bsrc2) & 0x7) << 6))
+#define is_st240_norl_bdest_bdest2_bsrc1_bsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fff8e38) == 0x06608000)
+#define st240_norl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_norl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05a00000)
+#define st240_norl_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07a00000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_norl_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07a00000)
+#define st240_or_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_or_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01600000)
+#define st240_or_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_or_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09600000)
+#define st240_or_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_or_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_or_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09600000)
+#define st240_orl_bdest_bdest2_bsrc1_bsrc2_insn(bdest2,bsrc1,bsrc2) (unsigned int)(0x06408000 | (((int)(bdest2) & 0x7) << 12) | ((int)(bsrc1) & 0x7) | (((int)(bsrc2) & 0x7) << 6))
+#define is_st240_orl_bdest_bdest2_bsrc1_bsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fff8e38) == 0x06408000)
+#define st240_orc_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_orc_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01800000)
+#define st240_orl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_orl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05800000)
+#define st240_orl_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07800000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_orl_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07800000)
+#define st240_pft_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x20000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_pft_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x20000000)
+#define st240_pft_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x20000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_pft_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_pft_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x20000000)
+#define st240_pftc_pcond_isrc2_src1_insn(pcond,isrc2,src1) (unsigned int)(0x20000000 | (((int)(pcond) & 0x7) << 21) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_pftc_pcond_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000fc0) == 0x20000000)
+#define st240_pftc_pcond_xsrc2_src1_insn_0(pcond,xsrc2,src1) (unsigned int)(0x20000000 | (((int)(pcond) & 0x7) << 21) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_pftc_pcond_xsrc2_src1_insn_1(pcond,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_pftc_pcond_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000fc0) == 0x20000000)
+#define st240_prgadd_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prgadd_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f000000)
+#define st240_prgadd_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prgadd_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prgadd_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f000000)
+#define st240_prgadd_l1_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f000040 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prgadd_l1_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f000040)
+#define st240_prgadd_l1_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f000040 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prgadd_l1_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prgadd_l1_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f000040)
+#define st240_prginsadd_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f400000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prginsadd_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f400000)
+#define st240_prginsadd_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f400000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prginsadd_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prginsadd_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f400000)
+#define st240_prginsadd_l1_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f400040 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prginsadd_l1_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f400040)
+#define st240_prginsadd_l1_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f400040 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prginsadd_l1_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prginsadd_l1_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f400040)
+#define st240_prginsset_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f600000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prginsset_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f600000)
+#define st240_prginsset_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f600000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prginsset_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prginsset_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f600000)
+#define st240_prginsset_l1_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f600040 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prginsset_l1_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f600040)
+#define st240_prginsset_l1_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f600040 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prginsset_l1_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prginsset_l1_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f600040)
+#define st240_prgset_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f200000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prgset_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f200000)
+#define st240_prgset_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f200000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prgset_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prgset_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f200000)
+#define st240_prgset_l1_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f200040 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prgset_l1_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f200040)
+#define st240_prgset_l1_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f200040 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prgset_l1_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prgset_l1_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f200040)
+#define st240_pswmask_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x2fa00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_pswmask_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fa00000)
+#define st240_pswmask_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x2fa00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_pswmask_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_pswmask_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fa00000)
+#define st240_rem_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03280000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_rem_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03280000)
+#define st240_remu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03680000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_remu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03680000)
+#define is_st240_retention_insn(x) (int)(((unsigned int)(x) & 0xffffffff) == 0xafe0c000)
+#define is_st240_return_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x33800000)
+#define is_st240_rfi_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x32000000)
+#define st240_rotl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x10e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_rotl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x10e00000)
+#define st240_rotl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x18e00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_rotl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18e00000)
+#define st240_rotl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x18e00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_rotl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_rotl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18e00000)
+#define st240_sats_dest_src1_insn(dest,src1) (unsigned int)(0x02900000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_sats_dest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0fc0) == 0x02900000)
+#define st240_satso_dest_src1_insn(dest,src1) (unsigned int)(0x03900000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_satso_dest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0fc0) == 0x03900000)
+#define st240_sbrk_brknum_insn(brknum) (unsigned int)(0xafe09000 | ((int)(brknum) & 0xfff))
+#define is_st240_sbrk_brknum_insn(x) (int)(((unsigned int)(x) & 0xfffff000) == 0xafe09000)
+#define st240_sh1add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_sh1add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00a00000)
+#define st240_sh1add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_sh1add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08a00000)
+#define st240_sh1add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_sh1add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_sh1add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08a00000)
+#define st240_sh1adds_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x02500000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sh1adds_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02500000)
+#define st240_sh1addso_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x03500000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sh1addso_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03500000)
+#define st240_sh1subs_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x02700000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sh1subs_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02700000)
+#define st240_sh1subso_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x03700000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sh1subso_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03700000)
+#define st240_sh2add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_sh2add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00c00000)
+#define st240_sh2add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_sh2add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08c00000)
+#define st240_sh2add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_sh2add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_sh2add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08c00000)
+#define st240_sh3add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_sh3add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00e00000)
+#define st240_sh3add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08e00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_sh3add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08e00000)
+#define st240_sh3add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08e00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_sh3add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_sh3add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08e00000)
+#define st240_shl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00400000)
+#define st240_shl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08400000)
+#define st240_shl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08400000)
+#define st240_shls_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x10000000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shls_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x10000000)
+#define st240_shls_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x18000000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shls_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18000000)
+#define st240_shls_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x18000000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shls_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shls_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18000000)
+#define st240_shlso_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x10200000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shlso_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x10200000)
+#define st240_shlso_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x18200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shlso_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18200000)
+#define st240_shlso_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x18200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shlso_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shlso_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18200000)
+#define st240_shr_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shr_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00600000)
+#define st240_shr_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shr_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08600000)
+#define st240_shr_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shr_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shr_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08600000)
+#define st240_shrrnp_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x18400000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shrrnp_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18400000)
+#define st240_shrrnp_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x18400000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shrrnp_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shrrnp_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18400000)
+#define st240_shru_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shru_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00800000)
+#define st240_shru_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shru_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08800000)
+#define st240_shru_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shru_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shru_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08800000)
+#define st240_slct_rsrc_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x16040000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_slct_rsrc_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x16040000)
+#define st240_slct_idest_scond_src1_isrc2_insn(idest,scond,src1,isrc2) (unsigned int)(0x1c000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_slct_idest_scond_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x1c000000)
+#define st240_slct_idest_scond_src1_xsrc2_insn_0(idest,scond,src1,xsrc2) (unsigned int)(0x1c000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_slct_idest_scond_src1_xsrc2_insn_1(idest,scond,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_slct_idest_scond_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x1c000000)
+#define st240_slctf_idest_scond_src1_isrc2_insn(idest,scond,src1,isrc2) (unsigned int)(0x1d000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_slctf_idest_scond_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x1d000000)
+#define st240_slctf_idest_scond_src1_xsrc2_insn_0(idest,scond,src1,xsrc2) (unsigned int)(0x1d000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_slctf_idest_scond_src1_xsrc2_insn_1(idest,scond,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_slctf_idest_scond_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x1d000000)
+#define st240_stb_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x2c000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_stb_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2c000000)
+#define st240_stb_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x2c000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st240_stb_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_stb_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2c000000)
+#define st240_stbc_isrc2_src1_pcond_src2_insn(isrc2,src1,pcond,src2) (unsigned int)(0x2c000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_stbc_isrc2_src1_pcond_src2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x2c000000)
+#define st240_stbc_xsrc2_src1_pcond_src2_insn_0(xsrc2,src1,pcond,src2) (unsigned int)(0x2c000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6))
+#define st240_stbc_xsrc2_src1_pcond_src2_insn_1(xsrc2,src1,pcond,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_stbc_xsrc2_src1_pcond_src2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x2c000000)
+#define st240_sth_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x2a000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_sth_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2a000000)
+#define st240_sth_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x2a000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st240_sth_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_sth_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2a000000)
+#define st240_sthc_isrc2_src1_pcond_src2_insn(isrc2,src1,pcond,src2) (unsigned int)(0x2a000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_sthc_isrc2_src1_pcond_src2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x2a000000)
+#define st240_sthc_xsrc2_src1_pcond_src2_insn_0(xsrc2,src1,pcond,src2) (unsigned int)(0x2a000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6))
+#define st240_sthc_xsrc2_src1_pcond_src2_insn_1(xsrc2,src1,pcond,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_sthc_xsrc2_src1_pcond_src2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x2a000000)
+#define st240_stl_isrc2_src1_src2p_insn(isrc2,src1,src2p) (unsigned int)(0x28000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2p) & 0x3f) << 6))
+#define is_st240_stl_isrc2_src1_src2p_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x28000000)
+#define st240_stl_xsrc2_src1_src2p_insn_0(xsrc2,src1,src2p) (unsigned int)(0x28000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2p) & 0x3f) << 6))
+#define st240_stl_xsrc2_src1_src2p_insn_1(xsrc2,src1,src2p) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_stl_xsrc2_src1_src2p_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x28000000)
+#define st240_stlc_isrc2_src1_pcond_src2p_insn(isrc2,src1,pcond,src2p) (unsigned int)(0x28000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2p) & 0x3f) << 6))
+#define is_st240_stlc_isrc2_src1_pcond_src2p_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x28000000)
+#define st240_stlc_xsrc2_src1_pcond_src2p_insn_0(xsrc2,src1,pcond,src2p) (unsigned int)(0x28000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2p) & 0x3f) << 6))
+#define st240_stlc_xsrc2_src1_pcond_src2p_insn_1(xsrc2,src1,pcond,src2p) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_stlc_xsrc2_src1_pcond_src2p_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x28000000)
+#define st240_stw_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x29000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_stw_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x29000000)
+#define st240_stw_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x29000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st240_stw_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_stw_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x29000000)
+#define st240_stwc_isrc2_src1_pcond_src2_insn(isrc2,src1,pcond,src2) (unsigned int)(0x29000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_stwc_isrc2_src1_pcond_src2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x29000000)
+#define st240_stwc_xsrc2_src1_pcond_src2_insn_0(xsrc2,src1,pcond,src2) (unsigned int)(0x29000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6))
+#define st240_stwc_xsrc2_src1_pcond_src2_insn_1(xsrc2,src1,pcond,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_stwc_xsrc2_src1_pcond_src2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x29000000)
+#define st240_stwl_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x2ff00000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_stwl_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x2ff00000)
+#define st240_sub_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x00200000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sub_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00200000)
+#define st240_sub_idest_isrc2_src1_insn(idest,isrc2,src1) (unsigned int)(0x08200000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_sub_idest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08200000)
+#define st240_sub_idest_xsrc2_src1_insn_0(idest,xsrc2,src1) (unsigned int)(0x08200000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_sub_idest_xsrc2_src1_insn_1(idest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_sub_idest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08200000)
+#define st240_subf_n_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02280000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_subf_n_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02280000)
+#define st240_subs_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x02300000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_subs_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02300000)
+#define st240_subso_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x03300000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_subso_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03300000)
+#define st240_sxt_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x10a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_sxt_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x10a00000)
+#define st240_sxt_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x18a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_sxt_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18a00000)
+#define st240_sxt_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x18a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_sxt_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_sxt_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18a00000)
+#define is_st240_sync_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x2fe02000)
+#define is_st240_syncins_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x2fe00000)
+#define st240_syscall_brknum_insn(brknum) (unsigned int)(0x2fe0a000 | ((int)(brknum) & 0xfff))
+#define is_st240_syscall_brknum_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x2fe0a000)
+#define is_st240_waitl_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x2fe04000)
+#define is_st240_wmb_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x2fe03000)
+#define st240_xor_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_xor_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01a00000)
+#define st240_xor_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_xor_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09a00000)
+#define st240_xor_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_xor_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_xor_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09a00000)
+#define st240_zxt_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x10c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_zxt_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x10c00000)
+#define st240_zxt_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x18c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_zxt_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18c00000)
+#define st240_zxt_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x18c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_zxt_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_zxt_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18c00000)
+#define st240_bswap_idest_src1_insn(idest,src1) (unsigned int)(0x1a01b000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_bswap_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x1a01b000)
+#define st240_convbi_idest_scond_insn(idest,scond) (unsigned int)(0x1d001000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st240_convbi_idest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1ff03f) == 0x1d001000)
+#define st240_convib_bdest2_src1_insn(bdest2,src1) (unsigned int)(0x07800000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_convib_bdest2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8fc0) == 0x07800000)
+#define st240_cmpge_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x04c00000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpge_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04c00000)
+#define st240_cmpge_bdest2_src2_src1_insn(bdest2,src2,src1) (unsigned int)(0x06c00000 | (((int)(bdest2) & 0x7) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpge_bdest2_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06c00000)
+#define st240_cmpgeu_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x04e00000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpgeu_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04e00000)
+#define st240_cmpgeu_bdest2_src2_src1_insn(bdest2,src2,src1) (unsigned int)(0x06e00000 | (((int)(bdest2) & 0x7) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpgeu_bdest2_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06e00000)
+#define st240_cmpgt_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x05000000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpgt_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05000000)
+#define st240_cmpgt_bdest2_src2_src1_insn(bdest2,src2,src1) (unsigned int)(0x07000000 | (((int)(bdest2) & 0x7) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpgt_bdest2_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07000000)
+#define st240_cmpgtu_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x05200000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpgtu_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05200000)
+#define st240_cmpgtu_bdest2_src2_src1_insn(bdest2,src2,src1) (unsigned int)(0x07200000 | (((int)(bdest2) & 0x7) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpgtu_bdest2_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07200000)
+#define st240_cmplef_n_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x04400000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmplef_n_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04400000)
+#define st240_cmplef_n_bdest2_src2_src1_insn(bdest2,src2,src1) (unsigned int)(0x06400000 | (((int)(bdest2) & 0x7) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmplef_n_bdest2_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06400000)
+#define st240_cmpltf_n_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x04800000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpltf_n_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04800000)
+#define st240_cmpltf_n_bdest2_src2_src1_insn(bdest2,src2,src1) (unsigned int)(0x06800000 | (((int)(bdest2) & 0x7) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpltf_n_bdest2_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06800000)
+#define is_st240_idle_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x31000000)
+#define st240_mfb_idest_scond_insn(idest,scond) (unsigned int)(0x1d001000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st240_mfb_idest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1ff03f) == 0x1d001000)
+#define st240_mov_dest_src2_insn(dest,src2) (unsigned int)(0x00000000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mov_dest_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc003f) == 0x00000000)
+#define st240_mov_idest_isrc2_insn(idest,isrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mov_idest_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe0003f) == 0x08000000)
+#define st240_mov_idest_xsrc2_insn_0(idest,xsrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mov_idest_xsrc2_insn_1(idest,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mov_idest_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe0003f) == 0x08000000)
+#define st240_mtb_bdest2_src1_insn(bdest2,src1) (unsigned int)(0x07800000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_mtb_bdest2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8fc0) == 0x07800000)
+#define st240_mull_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0ac00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mull_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ac00000)
+#define st240_mull_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0ac00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mull_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mull_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ac00000)
+#define is_st240_nop_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x00000000)
+#define st240_slctf_dest_scond_src2_src1_insn(dest,scond,src2,src1) (unsigned int)(0x16040000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_slctf_dest_scond_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x16040000)
+#define st240_sxtb_idest_src1_insn(idest,src1) (unsigned int)(0x18a08000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sxtb_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x18a08000)
+#define st240_sxth_idest_src1_insn(idest,src1) (unsigned int)(0x18a10000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sxth_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x18a10000)
+#define st240_zxtb_idest_src1_insn(idest,src1) (unsigned int)(0x092ff000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_zxtb_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x092ff000)
+#define st240_zxth_idest_src1_insn(idest,src1) (unsigned int)(0x18c10000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_zxth_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x18c10000)
+#define st240_slctf_pb_dest_scond_src2_src1_insn(dest,scond,src2,src1) (unsigned int)(0x16000000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_slctf_pb_dest_scond_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x16000000)
+#define st240_unpacku_pbh_dest_src1_insn(dest,src1) (unsigned int)(0x12040000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_unpacku_pbh_dest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0fc0) == 0x12040000)
+#define st240_unpacku_pbl_dest_src1_insn(dest,src1) (unsigned int)(0x12240000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_unpacku_pbl_dest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0fc0) == 0x12240000)
+#define st240_pack_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13280000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_pack_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13280000)
+
+/*
+ * The following macros are provided for compatibility with old
+ * code.  They should not be used in new code.
+ */
+
+#define LXIMMEXTR(i)   st220_immr_imm_insn(i)
+#define LXIMMEXTL(i)   st220_imml_imm_insn(i)
+#define LXISIMMEXTR(x) is_st220_immr_imm_insn(x)
+#define LXISIMMEXTL(x) is_st220_imml_imm_insn(x)
+#define LXIMMVAL(x)    (int)st200_xsrc2_opd(0,x)
+#define LXSTOP(x)      st200_STOPBIT_fld(x)
+#define LXCLUSTER(x)   (int)(((unsigned int)(x) & 0x40000000) != 0)
+
+enum {
+  Method_st200_ERROR,
+  Immediate_st200_brknum,
+  Immediate_st200_btarg,
+  Immediate_st200_imm,
+  Immediate_st200_isrc2,
+  Immediate_st200_sbrknum,
+  Immediate_st200_xsrc2,
+  RegClass_st200_branch,
+  RegClass_st200_general,
+  RegClass_st200_link,
+  RegClass_st200_nolink,
+  RegClass_st200_nzpaired,
+  RegClass_st200_nzpairedfirst,
+  RegClass_st200_nzpairedsecond,
+  RegClass_st200_paired,
+  RegClass_st200_pairedfirst,
+  RegClass_st200_pairedsecond,
+  RegClass_st200_predicate
+};
+
+/***********************************************/
+/*       DATA TYPES                            */
+/***********************************************/
+
+/*  Operand definition -- used in building     */
+/*  format table                               */
+
+struct lx_operand
+{
+  char *tname;        /* operand type name     */
+  int type;           /* type of operand       */
+  int bits;           /* number of bits        */
+  int shift;          /* amount to shift       */
+  int flags;          /*                       */
+};
+
+typedef struct lx_operand lxbfield;
+
+/* some flags for lx_operand                                 */
+/* lxSIGNED    : is this operand treated as signed ?         */
+/* lxCANEXTEND : can this operand have an extension syllable */
+
+#define lxSIGNED  1
+#define lxCANEXTEND 2
+
+/* Opcode definition.                          */
+
+struct lxopc_s {
+  char     *as_op;                      /* asm name                       */
+  unsigned opcode;                      /* the opcode                     */
+  unsigned mask;                        /* disassembly mask               */
+  int      bundlings;                   /* user specific flags            */
+  int      reservation;                 /* reservation table index        */
+  lxbfield *format[LXMAXOPERANDS + 1];  /* 0 terminated                   */
+                                        /*list of operands                */
+  char     *rclass;                     /* resource class                 */
+  char     *fmtstring;                  /* formating string               */
+};
+typedef struct lxopc_s lxopc_t;
+
+struct lx_core_info_s
+  {
+    const char *name;
+    lxopc_t *optab;
+    const int *resources;
+    int elf_core;
+    int supported;
+  };
+
+typedef struct lx_core_info_s Lx_Core_Info;
+
+typedef int Bundling;
+
+struct bundletype_s
+  {
+    int entries;
+    int bias, base;
+    int nnops;
+    Bundling bundling[LXMAXBUNDLESIZE];
+    int nops[LXMAXBUNDLESIZE];
+  };
+
+typedef struct bundletype_s BundleType;
+
+struct bundlematchtype_s { int entries; int entry[4]; };
+
+typedef struct bundlematchtype_s BundleMatchType;
+
+extern BundleType bundle_types[];
+extern short bundlematch_table_size;
+extern short bundlematch_table[];
+extern BundleMatchType canonical_table[];
+
+extern const int st200_resource_max;
+
+extern const int st200_reservation_table_lines;
+extern const int *st200_reservation_table_table[];
+extern const char *st200_resource_names[];
+
+extern const int st220_resources[];
+extern lxopc_t st220_lxoptab[];
+extern const Lx_Core_Info st220_core_info;
+extern const int st231_resources[];
+extern lxopc_t st231_lxoptab[];
+extern const Lx_Core_Info st231_core_info;
+extern const int st240_resources[];
+extern lxopc_t st240_lxoptab[];
+extern const Lx_Core_Info st240_core_info;
+extern const Lx_Core_Info st210_core_info;
+extern const Lx_Core_Info *st200_core_info_table[];
+
+#endif /* OPCODE_LX_H */
diff -r -N -u binutils-2.21.51/include/secinit.h binutils/include/secinit.h
--- binutils-2.21.51/include/secinit.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils/include/secinit.h	2010-07-14 15:39:20.104113000 +0100
@@ -0,0 +1,65 @@
+typedef enum {
+  secinit_end_of_table_enum = 0x00,
+  secinit_memory_bss_enum   = 0x01,
+  secinit_memory_data_enum  = 0x02,
+  secinit_memory_compress_enum   = 0x03,
+  secinit_invalid_enum      = 0x04
+} secinit_enum_t;
+
+typedef struct _secinit_clear {
+  bfd_vma vma;
+  unsigned int size;
+  unsigned int status;
+} secinit_clear_t;
+
+typedef secinit_clear_t *secinit_clear_ptr;
+
+typedef struct _secinit_copy {
+  bfd_vma vma;
+  bfd_vma lma;
+  unsigned int size;
+  unsigned int status;
+} secinit_copy_t;
+
+typedef secinit_copy_t *secinit_copy_ptr;
+
+#define MAX_NAME_LEN 8
+
+typedef struct _secinit_compress {
+  bfd_vma vma;
+  bfd_vma lma;
+  unsigned int size;
+  unsigned int compressed_size;
+  char algo_name[MAX_NAME_LEN];
+//  int (*algo)(char *vma, char *lma, unsigned int compressed_size, unsigned int size);
+  bfd_vma algo;
+  unsigned int status;
+} secinit_compress_t;
+
+typedef secinit_compress_t *secinit_compress_ptr;
+
+typedef union _secinit_union {
+  secinit_clear_t clear;
+  secinit_copy_t copy;
+  secinit_compress_t compress;
+} secinit_union_t;
+
+typedef struct _secinit {
+  secinit_enum_t type;
+  secinit_union_t u;
+} secinit_t;
+
+typedef secinit_t *secinit_ptr;
+
+bfd_boolean
+elf_lx_get_secinit_table ( bfd *abfd, secinit_ptr *secinit_table, unsigned int *secinit_table_entry_nb);
+
+bfd_boolean
+elf_lx_set_secinit_table ( bfd *abfd, secinit_ptr secinit_table, int secinit_table_entry_nb);
+
+void
+elf_lx_dump_secinit_table(bfd *abfd, FILE *writer);
+
+extern bfd_boolean
+elf_lx_secinit_compress_or_decompress(bfd *abfd, bfd_boolean compress, char *library_name);
+
diff -r -N -u binutils-2.21.51/include/ST_version.h binutils/include/ST_version.h
--- binutils-2.21.51/include/ST_version.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils/include/ST_version.h	2011-11-08 16:38:07.068934000 +0000
@@ -0,0 +1,6 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2010
+*/
+
+#define ST_BINUTILS_VERSION "7.03"
+#define ST_BINUTILS_VERSION_DATE "20111108"
diff -r -N -u binutils-2.21.51/intl/plural.c binutils/intl/plural.c
--- binutils-2.21.51/intl/plural.c	2007-09-24 11:42:14.000000000 +0100
+++ binutils/intl/plural.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1518 +0,0 @@
-/* A Bison parser, made from plural.y
-   by GNU bison 1.35.  */
-
-#define YYBISON 1  /* Identify Bison output.  */
-
-#define yyparse __gettextparse
-#define yylex __gettextlex
-#define yyerror __gettexterror
-#define yylval __gettextlval
-#define yychar __gettextchar
-#define yydebug __gettextdebug
-#define yynerrs __gettextnerrs
-# define	EQUOP2	257
-# define	CMPOP2	258
-# define	ADDOP2	259
-# define	MULOP2	260
-# define	NUMBER	261
-
-#line 1 "plural.y"
-
-/* Expression parsing for plural form selection.
-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
-   Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
-
-   This program is free software; you can redistribute it and/or modify it
-   under the terms of the GNU Library General Public License as published
-   by the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public
-   License along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,
-   USA.  */
-
-/* The bison generated parser uses alloca.  AIX 3 forces us to put this
-   declaration at the beginning of the file.  The declaration in bison's
-   skeleton file comes too late.  This must come before <config.h>
-   because <config.h> may include arbitrary system headers.  */
-#if defined _AIX && !defined __GNUC__
- #pragma alloca
-#endif
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#include <stddef.h>
-#include <stdlib.h>
-#include "plural-exp.h"
-
-/* The main function generated by the parser is called __gettextparse,
-   but we want it to be called PLURAL_PARSE.  */
-#ifndef _LIBC
-# define __gettextparse PLURAL_PARSE
-#endif
-
-#define YYLEX_PARAM	&((struct parse_args *) arg)->cp
-#define YYPARSE_PARAM	arg
-
-#line 49 "plural.y"
-#ifndef YYSTYPE
-typedef union {
-  unsigned long int num;
-  enum operator op;
-  struct expression *exp;
-} yystype;
-# define YYSTYPE yystype
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-#line 55 "plural.y"
-
-/* Prototypes for local functions.  */
-static struct expression *new_exp PARAMS ((int nargs, enum operator op,
-					   struct expression * const *args));
-static inline struct expression *new_exp_0 PARAMS ((enum operator op));
-static inline struct expression *new_exp_1 PARAMS ((enum operator op,
-						   struct expression *right));
-static struct expression *new_exp_2 PARAMS ((enum operator op,
-					     struct expression *left,
-					     struct expression *right));
-static inline struct expression *new_exp_3 PARAMS ((enum operator op,
-						   struct expression *bexp,
-						   struct expression *tbranch,
-						   struct expression *fbranch));
-static int yylex PARAMS ((YYSTYPE *lval, const char **pexp));
-static void yyerror PARAMS ((const char *str));
-
-/* Allocation of expressions.  */
-
-static struct expression *
-new_exp (nargs, op, args)
-     int nargs;
-     enum operator op;
-     struct expression * const *args;
-{
-  int i;
-  struct expression *newp;
-
-  /* If any of the argument could not be malloc'ed, just return NULL.  */
-  for (i = nargs - 1; i >= 0; i--)
-    if (args[i] == NULL)
-      goto fail;
-
-  /* Allocate a new expression.  */
-  newp = (struct expression *) malloc (sizeof (*newp));
-  if (newp != NULL)
-    {
-      newp->nargs = nargs;
-      newp->operation = op;
-      for (i = nargs - 1; i >= 0; i--)
-	newp->val.args[i] = args[i];
-      return newp;
-    }
-
- fail:
-  for (i = nargs - 1; i >= 0; i--)
-    FREE_EXPRESSION (args[i]);
-
-  return NULL;
-}
-
-static inline struct expression *
-new_exp_0 (op)
-     enum operator op;
-{
-  return new_exp (0, op, NULL);
-}
-
-static inline struct expression *
-new_exp_1 (op, right)
-     enum operator op;
-     struct expression *right;
-{
-  struct expression *args[1];
-
-  args[0] = right;
-  return new_exp (1, op, args);
-}
-
-static struct expression *
-new_exp_2 (op, left, right)
-     enum operator op;
-     struct expression *left;
-     struct expression *right;
-{
-  struct expression *args[2];
-
-  args[0] = left;
-  args[1] = right;
-  return new_exp (2, op, args);
-}
-
-static inline struct expression *
-new_exp_3 (op, bexp, tbranch, fbranch)
-     enum operator op;
-     struct expression *bexp;
-     struct expression *tbranch;
-     struct expression *fbranch;
-{
-  struct expression *args[3];
-
-  args[0] = bexp;
-  args[1] = tbranch;
-  args[2] = fbranch;
-  return new_exp (3, op, args);
-}
-
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-
-
-#define	YYFINAL		27
-#define	YYFLAG		-32768
-#define	YYNTBASE	16
-
-/* YYTRANSLATE(YYLEX) -- Bison token number corresponding to YYLEX. */
-#define YYTRANSLATE(x) ((unsigned)(x) <= 261 ? yytranslate[x] : 18)
-
-/* YYTRANSLATE[YYLEX] -- Bison token number corresponding to YYLEX. */
-static const char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,    10,     2,     2,     2,     2,     5,     2,
-      14,    15,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,    12,     2,
-       2,     2,     2,     3,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-      13,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     4,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     6,     7,     8,
-       9,    11
-};
-
-#if YYDEBUG
-static const short yyprhs[] =
-{
-       0,     0,     2,     8,    12,    16,    20,    24,    28,    32,
-      35,    37,    39
-};
-static const short yyrhs[] =
-{
-      17,     0,    17,     3,    17,    12,    17,     0,    17,     4,
-      17,     0,    17,     5,    17,     0,    17,     6,    17,     0,
-      17,     7,    17,     0,    17,     8,    17,     0,    17,     9,
-      17,     0,    10,    17,     0,    13,     0,    11,     0,    14,
-      17,    15,     0
-};
-
-#endif
-
-#if YYDEBUG
-/* YYRLINE[YYN] -- source line where rule number YYN was defined. */
-static const short yyrline[] =
-{
-       0,   174,   182,   186,   190,   194,   198,   202,   206,   210,
-     214,   218,   223
-};
-#endif
-
-
-#if (YYDEBUG) || defined YYERROR_VERBOSE
-
-/* YYTNAME[TOKEN_NUM] -- String name of the token TOKEN_NUM. */
-static const char *const yytname[] =
-{
-  "$", "error", "$undefined.", "'?'", "'|'", "'&'", "EQUOP2", "CMPOP2", 
-  "ADDOP2", "MULOP2", "'!'", "NUMBER", "':'", "'n'", "'('", "')'", 
-  "start", "exp", 0
-};
-#endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives. */
-static const short yyr1[] =
-{
-       0,    16,    17,    17,    17,    17,    17,    17,    17,    17,
-      17,    17,    17
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN. */
-static const short yyr2[] =
-{
-       0,     1,     5,     3,     3,     3,     3,     3,     3,     2,
-       1,     1,     3
-};
-
-/* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
-   doesn't specify something else to do.  Zero means the default is an
-   error. */
-static const short yydefact[] =
-{
-       0,     0,    11,    10,     0,     1,     9,     0,     0,     0,
-       0,     0,     0,     0,     0,    12,     0,     3,     4,     5,
-       6,     7,     8,     0,     2,     0,     0,     0
-};
-
-static const short yydefgoto[] =
-{
-      25,     5
-};
-
-static const short yypact[] =
-{
-      -9,    -9,-32768,-32768,    -9,    34,-32768,    11,    -9,    -9,
-      -9,    -9,    -9,    -9,    -9,-32768,    24,    39,    43,    16,
-      26,    -3,-32768,    -9,    34,    21,    53,-32768
-};
-
-static const short yypgoto[] =
-{
-  -32768,    -1
-};
-
-
-#define	YYLAST		53
-
-
-static const short yytable[] =
-{
-       6,     1,     2,     7,     3,     4,    14,    16,    17,    18,
-      19,    20,    21,    22,     8,     9,    10,    11,    12,    13,
-      14,    26,    24,    12,    13,    14,    15,     8,     9,    10,
-      11,    12,    13,    14,    13,    14,    23,     8,     9,    10,
-      11,    12,    13,    14,    10,    11,    12,    13,    14,    11,
-      12,    13,    14,    27
-};
-
-static const short yycheck[] =
-{
-       1,    10,    11,     4,    13,    14,     9,     8,     9,    10,
-      11,    12,    13,    14,     3,     4,     5,     6,     7,     8,
-       9,     0,    23,     7,     8,     9,    15,     3,     4,     5,
-       6,     7,     8,     9,     8,     9,    12,     3,     4,     5,
-       6,     7,     8,     9,     5,     6,     7,     8,     9,     6,
-       7,     8,     9,     0
-};
-#define YYPURE 1
-
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/local/share/bison/bison.simple"
-
-/* Skeleton output parser for bison,
-
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software
-   Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* This is the parser code that is written into each bison parser when
-   the %semantic_parser declaration is not specified in the grammar.
-   It was written by Richard Stallman by simplifying the hairy parser
-   used when %semantic_parser is specified.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-#if ! defined (yyoverflow) || defined (YYERROR_VERBOSE)
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# if YYSTACK_USE_ALLOCA
-#  define YYSTACK_ALLOC alloca
-# else
-#  ifndef YYSTACK_USE_ALLOCA
-#   if defined (alloca) || defined (_ALLOCA_H)
-#    define YYSTACK_ALLOC alloca
-#   else
-#    ifdef __GNUC__
-#     define YYSTACK_ALLOC __builtin_alloca
-#    endif
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
-#  endif
-#  define YYSTACK_ALLOC malloc
-#  define YYSTACK_FREE free
-# endif
-#endif /* ! defined (yyoverflow) || defined (YYERROR_VERBOSE) */
-
-
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (YYLTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  short yyss;
-  YYSTYPE yyvs;
-# if YYLSP_NEEDED
-  YYLTYPE yyls;
-# endif
-};
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAX (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# if YYLSP_NEEDED
-#  define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE) + sizeof (YYLTYPE))	\
-      + 2 * YYSTACK_GAP_MAX)
-# else
-#  define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAX)
-# endif
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  register YYSIZE_T yyi;		\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (0)
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAX;	\
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (0)
-
-#endif
-
-
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
-#define YYEOF		0
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
-#define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-#define YYFAIL		goto yyerrlab
-#define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");			\
-      YYERROR;							\
-    }								\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).
-
-   When YYLLOC_DEFAULT is run, CURRENT is set the location of the
-   first token.  By default, to implement support for ranges, extend
-   its range to the last symbol.  */
-
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)       	\
-   Current.last_line   = Rhs[N].last_line;	\
-   Current.last_column = Rhs[N].last_column;
-#endif
-
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#if YYPURE
-# if YYLSP_NEEDED
-#  ifdef YYLEX_PARAM
-#   define YYLEX		yylex (&yylval, &yylloc, YYLEX_PARAM)
-#  else
-#   define YYLEX		yylex (&yylval, &yylloc)
-#  endif
-# else /* !YYLSP_NEEDED */
-#  ifdef YYLEX_PARAM
-#   define YYLEX		yylex (&yylval, YYLEX_PARAM)
-#  else
-#   define YYLEX		yylex (&yylval)
-#  endif
-# endif /* !YYLSP_NEEDED */
-#else /* !YYPURE */
-# define YYLEX			yylex ()
-#endif /* !YYPURE */
-
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (0)
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-#endif /* !YYDEBUG */
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#if YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-#ifdef YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
-yystrlen (const char *yystr)
-#   else
-yystrlen (yystr)
-     const char *yystr;
-#   endif
-{
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
-    continue;
-
-  return yys - yystr - 1;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-#   if defined (__STDC__) || defined (__cplusplus)
-yystpcpy (char *yydest, const char *yysrc)
-#   else
-yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
-{
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-#endif
-
-#line 315 "/usr/local/share/bison/bison.simple"
-
-
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-#  define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#  define YYPARSE_PARAM_DECL
-# else
-#  define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#  define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-# endif
-#else /* !YYPARSE_PARAM */
-# define YYPARSE_PARAM_ARG
-# define YYPARSE_PARAM_DECL
-#endif /* !YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-# ifdef YYPARSE_PARAM
-int yyparse (void *);
-# else
-int yyparse (void);
-# endif
-#endif
-
-/* YY_DECL_VARIABLES -- depending whether we use a pure parser,
-   variables are global, or local to YYPARSE.  */
-
-#define YY_DECL_NON_LSP_VARIABLES			\
-/* The lookahead symbol.  */				\
-int yychar;						\
-							\
-/* The semantic value of the lookahead symbol. */	\
-YYSTYPE yylval;						\
-							\
-/* Number of parse errors so far.  */			\
-int yynerrs;
-
-#if YYLSP_NEEDED
-# define YY_DECL_VARIABLES			\
-YY_DECL_NON_LSP_VARIABLES			\
-						\
-/* Location data for the lookahead symbol.  */	\
-YYLTYPE yylloc;
-#else
-# define YY_DECL_VARIABLES			\
-YY_DECL_NON_LSP_VARIABLES
-#endif
-
-
-/* If nonreentrant, generate the variables here. */
-
-#if !YYPURE
-YY_DECL_VARIABLES
-#endif  /* !YYPURE */
-
-int
-yyparse (YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
-{
-  /* If reentrant, generate the variables here. */
-#if YYPURE
-  YY_DECL_VARIABLES
-#endif  /* !YYPURE */
-
-  register int yystate;
-  register int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yychar1 = 0;
-
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack. */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
-
-#if YYLSP_NEEDED
-  /* The location stack.  */
-  YYLTYPE yylsa[YYINITDEPTH];
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
-#endif
-
-#if YYLSP_NEEDED
-# define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
-# define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
-
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-#if YYLSP_NEEDED
-  YYLTYPE yyloc;
-#endif
-
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule. */
-  int yylen;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss;
-  yyvsp = yyvs;
-#if YYLSP_NEEDED
-  yylsp = yyls;
-#endif
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-	/* Give user a chance to reallocate the stack. Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  */
-# if YYLSP_NEEDED
-	YYLTYPE *yyls1 = yyls;
-	/* This used to be a conditional around just the two extra args,
-	   but that might be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-		    &yyls1, yysize * sizeof (*yylsp),
-		    &yystacksize);
-	yyls = yyls1;
-# else
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-		    &yystacksize);
-# endif
-	yyss = yyss1;
-	yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
-# else
-      /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	goto yyoverflowlab;
-      yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
-	yystacksize = YYMAXDEPTH;
-
-      {
-	short *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyoverflowlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-# if YYLSP_NEEDED
-	YYSTACK_RELOCATE (yyls);
-# endif
-# undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-#if YYLSP_NEEDED
-      yylsp = yyls + yysize - 1;
-#endif
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyssp >= yyss + yystacksize - 1)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
-    {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yychar1 = YYTRANSLATE (yychar);
-
-#if YYDEBUG
-     /* We have to keep this `#if YYDEBUG', since we use variables
-	which are defined only if `YYDEBUG' is set.  */
-      if (yydebug)
-	{
-	  YYFPRINTF (stderr, "Next token is %d (%s",
-		     yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise
-	     meaning of a token, for further debugging info.  */
-# ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-# endif
-	  YYFPRINTF (stderr, ")\n");
-	}
-#endif
-    }
-
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
-    goto yydefault;
-
-  yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrlab;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %d (%s), ",
-	      yychar, yytname[yychar1]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-#if YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to the semantic value of
-     the lookahead token.  This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-#if YYLSP_NEEDED
-  /* Similarly for the default location.  Let the user run additional
-     commands if for instance locations are ranges.  */
-  yyloc = yylsp[1-yylen];
-  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
-#endif
-
-#if YYDEBUG
-  /* We have to keep this `#if YYDEBUG', since we use variables which
-     are defined only if `YYDEBUG' is set.  */
-  if (yydebug)
-    {
-      int yyi;
-
-      YYFPRINTF (stderr, "Reducing via rule %d (line %d), ",
-		 yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (yyi = yyprhs[yyn]; yyrhs[yyi] > 0; yyi++)
-	YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
-      YYFPRINTF (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
-
-  switch (yyn) {
-
-case 1:
-#line 175 "plural.y"
-{
-	    if (yyvsp[0].exp == NULL)
-	      YYABORT;
-	    ((struct parse_args *) arg)->res = yyvsp[0].exp;
-	  }
-    break;
-case 2:
-#line 183 "plural.y"
-{
-	    yyval.exp = new_exp_3 (qmop, yyvsp[-4].exp, yyvsp[-2].exp, yyvsp[0].exp);
-	  }
-    break;
-case 3:
-#line 187 "plural.y"
-{
-	    yyval.exp = new_exp_2 (lor, yyvsp[-2].exp, yyvsp[0].exp);
-	  }
-    break;
-case 4:
-#line 191 "plural.y"
-{
-	    yyval.exp = new_exp_2 (land, yyvsp[-2].exp, yyvsp[0].exp);
-	  }
-    break;
-case 5:
-#line 195 "plural.y"
-{
-	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
-	  }
-    break;
-case 6:
-#line 199 "plural.y"
-{
-	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
-	  }
-    break;
-case 7:
-#line 203 "plural.y"
-{
-	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
-	  }
-    break;
-case 8:
-#line 207 "plural.y"
-{
-	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
-	  }
-    break;
-case 9:
-#line 211 "plural.y"
-{
-	    yyval.exp = new_exp_1 (lnot, yyvsp[0].exp);
-	  }
-    break;
-case 10:
-#line 215 "plural.y"
-{
-	    yyval.exp = new_exp_0 (var);
-	  }
-    break;
-case 11:
-#line 219 "plural.y"
-{
-	    if ((yyval.exp = new_exp_0 (num)) != NULL)
-	      yyval.exp->val.num = yyvsp[0].num;
-	  }
-    break;
-case 12:
-#line 224 "plural.y"
-{
-	    yyval.exp = yyvsp[-1].exp;
-	  }
-    break;
-}
-
-#line 705 "/usr/local/share/bison/bison.simple"
-
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#if YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
-
-#if YYDEBUG
-  if (yydebug)
-    {
-      short *yyssp1 = yyss - 1;
-      YYFPRINTF (stderr, "state stack now");
-      while (yyssp1 != yyssp)
-	YYFPRINTF (stderr, " %d", *++yyssp1);
-      YYFPRINTF (stderr, "\n");
-    }
-#endif
-
-  *++yyvsp = yyval;
-#if YYLSP_NEEDED
-  *++yylsp = yyloc;
-#endif
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTBASE];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  char *yymsg;
-	  int yyx, yycount;
-
-	  yycount = 0;
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  for (yyx = yyn < 0 ? -yyn : 0;
-	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
-	    if (yycheck[yyx + yyn] == yyx)
-	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
-	  yysize += yystrlen ("parse error, unexpected ") + 1;
-	  yysize += yystrlen (yytname[YYTRANSLATE (yychar)]);
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "parse error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[YYTRANSLATE (yychar)]);
-
-	      if (yycount < 5)
-		{
-		  yycount = 0;
-		  for (yyx = yyn < 0 ? -yyn : 0;
-		       yyx < (int) (sizeof (yytname) / sizeof (char *));
-		       yyx++)
-		    if (yycheck[yyx + yyn] == yyx)
-		      {
-			const char *yyq = ! yycount ? ", expecting " : " or ";
-			yyp = yystpcpy (yyp, yyq);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yycount++;
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exhausted");
-	}
-      else
-#endif /* defined (YYERROR_VERBOSE) */
-	yyerror ("parse error");
-    }
-  goto yyerrlab1;
-
-
-/*--------------------------------------------------.
-| yyerrlab1 -- error raised explicitly by an action |
-`--------------------------------------------------*/
-yyerrlab1:
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-	 error, discard it.  */
-
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
-      YYDPRINTF ((stderr, "Discarding token %d (%s).\n",
-		  yychar, yytname[yychar1]));
-      yychar = YYEMPTY;
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
-
-  goto yyerrhandle;
-
-
-/*-------------------------------------------------------------------.
-| yyerrdefault -- current state does not do anything special for the |
-| error token.                                                       |
-`-------------------------------------------------------------------*/
-yyerrdefault:
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-
-  /* If its default is to accept any token, ok.  Otherwise pop it.  */
-  yyn = yydefact[yystate];
-  if (yyn)
-    goto yydefault;
-#endif
-
-
-/*---------------------------------------------------------------.
-| yyerrpop -- pop the current state because it cannot handle the |
-| error token                                                    |
-`---------------------------------------------------------------*/
-yyerrpop:
-  if (yyssp == yyss)
-    YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#if YYLSP_NEEDED
-  yylsp--;
-#endif
-
-#if YYDEBUG
-  if (yydebug)
-    {
-      short *yyssp1 = yyss - 1;
-      YYFPRINTF (stderr, "Error: state stack now");
-      while (yyssp1 != yyssp)
-	YYFPRINTF (stderr, " %d", *++yyssp1);
-      YYFPRINTF (stderr, "\n");
-    }
-#endif
-
-/*--------------.
-| yyerrhandle.  |
-`--------------*/
-yyerrhandle:
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
-
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
-
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrpop;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
-  *++yyvsp = yylval;
-#if YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-/*---------------------------------------------.
-| yyoverflowab -- parser overflow comes here.  |
-`---------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
-  yyresult = 2;
-  /* Fall through.  */
-
-yyreturn:
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-  return yyresult;
-}
-#line 229 "plural.y"
-
-
-void
-internal_function
-FREE_EXPRESSION (exp)
-     struct expression *exp;
-{
-  if (exp == NULL)
-    return;
-
-  /* Handle the recursive case.  */
-  switch (exp->nargs)
-    {
-    case 3:
-      FREE_EXPRESSION (exp->val.args[2]);
-      /* FALLTHROUGH */
-    case 2:
-      FREE_EXPRESSION (exp->val.args[1]);
-      /* FALLTHROUGH */
-    case 1:
-      FREE_EXPRESSION (exp->val.args[0]);
-      /* FALLTHROUGH */
-    default:
-      break;
-    }
-
-  free (exp);
-}
-
-
-static int
-yylex (lval, pexp)
-     YYSTYPE *lval;
-     const char **pexp;
-{
-  const char *exp = *pexp;
-  int result;
-
-  while (1)
-    {
-      if (exp[0] == '\0')
-	{
-	  *pexp = exp;
-	  return YYEOF;
-	}
-
-      if (exp[0] != ' ' && exp[0] != '\t')
-	break;
-
-      ++exp;
-    }
-
-  result = *exp++;
-  switch (result)
-    {
-    case '0': case '1': case '2': case '3': case '4':
-    case '5': case '6': case '7': case '8': case '9':
-      {
-	unsigned long int n = result - '0';
-	while (exp[0] >= '0' && exp[0] <= '9')
-	  {
-	    n *= 10;
-	    n += exp[0] - '0';
-	    ++exp;
-	  }
-	lval->num = n;
-	result = NUMBER;
-      }
-      break;
-
-    case '=':
-      if (exp[0] == '=')
-	{
-	  ++exp;
-	  lval->op = equal;
-	  result = EQUOP2;
-	}
-      else
-	result = YYERRCODE;
-      break;
-
-    case '!':
-      if (exp[0] == '=')
-	{
-	  ++exp;
-	  lval->op = not_equal;
-	  result = EQUOP2;
-	}
-      break;
-
-    case '&':
-    case '|':
-      if (exp[0] == result)
-	++exp;
-      else
-	result = YYERRCODE;
-      break;
-
-    case '<':
-      if (exp[0] == '=')
-	{
-	  ++exp;
-	  lval->op = less_or_equal;
-	}
-      else
-	lval->op = less_than;
-      result = CMPOP2;
-      break;
-
-    case '>':
-      if (exp[0] == '=')
-	{
-	  ++exp;
-	  lval->op = greater_or_equal;
-	}
-      else
-	lval->op = greater_than;
-      result = CMPOP2;
-      break;
-
-    case '*':
-      lval->op = mult;
-      result = MULOP2;
-      break;
-
-    case '/':
-      lval->op = divide;
-      result = MULOP2;
-      break;
-
-    case '%':
-      lval->op = module;
-      result = MULOP2;
-      break;
-
-    case '+':
-      lval->op = plus;
-      result = ADDOP2;
-      break;
-
-    case '-':
-      lval->op = minus;
-      result = ADDOP2;
-      break;
-
-    case 'n':
-    case '?':
-    case ':':
-    case '(':
-    case ')':
-      /* Nothing, just return the character.  */
-      break;
-
-    case ';':
-    case '\n':
-    case '\0':
-      /* Be safe and let the user call this function again.  */
-      --exp;
-      result = YYEOF;
-      break;
-
-    default:
-      result = YYERRCODE;
-#if YYDEBUG != 0
-      --exp;
-#endif
-      break;
-    }
-
-  *pexp = exp;
-
-  return result;
-}
-
-
-static void
-yyerror (str)
-     const char *str;
-{
-  /* Do nothing.  We don't print error messages here.  */
-}
diff -r -N -u binutils-2.21.51/ld/config.in binutils/ld/config.in
--- binutils-2.21.51/ld/config.in	2011-04-13 08:41:36.000000000 +0100
+++ binutils/ld/config.in	2011-07-06 12:44:26.137253000 +0100
@@ -142,6 +142,9 @@
    */
 #undef LT_OBJDIR
 
+/* secinfo support disabled */
+#undef NO_SECINFO_SUPPORT
+
 /* Name of package */
 #undef PACKAGE
 
diff -r -N -u binutils-2.21.51/ld/configure binutils/ld/configure
--- binutils-2.21.51/ld/configure	2011-04-13 08:41:36.000000000 +0100
+++ binutils/ld/configure	2011-07-06 12:44:26.137253000 +0100
@@ -656,6 +656,7 @@
 FGREP
 SED
 LIBTOOL
+SIM
 am__fastdepCXX_FALSE
 am__fastdepCXX_TRUE
 CXXDEPMODE
@@ -773,6 +774,7 @@
 enable_targets
 enable_64_bit_bfd
 with_sysroot
+enable_secinfo
 enable_gold
 enable_got
 enable_werror
@@ -1427,6 +1429,7 @@
 			  (and sometimes confusing) to the casual installer
   --enable-targets        alternative target configurations
   --enable-64-bit-bfd     64-bit support (on hosts with narrower word sizes)
+  --enable-secinfo        include secinfo support (default is yes)
   --enable-gold[=ARG]     build gold [ARG={default,yes,no}]
   --enable-got=<type>     GOT handling scheme (target, single, negative,
                           multigot)
@@ -4311,6 +4314,15 @@
 
 fi
 
+# Check whether --enable-secinfo was given.
+if test "${enable_secinfo+set}" = set; then :
+  enableval=$enable_secinfo; case "${enableval}" in
+  no)
+$as_echo "#define NO_SECINFO_SUPPORT 1" >>confdefs.h
+ ;;
+  *) ;;
+esac
+fi
 
 
 
diff -r -N -u binutils-2.21.51/ld/configure.in binutils/ld/configure.in
--- binutils-2.21.51/ld/configure.in	2011-04-13 08:41:36.000000000 +0100
+++ binutils/ld/configure.in	2011-07-06 12:44:26.137253000 +0100
@@ -66,6 +66,13 @@
  TARGET_SYSTEM_ROOT=
  TARGET_SYSTEM_ROOT_DEFINE='-DTARGET_SYSTEM_ROOT=\"\"'
 ])
+AC_ARG_ENABLE(secinfo,
+[AS_HELP_STRING([--enable-secinfo],[include secinfo support (default is yes)])],
+[case "${enableval}" in
+  no) AC_DEFINE([NO_SECINFO_SUPPORT], [1], [secinfo support disabled]) ;;
+  *) ;;
+esac])
+
 AC_SUBST(use_sysroot)
 AC_SUBST(TARGET_SYSTEM_ROOT)
 AC_SUBST(TARGET_SYSTEM_ROOT_DEFINE)
@@ -138,6 +145,8 @@
 ACX_LARGEFILE
 AC_PROG_INSTALL
 
+AC_SUBST(SIM)
+
 LT_INIT
 
 ALL_LINGUAS="fr sv tr es da vi zh_CN zh_TW ga fi id bg"
diff -r -N -u binutils-2.21.51/ld/configure.tgt binutils/ld/configure.tgt
--- binutils-2.21.51/ld/configure.tgt	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/configure.tgt	2011-07-06 12:44:26.137253000 +0100
@@ -574,6 +574,9 @@
 sh64-*-elf*)		targ_emul=shelf
 			targ_extra_emuls="shlelf shelf32 shlelf32 shelf64 shlelf64"
 			targ_extra_libpath=$targ_extra_emuls ;;
+lx*-*-*elf*)            targ_emul=elf32_lx;;
+lx*-*-linux-gnu*)       targ_emul=elf32_lx_linux;;
+st2[2-4][0-9]-*-linux-gnu*)       targ_emul=elf32_lx_linux;;
 sparc64-*-aout*)	targ_emul=sparcaout ;;
 sparc64-*-elf*)		targ_emul=elf64_sparc ;;
 sparc64-*-rtems*)	targ_emul=elf64_sparc ;;
diff -r -N -u binutils-2.21.51/ld/deffilep.c binutils/ld/deffilep.c
--- binutils-2.21.51/ld/deffilep.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/deffilep.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2934 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     NAME = 258,
-     LIBRARY = 259,
-     DESCRIPTION = 260,
-     STACKSIZE_K = 261,
-     HEAPSIZE = 262,
-     CODE = 263,
-     DATAU = 264,
-     DATAL = 265,
-     SECTIONS = 266,
-     EXPORTS = 267,
-     IMPORTS = 268,
-     VERSIONK = 269,
-     BASE = 270,
-     CONSTANTU = 271,
-     CONSTANTL = 272,
-     PRIVATEU = 273,
-     PRIVATEL = 274,
-     ALIGNCOMM = 275,
-     READ = 276,
-     WRITE = 277,
-     EXECUTE = 278,
-     SHARED = 279,
-     NONAMEU = 280,
-     NONAMEL = 281,
-     DIRECTIVE = 282,
-     EQUAL = 283,
-     ID = 284,
-     DIGITS = 285
-   };
-#endif
-#define NAME 258
-#define LIBRARY 259
-#define DESCRIPTION 260
-#define STACKSIZE_K 261
-#define HEAPSIZE 262
-#define CODE 263
-#define DATAU 264
-#define DATAL 265
-#define SECTIONS 266
-#define EXPORTS 267
-#define IMPORTS 268
-#define VERSIONK 269
-#define BASE 270
-#define CONSTANTU 271
-#define CONSTANTL 272
-#define PRIVATEU 273
-#define PRIVATEL 274
-#define ALIGNCOMM 275
-#define READ 276
-#define WRITE 277
-#define EXECUTE 278
-#define SHARED 279
-#define NONAMEU 280
-#define NONAMEL 281
-#define DIRECTIVE 282
-#define EQUAL 283
-#define ID 284
-#define DIGITS 285
-
-
-
-
-/* Copy the first part of user declarations.  */
-#line 1 "deffilep.y"
- /* deffilep.y - parser for .def files */
-
-/*   Copyright 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006,
-     2007, 2009 Free Software Foundation, Inc.
-
-     This file is part of GNU Binutils.
-
-     This program is free software; you can redistribute it and/or modify
-     it under the terms of the GNU General Public License as published by
-     the Free Software Foundation; either version 3 of the License, or
-     (at your option) any later version.
-
-     This program is distributed in the hope that it will be useful,
-     but WITHOUT ANY WARRANTY; without even the implied warranty of
-     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-     GNU General Public License for more details.
-
-     You should have received a copy of the GNU General Public License
-     along with this program; if not, write to the Free Software
-     Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-     MA 02110-1301, USA.  */
-
-#include "sysdep.h"
-#include "libiberty.h"
-#include "safe-ctype.h"
-#include "bfd.h"
-#include "ld.h"
-#include "ldmisc.h"
-#include "deffile.h"
-
-#define TRACE 0
-
-#define ROUND_UP(a, b) (((a)+((b)-1))&~((b)-1))
-
-/* Remap normal yacc parser interface names (yyparse, yylex, yyerror, etc),
-   as well as gratuitiously global symbol names, so we can have multiple
-   yacc generated parsers in ld.  Note that these are only the variables
-   produced by yacc.  If other parser generators (bison, byacc, etc) produce
-   additional global names that conflict at link time, then those parser
-   generators need to be fixed instead of adding those names to this list.  */
-
-#define	yymaxdepth def_maxdepth
-#define	yyparse	def_parse
-#define	yylex	def_lex
-#define	yyerror	def_error
-#define	yylval	def_lval
-#define	yychar	def_char
-#define	yydebug	def_debug
-#define	yypact	def_pact	
-#define	yyr1	def_r1			
-#define	yyr2	def_r2			
-#define	yydef	def_def		
-#define	yychk	def_chk		
-#define	yypgo	def_pgo		
-#define	yyact	def_act		
-#define	yyexca	def_exca
-#define yyerrflag def_errflag
-#define yynerrs	def_nerrs
-#define	yyps	def_ps
-#define	yypv	def_pv
-#define	yys	def_s
-#define	yy_yys	def_yys
-#define	yystate	def_state
-#define	yytmp	def_tmp
-#define	yyv	def_v
-#define	yy_yyv	def_yyv
-#define	yyval	def_val
-#define	yylloc	def_lloc
-#define yyreds	def_reds		/* With YYDEBUG defined.  */
-#define yytoks	def_toks		/* With YYDEBUG defined.  */
-#define yylhs	def_yylhs
-#define yylen	def_yylen
-#define yydefred def_yydefred
-#define yydgoto	def_yydgoto
-#define yysindex def_yysindex
-#define yyrindex def_yyrindex
-#define yygindex def_yygindex
-#define yytable	 def_yytable
-#define yycheck	 def_yycheck
-
-typedef struct def_pool_str {
-  struct def_pool_str *next;
-  char data[1];
-} def_pool_str;
-
-static def_pool_str *pool_strs = NULL;
-
-static char *def_pool_alloc (size_t sz);
-static char *def_pool_strdup (const char *str);
-static void def_pool_free (void);
-
-static void def_description (const char *);
-static void def_exports (const char *, const char *, int, int, const char *);
-static void def_heapsize (int, int);
-static void def_import (const char *, const char *, const char *, const char *,
-			int, const char *);
-static void def_image_name (const char *, int, int);
-static void def_section (const char *, int);
-static void def_section_alt (const char *, const char *);
-static void def_stacksize (int, int);
-static void def_version (int, int);
-static void def_directive (char *);
-static void def_aligncomm (char *str, int align);
-static int def_parse (void);
-static int def_error (const char *);
-static int def_lex (void);
-
-static int lex_forced_token = 0;
-static const char *lex_parse_string = 0;
-static const char *lex_parse_string_end = 0;
-
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 114 "deffilep.y"
-typedef union YYSTYPE {
-  char *id;
-  int number;
-  char *digits;
-} YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 255 "deffilep.c"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 214 of yacc.c.  */
-#line 267 "deffilep.c"
-
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
-
-# ifndef YYFREE
-#  define YYFREE free
-# endif
-# ifndef YYMALLOC
-#  define YYMALLOC malloc
-# endif
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
-#  endif
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-# endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
-
-
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  short yyss;
-  YYSTYPE yyvs;
-  };
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAXIMUM)
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  register YYSIZE_T yyi;		\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (0)
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (0)
-
-#endif
-
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
-#define YYFINAL  47
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   126
-
-/* YYNTOKENS -- Number of terminals. */
-#define YYNTOKENS  35
-/* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  25
-/* YYNRULES -- Number of rules. */
-#define YYNRULES  76
-/* YYNRULES -- Number of states. */
-#define YYNSTATES  123
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   285
-
-#define YYTRANSLATE(YYX) 						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,    32,     2,    31,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,    33,     2,     2,    34,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const unsigned char yyprhs[] =
-{
-       0,     0,     3,     6,     8,    12,    16,    19,    23,    27,
-      30,    33,    36,    39,    42,    45,    50,    53,    58,    59,
-      61,    64,    72,    76,    77,    79,    81,    83,    85,    87,
-      89,    91,    93,    96,    98,   107,   116,   123,   130,   137,
-     142,   145,   147,   150,   153,   157,   159,   161,   162,   165,
-     166,   168,   170,   172,   174,   176,   179,   183,   184,   187,
-     188,   191,   192,   195,   196,   200,   201,   203,   206,   210,
-     212,   215,   220,   222,   223,   225,   226
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
-{
-      36,     0,    -1,    36,    37,    -1,    37,    -1,     3,    50,
-      54,    -1,     4,    50,    54,    -1,     5,    29,    -1,     6,
-      59,    48,    -1,     7,    59,    48,    -1,     8,    46,    -1,
-       9,    46,    -1,    11,    44,    -1,    12,    38,    -1,    13,
-      42,    -1,    14,    59,    -1,    14,    59,    31,    59,    -1,
-      27,    29,    -1,    20,    56,    32,    59,    -1,    -1,    39,
-      -1,    38,    39,    -1,    55,    53,    52,    47,    40,    47,
-      51,    -1,    41,    47,    40,    -1,    -1,    25,    -1,    26,
-      -1,    16,    -1,    17,    -1,     9,    -1,    10,    -1,    18,
-      -1,    19,    -1,    42,    43,    -1,    43,    -1,    29,    33,
-      29,    31,    29,    31,    29,    51,    -1,    29,    33,    29,
-      31,    29,    31,    59,    51,    -1,    29,    33,    29,    31,
-      29,    51,    -1,    29,    33,    29,    31,    59,    51,    -1,
-      29,    31,    29,    31,    29,    51,    -1,    29,    31,    29,
-      51,    -1,    44,    45,    -1,    45,    -1,    29,    46,    -1,
-      29,    29,    -1,    46,    47,    49,    -1,    49,    -1,    32,
-      -1,    -1,    32,    59,    -1,    -1,    21,    -1,    22,    -1,
-      23,    -1,    24,    -1,    29,    -1,    31,    29,    -1,    29,
-      31,    29,    -1,    -1,    28,    29,    -1,    -1,    34,    59,
-      -1,    -1,    33,    55,    -1,    -1,    15,    33,    59,    -1,
-      -1,    29,    -1,    31,    29,    -1,    55,    31,    29,    -1,
-      29,    -1,    31,    29,    -1,    56,    31,    57,    58,    -1,
-      30,    -1,    -1,    29,    -1,    -1,    30,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
-{
-       0,   135,   135,   136,   140,   141,   142,   143,   144,   145,
-     146,   147,   148,   149,   150,   151,   152,   153,   157,   159,
-     160,   167,   174,   175,   178,   179,   180,   181,   182,   183,
-     184,   185,   188,   189,   193,   195,   197,   199,   201,   203,
-     208,   209,   213,   214,   218,   219,   223,   224,   226,   227,
-     231,   232,   233,   234,   237,   238,   244,   250,   253,   254,
-     258,   259,   263,   264,   267,   268,   271,   272,   278,   286,
-     287,   293,   301,   302,   305,   306,   309
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "NAME", "LIBRARY", "DESCRIPTION",
-  "STACKSIZE_K", "HEAPSIZE", "CODE", "DATAU", "DATAL", "SECTIONS",
-  "EXPORTS", "IMPORTS", "VERSIONK", "BASE", "CONSTANTU", "CONSTANTL",
-  "PRIVATEU", "PRIVATEL", "ALIGNCOMM", "READ", "WRITE", "EXECUTE",
-  "SHARED", "NONAMEU", "NONAMEL", "DIRECTIVE", "EQUAL", "ID", "DIGITS",
-  "'.'", "','", "'='", "'@'", "$accept", "start", "command", "explist",
-  "expline", "exp_opt_list", "exp_opt", "implist", "impline", "seclist",
-  "secline", "attr_list", "opt_comma", "opt_number", "attr", "opt_name",
-  "opt_equalequal_name", "opt_ordinal", "opt_equal_name", "opt_base",
-  "dot_name", "anylang_id", "opt_digits", "opt_id", "NUMBER", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,    46,    44,    61,    64
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
-{
-       0,    35,    36,    36,    37,    37,    37,    37,    37,    37,
-      37,    37,    37,    37,    37,    37,    37,    37,    38,    38,
-      38,    39,    40,    40,    41,    41,    41,    41,    41,    41,
-      41,    41,    42,    42,    43,    43,    43,    43,    43,    43,
-      44,    44,    45,    45,    46,    46,    47,    47,    48,    48,
-      49,    49,    49,    49,    50,    50,    50,    50,    51,    51,
-      52,    52,    53,    53,    54,    54,    55,    55,    55,    56,
-      56,    56,    57,    57,    58,    58,    59
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
-{
-       0,     2,     2,     1,     3,     3,     2,     3,     3,     2,
-       2,     2,     2,     2,     2,     4,     2,     4,     0,     1,
-       2,     7,     3,     0,     1,     1,     1,     1,     1,     1,
-       1,     1,     2,     1,     8,     8,     6,     6,     6,     4,
-       2,     1,     2,     2,     3,     1,     1,     0,     2,     0,
-       1,     1,     1,     1,     1,     2,     3,     0,     2,     0,
-       2,     0,     2,     0,     3,     0,     1,     2,     3,     1,
-       2,     4,     1,     0,     1,     0,     1
-};
-
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const unsigned char yydefact[] =
-{
-       0,    57,    57,     0,     0,     0,     0,     0,     0,    18,
-       0,     0,     0,     0,     0,     3,    54,     0,    65,    65,
-       6,    76,    49,    49,    50,    51,    52,    53,     9,    45,
-      10,     0,    11,    41,    66,     0,    12,    19,    63,     0,
-      13,    33,    14,    69,     0,     0,    16,     1,     2,     0,
-      55,     0,     4,     5,     0,     7,     8,    46,     0,    43,
-      42,    40,    67,    20,     0,     0,    61,     0,     0,    32,
-       0,    70,    73,     0,    56,     0,    48,    44,    68,    62,
-       0,    47,    59,     0,    15,    72,    75,    17,    64,    60,
-      23,     0,     0,    39,     0,    74,    71,    28,    29,    26,
-      27,    30,    31,    24,    25,    47,    47,    58,    59,    59,
-      59,    59,    23,    38,     0,    36,    37,    21,    22,    59,
-      59,    34,    35
-};
-
-/* YYDEFGOTO[NTERM-NUM]. */
-static const yysigned_char yydefgoto[] =
-{
-      -1,    14,    15,    36,    37,   105,   106,    40,    41,    32,
-      33,    28,    58,    55,    29,    18,    93,    81,    66,    52,
-      38,    45,    86,    96,    22
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -81
-static const yysigned_char yypact[] =
-{
-      30,    27,    27,   -15,    -7,    -7,    64,    64,    -1,    35,
-      11,    -7,    38,    22,     4,   -81,    28,    31,    48,    48,
-     -81,   -81,    66,    66,   -81,   -81,   -81,   -81,    -2,   -81,
-      -2,    55,    -1,   -81,   -81,    67,    35,   -81,    59,    60,
-      11,   -81,    68,   -81,    71,    16,   -81,   -81,   -81,    72,
-     -81,    69,   -81,   -81,    -7,   -81,   -81,   -81,    64,   -81,
-      -2,   -81,   -81,   -81,    74,    35,    63,    75,    76,   -81,
-      -7,   -81,    77,    -7,   -81,    -7,   -81,   -81,   -81,    79,
-      -7,    80,   -26,    82,   -81,   -81,    85,   -81,   -81,   -81,
-      36,    86,    87,   -81,    51,   -81,   -81,   -81,   -81,   -81,
-     -81,   -81,   -81,   -81,   -81,    80,    80,   -81,    78,     1,
-      78,    78,    36,   -81,    65,   -81,   -81,   -81,   -81,    78,
-      78,   -81,   -81
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const yysigned_char yypgoto[] =
-{
-     -81,   -81,    94,   -81,    81,     6,   -81,   -81,    83,   -81,
-      88,    -4,   -80,    96,    53,   119,   -37,   -81,   -81,   103,
-      61,   -81,   -81,   -81,    -5
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -48
-static const yysigned_char yytable[] =
-{
-      23,    90,    91,    30,    47,    92,    42,     1,     2,     3,
-       4,     5,     6,     7,    20,     8,     9,    10,    11,   -47,
-     -47,   -47,   -47,    21,    12,   111,   112,    60,    31,    91,
-      57,    13,   114,     1,     2,     3,     4,     5,     6,     7,
-      39,     8,     9,    10,    11,    97,    98,    72,    73,    76,
-      12,    46,    99,   100,   101,   102,    16,    13,    17,    49,
-      50,   103,   104,    51,    34,    84,    35,    43,    87,    44,
-      88,   113,   115,   116,   117,    89,    24,    25,    26,    27,
-     109,    21,   121,   122,    59,    24,    25,    26,    27,   110,
-      64,    67,    65,    68,   119,    21,    62,    80,    54,    70,
-      71,    74,    75,    78,    82,    83,    91,    85,    48,   120,
-      64,    77,    57,    94,    95,   107,   108,    63,   118,    56,
-      61,    19,    53,    69,     0,     0,    79
-};
-
-static const yysigned_char yycheck[] =
-{
-       5,    81,    28,     7,     0,    31,    11,     3,     4,     5,
-       6,     7,     8,     9,    29,    11,    12,    13,    14,    21,
-      22,    23,    24,    30,    20,   105,   106,    31,    29,    28,
-      32,    27,    31,     3,     4,     5,     6,     7,     8,     9,
-      29,    11,    12,    13,    14,     9,    10,    31,    32,    54,
-      20,    29,    16,    17,    18,    19,    29,    27,    31,    31,
-      29,    25,    26,    15,    29,    70,    31,    29,    73,    31,
-      75,   108,   109,   110,   111,    80,    21,    22,    23,    24,
-      29,    30,   119,   120,    29,    21,    22,    23,    24,    94,
-      31,    31,    33,    33,    29,    30,    29,    34,    32,    31,
-      29,    29,    33,    29,    29,    29,    28,    30,    14,   114,
-      31,    58,    32,    31,    29,    29,    29,    36,   112,    23,
-      32,     2,    19,    40,    -1,    -1,    65
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
-{
-       0,     3,     4,     5,     6,     7,     8,     9,    11,    12,
-      13,    14,    20,    27,    36,    37,    29,    31,    50,    50,
-      29,    30,    59,    59,    21,    22,    23,    24,    46,    49,
-      46,    29,    44,    45,    29,    31,    38,    39,    55,    29,
-      42,    43,    59,    29,    31,    56,    29,     0,    37,    31,
-      29,    15,    54,    54,    32,    48,    48,    32,    47,    29,
-      46,    45,    29,    39,    31,    33,    53,    31,    33,    43,
-      31,    29,    31,    32,    29,    33,    59,    49,    29,    55,
-      34,    52,    29,    29,    59,    30,    57,    59,    59,    59,
-      47,    28,    31,    51,    31,    29,    58,     9,    10,    16,
-      17,    18,    19,    25,    26,    40,    41,    29,    29,    29,
-      59,    47,    47,    51,    31,    51,    51,    51,    40,    29,
-      59,    51,    51
-};
-
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-
-#define YYFAIL		goto yyerrlab
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
-      YYERROR;							\
-    }								\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
-
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
-#endif
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
-#endif
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (0)
-
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
-
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_stack_print (short *bottom, short *top)
-#else
-static void
-yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
-#endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (0)
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_reduce_print (int yyrule)
-#else
-static void
-yy_reduce_print (yyrule)
-    int yyrule;
-#endif
-{
-  int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
-yystrlen (const char *yystr)
-#   else
-yystrlen (yystr)
-     const char *yystr;
-#   endif
-{
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
-    continue;
-
-  return yys - yystr - 1;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-#   if defined (__STDC__) || defined (__cplusplus)
-yystpcpy (char *yydest, const char *yysrc)
-#   else
-yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
-{
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-#endif /* !YYERROR_VERBOSE */
-
-
-
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  if (yytype < YYNTOKENS)
-    {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-  switch (yytype)
-    {
-      default:
-        break;
-    }
-  YYFPRINTF (yyoutput, ")");
-}
-
-#endif /* ! YYDEBUG */
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yydestruct (yytype, yyvaluep)
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  switch (yytype)
-    {
-
-      default:
-        break;
-    }
-}
-
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM);
-# else
-int yyparse ();
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-
-/* The lookahead symbol.  */
-int yychar;
-
-/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int
-yyparse (void)
-#else
-int
-yyparse ()
-
-#endif
-#endif
-{
-  
-  register int yystate;
-  register int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss;
-  yyvsp = yyvs;
-
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-	/* Give user a chance to reallocate the stack. Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
-
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-
-		    &yystacksize);
-
-	yyss = yyss1;
-	yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
-      {
-	short *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyoverflowlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
-    {
-        case 4:
-#line 140 "deffilep.y"
-    { def_image_name (yyvsp[-1].id, yyvsp[0].number, 0); }
-    break;
-
-  case 5:
-#line 141 "deffilep.y"
-    { def_image_name (yyvsp[-1].id, yyvsp[0].number, 1); }
-    break;
-
-  case 6:
-#line 142 "deffilep.y"
-    { def_description (yyvsp[0].id);}
-    break;
-
-  case 7:
-#line 143 "deffilep.y"
-    { def_stacksize (yyvsp[-1].number, yyvsp[0].number);}
-    break;
-
-  case 8:
-#line 144 "deffilep.y"
-    { def_heapsize (yyvsp[-1].number, yyvsp[0].number);}
-    break;
-
-  case 9:
-#line 145 "deffilep.y"
-    { def_section ("CODE", yyvsp[0].number);}
-    break;
-
-  case 10:
-#line 146 "deffilep.y"
-    { def_section ("DATA", yyvsp[0].number);}
-    break;
-
-  case 14:
-#line 150 "deffilep.y"
-    { def_version (yyvsp[0].number, 0);}
-    break;
-
-  case 15:
-#line 151 "deffilep.y"
-    { def_version (yyvsp[-2].number, yyvsp[0].number);}
-    break;
-
-  case 16:
-#line 152 "deffilep.y"
-    { def_directive (yyvsp[0].id);}
-    break;
-
-  case 17:
-#line 153 "deffilep.y"
-    { def_aligncomm (yyvsp[-2].id, yyvsp[0].number);}
-    break;
-
-  case 21:
-#line 168 "deffilep.y"
-    { def_exports (yyvsp[-6].id, yyvsp[-5].id, yyvsp[-4].number, yyvsp[-2].number, yyvsp[0].id); }
-    break;
-
-  case 22:
-#line 174 "deffilep.y"
-    { yyval.number = yyvsp[-2].number | yyvsp[0].number; }
-    break;
-
-  case 23:
-#line 175 "deffilep.y"
-    { yyval.number = 0; }
-    break;
-
-  case 24:
-#line 178 "deffilep.y"
-    { yyval.number = 1; }
-    break;
-
-  case 25:
-#line 179 "deffilep.y"
-    { yyval.number = 1; }
-    break;
-
-  case 26:
-#line 180 "deffilep.y"
-    { yyval.number = 2; }
-    break;
-
-  case 27:
-#line 181 "deffilep.y"
-    { yyval.number = 2; }
-    break;
-
-  case 28:
-#line 182 "deffilep.y"
-    { yyval.number = 4; }
-    break;
-
-  case 29:
-#line 183 "deffilep.y"
-    { yyval.number = 4; }
-    break;
-
-  case 30:
-#line 184 "deffilep.y"
-    { yyval.number = 8; }
-    break;
-
-  case 31:
-#line 185 "deffilep.y"
-    { yyval.number = 8; }
-    break;
-
-  case 34:
-#line 194 "deffilep.y"
-    { def_import (yyvsp[-7].id, yyvsp[-5].id, yyvsp[-3].id, yyvsp[-1].id, -1, yyvsp[0].id); }
-    break;
-
-  case 35:
-#line 196 "deffilep.y"
-    { def_import (yyvsp[-7].id, yyvsp[-5].id, yyvsp[-3].id,  0, yyvsp[-1].number, yyvsp[0].id); }
-    break;
-
-  case 36:
-#line 198 "deffilep.y"
-    { def_import (yyvsp[-5].id, yyvsp[-3].id,  0, yyvsp[-1].id, -1, yyvsp[0].id); }
-    break;
-
-  case 37:
-#line 200 "deffilep.y"
-    { def_import (yyvsp[-5].id, yyvsp[-3].id,  0,  0, yyvsp[-1].number, yyvsp[0].id); }
-    break;
-
-  case 38:
-#line 202 "deffilep.y"
-    { def_import( 0, yyvsp[-5].id, yyvsp[-3].id, yyvsp[-1].id, -1, yyvsp[0].id); }
-    break;
-
-  case 39:
-#line 204 "deffilep.y"
-    { def_import ( 0, yyvsp[-3].id,  0, yyvsp[-1].id, -1, yyvsp[0].id); }
-    break;
-
-  case 42:
-#line 213 "deffilep.y"
-    { def_section (yyvsp[-1].id, yyvsp[0].number);}
-    break;
-
-  case 43:
-#line 214 "deffilep.y"
-    { def_section_alt (yyvsp[-1].id, yyvsp[0].id);}
-    break;
-
-  case 44:
-#line 218 "deffilep.y"
-    { yyval.number = yyvsp[-2].number | yyvsp[0].number; }
-    break;
-
-  case 45:
-#line 219 "deffilep.y"
-    { yyval.number = yyvsp[0].number; }
-    break;
-
-  case 48:
-#line 226 "deffilep.y"
-    { yyval.number=yyvsp[0].number;}
-    break;
-
-  case 49:
-#line 227 "deffilep.y"
-    { yyval.number=-1;}
-    break;
-
-  case 50:
-#line 231 "deffilep.y"
-    { yyval.number = 1;}
-    break;
-
-  case 51:
-#line 232 "deffilep.y"
-    { yyval.number = 2;}
-    break;
-
-  case 52:
-#line 233 "deffilep.y"
-    { yyval.number=4;}
-    break;
-
-  case 53:
-#line 234 "deffilep.y"
-    { yyval.number=8;}
-    break;
-
-  case 54:
-#line 237 "deffilep.y"
-    { yyval.id = yyvsp[0].id; }
-    break;
-
-  case 55:
-#line 239 "deffilep.y"
-    {
-	    char *name = def_pool_alloc (strlen (yyvsp[0].id) + 2);
-	    sprintf (name, ".%s", yyvsp[0].id);
-	    yyval.id = name;
-	  }
-    break;
-
-  case 56:
-#line 245 "deffilep.y"
-    { 
-	    char *name = def_pool_alloc (strlen (yyvsp[-2].id) + 1 + strlen (yyvsp[0].id) + 1);
-	    sprintf (name, "%s.%s", yyvsp[-2].id, yyvsp[0].id);
-	    yyval.id = name;
-	  }
-    break;
-
-  case 57:
-#line 250 "deffilep.y"
-    { yyval.id = ""; }
-    break;
-
-  case 58:
-#line 253 "deffilep.y"
-    { yyval.id = yyvsp[0].id; }
-    break;
-
-  case 59:
-#line 254 "deffilep.y"
-    { yyval.id = 0; }
-    break;
-
-  case 60:
-#line 258 "deffilep.y"
-    { yyval.number = yyvsp[0].number;}
-    break;
-
-  case 61:
-#line 259 "deffilep.y"
-    { yyval.number = -1;}
-    break;
-
-  case 62:
-#line 263 "deffilep.y"
-    { yyval.id = yyvsp[0].id; }
-    break;
-
-  case 63:
-#line 264 "deffilep.y"
-    { yyval.id =  0; }
-    break;
-
-  case 64:
-#line 267 "deffilep.y"
-    { yyval.number = yyvsp[0].number;}
-    break;
-
-  case 65:
-#line 268 "deffilep.y"
-    { yyval.number = -1;}
-    break;
-
-  case 66:
-#line 271 "deffilep.y"
-    { yyval.id = yyvsp[0].id; }
-    break;
-
-  case 67:
-#line 273 "deffilep.y"
-    {
-	    char *name = def_pool_alloc (strlen (yyvsp[0].id) + 2);
-	    sprintf (name, ".%s", yyvsp[0].id);
-	    yyval.id = name;
-	  }
-    break;
-
-  case 68:
-#line 279 "deffilep.y"
-    { 
-	    char *name = def_pool_alloc (strlen (yyvsp[-2].id) + 1 + strlen (yyvsp[0].id) + 1);
-	    sprintf (name, "%s.%s", yyvsp[-2].id, yyvsp[0].id);
-	    yyval.id = name;
-	  }
-    break;
-
-  case 69:
-#line 286 "deffilep.y"
-    { yyval.id = yyvsp[0].id; }
-    break;
-
-  case 70:
-#line 288 "deffilep.y"
-    {
-	    char *id = def_pool_alloc (strlen (yyvsp[0].id) + 2);
-	    sprintf (id, ".%s", yyvsp[0].id);
-	    yyval.id = id;
-	  }
-    break;
-
-  case 71:
-#line 294 "deffilep.y"
-    {
-	    char *id = def_pool_alloc (strlen (yyvsp[-3].id) + 1 + strlen (yyvsp[-1].digits) + strlen (yyvsp[0].id) + 1);
-	    sprintf (id, "%s.%s%s", yyvsp[-3].id, yyvsp[-1].digits, yyvsp[0].id);
-	    yyval.id = id;
-	  }
-    break;
-
-  case 72:
-#line 301 "deffilep.y"
-    { yyval.digits = yyvsp[0].digits; }
-    break;
-
-  case 73:
-#line 302 "deffilep.y"
-    { yyval.digits = ""; }
-    break;
-
-  case 74:
-#line 305 "deffilep.y"
-    { yyval.id = yyvsp[0].id; }
-    break;
-
-  case 75:
-#line 306 "deffilep.y"
-    { yyval.id = ""; }
-    break;
-
-  case 76:
-#line 309 "deffilep.y"
-    { yyval.number = strtoul (yyvsp[0].digits, 0, 0); }
-    break;
-
-
-    }
-
-/* Line 1000 of yacc.c.  */
-#line 1592 "deffilep.c"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
-	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
-
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
-	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
-      else
-	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
-	  yychar = YYEMPTY;
-
-	}
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
-     goto yyerrorlab;
-#endif
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-	YYABORT;
-
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
-  *++yyvsp = yylval;
-
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-yyreturn:
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-  return yyresult;
-}
-
-
-#line 311 "deffilep.y"
-
-
-/*****************************************************************************
- API
- *****************************************************************************/
-
-static FILE *the_file;
-static const char *def_filename;
-static int linenumber;
-static def_file *def;
-static int saw_newline;
-
-struct directive
-  {
-    struct directive *next;
-    char *name;
-    int len;
-  };
-
-static struct directive *directives = 0;
-
-def_file *
-def_file_empty (void)
-{
-  def_file *rv = xmalloc (sizeof (def_file));
-  memset (rv, 0, sizeof (def_file));
-  rv->is_dll = -1;
-  rv->base_address = (bfd_vma) -1;
-  rv->stack_reserve = rv->stack_commit = -1;
-  rv->heap_reserve = rv->heap_commit = -1;
-  rv->version_major = rv->version_minor = -1;
-  return rv;
-}
-
-def_file *
-def_file_parse (const char *filename, def_file *add_to)
-{
-  struct directive *d;
-
-  the_file = fopen (filename, "r");
-  def_filename = filename;
-  linenumber = 1;
-  if (!the_file)
-    {
-      perror (filename);
-      return 0;
-    }
-  if (add_to)
-    {
-      def = add_to;
-    }
-  else
-    {
-      def = def_file_empty ();
-    }
-
-  saw_newline = 1;
-  if (def_parse ())
-    {
-      def_file_free (def);
-      fclose (the_file);
-      def_pool_free ();
-      return 0;
-    }
-
-  fclose (the_file);
-
-  while ((d = directives) != NULL)
-    {
-#if TRACE
-      printf ("Adding directive %08x `%s'\n", d->name, d->name);
-#endif
-      def_file_add_directive (def, d->name, d->len);
-      directives = d->next;
-      free (d->name);
-      free (d);
-    }
-  def_pool_free ();
-
-  return def;
-}
-
-void
-def_file_free (def_file *fdef)
-{
-  int i;
-
-  if (!fdef)
-    return;
-  if (fdef->name)
-    free (fdef->name);
-  if (fdef->description)
-    free (fdef->description);
-
-  if (fdef->section_defs)
-    {
-      for (i = 0; i < fdef->num_section_defs; i++)
-	{
-	  if (fdef->section_defs[i].name)
-	    free (fdef->section_defs[i].name);
-	  if (fdef->section_defs[i].class)
-	    free (fdef->section_defs[i].class);
-	}
-      free (fdef->section_defs);
-    }
-
-  if (fdef->exports)
-    {
-      for (i = 0; i < fdef->num_exports; i++)
-	{
-	  if (fdef->exports[i].internal_name
-	      && fdef->exports[i].internal_name != fdef->exports[i].name)
-	    free (fdef->exports[i].internal_name);
-	  if (fdef->exports[i].name)
-	    free (fdef->exports[i].name);
-	  if (fdef->exports[i].its_name)
-	    free (fdef->exports[i].its_name);
-	}
-      free (fdef->exports);
-    }
-
-  if (fdef->imports)
-    {
-      for (i = 0; i < fdef->num_imports; i++)
-	{
-	  if (fdef->imports[i].internal_name
-	      && fdef->imports[i].internal_name != fdef->imports[i].name)
-	    free (fdef->imports[i].internal_name);
-	  if (fdef->imports[i].name)
-	    free (fdef->imports[i].name);
-	  if (fdef->imports[i].its_name)
-	    free (fdef->imports[i].its_name);
-	}
-      free (fdef->imports);
-    }
-
-  while (fdef->modules)
-    {
-      def_file_module *m = fdef->modules;
-
-      fdef->modules = fdef->modules->next;
-      free (m);
-    }
-
-  while (fdef->aligncomms)
-    {
-      def_file_aligncomm *c = fdef->aligncomms;
-
-      fdef->aligncomms = fdef->aligncomms->next;
-      free (c->symbol_name);
-      free (c);
-    }
-
-  free (fdef);
-}
-
-#ifdef DEF_FILE_PRINT
-void
-def_file_print (FILE *file, def_file *fdef)
-{
-  int i;
-
-  fprintf (file, ">>>> def_file at 0x%08x\n", fdef);
-  if (fdef->name)
-    fprintf (file, "  name: %s\n", fdef->name ? fdef->name : "(unspecified)");
-  if (fdef->is_dll != -1)
-    fprintf (file, "  is dll: %s\n", fdef->is_dll ? "yes" : "no");
-  if (fdef->base_address != (bfd_vma) -1)
-    fprintf (file, "  base address: 0x%08x\n", fdef->base_address);
-  if (fdef->description)
-    fprintf (file, "  description: `%s'\n", fdef->description);
-  if (fdef->stack_reserve != -1)
-    fprintf (file, "  stack reserve: 0x%08x\n", fdef->stack_reserve);
-  if (fdef->stack_commit != -1)
-    fprintf (file, "  stack commit: 0x%08x\n", fdef->stack_commit);
-  if (fdef->heap_reserve != -1)
-    fprintf (file, "  heap reserve: 0x%08x\n", fdef->heap_reserve);
-  if (fdef->heap_commit != -1)
-    fprintf (file, "  heap commit: 0x%08x\n", fdef->heap_commit);
-
-  if (fdef->num_section_defs > 0)
-    {
-      fprintf (file, "  section defs:\n");
-
-      for (i = 0; i < fdef->num_section_defs; i++)
-	{
-	  fprintf (file, "    name: `%s', class: `%s', flags:",
-		   fdef->section_defs[i].name, fdef->section_defs[i].class);
-	  if (fdef->section_defs[i].flag_read)
-	    fprintf (file, " R");
-	  if (fdef->section_defs[i].flag_write)
-	    fprintf (file, " W");
-	  if (fdef->section_defs[i].flag_execute)
-	    fprintf (file, " X");
-	  if (fdef->section_defs[i].flag_shared)
-	    fprintf (file, " S");
-	  fprintf (file, "\n");
-	}
-    }
-
-  if (fdef->num_exports > 0)
-    {
-      fprintf (file, "  exports:\n");
-
-      for (i = 0; i < fdef->num_exports; i++)
-	{
-	  fprintf (file, "    name: `%s', int: `%s', ordinal: %d, flags:",
-		   fdef->exports[i].name, fdef->exports[i].internal_name,
-		   fdef->exports[i].ordinal);
-	  if (fdef->exports[i].flag_private)
-	    fprintf (file, " P");
-	  if (fdef->exports[i].flag_constant)
-	    fprintf (file, " C");
-	  if (fdef->exports[i].flag_noname)
-	    fprintf (file, " N");
-	  if (fdef->exports[i].flag_data)
-	    fprintf (file, " D");
-	  fprintf (file, "\n");
-	}
-    }
-
-  if (fdef->num_imports > 0)
-    {
-      fprintf (file, "  imports:\n");
-
-      for (i = 0; i < fdef->num_imports; i++)
-	{
-	  fprintf (file, "    int: %s, from: `%s', name: `%s', ordinal: %d\n",
-		   fdef->imports[i].internal_name,
-		   fdef->imports[i].module,
-		   fdef->imports[i].name,
-		   fdef->imports[i].ordinal);
-	}
-    }
-
-  if (fdef->version_major != -1)
-    fprintf (file, "  version: %d.%d\n", fdef->version_major, fdef->version_minor);
-
-  fprintf (file, "<<<< def_file at 0x%08x\n", fdef);
-}
-#endif
-
-/* Helper routine to check for identity of string pointers,
-   which might be NULL.  */
-
-static int
-are_names_equal (const char *s1, const char *s2)
-{
-  if (!s1 && !s2)
-    return 0;
-  if (!s1 || !s2)
-    return (!s1 ? -1 : 1);
-  return strcmp (s1, s2);
-}
-
-static int
-cmp_export_elem (const def_file_export *e, const char *ex_name,
-		 const char *in_name, const char *its_name,
-		 int ord)
-{
-  int r;
-
-  if ((r = are_names_equal (ex_name, e->name)) != 0)
-    return r;
-  if ((r = are_names_equal (in_name, e->internal_name)) != 0)
-    return r;
-  if ((r = are_names_equal (its_name, e->its_name)) != 0)
-    return r;
-  return (ord - e->ordinal);
-}
-
-/* Search the position of the identical element, or returns the position
-   of the next higher element. If last valid element is smaller, then MAX
-   is returned.  */
-
-static int
-find_export_in_list (def_file_export *b, int max,
-		     const char *ex_name, const char *in_name,
-		     const char *its_name, int ord, int *is_ident)
-{
-  int e, l, r, p;
-
-  *is_ident = 0;
-  if (!max)
-    return 0;
-  if ((e = cmp_export_elem (b, ex_name, in_name, its_name, ord)) <= 0)
-    return 0;
-  if (max == 1)
-    return 1;
-  if ((e = cmp_export_elem (b + (max - 1), ex_name, in_name, its_name, ord)) > 0)
-    return max;
-  else if (!e || max == 2)
-    return max - 1;
-  l = 0; r = max - 1;
-  while (l < r)
-    {
-      p = (l + r) / 2;
-      e = cmp_export_elem (b + p, ex_name, in_name, its_name, ord);
-      if (!e)
-        {
-          *is_ident = 1;
-          return p;
-        }
-      else if (e < 0)
-        r = p - 1;
-      else if (e > 0)
-        l = p + 1;
-    }
-  if ((e = cmp_export_elem (b + l, ex_name, in_name, its_name, ord)) > 0)
-    ++l;
-  else if (!e)
-    *is_ident = 1;
-  return l;
-}
-
-def_file_export *
-def_file_add_export (def_file *fdef,
-		     const char *external_name,
-		     const char *internal_name,
-		     int ordinal,
-		     const char *its_name,
-		     int *is_dup)
-{
-  def_file_export *e;
-  int pos;
-  int max_exports = ROUND_UP(fdef->num_exports, 32);
-
-  if (internal_name && !external_name)
-    external_name = internal_name;
-  if (external_name && !internal_name)
-    internal_name = external_name;
-
-  /* We need to avoid duplicates.  */
-  *is_dup = 0;
-  pos = find_export_in_list (fdef->exports, fdef->num_exports,
-		     external_name, internal_name,
-		     its_name, ordinal, is_dup);
-
-  if (*is_dup != 0)
-    return (fdef->exports + pos);
-
-  if (fdef->num_exports >= max_exports)
-    {
-      max_exports = ROUND_UP(fdef->num_exports + 1, 32);
-      if (fdef->exports)
-	fdef->exports = xrealloc (fdef->exports,
-				 max_exports * sizeof (def_file_export));
-      else
-	fdef->exports = xmalloc (max_exports * sizeof (def_file_export));
-    }
-
-  e = fdef->exports + pos;
-  if (pos != fdef->num_exports)
-    memmove (&e[1], e, (sizeof (def_file_export) * (fdef->num_exports - pos)));
-  memset (e, 0, sizeof (def_file_export));
-  e->name = xstrdup (external_name);
-  e->internal_name = xstrdup (internal_name);
-  e->its_name = (its_name ? xstrdup (its_name) : NULL);
-  e->ordinal = ordinal;
-  fdef->num_exports++;
-  return e;
-}
-
-def_file_module *
-def_get_module (def_file *fdef, const char *name)
-{
-  def_file_module *s;
-
-  for (s = fdef->modules; s; s = s->next)
-    if (strcmp (s->name, name) == 0)
-      return s;
-
-  return NULL;
-}
-
-static def_file_module *
-def_stash_module (def_file *fdef, const char *name)
-{
-  def_file_module *s;
-
-  if ((s = def_get_module (fdef, name)) != NULL)
-      return s;
-  s = xmalloc (sizeof (def_file_module) + strlen (name));
-  s->next = fdef->modules;
-  fdef->modules = s;
-  s->user_data = 0;
-  strcpy (s->name, name);
-  return s;
-}
-
-static int
-cmp_import_elem (const def_file_import *e, const char *ex_name,
-		 const char *in_name, const char *module,
-		 int ord)
-{
-  int r;
-
-  if ((r = are_names_equal (ex_name, e->name)) != 0)
-    return r;
-  if ((r = are_names_equal (in_name, e->internal_name)) != 0)
-    return r;
-  if (ord != e->ordinal)
-    return (ord < e->ordinal ? -1 : 1);
-  return are_names_equal (module, (e->module ? e->module->name : NULL));
-}
-
-/* Search the position of the identical element, or returns the position
-   of the next higher element. If last valid element is smaller, then MAX
-   is returned.  */
-
-static int
-find_import_in_list (def_file_import *b, int max,
-		     const char *ex_name, const char *in_name,
-		     const char *module, int ord, int *is_ident)
-{
-  int e, l, r, p;
-
-  *is_ident = 0;
-  if (!max)
-    return 0;
-  if ((e = cmp_import_elem (b, ex_name, in_name, module, ord)) <= 0)
-    return 0;
-  if (max == 1)
-    return 1;
-  if ((e = cmp_import_elem (b + (max - 1), ex_name, in_name, module, ord)) > 0)
-    return max;
-  else if (!e || max == 2)
-    return max - 1;
-  l = 0; r = max - 1;
-  while (l < r)
-    {
-      p = (l + r) / 2;
-      e = cmp_import_elem (b + p, ex_name, in_name, module, ord);
-      if (!e)
-        {
-          *is_ident = 1;
-          return p;
-        }
-      else if (e < 0)
-        r = p - 1;
-      else if (e > 0)
-        l = p + 1;
-    }
-  if ((e = cmp_import_elem (b + l, ex_name, in_name, module, ord)) > 0)
-    ++l;
-  else if (!e)
-    *is_ident = 1;
-  return l;
-}
-
-def_file_import *
-def_file_add_import (def_file *fdef,
-		     const char *name,
-		     const char *module,
-		     int ordinal,
-		     const char *internal_name,
-		     const char *its_name,
-		     int *is_dup)
-{
-  def_file_import *i;
-  int pos;
-  int max_imports = ROUND_UP (fdef->num_imports, 16);
-
-  /* We need to avoid here duplicates.  */
-  *is_dup = 0;
-  pos = find_import_in_list (fdef->imports, fdef->num_imports,
-			     name,
-			     (!internal_name ? name : internal_name),
-			     module, ordinal, is_dup);
-  if (*is_dup != 0)
-    return fdef->imports + pos;
-
-  if (fdef->num_imports >= max_imports)
-    {
-      max_imports = ROUND_UP (fdef->num_imports+1, 16);
-
-      if (fdef->imports)
-	fdef->imports = xrealloc (fdef->imports,
-				 max_imports * sizeof (def_file_import));
-      else
-	fdef->imports = xmalloc (max_imports * sizeof (def_file_import));
-    }
-  i = fdef->imports + pos;
-  if (pos != fdef->num_imports)
-    memmove (&i[1], i, (sizeof (def_file_import) * (fdef->num_imports - pos)));
-  memset (i, 0, sizeof (def_file_import));
-  if (name)
-    i->name = xstrdup (name);
-  if (module)
-    i->module = def_stash_module (fdef, module);
-  i->ordinal = ordinal;
-  if (internal_name)
-    i->internal_name = xstrdup (internal_name);
-  else
-    i->internal_name = i->name;
-  i->its_name = (its_name ? xstrdup (its_name) : NULL);
-  fdef->num_imports++;
-
-  return i;
-}
-
-struct
-{
-  char *param;
-  int token;
-}
-diropts[] =
-{
-  { "-heap", HEAPSIZE },
-  { "-stack", STACKSIZE_K },
-  { "-attr", SECTIONS },
-  { "-export", EXPORTS },
-  { "-aligncomm", ALIGNCOMM },
-  { 0, 0 }
-};
-
-void
-def_file_add_directive (def_file *my_def, const char *param, int len)
-{
-  def_file *save_def = def;
-  const char *pend = param + len;
-  char * tend = (char *) param;
-  int i;
-
-  def = my_def;
-
-  while (param < pend)
-    {
-      while (param < pend
-	     && (ISSPACE (*param) || *param == '\n' || *param == 0))
-	param++;
-
-      if (param == pend)
-	break;
-
-      /* Scan forward until we encounter any of:
-          - the end of the buffer
-	  - the start of a new option
-	  - a newline seperating options
-          - a NUL seperating options.  */
-      for (tend = (char *) (param + 1);
-	   (tend < pend
-	    && !(ISSPACE (tend[-1]) && *tend == '-')
-	    && *tend != '\n' && *tend != 0);
-	   tend++)
-	;
-
-      for (i = 0; diropts[i].param; i++)
-	{
-	  len = strlen (diropts[i].param);
-
-	  if (tend - param >= len
-	      && strncmp (param, diropts[i].param, len) == 0
-	      && (param[len] == ':' || param[len] == ' '))
-	    {
-	      lex_parse_string_end = tend;
-	      lex_parse_string = param + len + 1;
-	      lex_forced_token = diropts[i].token;
-	      saw_newline = 0;
-	      if (def_parse ())
-		continue;
-	      break;
-	    }
-	}
-
-      if (!diropts[i].param)
-	{
-	  char saved;
-
-	  saved = * tend;
-	  * tend = 0;
-	  /* xgettext:c-format */
-	  einfo (_("Warning: .drectve `%s' unrecognized\n"), param);
-	  * tend = saved;
-	}
-
-      lex_parse_string = 0;
-      param = tend;
-    }
-
-  def = save_def;
-  def_pool_free ();
-}
-
-/* Parser Callbacks.  */
-
-static void
-def_image_name (const char *name, int base, int is_dll)
-{
-  /* If a LIBRARY or NAME statement is specified without a name, there is nothing
-     to do here.  We retain the output filename specified on command line.  */
-  if (*name)
-    {
-      const char* image_name = lbasename (name);
-
-      if (image_name != name)
-	einfo ("%s:%d: Warning: path components stripped from %s, '%s'\n",
-	       def_filename, linenumber, is_dll ? "LIBRARY" : "NAME",
-	       name);
-      if (def->name)
-	free (def->name);
-      /* Append the default suffix, if none specified.  */ 
-      if (strchr (image_name, '.') == 0)
-	{
-	  const char * suffix = is_dll ? ".dll" : ".exe";
-
-	  def->name = xmalloc (strlen (image_name) + strlen (suffix) + 1);
-	  sprintf (def->name, "%s%s", image_name, suffix);
-        }
-      else
-	def->name = xstrdup (image_name);
-    }
-
-  /* Honor a BASE address statement, even if LIBRARY string is empty.  */
-  def->base_address = base;
-  def->is_dll = is_dll;
-}
-
-static void
-def_description (const char *text)
-{
-  int len = def->description ? strlen (def->description) : 0;
-
-  len += strlen (text) + 1;
-  if (def->description)
-    {
-      def->description = xrealloc (def->description, len);
-      strcat (def->description, text);
-    }
-  else
-    {
-      def->description = xmalloc (len);
-      strcpy (def->description, text);
-    }
-}
-
-static void
-def_stacksize (int reserve, int commit)
-{
-  def->stack_reserve = reserve;
-  def->stack_commit = commit;
-}
-
-static void
-def_heapsize (int reserve, int commit)
-{
-  def->heap_reserve = reserve;
-  def->heap_commit = commit;
-}
-
-static void
-def_section (const char *name, int attr)
-{
-  def_file_section *s;
-  int max_sections = ROUND_UP (def->num_section_defs, 4);
-
-  if (def->num_section_defs >= max_sections)
-    {
-      max_sections = ROUND_UP (def->num_section_defs+1, 4);
-
-      if (def->section_defs)
-	def->section_defs = xrealloc (def->section_defs,
-				      max_sections * sizeof (def_file_import));
-      else
-	def->section_defs = xmalloc (max_sections * sizeof (def_file_import));
-    }
-  s = def->section_defs + def->num_section_defs;
-  memset (s, 0, sizeof (def_file_section));
-  s->name = xstrdup (name);
-  if (attr & 1)
-    s->flag_read = 1;
-  if (attr & 2)
-    s->flag_write = 1;
-  if (attr & 4)
-    s->flag_execute = 1;
-  if (attr & 8)
-    s->flag_shared = 1;
-
-  def->num_section_defs++;
-}
-
-static void
-def_section_alt (const char *name, const char *attr)
-{
-  int aval = 0;
-
-  for (; *attr; attr++)
-    {
-      switch (*attr)
-	{
-	case 'R':
-	case 'r':
-	  aval |= 1;
-	  break;
-	case 'W':
-	case 'w':
-	  aval |= 2;
-	  break;
-	case 'X':
-	case 'x':
-	  aval |= 4;
-	  break;
-	case 'S':
-	case 's':
-	  aval |= 8;
-	  break;
-	}
-    }
-  def_section (name, aval);
-}
-
-static void
-def_exports (const char *external_name,
-	     const char *internal_name,
-	     int ordinal,
-	     int flags,
-	     const char *its_name)
-{
-  def_file_export *dfe;
-  int is_dup = 0;
-
-  if (!internal_name && external_name)
-    internal_name = external_name;
-#if TRACE
-  printf ("def_exports, ext=%s int=%s\n", external_name, internal_name);
-#endif
-
-  dfe = def_file_add_export (def, external_name, internal_name, ordinal,
-			     its_name, &is_dup);
-
-  /* We might check here for flag redefinition and warn.  For now we
-     ignore duplicates silently.  */
-  if (is_dup)
-    return;
-
-  if (flags & 1)
-    dfe->flag_noname = 1;
-  if (flags & 2)
-    dfe->flag_constant = 1;
-  if (flags & 4)
-    dfe->flag_data = 1;
-  if (flags & 8)
-    dfe->flag_private = 1;
-}
-
-static void
-def_import (const char *internal_name,
-	    const char *module,
-	    const char *dllext,
-	    const char *name,
-	    int ordinal,
-	    const char *its_name)
-{
-  char *buf = 0;
-  const char *ext = dllext ? dllext : "dll";
-  int is_dup = 0;
-   
-  buf = xmalloc (strlen (module) + strlen (ext) + 2);
-  sprintf (buf, "%s.%s", module, ext);
-  module = buf;
-
-  def_file_add_import (def, name, module, ordinal, internal_name, its_name,
-		       &is_dup);
-  free (buf);
-}
-
-static void
-def_version (int major, int minor)
-{
-  def->version_major = major;
-  def->version_minor = minor;
-}
-
-static void
-def_directive (char *str)
-{
-  struct directive *d = xmalloc (sizeof (struct directive));
-
-  d->next = directives;
-  directives = d;
-  d->name = xstrdup (str);
-  d->len = strlen (str);
-}
-
-static void
-def_aligncomm (char *str, int align)
-{
-  def_file_aligncomm *c, *p;
-  
-  p = NULL;
-  c = def->aligncomms;
-  while (c != NULL)
-    {
-      int e = strcmp (c->symbol_name, str);
-      if (!e)
-	{
-	  /* Not sure if we want to allow here duplicates with
-	     different alignments, but for now we keep them.  */
-	  e = (int) c->alignment - align;
-	  if (!e)
-	    return;
-	}
-      if (e > 0)
-        break;
-      c = (p = c)->next;
-    }
-
-  c = xmalloc (sizeof (def_file_aligncomm));
-  c->symbol_name = xstrdup (str);
-  c->alignment = (unsigned int) align;
-  if (!p)
-    {
-      c->next = def->aligncomms;
-      def->aligncomms = c;
-    }
-  else
-    {
-      c->next = p->next;
-      p->next = c;
-    }
-}
-
-static int
-def_error (const char *err)
-{
-  einfo ("%P: %s:%d: %s\n",
-	 def_filename ? def_filename : "<unknown-file>", linenumber, err);
-  return 0;
-}
-
-
-/* Lexical Scanner.  */
-
-#undef TRACE
-#define TRACE 0
-
-/* Never freed, but always reused as needed, so no real leak.  */
-static char *buffer = 0;
-static int buflen = 0;
-static int bufptr = 0;
-
-static void
-put_buf (char c)
-{
-  if (bufptr == buflen)
-    {
-      buflen += 50;		/* overly reasonable, eh?  */
-      if (buffer)
-	buffer = xrealloc (buffer, buflen + 1);
-      else
-	buffer = xmalloc (buflen + 1);
-    }
-  buffer[bufptr++] = c;
-  buffer[bufptr] = 0;		/* not optimal, but very convenient.  */
-}
-
-static struct
-{
-  char *name;
-  int token;
-}
-tokens[] =
-{
-  { "BASE", BASE },
-  { "CODE", CODE },
-  { "CONSTANT", CONSTANTU },
-  { "constant", CONSTANTL },
-  { "DATA", DATAU },
-  { "data", DATAL },
-  { "DESCRIPTION", DESCRIPTION },
-  { "DIRECTIVE", DIRECTIVE },
-  { "EXECUTE", EXECUTE },
-  { "EXPORTS", EXPORTS },
-  { "HEAPSIZE", HEAPSIZE },
-  { "IMPORTS", IMPORTS },
-  { "LIBRARY", LIBRARY },
-  { "NAME", NAME },
-  { "NONAME", NONAMEU },
-  { "noname", NONAMEL },
-  { "PRIVATE", PRIVATEU },
-  { "private", PRIVATEL },
-  { "READ", READ },
-  { "SECTIONS", SECTIONS },
-  { "SEGMENTS", SECTIONS },
-  { "SHARED", SHARED },
-  { "STACKSIZE", STACKSIZE_K },
-  { "VERSION", VERSIONK },
-  { "WRITE", WRITE },
-  { 0, 0 }
-};
-
-static int
-def_getc (void)
-{
-  int rv;
-
-  if (lex_parse_string)
-    {
-      if (lex_parse_string >= lex_parse_string_end)
-	rv = EOF;
-      else
-	rv = *lex_parse_string++;
-    }
-  else
-    {
-      rv = fgetc (the_file);
-    }
-  if (rv == '\n')
-    saw_newline = 1;
-  return rv;
-}
-
-static int
-def_ungetc (int c)
-{
-  if (lex_parse_string)
-    {
-      lex_parse_string--;
-      return c;
-    }
-  else
-    return ungetc (c, the_file);
-}
-
-static int
-def_lex (void)
-{
-  int c, i, q;
-
-  if (lex_forced_token)
-    {
-      i = lex_forced_token;
-      lex_forced_token = 0;
-#if TRACE
-      printf ("lex: forcing token %d\n", i);
-#endif
-      return i;
-    }
-
-  c = def_getc ();
-
-  /* Trim leading whitespace.  */
-  while (c != EOF && (c == ' ' || c == '\t') && saw_newline)
-    c = def_getc ();
-
-  if (c == EOF)
-    {
-#if TRACE
-      printf ("lex: EOF\n");
-#endif
-      return 0;
-    }
-
-  if (saw_newline && c == ';')
-    {
-      do
-	{
-	  c = def_getc ();
-	}
-      while (c != EOF && c != '\n');
-      if (c == '\n')
-	return def_lex ();
-      return 0;
-    }
-
-  /* Must be something else.  */
-  saw_newline = 0;
-
-  if (ISDIGIT (c))
-    {
-      bufptr = 0;
-      while (c != EOF && (ISXDIGIT (c) || (c == 'x')))
-	{
-	  put_buf (c);
-	  c = def_getc ();
-	}
-      if (c != EOF)
-	def_ungetc (c);
-      yylval.digits = def_pool_strdup (buffer);
-#if TRACE
-      printf ("lex: `%s' returns DIGITS\n", buffer);
-#endif
-      return DIGITS;
-    }
-
-  if (ISALPHA (c) || strchr ("$:-_?@", c))
-    {
-      bufptr = 0;
-      q = c;
-      put_buf (c);
-      c = def_getc ();
-
-      if (q == '@')
-	{
-          if (ISBLANK (c) ) /* '@' followed by whitespace.  */
-	    return (q);
-          else if (ISDIGIT (c)) /* '@' followed by digit.  */
-            {
-	      def_ungetc (c);
-              return (q);
-	    }
-#if TRACE
-	  printf ("lex: @ returns itself\n");
-#endif
-	}
-
-      while (c != EOF && (ISALNUM (c) || strchr ("$:-_?/@<>", c)))
-	{
-	  put_buf (c);
-	  c = def_getc ();
-	}
-      if (c != EOF)
-	def_ungetc (c);
-      if (ISALPHA (q)) /* Check for tokens.  */
-	{
-          for (i = 0; tokens[i].name; i++)
-	    if (strcmp (tokens[i].name, buffer) == 0)
-	      {
-#if TRACE
-	        printf ("lex: `%s' is a string token\n", buffer);
-#endif
-	        return tokens[i].token;
-	      }
-	}
-#if TRACE
-      printf ("lex: `%s' returns ID\n", buffer);
-#endif
-      yylval.id = def_pool_strdup (buffer);
-      return ID;
-    }
-
-  if (c == '\'' || c == '"')
-    {
-      q = c;
-      c = def_getc ();
-      bufptr = 0;
-
-      while (c != EOF && c != q)
-	{
-	  put_buf (c);
-	  c = def_getc ();
-	}
-      yylval.id = def_pool_strdup (buffer);
-#if TRACE
-      printf ("lex: `%s' returns ID\n", buffer);
-#endif
-      return ID;
-    }
-
-  if ( c == '=')
-    {
-      c = def_getc ();
-      if (c == '=')
-        {
-#if TRACE
-          printf ("lex: `==' returns EQUAL\n");
-#endif
-		  return EQUAL;
-        }
-      def_ungetc (c);
-#if TRACE
-      printf ("lex: `=' returns itself\n");
-#endif
-      return '=';
-    }
-  if (c == '.' || c == ',')
-    {
-#if TRACE
-      printf ("lex: `%c' returns itself\n", c);
-#endif
-      return c;
-    }
-
-  if (c == '\n')
-    {
-      linenumber++;
-      saw_newline = 1;
-    }
-
-  /*printf ("lex: 0x%02x ignored\n", c); */
-  return def_lex ();
-}
-
-static char *
-def_pool_alloc (size_t sz)
-{
-  def_pool_str *e;
-
-  e = (def_pool_str *) xmalloc (sizeof (def_pool_str) + sz);
-  e->next = pool_strs;
-  pool_strs = e;
-  return e->data;
-}
-
-static char *
-def_pool_strdup (const char *str)
-{
-  char *s;
-  size_t len;
-  if (!str)
-    return NULL;
-  len = strlen (str) + 1;
-  s = def_pool_alloc (len);
-  memcpy (s, str, len);
-  return s;
-}
-
-static void
-def_pool_free (void)
-{
-  def_pool_str *p;
-  while ((p = pool_strs) != NULL)
-    {
-      pool_strs = p->next;
-      free (p);
-    }
-}
-
diff -r -N -u binutils-2.21.51/ld/deffilep.h binutils/ld/deffilep.h
--- binutils-2.21.51/ld/deffilep.h	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/deffilep.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,111 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     NAME = 258,
-     LIBRARY = 259,
-     DESCRIPTION = 260,
-     STACKSIZE_K = 261,
-     HEAPSIZE = 262,
-     CODE = 263,
-     DATAU = 264,
-     DATAL = 265,
-     SECTIONS = 266,
-     EXPORTS = 267,
-     IMPORTS = 268,
-     VERSIONK = 269,
-     BASE = 270,
-     CONSTANTU = 271,
-     CONSTANTL = 272,
-     PRIVATEU = 273,
-     PRIVATEL = 274,
-     ALIGNCOMM = 275,
-     READ = 276,
-     WRITE = 277,
-     EXECUTE = 278,
-     SHARED = 279,
-     NONAMEU = 280,
-     NONAMEL = 281,
-     DIRECTIVE = 282,
-     EQUAL = 283,
-     ID = 284,
-     DIGITS = 285
-   };
-#endif
-#define NAME 258
-#define LIBRARY 259
-#define DESCRIPTION 260
-#define STACKSIZE_K 261
-#define HEAPSIZE 262
-#define CODE 263
-#define DATAU 264
-#define DATAL 265
-#define SECTIONS 266
-#define EXPORTS 267
-#define IMPORTS 268
-#define VERSIONK 269
-#define BASE 270
-#define CONSTANTU 271
-#define CONSTANTL 272
-#define PRIVATEU 273
-#define PRIVATEL 274
-#define ALIGNCOMM 275
-#define READ 276
-#define WRITE 277
-#define EXECUTE 278
-#define SHARED 279
-#define NONAMEU 280
-#define NONAMEL 281
-#define DIRECTIVE 282
-#define EQUAL 283
-#define ID 284
-#define DIGITS 285
-
-
-
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 114 "deffilep.y"
-typedef union YYSTYPE {
-  char *id;
-  int number;
-  char *digits;
-} YYSTYPE;
-/* Line 1275 of yacc.c.  */
-#line 103 "deffilep.h"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-extern YYSTYPE yylval;
-
-
-
diff -r -N -u binutils-2.21.51/ld/emulparams/elf32_lx_linux.sh binutils/ld/emulparams/elf32_lx_linux.sh
--- binutils-2.21.51/ld/emulparams/elf32_lx_linux.sh	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/emulparams/elf32_lx_linux.sh	2011-07-12 18:25:55.000598000 +0100
@@ -0,0 +1,28 @@
+###
+###  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+###
+
+SCRIPT_NAME=elf
+ARCH=lx
+MACHINE=
+TEMPLATE_NAME=elf32
+OUTPUT_FORMAT="elf32-littlelx-linux"
+TEXT_START_ADDR=0x00400000
+MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
+GENERATE_SHLIB_SCRIPT=yes
+GENERATE_PIE_SCRIPT=yes
+ENTRY=_start
+NOP=0x80000080
+OTHER_SECTIONS='
+  /* No point in keeping this in the executable. What about partial links though? */
+  /DISCARD/ : { *(.profile_info) }
+'
+OTHER_GOT_SECTIONS="
+  .lx.pltoff ${RELOCATING-0} : { *(.lx.pltoff) }"
+OTHER_PLT_RELOC_SECTIONS="
+  .rela.lx.pltoff ${RELOCATING-0} : { *(.rela.lx.pltoff) }"
+OTHER_READONLY_SECTIONS="
+  .opd          ${RELOCATING-0} : { *(.opd) }"
+OTHER_SDATA_SECTIONS="
+  .srdata       ${RELOCATING-0} : { *(.srdata) }"
+EXTRA_EM_FILE=lxelf
diff -r -N -u binutils-2.21.51/ld/emulparams/elf32_lx.sh binutils/ld/emulparams/elf32_lx.sh
--- binutils-2.21.51/ld/emulparams/elf32_lx.sh	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/emulparams/elf32_lx.sh	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,39 @@
+###
+### (c) Copyright Hewlett-Packard Company 1999-2003
+###
+### This program is free software; you can redistribute it and/or
+### modify it under the terms of the GNU General Public License
+### as published by the Free Software Foundation; either version
+### 2 of the License, or (at your option) any later version.
+###
+### This program is distributed in the hope that it will be useful,
+### but WITHOUT ANY WARRANTY; without even the implied warranty of
+### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+### General Public License for more details.
+###
+### You should have received a copy of the GNU General Public License
+### along with this program; if not, write to the Free Software
+### Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+###
+
+### THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+
+###
+### static char sccs_id[] = "@(#)elf32_lx.sh	1.3 05/18/99 15:21:59";
+###
+
+SCRIPT_NAME=elflx
+ARCH=lx
+TEMPLATE_NAME=elf32
+OUTPUT_FORMAT="elf32-littlelx"
+BIG_OUTPUT_FORMAT="elf32-lx"
+LITTLE_OUTPUT_FORMAT="elf32-littlelx"
+TEXT_START_ADDR=0x0000
+SEGMENT_SIZE=0x800
+TARGET_PAGE_SIZE=128
+NOP=0x80000080
+MAXPAGESIZE=0x1000;
+GENERATE_SHLIB_SCRIPT=yes
+OTHER_READONLY_SECTIONS="
+  .opd          ${RELOCATING-0} : { *(.opd) }"
+EXTRA_EM_FILE=lxelf
diff -r -N -u binutils-2.21.51/ld/emultempl/elf32.em binutils/ld/emultempl/elf32.em
--- binutils-2.21.51/ld/emultempl/elf32.em	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/emultempl/elf32.em	2011-08-25 16:05:17.282764000 +0100
@@ -61,6 +61,19 @@
 #include "elf-bfd.h"
 #include "filenames.h"
 
+/* Record Emultation name. Used in elf.c ST200 patch to decide if PHDR table should
+   be generated or not (See Codex #59949) */
+char *lx_emul_name = "${EMULATION_NAME}";
+
+/* Wether we do a simple merge of all inputs or not  : this is like -r option
+   except that :
+     - no linker script may be given on the comand line (embedded one is used)
+     - the librery search algorithm does include the search for .so files,
+       but does not merge them into the output. This avoid .a files being
+       found and merged into the output if a .so file exists.
+*/
+static bfd_boolean do_merge = FALSE;
+
 /* Declare functions used by various EXTRA_EM_FILEs.  */
 static void gld${EMULATION_NAME}_before_parse (void);
 static void gld${EMULATION_NAME}_after_open (void);
@@ -68,6 +81,17 @@
 static void gld${EMULATION_NAME}_after_allocation (void);
 static lang_output_section_statement_type *gld${EMULATION_NAME}_place_orphan
   (asection *, const char *, int);
+static void gld${EMULATION_NAME}_after_parse (void);
+
+#include "obstack.h"
+
+/* Use obstack for memory allocation. */
+static struct obstack ${EMULATION_NAME}_obstack;
+
+#define obstack_chunk_alloc xmalloc
+#define obstack_chunk_free  free
+#define bfd_section_bfd(ptr)                  ((ptr)->owner)
+
 EOF
 
 if [ "x${USE_LIBPATH}" = xyes ] ; then
@@ -104,6 +128,32 @@
   ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
   config.dynamic_link = ${DYNAMIC_LINK-TRUE};
   config.has_shared = `if test -n "$GENERATE_SHLIB_SCRIPT" ; then echo TRUE ; else echo FALSE ; fi`;
+
+  /* (sgr) ensure that section information table is
+     generated. The only way to force section information
+     table to not be generated, is to used the specific
+     command line option. */
+  config.build_secinfo_table = TRUE;
+
+  /* (sgr) initialize obstack structure */
+  obstack_begin (&${EMULATION_NAME}_obstack, 1000);
+
+}
+
+EOF
+fi
+
+if test x"$LDEMUL_AFTER_PARSE" != xgld"$EMULATION_NAME"_after_parse; then
+cat >>e${EMULATION_NAME}.c <<EOF
+
+static void
+gld${EMULATION_NAME}_after_parse ()
+{
+  if (do_merge && saved_script_handle) {
+    einfo (_("%P%F: -T and --merge may not be used together\n")); 
+  }
+
+  after_parse_default ();
 }
 
 EOF
@@ -1060,6 +1110,13 @@
   struct bfd_link_needed_list *needed, *l;
   struct elf_link_hash_table *htab;
 
+/* This must be repeated here because a linker script may be hidden in the
+   input file list, and thus it is only detected when all input files are
+   read */
+  if (do_merge && saved_script_handle) {
+    einfo (_("%P%F: -T and --merge may not be used together\n"));
+  }
+
   after_open_default ();
 
   htab = elf_hash_table (&link_info);
@@ -1413,6 +1470,220 @@
    tells the ELF backend about them, in case they are assignments to
    symbols which are referred to by dynamic objects.  */
 
+#ifdef DUMP_SYMS
+static void
+dump_data (abfd)
+     bfd *abfd;
+{
+  asection *section;
+  bfd_byte *data = 0;
+  bfd_size_type datasize = 0;
+  bfd_size_type addr_offset;
+  bfd_size_type start_offset, stop_offset;
+  unsigned int opb = bfd_octets_per_byte (abfd);
+  char *only= ".init";
+
+  for (section = abfd->sections; section != NULL; section =
+       section->next)
+    {
+      int onaline = 16;
+
+      if (only == (char *) NULL ||
+          strcmp (only, section->name) == 0)
+        {
+          if (section->flags & SEC_HAS_CONTENTS)
+            {
+              printf (_("Contents of section %s:\n"), section->name);
+
+              if (bfd_section_size (abfd, section) == 0)
+                continue;
+              data = (bfd_byte *) xmalloc ((size_t) bfd_section_size (abfd, section));
+              datasize = bfd_section_size (abfd, section);
+
+
+              bfd_get_section_contents (abfd, section, (PTR) data, 0, bfd_section_size (abfd, section));
+
+                start_offset = 0;
+                stop_offset = bfd_section_size (abfd, section) / opb;
+
+
+              for (addr_offset = start_offset;
+                   addr_offset < stop_offset; addr_offset += onaline)
+                {
+                  bfd_size_type j;
+
+                  printf (" %04lx ", (unsigned long int)
+                          (addr_offset + section->vma));
+                  for (j = addr_offset * opb;
+                       j < addr_offset * opb + onaline; j++)
+                    {
+                      if (j < stop_offset * opb)
+                        printf ("%02x", (unsigned) (data[j]));
+                      else
+                        printf ("  ");
+                      if ((j & 3) == 3)
+                        printf (" ");
+                    }
+
+                  printf (" ");
+                  for (j = addr_offset; j < addr_offset * opb + onaline; j++)
+                    {
+                      if (j >= stop_offset * opb)
+                        printf (" ");
+                      else
+                        printf ("%c", ISPRINT (data[j]) ? data[j] : '.');
+                    }
+                  putchar ('\n');
+                }
+              free (data);
+            }
+        }
+    }
+}
+
+
+static void
+dump_section_header (abfd, section, ignored)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     asection *section;
+     PTR ignored ATTRIBUTE_UNUSED;
+{
+  char *comma = "";
+  unsigned int opb = bfd_octets_per_byte (abfd);
+
+  printf ("%3d %-13s %08lx  ", section->index,
+          bfd_get_section_name (abfd, section),
+          (unsigned long) bfd_section_size (abfd, section) / opb);
+  bfd_printf_vma (abfd, bfd_get_section_vma (abfd, section));
+  printf ("  ");
+  bfd_printf_vma (abfd, section->lma);
+  printf ("  %08lx  2**%u", (unsigned long) section->filepos,
+          bfd_get_section_alignment (abfd, section));
+  printf ("  ");
+
+#define PF(x, y) \
+  if (section->flags & x) { printf ("%s%s", comma, y); comma = ", "; }
+
+  PF (SEC_HAS_CONTENTS, "CONTENTS");
+  PF (SEC_ALLOC, "ALLOC");
+  PF (SEC_CONSTRUCTOR, "CONSTRUCTOR");
+  PF (SEC_LOAD, "LOAD");
+  PF (SEC_RELOC, "RELOC");
+  PF (SEC_READONLY, "READONLY");
+  PF (SEC_CODE, "CODE");
+  PF (SEC_DATA, "DATA");
+  PF (SEC_ROM, "ROM");
+  PF (SEC_DEBUGGING, "DEBUGGING");
+  PF (SEC_NEVER_LOAD, "NEVER_LOAD");
+  PF (SEC_EXCLUDE, "EXCLUDE");
+  PF (SEC_SORT_ENTRIES, "SORT_ENTRIES");
+  PF (SEC_BLOCK, "BLOCK");
+  PF (SEC_CLINK, "CLINK");
+  PF (SEC_SMALL_DATA, "SMALL_DATA");
+  PF (SEC_SHARED, "SHARED");
+  PF (SEC_ARCH_BIT_0, "ARCH_BIT_0");
+  PF (SEC_THREAD_LOCAL, "THREAD_LOCAL");
+
+  if ((section->flags & SEC_LINK_ONCE) != 0)
+    {
+      const char *ls;
+
+      switch (section->flags & SEC_LINK_DUPLICATES)
+        {
+        default:
+          abort ();
+        case SEC_LINK_DUPLICATES_DISCARD:
+          ls = "LINK_ONCE_DISCARD";
+          break;
+        case SEC_LINK_DUPLICATES_ONE_ONLY:
+          ls = "LINK_ONCE_ONE_ONLY";
+          break;
+        case SEC_LINK_DUPLICATES_SAME_SIZE:
+          ls = "LINK_ONCE_SAME_SIZE";
+          break;
+        case SEC_LINK_DUPLICATES_SAME_CONTENTS:
+          ls = "LINK_ONCE_SAME_CONTENTS";
+          break;
+        }
+      printf ("%s%s", comma, ls);
+
+      if (section->comdat != NULL)
+        printf (" (COMDAT %s %ld)", section->comdat->name,
+                section->comdat->symbol);
+
+      comma = ", ";
+    }
+
+  printf ("\n");
+#undef PF
+}
+
+
+static void
+dump_headers (abfd)
+     bfd *abfd;
+{
+  printf (_("Sections:\n"));
+
+#ifndef BFD64
+  printf (_("Idx Name          Size      VMA       LMA       File off  Algn"));
+#else
+  /* With BFD64, non-ELF returns -1 and wants always 64 bit addresses.  */
+  if (bfd_get_arch_size (abfd) == 32)
+    printf (_("Idx Name          Size      VMA       LMA       File off  Algn"))
+;
+  else
+    printf (_("Idx Name          Size      VMA               LMA               File off  Algn"));
+#endif
+
+  printf ("\n");
+
+  bfd_map_over_sections (abfd, dump_section_header, (PTR) NULL);
+}
+
+static bfd_boolean
+print_one_symbol (hash_entry, ptr)
+     struct bfd_link_hash_entry *hash_entry;
+     PTR ptr;
+{
+//  asection *sec = (asection *) ptr;
+
+  if ((hash_entry->type == bfd_link_hash_defined
+       || hash_entry->type == bfd_link_hash_defweak))
+//      && sec == hash_entry->u.def.section)
+    {
+//      int i;
+
+//      for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
+//        print_space ();
+      printf ("0x%x   ",
+             (hash_entry->u.def.value
+              + hash_entry->u.def.section->output_offset
+              + hash_entry->u.def.section->output_section->vma));
+      printf (" %s",hash_entry->u.def.section->output_section->name);
+      printf (" 0x%x",hash_entry->u.def.section->output_section->vma);
+
+      printf ("             %s\n", hash_entry->root.string);
+    }
+
+  return TRUE;
+}
+
+static void
+dump_syms(abfd)
+     bfd *abfd;
+{
+  printf ("SYMBOL TABLE:\n");
+  if (link_info.hash == NULL) {
+    printf (_("%s: no symbols\n"), bfd_get_filename (abfd));
+  } else {
+    bfd_link_hash_traverse (link_info.hash, print_one_symbol, (PTR) NULL);
+  }
+  printf ("END SYMBOL TABLE\n");
+
+}
+#endif
+
 static void
 gld${EMULATION_NAME}_find_statement_assignment (lang_statement_union_type *s)
 {
@@ -1490,6 +1761,9 @@
   if (link_info.hash->type == bfd_link_elf_hash_table)
     _bfd_elf_tls_setup (link_info.output_bfd, &link_info);
 
+  //  dump_syms(output_bfd);
+  //  dump_headers(output_bfd);
+
   /* If we are going to make any variable assignments, we need to let
      the ELF backend know about them in case the variables are
      referred to by dynamic objects.  */
@@ -1621,6 +1895,10 @@
   const char *filename;
   char *string;
 
+  if  ((!entry->dynamic || link_info.relocatable)
+       && (! do_merge) )
+    return FALSE;
+
   if (! entry->maybe_archive)
     return FALSE;
 
@@ -1972,6 +2250,27 @@
 EOF
 fi
 
+if test x"$LDEMUL_AFTER_ALLOCATION" != xgld"$EMULATION_NAME"_after_allocation; then
+cat >>e${EMULATION_NAME}.c <<EOF
+
+//static void
+//gld${EMULATION_NAME}_after_allocation ()
+//{
+//  char *name = "_init";
+//  struct bfd_link_hash_entry *hash_entry;
+
+//  dump_headers(output_bfd);
+//  dump_syms(output_bfd);
+//  hash_entry = bfd_link_hash_lookup (link_info.hash, name, FALSE, FALSE, TRUE);
+//  hash_entry->u.def.value = 0;
+
+//  dump_headers(output_bfd);
+//  dump_syms(output_bfd);
+//  dump_data(hash_entry->u.def.section->owner);
+//}
+EOF
+fi
+
 if test x"$LDEMUL_GET_SCRIPT" != xgld"$EMULATION_NAME"_get_script; then
 fragment <<EOF
 
@@ -2124,6 +2423,7 @@
 #define OPTION_HASH_STYLE		(OPTION_EXCLUDE_LIBS + 1)
 #define OPTION_BUILD_ID			(OPTION_HASH_STYLE + 1)
 #define OPTION_AUDIT			(OPTION_BUILD_ID + 1)
+#define OPTION_MERGE			(OPTION_AUDIT + 1)
 
 static void
 gld${EMULATION_NAME}_add_options
@@ -2132,6 +2432,7 @@
 {
   static const char xtra_short[] = "${PARSE_AND_LIST_SHORTOPTS}z:P:";
   static const struct option xtra_long[] = {
+    {"merge", no_argument, NULL, OPTION_MERGE},
     {"build-id", optional_argument, NULL, OPTION_BUILD_ID},
     {"audit", required_argument, NULL, OPTION_AUDIT},
     {"depaudit", required_argument, NULL, 'P'},
@@ -2174,6 +2475,14 @@
     {
     default:
       return FALSE;
+    case OPTION_MERGE:
+      do_merge = TRUE;
+      link_info.relocatable = TRUE;
+      config.build_constructors = FALSE;
+      config.magic_demand_paged = FALSE;
+      config.text_read_only = FALSE;
+      config.dynamic_link = FALSE;
+      break;
 
     case OPTION_BUILD_ID:
       if (link_info.emit_note_gnu_build_id != NULL)
@@ -2456,12 +2765,1148 @@
 
 fragment <<EOF
 
+#include "ldexp.h"
+#include "ldlang.h"
+#include "ldgram.h"
+
+static void     gld${EMULATION_NAME}_get_secinfo_table_content
+  PARAMS ((lang_secinfo_table_statement_type *, bfd_vma));
+static void     gld${EMULATION_NAME}_after_assignment
+  PARAMS ((bfd_boolean *));
+
+/* Abort on a fatal error */
+#define ABORT()     (einfo("%P: internal error %s, line %d\n", __FILE__, __LINE__), abort())
+
+/* Macro used to trace secinfo table generation. */
+#if defined(ID_MAKE)
+#define SECINFO_DEBUG
+#endif
+
+#ifdef SECINFO_DEBUG
+#define SECINFO_TRACE(PARAMS) secinfo_print PARAMS
+
+#include <stdarg.h>
+
+static void
+secinfo_print(const char *fmt, ...)
+{
+/*  if (getenv("SECINFO_DEBUG")) */
+    {
+      va_list args;
+
+      va_start (args, fmt);
+      vfprintf (stderr, fmt, args);
+      va_end (args);
+    }
+}
+
+#else
+#define SECINFO_TRACE(PARAMS)
+#endif
+
+/* Check that a flag has a set of bits on. */
+#define flag_has_all(FLAGS, EXPECTED)    (((FLAGS) & (EXPECTED)) == (EXPECTED))
+#define flag_has_one_of(FLAGS, EXPECTED) ((FLAGS) & (EXPECTED))
+
+/* Secinfo types supported for sections:
+   . SECINFO_MEMORY_DATA:  data in memory to be copied,
+   . SECINFO_MEMORY_BSS:   bss in memory to be initialized,
+   . SECINFO_END_OF_TABLE: type that handle the end of the table. */
+typedef enum {
+  secinfo_end_of_table_enum = 0x00,
+  secinfo_memory_bss_enum   = 0x01,
+  secinfo_memory_data_enum  = 0x02,
+  secinfo_memory_compress_enum   = 0x03,
+  secinfo_invalid_enum      = 0x04
+} secinfo_section_enum;
+
+#define secinfo_enum_size  secinfo_invalid_enum
+
+/* Header for all secinfo structures */
+typedef union secinfo_union *secinfo_next_type;
+
+/* List to handle BFD sections associated to a secinfo
+   table entry. */
+typedef struct secinfo_bfd_section_struct {
+  struct secinfo_bfd_section_struct *next;
+  asection *bfd_section;
+} secinfo_bfd_section_type;
+
+typedef struct {
+  secinfo_next_type         next;
+  secinfo_bfd_section_type *sections;
+  bfd_vma                   dot;
+  secinfo_section_enum      type;
+} secinfo_header_type;
+
+/* Define a structure to handle a compress in memory element */
+typedef struct {
+  secinfo_header_type header;
+  bfd_vma             start_address;
+  bfd_size_type       size;
+  bfd_size_type       compressed_size;
+  bfd_vma             load_address;
+  bfd_vma             algo_vma;
+  char *              algo_name;
+  char *              algo_proc_name;
+} secinfo_memory_compress_type;
+typedef secinfo_memory_compress_type secinfo_rfile_compress_type;
+
+/* Define a structure to handle a data in memory element */
+typedef struct {
+  secinfo_header_type header;
+  bfd_vma             start_address;
+  bfd_size_type       size;
+  bfd_vma             load_address;
+} secinfo_memory_data_type;
+typedef secinfo_memory_data_type secinfo_rfile_data_type;
+
+typedef unsigned int secinfo_fill_type;
+
+/* Define a structure to handle a bss in memory element */
+typedef struct {
+  secinfo_header_type header;
+  bfd_vma             start_address;
+  bfd_size_type       size;
+  secinfo_fill_type   fill;
+} secinfo_memory_bss_type;
+typedef secinfo_memory_bss_type secinfo_rfile_bss_type;
+
+/* Define a structure to handle the end of table */
+typedef struct {
+  secinfo_header_type header;
+} secinfo_end_of_table_type;
+
+/* Define the global structure */
+typedef union secinfo_union{
+  secinfo_next_type         next;
+  secinfo_header_type       header;
+  secinfo_memory_compress_type  memory_comp;
+  secinfo_memory_data_type  memory_data;
+  secinfo_memory_bss_type   memory_bss;
+  secinfo_end_of_table_type end_of_table;
+} secinfo_union_type;
+
+static int secinfo_union_sizeof[] = {
+  sizeof(secinfo_end_of_table_type),
+  sizeof(secinfo_memory_bss_type),
+  sizeof(secinfo_memory_data_type),
+  sizeof(secinfo_memory_compress_type),
+};
+
+/* List of secinfo table type */
+typedef struct secinfo_list_struct {
+  struct secinfo_list_struct *next;
+  secinfo_union_type         *head;
+  secinfo_union_type        **tail;
+  bfd_size_type               size;
+} secinfo_list_type;
+
+/* Manage list of secinfo table list to detect
+   loop. */
+typedef struct {
+  secinfo_list_type *head;
+  secinfo_list_type **tail;
+} secinfo_listall_type;
+
+/* Structure below handles the list of output sections that
+   are reported to be initialized by startup file. */
+typedef struct _output_section{
+  struct _output_section             *next;
+  secinfo_section_enum type;
+  lang_output_section_statement_type *statement;
+} output_section_type;
+
+
+/* Variable indicates the current secinfo table location
+   within the application.
+   Note: only one secinfo table exists within the application. */
+static lang_secinfo_table_statement_type *secinfo_table_statement = NULL;
+
+static output_section_type *output_section_list = NULL;
+
+/* Variable indicates the original address of the generated
+   part of the secinfo table. */
+static bfd_vma secinfo_table_dot = 0;
+
+/* Variable indicates the size of the secinfo to be.
+   This variable is ONLY updated when a loop is detected.
+   (see also secinfo_listall_detect_loop). */
+static bfd_size_type secinfo_table_size = 0;
+
+/* Variable handling the last secinfo list computed */
+static secinfo_list_type *last_secinfo_table = NULL;
+
+/* Number of times we have looped to get the right
+   secinfo table content. */
+static int secinfo_loop_counter = 0;
+
+/* Variable handling whether secinfo generation
+   has detected a loop or not (used as a static variable
+   to print information about this detection in
+   map file. */
+static bfd_boolean secinfo_loop_detected = FALSE;
+
+/* Maximum number loop before aborting the generation
+   process. */
+#define SECINFO_MAX_LOOP_COUNTER          50
+
+
+/* Allocation of memory within this file is handled by
+   an obstack structure. */
+static PTR
+secinfo_alloc (size_t size)
+{
+  return obstack_alloc (&${EMULATION_NAME}_obstack, size);
+}
+
+/* Check whether a BFD section of output contains the secinfo table or not. */
+static bfd_boolean
+bfd_section_has_secinfo_table(asection *section)
+{
+  if ((!config.build_secinfo_table) || (lang_secinfo_table_statement == NULL))
+    return FALSE;
+
+  return (strcmp(bfd_section_name(bfd_section_bfd(section), section),
+                 bfd_section_name(bfd_section_bfd(lang_secinfo_table_statement->output_section),lang_secinfo_table_statement->output_section)) == 0
+          ? TRUE : FALSE);
+}
+
+static bfd_vma
+output_section_get_vma(const output_section_type *secinfo)
+{
+  switch (secinfo->type)
+    {
+    case secinfo_memory_data_enum:
+    case secinfo_memory_bss_enum:
+    case secinfo_memory_compress_enum:
+      return bfd_section_vma(bfd_section_bfd(secinfo->statement->bfd_section),
+                             secinfo->statement->bfd_section);
+    case secinfo_end_of_table_enum:
+      return ~0;
+    case secinfo_invalid_enum:
+      break;
+    }
+  ABORT();
+}
+
+static bfd_vma
+output_section_get_lma(const output_section_type *secinfo)
+{
+  switch (secinfo->type)
+    {
+    case secinfo_memory_data_enum:
+    case secinfo_memory_bss_enum:
+    case secinfo_memory_compress_enum:
+      return bfd_section_lma(bfd_section_bfd(secinfo->statement->bfd_section),
+                             secinfo->statement->bfd_section);
+    case secinfo_end_of_table_enum:
+      return ~0;
+    case secinfo_invalid_enum:
+      break;
+    }
+  ABORT();
+}
+
+
+static int
+compare_output_section(const output_section_type *s1,
+                       const output_section_type *s2)
+{
+  bfd_vma vma1, vma2;
+  bfd_vma lma1, lma2;
+
+  vma1 = output_section_get_vma(s1);
+  vma2 = output_section_get_vma(s2);
+
+  if (vma1 != vma2)
+    return (vma1 > vma2 ? 1 : -1);
+
+  lma1 = output_section_get_lma(s1);
+  lma2 = output_section_get_lma(s2);
+
+  return (lma1 > lma2 ? 1 : (lma1 == lma2 ? 0 : -1));
+}
+
+/* Insert a key into the list of output section
+   to be included into the secinfo table. */
+static void
+insert_output_section(output_section_type *new)
+{
+  output_section_type **cursor = &output_section_list;
+
+  /* Looking where the secinfo entry must be inserted */
+  while ((*cursor) && (compare_output_section(new, *cursor) > 0))
+    cursor = &(*cursor)->next;
+
+  new->next = *cursor;
+  *cursor   = new;
+}
+
+
+/* Initialize the list of section to include in the list
+   of section to initialize. */
+static void
+insert_relevant_output_section(bfd *abfd ATTRIBUTE_UNUSED,
+                              asection *section,
+                              PTR object ATTRIBUTE_UNUSED)
+{
+  secinfo_section_enum                type     = secinfo_invalid_enum;
+  bfd_boolean                             is_valid = FALSE;
+  output_section_type                *new;
+  lang_output_section_statement_type *os;
+
+  /* Debug section is not relevant for us, neither to compute
+     secinfo table content, nor for program header fixing. */
+  if (flag_has_one_of(bfd_get_section_flags(abfd, section), SEC_DEBUGGING))
+    return;
+
+  do
+    {
+      if (bfd_section_size(abfd, section) == 0)
+        /* This is an empty section: nothing to be done with it. */
+        break;
+
+
+      os = lang_output_section_statement_lookup(bfd_section_name(abfd, section), 0 , TRUE);
+      if (os->secattr & SECATTR_NOINIT)
+        /* End-user force linker to not integrated this section into
+           its initialization process. */
+        break;
+
+      if (((bfd_get_section_flags(abfd, section) & ~SEC_NEVER_LOAD) == SEC_ALLOC)
+         || (os->secattr & SECATTR_CLEAR))
+        /* Found a bss section in memory */
+        type = secinfo_memory_bss_enum;
+      else if (os->algo_name)
+      {
+        type = secinfo_memory_compress_enum;
+      }
+      else if ((bfd_section_vma(abfd, section) == bfd_section_lma(abfd, section))
+               || flag_has_one_of(bfd_get_section_flags(abfd, section), SEC_NEVER_LOAD))
+        /* This section have its data at its virtual memory
+           address or it is not loadable: no initialization is
+           required for such data. */
+        break;
+
+      else if ( flag_has_all(bfd_get_section_flags(abfd, section), SEC_ALLOC | SEC_LOAD) )
+       /* Found a data section in memory */
+        type = secinfo_memory_data_enum;
+
+      /* Check that the section to initialize does not contain
+         the secinfo table itself. If so, then exit with an error
+         because it is not allowed. */
+      if (bfd_section_has_secinfo_table(section))
+        einfo("%P%F: Illegal use of CREATE_SECINIT_TABLE\n");
+
+      /* If we are here, it is because we have found a new section
+         to insert to the list of output section to initialized. */
+      switch (type)
+        {
+        case secinfo_memory_data_enum:
+        case secinfo_memory_bss_enum:
+       case secinfo_memory_compress_enum:
+          is_valid = TRUE;
+          break;
+        default: break;
+        }
+      if (is_valid == FALSE)
+        break;
+
+      /* Create the new entry */
+      new                  = (output_section_type *)secinfo_alloc(sizeof(output_section_type));
+      new->statement  = os;
+      new->type       = type;
+
+      /* Insert the newly created entry into the list of output
+         sections to be inserted in the secinfo table. */
+      insert_output_section(new);
+    }
+  while (FALSE);
+
+}
+
+static void
+create_output_section_list (void)
+{
+  static bfd_boolean initialized = FALSE;
+
+  if (initialized == TRUE)
+    return;
+
+  initialized = TRUE;
+
+  /* Create array: number of elements is at more the number of
+     output sections defined in the output_bfd object.
+     FIXME: The last element has the field 'output_section_statement'
+     set to NULL, because the number of element of the array is not
+     exactly the number of output section, because debug sections
+     are ignored. */
+  bfd_map_over_sections(link_info.output_bfd, insert_relevant_output_section, (PTR) NULL);
+}
+
+/* Get the size of an entry (depending on its type) on
+   the target machine. */
+static bfd_size_type
+secinfo_get_sizeof_on_target(secinfo_union_type *entry)
+{
+  switch (entry->header.type)
+    {
+    case secinfo_end_of_table_enum:
+      return 0;
+    case secinfo_memory_data_enum:
+      return 16;
+    case secinfo_memory_bss_enum:
+      return 12;
+    case secinfo_memory_compress_enum:
+      return 28;
+    default :
+      ABORT();
+    }
+  return 0;
+}
+
+/* Update secinfo table i.e. update the DOT field of header of each element. */
+static bfd_vma
+update_secinfo(secinfo_list_type *table,
+                      bfd_vma dot)
+{
+  secinfo_union_type *entry;
+
+  for (entry = table->head;
+       entry;
+       entry = entry->next)
+    {
+      entry->header.dot = dot;
+      dot += secinfo_get_sizeof_on_target(entry);
+    }
+
+  return dot;
+}
+
+/* Check whether two secinfo entries are equals
+   (return TRUE) or not (return FALSE). */
+static bfd_boolean
+secinfo_union_equals(secinfo_union_type *s1,
+                     secinfo_union_type *s2)
+{
+  /* FIXME: Memory comparison should not check next pointer
+     located at the beginning of all structures, because
+     the four first bytes will always be different, and memcmp
+     return non zero, and linker loop indefinitely.
+     So, we MUST get the address of the first relevant
+     information of a secinfo element structure. */
+
+  /* First compare header */
+  if (s1->header.type != s2->header.type)
+    return FALSE;
+
+  /* Compare addresses */
+  if (s1->header.dot != s2->header.dot)
+    return FALSE;
+
+  /* Second compare the two structures, i.e. just
+     compare memory content. */
+  switch (s1->header.type)
+    {
+    case secinfo_end_of_table_enum:
+    case secinfo_memory_compress_enum:
+    case secinfo_memory_data_enum:
+    case secinfo_memory_bss_enum:
+
+      if (memcmp((char *)s1 + sizeof(secinfo_header_type),
+                 (char *)s2 + sizeof(secinfo_header_type),
+                 secinfo_union_sizeof[s1->header.type] - sizeof(secinfo_header_type)))
+        return FALSE;
+      break;
+    default:
+      ABORT();
+    }
+
+  return TRUE;
+}
+
+/* Check whether two lists are identical or not. */
+static bfd_boolean
+secinfo_list_equals(secinfo_list_type *list1,
+                    secinfo_list_type *list2)
+{
+  secinfo_union_type *ns, *os;
+
+  if ( (list1 == (secinfo_list_type *)0)
+       && (list2 == (secinfo_list_type *)0) )
+    return TRUE;
+
+  if ( (list1 == (secinfo_list_type *)0)
+       || (list2 == (secinfo_list_type *)0) )
+    return FALSE;
+
+  /* Check whether the new secinfo table and old secinfo
+     table are identical or not. */
+  ns = list1->head;
+  os = list2->head;
+  while (ns && os && secinfo_union_equals(ns, os))
+    {
+      ns = ns->next;
+      os = os->next;
+    }
+
+  if (ns || os)
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Detect loop from all list already computed. */
+static bfd_boolean
+secinfo_listall_detect_loop(secinfo_list_type *table,
+                            secinfo_listall_type *tables)
+{
+  secinfo_list_type *cursor;
+
+  if (tables == NULL)
+    return FALSE;
+
+  for (cursor = tables->head; cursor; cursor = cursor->next)
+    {
+      if (secinfo_list_equals(cursor, table))
+        {
+          secinfo_table_size = cursor->size;
+          for (cursor = cursor->next; cursor; cursor=cursor->next)
+            if (cursor->size > secinfo_table_size)
+              secinfo_table_size = cursor->size;
+
+          SECINFO_TRACE (("[%02d] Loop detected: force secinfo table size to %d bytes\n",
+                          secinfo_loop_counter,
+                          secinfo_table_size));
+
+          secinfo_loop_detected = TRUE;
+          return TRUE;
+        }
+    }
+
+  return FALSE;
+}
+
+/* Create an entry in the list of a BFD section
+   [ASECTION]. */
+
+static inline secinfo_bfd_section_type *
+secinfo_new_bfd_section(secinfo_bfd_section_type *list,
+                        asection *bfd_section)
+{
+  secinfo_bfd_section_type *cursor;
+  secinfo_bfd_section_type *new;
+
+  if (bfd_section == 0)
+    return list;
+
+  new = (secinfo_bfd_section_type *)secinfo_alloc(sizeof(secinfo_bfd_section_type));
+
+  new->bfd_section = bfd_section;
+  new->next        = (secinfo_bfd_section_type *)0;
+
+  if (list == 0)
+    return new;
+
+  /* Append the new born object to the list of
+     bfd sections. */
+  cursor = list;
+  while (cursor->next)
+    cursor = cursor->next;
+  cursor->next = new;
+
+  return list;
+}
+
+/* Append a list OTHER to the list LIST. */
+static inline secinfo_bfd_section_type *
+secinfo_append_bfd_section(secinfo_bfd_section_type *list,
+                           secinfo_bfd_section_type *other)
+{
+  secinfo_bfd_section_type *cursor;
+
+  for (cursor = other; cursor; cursor = cursor->next)
+    list = secinfo_new_bfd_section(list, cursor->bfd_section);
+
+  return list;
+}
+
+/* Create a secinfo table entry and set the header
+   according to parameters given in argument. */
+static secinfo_union_type *
+secinfo_new_element(secinfo_section_enum type,
+                    asection *bfd_section)
+{
+  secinfo_union_type *new = (secinfo_union_type *)secinfo_alloc (secinfo_union_sizeof[type]);
+
+  new->header.type     = type;
+  new->header.sections = secinfo_new_bfd_section(0, bfd_section);
+
+  return new;
+}
+
+/* Initialize a secinfo list */
+static void
+secinfo_list_init (secinfo_list_type *list)
+{
+  list->head = (secinfo_union_type *)0;
+  list->tail = &list->head;
+  list->next = (secinfo_list_type *)0;
+}
+
+/* Append a secinfo union type at the end of a list. */
+static secinfo_union_type *
+secinfo_list_append (secinfo_list_type *list,
+                     secinfo_union_type *new)
+{
+  *list->tail = new;
+  list->tail = &new->next;
+  new->next = (secinfo_union_type *)0;
+  return new;
+}
+
+static bfd_boolean
+secinfo_is_new(secinfo_list_type *table)
+{
+  static secinfo_listall_type *secinfo_tables     = NULL;
+
+  /* Check whether the new secinfo table and old secinfo
+     table are identical or not. */
+  if (secinfo_list_equals(table, last_secinfo_table))
+    /* Nothing changed */
+    return FALSE;
+
+  /* Check whether a loop has been detected */
+  last_secinfo_table = table;
+  if (secinfo_listall_detect_loop(last_secinfo_table, secinfo_tables))
+    /* Remove all referenced to previously computed
+       secinfo tables. */
+    secinfo_tables = NULL;
+
+  /* Append the secinfo table content found to the
+     list of already computed secinfo table. */
+  if (secinfo_tables == NULL)
+    {
+      secinfo_tables = (secinfo_listall_type *)secinfo_alloc(sizeof(*secinfo_tables));
+      secinfo_tables->head = NULL;
+      secinfo_tables->tail = &secinfo_tables->head;
+    }
+
+  *secinfo_tables->tail = last_secinfo_table;
+  secinfo_tables->tail  = &last_secinfo_table->next;
+
+  return TRUE;
+}
+
+/* --------------------------------------------------------------- */
+/* Optimize a secinfo table content to reduce its content.
+   Try to merge subsequent entries in the table that describe
+   a subsequent memory area initialization.
+   Level 1: merging subsequent bss and data-like sections sections.
+   Level 2: create 'rfile_set' entries when subsequent 'rfile_bss'
+            entries have a maxium size under which it is better
+            to create a 'rfile_set' entries instead of keeping
+            an 'rfile_bss' entry. */
+
+#if 0
+/* Disable optim because we can not recognize the section any more if it's
+   entry is merged with another one */
+
+static bfd_boolean
+optimize_secinfo(secinfo_union_type *entry)
+{
+  bfd_boolean has_optimization = FALSE;
+  secinfo_union_type *next_entry;
+
+  while (entry)
+    {
+      next_entry = entry->next;
+
+      switch (entry->header.type)
+        {
+        case secinfo_memory_data_enum:
+
+          if ((entry->header.type == next_entry->header.type)
+              && (entry->memory_data.start_address + entry->memory_data.size
+                  == next_entry->memory_data.start_address)
+              && (entry->memory_data.load_address + entry->memory_data.size
+                  == next_entry->memory_data.load_address))
+            {
+              /* This section can be merged with the previous one, because
+                 start and load address are consecutive in memory.
+                 Just increase its size. */
+              entry->memory_data.size += next_entry->memory_data.size;
+
+              goto two_entries_merged;
+            }
+
+          break;
+
+        case secinfo_memory_bss_enum:
+
+          if ((entry->header.type == next_entry->header.type)
+              && (entry->memory_bss.start_address + entry->memory_bss.size
+                  == next_entry->memory_bss.start_address)
+              && (entry->memory_bss.fill == next_entry->memory_bss.fill))
+            {
+              /* This section can be merged with the previous one, because
+                 start address are consecutive in memory and fill value are
+                 identical.
+                 Just increase its size and append the current section name
+                 to the list of section. */
+              entry->memory_bss.size += next_entry->memory_bss.size;
+
+              goto two_entries_merged;
+            }
+
+          break;
+        case secinfo_memory_compress_enum:
+        case secinfo_end_of_table_enum:
+
+          break;
+
+        default:
+
+	  ABORT();
+
+        }
+
+      /* Advance to the next entry available.
+         Assuming that the no optimization have been done for this entry. */
+      entry = next_entry;
+      continue;
+
+    two_entries_merged:
+      entry->header.sections = secinfo_append_bfd_section
+        (entry->header.sections,entry->next->header.sections);
+      entry->next = entry->next->next;
+
+      /* We continue instead of breaking because the current entry
+         can be merge with more than one subsequent entries. */
+      has_optimization = TRUE;
+    }
+
+  return has_optimization;
+}
+#endif
+
+/* --------------------------------------------------------------- */
+/* Get the next secinfo table. Compute it using the following
+   algorithm:
+   (1) build chaining list that merge successive memory
+   .   space that have the same type and are consecutive,
+   (2) call a callback of targetted chips to update the
+   .   'dot' field of all elements and update the list if
+   .   needed. */
+static secinfo_list_type * secinfo_get_next_table(void);
+static secinfo_list_type *
+secinfo_get_next_table(void)
+{
+  bfd_vma dot;
+
+  secinfo_list_type  *table;
+  secinfo_union_type *entry;
+
+ output_section_type *section;
+  register asection *bfd_section;
+
+  /* Create a new secinfo table */
+  table = (secinfo_list_type *)secinfo_alloc(sizeof(*table));
+  secinfo_list_init (table);
+
+  /* Increase the loop counter against secinfo table
+     generation. */
+  if (++secinfo_loop_counter == SECINFO_MAX_LOOP_COUNTER)
+    /* Reached the end of secinfo table loop counter.
+       Abort or print an error message to the end-user. */
+    einfo ("%P%F: unable to get secinfo table\n"
+           "Try to link with --no-secinfo-table\n");
+
+  /* Build the table */
+  SECINFO_TRACE (("*** Generation pass #%d ***\n", secinfo_loop_counter));
+
+  /* Build the generic part of the table. */
+  if (output_section_list)
+    {
+      entry = (secinfo_union_type *)0;
+
+      for (section = output_section_list;
+           section;
+           section = section->next)
+        {
+          switch (section->type)
+            {
+            case secinfo_memory_compress_enum:
+
+              bfd_section = section->statement->bfd_section;
+              entry = secinfo_list_append(table,
+                      secinfo_new_element(section->type,bfd_section));
+
+              entry->memory_comp.start_address =
+                                     bfd_section_vma(bfd_section_bfd
+                                     (bfd_section), bfd_section);
+              entry->memory_comp.size         =
+                                     bfd_section_size(bfd_section_bfd
+                                     (bfd_section), bfd_section);
+              entry->memory_comp.load_address  =
+                                     bfd_section_lma(bfd_section_bfd
+                                     (bfd_section), bfd_section);
+              entry->memory_comp.algo_name = section->statement->algo_name;
+              entry->memory_comp.algo_proc_name = section->statement->algo_proc_name;
+              entry->memory_comp.algo_vma = 0;
+              entry->memory_comp.compressed_size = 0;
+              break;
+
+            case secinfo_memory_data_enum:
+
+              bfd_section = section->statement->bfd_section;
+              entry = secinfo_list_append(table,
+                      secinfo_new_element(section->type,bfd_section));
+
+              entry->memory_data.start_address = bfd_section_vma(bfd_section_bfd
+                                                 (bfd_section), bfd_section);
+              entry->memory_data.size         = bfd_section_size(bfd_section_bfd
+                                                (bfd_section), bfd_section);
+              entry->memory_data.load_address  = bfd_section_lma(bfd_section_bfd
+                                                 (bfd_section), bfd_section);
+              break;
+
+            case secinfo_memory_bss_enum:
+
+              bfd_section = section->statement->bfd_section;
+              entry = secinfo_list_append(table,secinfo_new_element
+                      (section->type, bfd_section));
+
+              entry->memory_bss.start_address = bfd_section_vma(bfd_section_bfd
+                                                (bfd_section), bfd_section);
+              entry->memory_bss.size          = bfd_section_size(bfd_section_bfd
+                                                (bfd_section), bfd_section);
+              entry->memory_bss.fill          = 0;
+
+              break;
+
+            case secinfo_end_of_table_enum:
+
+	      break;
+
+            default:
+
+              ABORT();
+
+            }
+        }
+    }
+  else
+    secinfo_loop_counter--;
+
+  secinfo_list_append(table, secinfo_new_element(secinfo_end_of_table_enum, 0));
+
+  /* Optimizing the secinfo table */
+  /* Disable optim because we can not recognize the section any more if it'
+     entrey is merged with another one */
+//  optimize_secinfo(table->head);
+
+  /* Build the specific part of the table, i.e. call a callback
+     implemented for a specific chips.
+     Is in charge to update the 'DOT' field of header part of
+     all entries. */
+  dot = update_secinfo(table, secinfo_table_dot);
+
+  /* Computed size of the table */
+  table->size  = dot - secinfo_table_dot;
+
+#if defined(SECINFO_DEBUG)
+  for (entry = table->head; entry; entry = entry->next)
+    {
+      secinfo_bfd_section_type *section;
+
+      switch (entry->header.type)
+        {
+        case secinfo_memory_compress_enum:
+          SECINFO_TRACE (("[%02d] %08x MCOMPRESS   = { _start = %08lx, _size = %08x,_load = %08lx }",
+                          secinfo_loop_counter-1,
+                          entry->header.dot,
+                          entry->memory_data.start_address,
+                          entry->memory_data.size,
+                          entry->memory_data.load_address));
+          break;
+        case secinfo_memory_data_enum:
+          SECINFO_TRACE (("[%02d] %08x MDATA   = { _start = %08lx, _size = %08x,_load = %08lx }",
+                          secinfo_loop_counter-1,
+                          entry->header.dot,
+                          entry->memory_data.start_address,
+                          entry->memory_data.size,
+                          entry->memory_data.load_address));
+          break;
+        case secinfo_memory_bss_enum:
+          SECINFO_TRACE (("[%02d] %08x MBSS    = { _start = %08lx, _size = %08x,_fill = %08x }",
+                          secinfo_loop_counter-1,
+                          entry->header.dot,
+                          entry->memory_bss.start_address,
+                          entry->memory_bss.size,
+                          entry->memory_bss.fill));
+          break;
+        case secinfo_end_of_table_enum:
+          SECINFO_TRACE (("[%02d] %08x END",
+                          secinfo_loop_counter-1,
+                          entry->header.dot));
+          break;
+        default:
+          ABORT();
+        }
+
+      for (section = entry->header.sections;
+           section;
+           section = section->next)
+        SECINFO_TRACE ((" <%s(%s)>",
+                        bfd_section_name(bfd_section_bfd(section->bfd_section),section->bfd_section), "Filename"));
+/*                        bfd_get_filename(bfd_section_bfd(section->bfd_section))));
+*/
+
+
+      SECINFO_TRACE (("\n"));
+    }
+#endif
+
+  SECINFO_TRACE (("[%02d] %08x %d bytes length\n",
+                  secinfo_loop_counter-1,
+                  dot,
+                  table->size));
+
+  return table;
+}
+
+/*****************************************************************
+ * Return the secinfo table computed by the last after_assignment
+ * called.
+ */
+#include <stdio.h>
+
+
+static void
+gld${EMULATION_NAME}_get_secinfo_table_content (lang_secinfo_table_statement_type *stmt, bfd_vma dot)
+{
+  secinfo_union_type *secinfo;
+  lang_statement_list_type *current = stat_ptr;
+  fill_type *fill;
+  unsigned int val;
+  unsigned int total_table_size;
+
+  secinfo_table_statement = stmt;
+  secinfo_table_dot       = dot;
+
+  lang_list_init (&stmt->content);
+  SECINFO_TRACE(("Get table\n"));
+
+  if (last_secinfo_table == (secinfo_list_type *)0)
+    secinfo_is_new(secinfo_get_next_table());
+
+  stat_ptr = &stmt->content;
+
+  if (last_secinfo_table->size != 0) {
+    fill = (fill_type *) xmalloc (4 + sizeof (*fill) - 1);
+    val = 0;
+    fill->data[0] = (val >> 24) & 0xff;
+    fill->data[1] = (val >> 16) & 0xff;
+    fill->data[2] = (val >>  8) & 0xff;
+    fill->data[3] = (val >>  0) & 0xff;
+    fill->size = 4;
+
+    lang_add_fill (fill);
+    lang_add_assignment(exp_assign(".",
+                        exp_unop(ALIGN_K,exp_intop(4)) ));
+  }
+
+  total_table_size = 0;
+  for (secinfo = last_secinfo_table->head; secinfo; secinfo = secinfo->next) {
+    switch (secinfo->header.type) {
+      case secinfo_memory_compress_enum:
+      case secinfo_memory_bss_enum:
+      case secinfo_memory_data_enum:
+      {
+        total_table_size++;
+        break;
+      }
+      default:
+        break;
+    }
+  }
+
+  lang_add_data(LONG, exp_intop(total_table_size));
+  lang_add_assignment(exp_assign("__stm_binit_table", exp_nameop(NAME, ".")));
+  for (secinfo = last_secinfo_table->head; secinfo; secinfo = secinfo->next) {
+    /* Ensure that type is align on a word */
+    switch (secinfo->header.type) {
+      case secinfo_memory_compress_enum:
+      {
+        secinfo_memory_compress_type *s = &secinfo->memory_comp;
+        struct bfd_link_hash_entry *h;
+        bfd_vma algo_vma = 0;
+        char * p;
+
+        h = bfd_link_hash_lookup(link_info.hash, s->algo_proc_name, FALSE, FALSE, FALSE);
+        if ((h == NULL) || (h->type == bfd_link_hash_undefined))
+        {
+          if (config.get_decompression_code) {
+            einfo (_("%P: warning: decompression algorithm %s undefined\n"), s->algo_proc_name);
+          }
+        } else {
+          algo_vma = h->u.def.value + h->u.def.section->output_offset
+                                    + h->u.def.section->output_section->vma;
+        }
+        lang_add_data(LONG, exp_intop(secinfo->header.type));
+        lang_add_data(LONG, exp_intop(s->start_address));
+        lang_add_data(LONG, exp_intop(s->load_address));
+        lang_add_data(LONG, exp_intop(s->size));
+        lang_add_data(LONG, exp_intop(s->compressed_size));
+        for (p=s->algo_name; (p-s->algo_name)<MAX_NAME_LEN; p++) {
+          lang_add_data(BYTE, exp_intop(*p));
+        }
+        lang_add_data(LONG, exp_intop(algo_vma));
+        lang_add_data(LONG, exp_intop(0)); /* status of initialisation */
+        break;
+      }
+      case secinfo_memory_data_enum:
+      {
+        secinfo_memory_data_type *s = &secinfo->memory_data;
+        lang_add_data(LONG, exp_intop(secinfo->header.type));
+        lang_add_data(LONG, exp_intop(s->start_address));
+        lang_add_data(LONG, exp_intop(s->load_address));
+        lang_add_data(LONG, exp_intop(s->size));
+        lang_add_data(LONG, exp_intop(0)); /* status of initialisation */
+        break;
+      }
+      case secinfo_memory_bss_enum:
+      {
+        secinfo_memory_bss_type *s = &secinfo->memory_bss;
+        lang_add_data(LONG, exp_intop(secinfo->header.type));
+        lang_add_data(LONG, exp_intop(s->start_address));
+        lang_add_data(LONG, exp_intop(s->size));
+        lang_add_data(LONG, exp_intop(0)); /* status of initialisation */
+        break;
+      }
+      default:
+        break;
+      }
+  }
+  lang_add_assignment(exp_assign("__stm_einit_table", exp_nameop(NAME, ".")));
+
+  stat_ptr = current;
+}
+
+/* Print the secinfo table content, as it will be dumped
+   in the application. */
+static void dump_map_secinfo_table (void);
+static void
+dump_map_secinfo_table (void)
+{
+  unsigned int ix = 0;
+  secinfo_union_type *s;
+
+  print_nl ();
+  minfo ("Section Initialization Table\n");
+  print_nl ();
+
+  if (config.build_secinfo_table == FALSE)
+    {
+      minfo ("Not generated.\n");
+      return;
+    }
+
+  minfo ("Generation required %u %s",
+         secinfo_loop_counter,
+         (secinfo_loop_counter > 1 ? "loops" : "loop"));
+  if (secinfo_loop_detected)
+    minfo (" [loop detected]");
+  minfo (".\n");
+  print_nl ();
+  minfo ("Idx  Address   Type   Memory    Length    VMA       LMA       ALGO_VMA  ALGO_NAME");
+  print_nl ();
+
+  if (last_secinfo_table)
+    {
+      for (s = last_secinfo_table->head;
+           s;
+           s = s->next, ix++)
+        {
+          fprintf (config.map_file,
+                   "%3u  %08lx  ",
+                   ix,
+                   (unsigned long)s->header.dot);
+
+          switch (s->header.type)
+            {
+            case secinfo_end_of_table_enum:
+              fprintf (config.map_file,
+                       "end");
+              break;
+            case secinfo_memory_compress_enum:
+              fprintf (config.map_file,
+                       "comp   memory    %08lx  %08lx  %08lx  %08lx  %s",
+                       (unsigned long)s->memory_comp.size,
+                       (unsigned long)(s->memory_comp.start_address),
+                       (unsigned long)(s->memory_comp.load_address),
+                       (unsigned long)s->memory_comp.algo_vma,
+                       s->memory_comp.algo_name);
+              break;
+            case secinfo_memory_data_enum:
+              fprintf (config.map_file,
+                       "copy   memory    %08lx  %08lx  %08lx",
+                       (unsigned long)s->memory_data.size,
+                       (unsigned long)(s->memory_data.start_address),
+                       (unsigned long)(s->memory_data.load_address));
+              break;
+            case secinfo_memory_bss_enum:
+              fprintf (config.map_file,
+                       "clear  memory    %08lx  %08lx        %2x",
+                       (unsigned long)s->memory_bss.size,
+                       (unsigned long)(s->memory_bss.start_address),
+                       s->memory_bss.fill);
+              break;
+            default:
+              ABORT();
+            }
+          print_nl ();
+        }
+      print_nl ();
+    }
+  else
+    {
+      /* Table is empty */
+      ABORT();
+    }
+}
+
+/* Callback routine implementation */
+static void
+gld${EMULATION_NAME}_after_assignment (bfd_boolean *again)
+{
+
+  SECINFO_TRACE(("After assignement\n"));
+  /* Create the output section list from which the secinfo table is derived. */
+  create_output_section_list ();
+
+  /* No secinfo table to create */
+  if (secinfo_table_statement == NULL)
+    return;
+
+  /* Get the next secinfo table and detect loop
+     in generation process. */
+  *again = secinfo_is_new(secinfo_get_next_table());
+
+  if ((!(*again)) && (config.map_file != NULL)) {
+    dump_map_secinfo_table ();
+  }
+}
+
 struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
 {
   ${LDEMUL_BEFORE_PARSE-gld${EMULATION_NAME}_before_parse},
   ${LDEMUL_SYSLIB-syslib_default},
   ${LDEMUL_HLL-hll_default},
-  ${LDEMUL_AFTER_PARSE-after_parse_default},
+//  ${LDEMUL_AFTER_PARSE-after_parse_default},
+  ${LDEMUL_AFTER_PARSE-gld${EMULATION_NAME}_after_parse},
   ${LDEMUL_AFTER_OPEN-gld${EMULATION_NAME}_after_open},
   ${LDEMUL_AFTER_ALLOCATION-gld${EMULATION_NAME}_after_allocation},
   ${LDEMUL_SET_OUTPUT_ARCH-set_output_arch_default},
@@ -2482,6 +3927,8 @@
   ${LDEMUL_LIST_OPTIONS-gld${EMULATION_NAME}_list_options},
   ${LDEMUL_RECOGNIZED_FILE-gld${EMULATION_NAME}_load_symbols},
   ${LDEMUL_FIND_POTENTIAL_LIBRARIES-NULL},
-  ${LDEMUL_NEW_VERS_PATTERN-NULL}
+  ${LDEMUL_NEW_VERS_PATTERN-NULL},
+  ${LDEMUL_GET_SECINFO_TABLE_CONTENTS-gld${EMULATION_NAME}_get_secinfo_table_content},
+  ${LDEMUL_AFTER_ASSIGNEMENT-gld${EMULATION_NAME}_after_assignment}
 };
 EOF
diff -r -N -u binutils-2.21.51/ld/emultempl/elf-generic.em binutils/ld/emultempl/elf-generic.em
--- binutils-2.21.51/ld/emultempl/elf-generic.em	2010-02-23 12:32:54.000000000 +0000
+++ binutils/ld/emultempl/elf-generic.em	2010-06-07 14:41:42.080337000 +0100
@@ -25,6 +25,9 @@
 fragment <<EOF
 
 static void
+gld${EMULATION_NAME}_map_segments (bfd_boolean need_layout) ATTRIBUTE_UNUSED;
+
+static void
 gld${EMULATION_NAME}_map_segments (bfd_boolean need_layout)
 {
   int tries = 10;
diff -r -N -u binutils-2.21.51/ld/emultempl/lxelf.em binutils/ld/emultempl/lxelf.em
--- binutils-2.21.51/ld/emultempl/lxelf.em	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/emultempl/lxelf.em	2010-07-13 16:59:00.135910000 +0100
@@ -0,0 +1,394 @@
+# This shell script emits a C file. -*- C -*-
+#   Copyright 2004, 2008
+#   Free Software Foundation, Inc.
+#
+# This file is part of the GNU Binutils.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+#
+#
+
+# This file is sourced from elf32.em, and defines extra lx-elf
+# specific routines.
+#
+fragment <<EOF
+
+#include "ldctor.h"
+#include "libbfd.h"
+#include "elf32-lx.h"
+
+/* Fake input file for stubs.  */
+static lang_input_statement_type *stub_file;
+
+/* Whether we need to call lx_layout_sections_again.  */
+static int need_laying_out = 0;
+
+/* Maximum size of a group of input sections that can be handled by
+   one stub section.  A value of +/-1 indicates the bfd back-end
+   should use a suitable default size.  */
+static bfd_signed_vma group_size = 1;
+
+/* Whether we can transform GP-relative relocations to absolute. */
+static bfd_boolean transform_to_absolute = 1;
+
+/* This is called before the input files are opened.  We create a new
+   fake input file to hold the stub sections.  */
+
+static void
+elf_lx_create_output_section_statements (void)
+{
+  stub_file = lang_add_input_file ("linker stubs",
+				   lang_input_file_is_fake_enum,
+				   NULL);
+  stub_file->the_bfd = bfd_create ("linker stubs", link_info.output_bfd);
+  if (stub_file->the_bfd == NULL
+      || ! bfd_set_arch_mach (stub_file->the_bfd,
+			      bfd_get_arch (link_info.output_bfd),
+			      bfd_get_mach (link_info.output_bfd)))
+    {
+      einfo ("%X%P: can not create BFD %E\n");
+      return;
+    }
+
+  stub_file->the_bfd->flags |= BFD_LINKER_CREATED;
+  ldlang_add_file (stub_file);
+  lx_elf_init_stub_bfd (stub_file->the_bfd, &link_info);
+}
+
+
+struct hook_stub_info
+{
+  lang_statement_list_type add;
+  asection *input_section;
+};
+
+/* Traverse the linker tree to find the spot where the stub goes.  */
+
+static bfd_boolean hook_in_stub
+  PARAMS ((struct hook_stub_info *, lang_statement_union_type **));
+
+static bfd_boolean
+hook_in_stub (info, lp)
+     struct hook_stub_info *info;
+     lang_statement_union_type **lp;
+{
+  lang_statement_union_type *l;
+  bfd_boolean ret;
+
+  for (; (l = *lp) != NULL; lp = &l->header.next)
+    {
+      switch (l->header.type)
+	{
+	case lang_constructors_statement_enum:
+	  ret = hook_in_stub (info, &constructor_list.head);
+	  if (ret)
+	    return ret;
+	  break;
+
+	case lang_output_section_statement_enum:
+	  ret = hook_in_stub (info,
+			      &l->output_section_statement.children.head);
+	  if (ret)
+	    return ret;
+	  break;
+
+	case lang_wild_statement_enum:
+	  ret = hook_in_stub (info, &l->wild_statement.children.head);
+	  if (ret)
+	    return ret;
+	  break;
+
+	case lang_group_statement_enum:
+	  ret = hook_in_stub (info, &l->group_statement.children.head);
+	  if (ret)
+	    return ret;
+	  break;
+
+	case lang_input_section_enum:
+	  if (l->input_section.section == info->input_section)
+	    {
+	      /* We've found our section.  Insert the stub immediately
+		 after its associated input section.  */
+	      *(info->add.tail) = l->header.next;
+	      l->header.next = info->add.head;
+	      return TRUE;
+	    }
+	  break;
+
+	case lang_data_statement_enum:
+	case lang_reloc_statement_enum:
+	case lang_object_symbols_statement_enum:
+	case lang_output_statement_enum:
+	case lang_target_statement_enum:
+	case lang_input_statement_enum:
+	case lang_assignment_statement_enum:
+	case lang_padding_statement_enum:
+	case lang_address_statement_enum:
+	case lang_fill_statement_enum:
+	  break;
+
+	default:
+	  FAIL ();
+	  break;
+	}
+    }
+  return FALSE;
+}
+
+
+/* Call-back for elf_lx_size_stubs.  */
+
+/* Create a new stub section, and arrange for it to be linked
+   immediately after INPUT_SECTION.  */
+
+static asection *
+elf_lx_add_stub_section (const char *stub_sec_name,
+			 asection *input_section)
+{
+  asection *stub_sec;
+  flagword flags;
+  asection *output_section;
+  const char *secname;
+  lang_output_section_statement_type *os;
+  struct hook_stub_info info;
+
+  flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
+	   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_KEEP);
+  stub_sec = bfd_make_section_anyway_with_flags (stub_file->the_bfd,
+						 stub_sec_name, flags);
+  if (stub_sec == NULL)
+    goto err_ret;
+
+  bfd_set_section_alignment (stub_file->the_bfd, stub_sec, 3);
+
+  output_section = input_section->output_section;
+  secname = bfd_get_section_name (output_section->owner, output_section);
+  os = lang_output_section_find (secname);
+
+  info.input_section = input_section;
+  lang_list_init (&info.add);
+  lang_add_section (&info.add, stub_sec, os);
+
+  if (info.add.head == NULL)
+    goto err_ret;
+
+  if (hook_in_stub (&info, &os->children.head))
+    return stub_sec;
+
+ err_ret:
+  einfo ("%X%P: can not make stub section: %E\n");
+  return NULL;
+}
+
+
+/* Another call-back for elf_lx_size_stubs.  */
+
+static void
+elf_lx_layout_sections_again (void)
+{
+  /* If we have changed sizes of the stub sections, then we need
+     to recalculate all the section offsets.  This may mean we need to
+     add even more stubs.  */
+  gld${EMULATION_NAME}_map_segments (TRUE);
+  need_laying_out = -1;
+}
+
+
+static void
+build_section_lists (lang_statement_union_type *statement)
+{
+  if (statement->header.type == lang_input_section_enum)
+    {
+      asection *i = statement->input_section.section;
+
+      if (!((lang_input_statement_type *) i->owner->usrdata)->just_syms_flag
+	  && (i->flags & SEC_EXCLUDE) == 0
+	  && i->output_section != NULL
+	  && i->output_section->owner == link_info.output_bfd)
+	{
+	  elf_lx_next_input_section (&link_info, i);
+	}
+    }
+}
+
+static void
+lx_elf_before_allocation (void)
+{
+
+  /* Call the standard elf routine.  */
+  gld${EMULATION_NAME}_before_allocation ();
+
+  bfd_elf32_lx_set_transform_to_absolute (&link_info, transform_to_absolute);
+}
+
+/* For the st200 we use this opportunity to size and build linker stubs.  */
+
+static void
+gld${EMULATION_NAME}_after_allocation (void)
+{
+  /* bfd_elf32_discard_info just plays with data and debugging sections,
+     ie. doesn't affect code size, so we can delay resizing the
+     sections.  It's likely we'll resize everything in the process of
+     adding stubs.  */
+  if (bfd_elf_discard_info (link_info.output_bfd, &link_info))
+    need_laying_out = 1;
+
+  /* If generating a relocatable output file, then we don't
+     have to examine the relocs.  */
+  if (stub_file != NULL && !link_info.relocatable)
+    {
+      int ret = elf_lx_setup_section_lists (link_info.output_bfd, &link_info);
+      
+      if (ret != 0)
+	{
+	  if (ret < 0)
+	    {
+	      einfo ("%X%P: can not size stub section: %E\n");
+	      return;
+	    }
+
+	  lang_for_each_statement (build_section_lists);
+
+	  /* Call into the BFD backend to do the real work.  */
+	  if (! elf_lx_size_stubs (link_info.output_bfd,
+				   stub_file->the_bfd,
+				   &link_info,
+				   group_size,
+				   &elf_lx_add_stub_section,
+				   &elf_lx_layout_sections_again))
+	    {
+	      einfo ("%X%P: can not size stub section: %E\n");
+	      return;
+	    }
+	}
+    }
+
+  if (need_laying_out != -1)
+    gld${EMULATION_NAME}_map_segments (need_laying_out);
+
+  if (! link_info.relocatable)
+    {
+      if (!elf_lx_set_gp (link_info.output_bfd, &link_info))
+	{
+	  einfo ("%X%P: cannot set gp\n");
+	  return;
+	}
+
+      /* Now build the linker stubs.  */
+      if (stub_file->the_bfd->sections != NULL)
+	{
+	  if (! elf_lx_build_stubs (&link_info))
+	    einfo ("%X%P: can not build stubs: %E\n");
+	}
+    }
+}
+
+
+/* Avoid processing the fake stub_file in vercheck, stat_needed and
+   check_needed routines.  */
+
+static void lx_for_each_input_file_wrapper
+  PARAMS ((lang_input_statement_type *));
+static void lx_lang_for_each_input_file
+  PARAMS ((void (*) (lang_input_statement_type *)));
+
+static void (*real_func) PARAMS ((lang_input_statement_type *));
+
+static void lx_for_each_input_file_wrapper (l)
+     lang_input_statement_type *l;
+{
+  if (l != stub_file)
+    (*real_func) (l);
+}
+
+static void
+lx_lang_for_each_input_file (func)
+     void (*func) PARAMS ((lang_input_statement_type *));
+{
+  real_func = func;
+  lang_for_each_input_file (&lx_for_each_input_file_wrapper);
+}
+
+#define lang_for_each_input_file lx_lang_for_each_input_file
+
+EOF
+
+# Define some shell vars to insert bits of code into the standard elf
+# parse_args and list_options functions.
+#
+PARSE_AND_LIST_PROLOGUE='
+#define OPTION_STUBGROUP_SIZE		301
+#define OPTION_TRANSFORM_TO_ABSOLUTE    302
+#define OPTION_NO_TRANSFORM_TO_ABSOLUTE 303
+'
+
+# The options are repeated below so that no abbreviations are allowed.
+# Otherwise -s matches stub-group-size
+PARSE_AND_LIST_LONGOPTS='
+  { "stub-group-size", required_argument, NULL, OPTION_STUBGROUP_SIZE },
+  { "transform-to-absolute", no_argument, NULL, OPTION_TRANSFORM_TO_ABSOLUTE },
+  { "no-transform-to-absolute", no_argument, NULL, OPTION_NO_TRANSFORM_TO_ABSOLUTE },
+'
+
+PARSE_AND_LIST_OPTIONS='
+  fprintf (file, _("\
+  --stub-group-size=N   Maximum size of a group of input sections that can\n\
+                        be handled by one stub section.  A negative\n\
+                        value locates all stubs after their branches\n\
+                        (with a group size of -N), while a positive value\n\
+                        allows two groups of input sections, one before,\n\
+                        and one after each stub section.  Values of +/-1\n\
+                        indicate the linker should choose suitable\n\
+                        defaults.\n"
+		   ));
+  fprintf (file, _("\
+  --transform-to-absolute Remove the use of the GP register from instructions\n\
+                        relocated by GP-relative and GOT relocations in an\n\
+                        absolute main program.\n\
+                        This is the default.\n"
+                   ));
+  fprintf (file, _("\
+  --no-transform-to-absolute Do not remove the use of the GP register from\n\
+                        instructions relocated by GP-relative and\n\
+                        GOT relocations in an absolute main program.\n"
+                   ));
+'
+
+PARSE_AND_LIST_ARGS_CASES='
+    case OPTION_STUBGROUP_SIZE:
+      {
+	const char *end;
+        group_size = bfd_scan_vma (optarg, &end, 0);
+        if (*end)
+	  einfo (_("%P%F: invalid number `%s'\''\n"), optarg);
+      }
+      break;
+    case OPTION_TRANSFORM_TO_ABSOLUTE:
+      transform_to_absolute = 1;
+      break;
+    case OPTION_NO_TRANSFORM_TO_ABSOLUTE:
+      transform_to_absolute = 0;
+      break;
+'
+
+# We have our own before_allocation function, but it calls the
+# standard routines, so give it a different name.
+LDEMUL_BEFORE_ALLOCATION=lx_elf_before_allocation
+
+# Put these extra lx elf routines in ld_${EMULATION_NAME}_emulation
+#
+LDEMUL_AFTER_ALLOCATION=gld${EMULATION_NAME}_after_allocation
+LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS=elf_lx_create_output_section_statements
diff -r -N -u binutils-2.21.51/ld/ipa_cmdline.c binutils/ld/ipa_cmdline.c
--- binutils-2.21.51/ld/ipa_cmdline.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/ipa_cmdline.c	2011-06-24 14:54:27.081878000 +0100
@@ -0,0 +1,766 @@
+/* THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003 */
+
+#ifdef IPA_LINK
+
+#if defined(__GNUC__)
+#include <stdio.h>		/* for sys_errlist */
+#endif
+#include <stdlib.h>		/* for getenv(3) */
+#include <unistd.h>		/* for unlink(2), rmdir(2), etc. */
+#include "libiberty.h"
+#include <sys/stat.h>		/* for chmod(2) */
+#include <fcntl.h>		/* for open(2) */
+#if defined(sun) || defined (__CYGWIN__) || defined (_WIN32)
+#include <sys/types.h>
+#include <dirent.h>
+#else
+#include <sys/dir.h>		/* for opendir(2), readdir, closedir */
+#endif
+#include <signal.h>		/* for kill(2) */
+#include <limits.h>		/* for PATH_MAX */
+#include <errno.h>
+#include <string.h>
+
+#include "aout/ar.h"
+
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "ldmisc.h"
+
+#ifdef _WIN32
+#include "dlfcn_win32.h"
+#else
+#include <dlfcn.h>
+#endif 
+
+#include "ipa_ld.h"
+#include "ipa_cmdline.h"
+
+#include "ld.h"
+
+int arg_count;			    /* argument count */
+char **arg_vector;		    /* argument vector */
+char **environ_vars;		    /* list of environment variables */
+    	    	    	    	    /* used by ipa to invoke recompilation */
+
+unsigned int max_gpa_size = 0x100000; /* gp area size, needs to more accurate */
+unsigned int used_gp_area;
+
+static int orig_iargc_size = 10;
+static char char_opt[] = {'a','A','b','c','e','f','F','G','h','l','L','m','o','O','R','T','u','y','Y','z','0'};
+
+string_t WB_flags = NULL;
+string_t Y_flags = NULL;
+
+extern string_t outfilename;
+extern void ipa_insert_whirl_obj_marker(void);
+
+/* 
+    I took the following out of /usr/include/elf.h because
+    for some reason bfd doesn't want to use it and it was
+    too complicated to use the bfd model at this time.
+    
+    This is stupid, I know.
+    
+*/
+
+/* Standard ELF types.  */
+
+#if defined(sun)
+#include <inttypes.h>
+#elif defined(__CYGWIN__)
+#ifndef _STDINT_H /* Define these types for old Cygwin */
+typedef u_int8_t uint8_t;
+typedef u_int16_t uint16_t;
+typedef u_int32_t uint32_t;
+typedef u_int64_t uint64_t;
+#endif
+#else
+#include <stdint.h>
+#endif
+
+/* Type for a 16-bit quantity.  */
+typedef uint16_t Elf32_Half;
+typedef uint16_t Elf64_Half;
+
+/* Types for signed and unsigned 32-bit quantities.  */
+typedef uint32_t Elf32_Word;
+typedef	int32_t  Elf32_Sword;
+typedef uint32_t Elf64_Word;
+typedef	int32_t  Elf64_Sword;
+
+/* Types for signed and unsigned 64-bit quantities.  */
+typedef uint64_t Elf32_Xword;
+typedef	int64_t  Elf32_Sxword;
+typedef uint64_t Elf64_Xword;
+typedef	int64_t  Elf64_Sxword;
+
+/* Type of addresses.  */
+typedef uint32_t Elf32_Addr;
+typedef uint64_t Elf64_Addr;
+
+/* Type of file offsets.  */
+typedef uint32_t Elf32_Off;
+typedef uint64_t Elf64_Off;
+
+/* Type for section indices, which are 16-bit quantities.  */
+typedef uint16_t Elf32_Section;
+typedef uint16_t Elf64_Section;
+
+/* Type of symbol indices.  */
+typedef uint32_t Elf32_Symndx;
+typedef uint64_t Elf64_Symndx;
+
+/* The ELF file header.  This appears at the start of every ELF file.  */
+
+#ifndef EI_NIDENT
+#define EI_NIDENT (16)
+#endif
+
+typedef struct
+{
+  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
+  Elf32_Half	e_type;			/* Object file type */
+  Elf32_Half	e_machine;		/* Architecture */
+  Elf32_Word	e_version;		/* Object file version */
+  Elf32_Addr	e_entry;		/* Entry point virtual address */
+  Elf32_Off	e_phoff;		/* Program header table file offset */
+  Elf32_Off	e_shoff;		/* Section header table file offset */
+  Elf32_Word	e_flags;		/* Processor-specific flags */
+  Elf32_Half	e_ehsize;		/* ELF header size in bytes */
+  Elf32_Half	e_phentsize;		/* Program header table entry size */
+  Elf32_Half	e_phnum;		/* Program header table entry count */
+  Elf32_Half	e_shentsize;		/* Section header table entry size */
+  Elf32_Half	e_shnum;		/* Section header table entry count */
+  Elf32_Half	e_shstrndx;		/* Section header string table index */
+} Elf32_Ehdr;
+
+typedef struct
+{
+  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
+  Elf64_Half	e_type;			/* Object file type */
+  Elf64_Half	e_machine;		/* Architecture */
+  Elf64_Word	e_version;		/* Object file version */
+  Elf64_Addr	e_entry;		/* Entry point virtual address */
+  Elf64_Off	e_phoff;		/* Program header table file offset */
+  Elf64_Off	e_shoff;		/* Section header table file offset */
+  Elf64_Word	e_flags;		/* Processor-specific flags */
+  Elf64_Half	e_ehsize;		/* ELF header size in bytes */
+  Elf64_Half	e_phentsize;		/* Program header table entry size */
+  Elf64_Half	e_phnum;		/* Program header table entry count */
+  Elf64_Half	e_shentsize;		/* Section header table entry size */
+  Elf64_Half	e_shnum;		/* Section header table entry count */
+  Elf64_Half	e_shstrndx;		/* Section header string table index */
+} Elf64_Ehdr;
+
+	/*******************************************************
+		Function: ipa_opt
+
+
+
+	 *******************************************************/
+static int
+ipa_opt (char **argv )
+{
+    if (ipa_argc == 0) {
+	ipa_argv = (string_t *) MALLOC (orig_iargc_size * sizeof (string_t));
+	MALLOC_ASSERT (ipa_argv);
+    }
+    else if (ipa_argc >= orig_iargc_size) {
+	orig_iargc_size *=2;
+	ipa_argv = (string_t *) REALLOC (ipa_argv, (orig_iargc_size * sizeof(string_t)));
+	MALLOC_ASSERT (ipa_argv);
+    }
+
+    ipa_argv[ipa_argc++] = ipa_copy_of(argv[0]);
+
+    return 1;
+} /* ipa_opt */
+
+/* ====================================================================
+ *
+ * add_WB_opt
+ *
+ * We have an option -WB,... to be passed to the back end via ipacom.
+ * If WB_flags is NULL, set it to this option with "-WB," stripped.
+ * Otherwise append this option with "-WB" stripped, i.e. retaining the
+ * comma separator.
+ *
+ * ====================================================================
+ */
+
+static void
+add_WB_opt (char **argv)
+{
+    char *p = *argv;
+
+    if ( WB_flags == NULL ) {
+    	WB_flags = concat_names("-Wb,",&p[3]);
+    } else {
+    	char *flg = concat_names(WB_flags,&p[3] ); /* include the comma */
+    	FREE(WB_flags);
+    	WB_flags = flg;
+  }
+
+  return;
+}
+
+
+/* ====================================================================
+ *
+ * add_Y_opt
+ *
+ * We have an option -Y... to be passed to the back end via ipacom.
+ * If Y_flags is NULL, set it to this option.  Otherwise append this
+ * option with a space delimiter.
+ *
+ * ====================================================================
+ */
+
+static void
+add_Y_opt (char **argv)
+{
+    char *p = *argv;
+
+    if ( Y_flags == NULL ) {
+    	Y_flags = ipa_copy_of(p);
+    } else {
+    	char *flg;
+	
+	flg = concat_names(Y_flags," ");
+	FREE (Y_flags);
+	Y_flags = flg;
+	
+	flg = concat_names(Y_flags,p);
+	FREE (Y_flags);
+	Y_flags = flg;
+    }
+
+    return;
+}
+
+	/*******************************************************
+		Function: check_for_whirl
+
+		Check to see if this is an ELF file and then
+		if it is a WHIRL object.
+		
+		I need to expand this to check for archives.
+
+	 *******************************************************/
+#define ET_SGI_IR   (ET_LOPROC + 0)
+static bfd_boolean
+check_for_whirl(char *name)
+{
+    int fd = -1;
+    char *raw_bits = NULL;
+    int size,bufsize;
+    Elf32_Ehdr *p_ehdr = NULL;
+    struct stat statb;
+    int test;
+    
+    fd = OPEN(name, O_RDONLY, 0755);
+    if (fd < 0)
+	return FALSE;
+
+    if ((test = fstat(fd, &statb) != 0)) {
+    	CLOSE(fd);
+	return FALSE;
+    }
+
+    if (statb.st_size < sizeof(Elf64_Ehdr)) {
+    	CLOSE(fd);
+    	return FALSE;
+    }
+    
+    bufsize = sizeof(Elf64_Ehdr);
+    
+    raw_bits = (char *)MALLOC(bufsize*4);
+    MALLOC_ASSERT(raw_bits);
+
+    size = READ(fd, raw_bits, bufsize);
+#if 0
+    if (size != statb.st_size) {
+    	CLOSE(fd);
+    	FREE(raw_bits);
+    	return FALSE;
+    }
+#endif
+    
+		/*
+		 * Check that the file is an elf executable.
+		 */
+    p_ehdr = (Elf32_Ehdr *)raw_bits;
+    if (p_ehdr->e_ident[EI_MAG0] != ELFMAG0 ||
+	p_ehdr->e_ident[EI_MAG1] != ELFMAG1 ||
+	p_ehdr->e_ident[EI_MAG2] != ELFMAG2 ||
+	p_ehdr->e_ident[EI_MAG3] != ELFMAG3) {
+	    CLOSE(fd);
+	    FREE(raw_bits);
+	    return(FALSE);
+    }
+
+    if(p_ehdr->e_ident[EI_CLASS] == ELFCLASS32){
+    	Elf32_Ehdr *p32_ehdr = (Elf32_Ehdr *)raw_bits;
+	if (p32_ehdr->e_type == ET_SGI_IR) {
+	    CLOSE(fd);
+	    FREE(raw_bits);
+	    return TRUE;
+	}
+    }
+    else {
+	Elf64_Ehdr *p64_ehdr = (Elf64_Ehdr *)raw_bits;
+	if (p64_ehdr->e_type == ET_SGI_IR) {
+	    CLOSE(fd);
+	    FREE(raw_bits);
+	    return TRUE;
+	}
+     }
+
+    CLOSE(fd);
+    FREE(raw_bits);
+    return FALSE;
+    
+ }
+
+	/*******************************************************
+		Function: needs_argument.
+
+		Determine if this option needs an argument.
+		This routine will need to change as the commandline
+		arguments change or are augmented.
+
+	 *******************************************************/
+static bfd_boolean
+needs_argument(char *string, bfd_boolean is_double_dash)
+{
+
+    int len = strlen(string);
+
+    if (is_double_dash) {
+    	if ((strcmp (string, "architecture") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "format") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "mri-script") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "entry") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "auxiliary") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "filter") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "gpsize") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "library") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "library-path") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "output") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "just-symbols") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "script") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "undefined") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "trace-symbol") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "assert") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "defsym") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "dynamic-linker") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "Map") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "oformat") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "retain-symbols-file") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "rpath-link") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "split-by-reloc") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "task-link") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "verbose") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "version-script") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "version-exports-section") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "wrap") == 0)) {
+    	    return TRUE;
+    	}
+    }
+    else {
+    	if (len == 1) {
+	    int i;
+	    int size = strlen(char_opt);
+	    for (i=0;i<size;i++) {
+	    	if (char_opt[i] == *string)
+		    return TRUE;
+	    }
+	    return FALSE;
+	}
+    	if ((strcmp (string, "soname") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "rpath") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "Tbss") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "Tdata") == 0)) {
+    	    return TRUE;
+    	}
+    	if ((strcmp (string, "Ttext") == 0)) {
+    	    return TRUE;
+    	}
+    }
+    
+    return FALSE;
+}
+
+
+	/*******************************************************
+		Function: blank_arg.
+
+		Blank out the given argument so other parts
+		of the program that read the argv don't get
+		confused.
+
+	 *******************************************************/
+static void
+blank_arg(char **argv, int ndx)
+{
+
+    int j,len;
+
+    len = strlen(argv[ndx]);
+
+#if 1
+    if (len >=3)
+    	strcpy(argv[ndx],"-g"); /* ignored by the linker */
+    else {
+    	for(j=0;j<len;j++)
+    	    argv[ndx][j] = ' ';
+    }
+#else
+    argv[ndx][0] = '\0';
+#endif
+
+}
+
+	/*******************************************************
+		Function: opt_search_command_line.
+
+		Read through the command line looking at each
+		option. If a linker commandfile is encountered
+		it will be open'ed an it's file descriptor pushed
+		on a stack of file descriptors. The contents of
+		the file will be read like options on the command
+		line.
+
+		This routine will eventually rebuild the input
+		command order to get rid of silly command order
+		errors.
+
+	 *******************************************************/
+bfd_boolean
+ipa_search_command_line(int argc,
+			char **argv,
+			char **envp
+			)
+{
+    int i;
+
+    	/*
+    	 * First check if ipa is on.
+    	 */
+    for (i=1;i<argc;i++) {
+    	char *string = argv[i];
+    	if (*string == '-') {
+	    if ((strncmp(string,"-IPA",4)) == 0) {
+	    	is_ipa = TRUE;
+		break;
+	    }
+	    else if ((strncmp(string,"--IPA",5)) == 0) {
+	    	is_ipa = TRUE;
+		break;
+	    }
+	    else if ((strcmp(string,"--ipa")) == 0) {
+	    	is_ipa = TRUE;
+		break;
+	    }
+ 	    else if ((strcmp(string,"-ipa")) == 0) {
+	    	is_ipa = TRUE;
+		break;
+	    }
+    	}
+    }
+
+    if (!is_ipa)
+    	return(FALSE);
+
+    arg_count = argc;
+    arg_vector = argv;
+    environ_vars = envp;
+
+    	/*
+	 *  The ipa.so needs to be opened and entry
+	 *  points need to be found with dlsym.
+	 */
+    ipa_set_syms();
+
+    	/*
+    	 * We need to build up the commandline options
+    	 * that will be passed to the linker/compiler during
+         * the second pass
+    	 */
+    (*p_ipa_init_link_line) (0, NULL);
+
+    for (i=1;i<argc;i++) {
+    	char *string = argv[i];
+    	if (*string == '-' && string[1] == '-') {
+	    if ((strncmp (&string[2], "ipa", strlen ("ipa")) == 0)) {
+	    	continue;
+	    }
+	    if ((strncmp (&string[2], "IPA:", strlen ("IPA:")) == 0)) {
+    	    	char *p = &argv[i][1];
+	    	ipa_opt(&p);
+		blank_arg(argv,i);
+	    	continue;
+	    }
+	    if ((strcmp (&string[2], "keep") == 0)) {
+    	    	ld_ipa_opt[LD_IPA_KEEP_TEMPS].flag = TRUE;
+		    /* Blank out argument */
+		blank_arg(argv,i);
+	    	continue;
+	    }
+	    else if ((needs_argument(&string[2],TRUE) == TRUE)) {
+	    	(*p_ipa_add_link_flag) (argv[i++]);
+		(*p_ipa_add_link_flag) (argv[i]);
+		continue;
+	    }
+	}   /* if "--" */
+	else if (*string == '-') {
+	    if ((strncmp(string,"-WB,",4)) == 0) {
+	    	add_WB_opt (&argv[i]);
+
+		    /* Blank out argument */
+		blank_arg(argv,i);
+		continue;
+	    }
+	    else if ((strncmp(string,"-Y",2)) == 0) {
+	    	add_Y_opt (&argv[i]);
+
+		    /* Blank out argument */
+		blank_arg(argv,i);
+		continue;
+	    }
+	    if ((strncmp (string, "-ipacom", strlen ("-ipacom")) == 0)) {
+		blank_arg(argv,i);
+	    	continue;
+	    }
+	    if ((strncmp (string, "-ipa", strlen ("-ipa")) == 0)) {
+		blank_arg(argv,i);
+	    	continue;
+	    }
+	    if ((strncmp (string, "-DEFAULT:", strlen ("-DEFAULT:")) == 0)) {
+	    	ipa_opt(&argv[i]);
+		blank_arg(argv,i);
+	    	continue;
+	    }
+	    if ((strncmp (string, "-IPA:", strlen ("-IPA:")) == 0)) {
+	    	ipa_opt(&argv[i]);
+		blank_arg(argv,i);
+	    	continue;
+	    }
+	    if ((strncmp (string, "-INLINE:", strlen ("-INLINE:")) == 0)) {
+	    	ipa_opt(&argv[i]);
+		blank_arg(argv,i);
+	    	continue;
+	    }
+	    if ((strncmp (string, "-INTERNAL:", strlen ("-INTERNAL:")) == 0)) {
+	    	ipa_opt(&argv[i]);
+		blank_arg(argv,i);
+	    	continue;
+	    }
+	    if ((strncmp (string, "-OPT:", strlen ("-OPT:")) == 0)) {
+	    	ipa_opt(&argv[i]);
+		blank_arg(argv,i);
+	    	continue;
+	    }
+	    if ((strncmp (string, "-TENV:", strlen ("-TENV:")) == 0)) {
+	    	ipa_opt(&argv[i]);
+		blank_arg(argv,i);
+	    	continue;
+	    }
+	    if ((strncmp (string, "-DEBUG:", strlen ("-DEBUG:")) == 0)) {
+	    	ipa_opt(&argv[i]);
+		blank_arg(argv,i);
+	    	continue;
+	    }
+	    else if ((strcmp(string,"-keep")) == 0) {
+    	    	ld_ipa_opt[LD_IPA_KEEP_TEMPS].flag = TRUE;
+
+		    /* Blank out argument */
+		blank_arg(argv,i);
+		continue;
+	    }
+	    else if ((strcmp(string,"-show")) == 0) {
+    	    	ld_ipa_opt[LD_IPA_SHOW].flag = TRUE;
+
+		    /* Blank out argument */
+		blank_arg(argv,i);
+		continue;
+	    }
+	    else if ((strcmp(string,"-demangle")) == 0) {
+    	    	ld_ipa_opt[LD_IPA_DEMANGLE].flag = TRUE;
+
+		    /* Blank out argument */
+		blank_arg(argv,i);
+		continue;
+	    }
+	    else if ((strcmp(string,"-o")) == 0) {
+    	    	outfilename = MALLOC(strlen(argv[i+1])+3);
+    	    	MALLOC_ASSERT(outfilename);
+#if 0 // [CL] remove leading ./ to allow output somewhere else
+      // than current directory
+		strcpy(outfilename,"./");
+		strcat(outfilename,argv[i+1]);
+#else
+		strcpy(outfilename,argv[i+1]);
+#endif
+	    	(*p_ipa_add_link_flag) (argv[i++]);
+		(*p_ipa_add_link_flag) (argv[i]);
+		continue;
+	    }
+	    else if ((strcmp(string,"-v")) == 0) {
+    	    	ld_ipa_opt[LD_IPA_VERBOSE].flag = TRUE;
+		/* [CL] -show is misinterpreted by pure ld,
+		   so make -v behave as -show */
+    	    	ld_ipa_opt[LD_IPA_SHOW].flag = TRUE;
+	    }
+	    	    /* Check for sgi debug tracing */
+	    else if (string[1] == 't' && strlen(string) > 3) {
+	    	ipa_opt(&argv[i]);
+
+		    /* Blank out argument */
+		blank_arg(argv,i);
+		continue;
+	    }
+	    /* [CL] support generation of a relocatable object
+	       instead of what type the user has really requested,
+	       in order to support Icacheopt tools which will
+	       call the linker once again with the right options */
+	    else if ((strcmp(string,"-produce-relocatable")) == 0) {
+    	    	ld_ipa_opt[LD_IPA_RELOCATABLE].flag = TRUE;
+
+		    /* Blank out argument */
+		blank_arg(argv,i);
+		continue;
+	    }
+	    /* [CL] support -shared, -non_shared, ... */
+	    else if ( ((strcmp(string,"-shared")) == 0) ||
+		      ((strcmp(string,"-Bshareable")) == 0) ) {
+    	    	ld_ipa_opt[LD_IPA_SHARABLE].flag = F_MAKE_SHARABLE;
+	    }
+	    else if ( ((strcmp(string,"-non_shared")) == 0) ||
+		      ((strcmp(string,"-dn")) == 0) ||
+		      ((strcmp(string,"-Bstatic")) == 0) ) {
+    	    	ld_ipa_opt[LD_IPA_SHARABLE].flag = F_NON_SHARED;
+	    }
+	    else if ( ((strcmp(string,"-call_shared")) == 0) ||
+		      ((strcmp(string,"-dy")) == 0) ||
+		      ((strcmp(string,"-Bdynamic")) == 0) ) {
+    	    	ld_ipa_opt[LD_IPA_SHARABLE].flag = F_CALL_SHARED;
+	    }
+	    else if ( ((strcmp(string,"-r")) == 0) ||
+		      ((strcmp(string,"-i")) == 0) ||
+		      ((strcmp(string,"--relocateable")) == 0) ) {
+    	    	ld_ipa_opt[LD_IPA_SHARABLE].flag = F_RELOCATABLE;
+	    }
+	    /* [CL] support -E, -export-dynamic, ... */
+	    else if ( ((strcmp(string,"-E")) == 0) ||
+		      ((strcmp(string,"-export-dynamic")) == 0) ) {
+    	    	ld_ipa_opt[LD_IPA_EXPORTS].flag = TRUE;
+	    }
+	    /* [CL] warn about the use of -defsym, which is not supported by IPA */
+	    else if ( (strcmp(string,"-defsym")) == 0) {
+	      einfo (_("warning: -defsym is not supported with -ipa\n"));
+	    }
+	    else if (needs_argument(&string[1],FALSE)) {
+	    	(*p_ipa_add_link_flag) (argv[i++]);
+		(*p_ipa_add_link_flag) (argv[i]);
+		continue;
+	    }
+	}
+	/* This splits the post ipa commandline arguments */
+	else if (check_for_whirl(argv[i])){
+	    (*p_ipa_insert_whirl_marker)();
+	    continue;
+	}
+
+    	(*p_ipa_add_link_flag) (argv[i]);
+
+    }	    /* for */
+
+    return(TRUE);
+}
+
+	/*******************************************************
+		Function: 
+
+		
+
+	 *******************************************************/
+
+	/*******************************************************
+		Function: 
+
+		
+
+	 *******************************************************/
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff -r -N -u binutils-2.21.51/ld/ipa_cmdline.h binutils/ld/ipa_cmdline.h
--- binutils-2.21.51/ld/ipa_cmdline.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/ipa_cmdline.h	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,22 @@
+/* THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003 */
+
+#ifndef __IPA_CMDLINE_H__
+#define __IPA_CMDLINE_H__
+
+
+extern int arg_count;			    /* argument count */
+extern char **arg_vector;		    /* argument vector */
+extern char **environ_vars;		    /* list of environment variables */
+
+extern unsigned int max_gpa_size;
+extern bfd_boolean is_ipa;
+extern unsigned int used_gp_area;
+
+extern bfd_boolean
+ipa_search_command_line(int, char **, char **);
+
+extern string_t WB_flags;
+extern string_t Y_flags;
+
+
+#endif /* __IPA_CMDLINE_H__ */
diff -r -N -u binutils-2.21.51/ld/ipa_ld.c binutils/ld/ipa_ld.c
--- binutils-2.21.51/ld/ipa_ld.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/ipa_ld.c	2011-10-20 09:48:19.463637000 +0100
@@ -0,0 +1,551 @@
+/* THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003 */
+
+#ifdef IPA_LINK
+
+#if defined(__GNUC__)
+#include <stdio.h>		/* for sys_errlist */
+#endif
+#include <stdlib.h>		/* for getenv(3) */
+#include <unistd.h>		/* for unlink(2), rmdir(2), etc. */
+
+#if defined(__CYGWIN__) || defined(_WIN32)
+#include "libiberty.h"
+#else
+#include <libgen.h>		/* for basename(3) */
+#endif
+
+#include <sys/stat.h>		/* for chmod(2) */
+#include <fcntl.h>		/* for open(2) */
+#if defined(sun) || defined(__CYGWIN__) || defined(_WIN32)
+#include <sys/types.h>
+#include <dirent.h>
+#else
+#include <sys/dir.h>		/* for opendir(2), readdir, closedir */
+#endif
+
+#include <signal.h>		/* for kill(2) */
+#include <limits.h>		/* for PATH_MAX */
+#include <errno.h>
+#include <string.h>
+#ifdef _WIN32
+#include "dlfcn_win32.h"
+#else
+#include <dlfcn.h>
+#endif 
+
+#include "aout/ar.h"
+
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+
+#include "ipa_bfd.h"
+#include "ipa_ld.h"
+
+extern bfd_boolean is_ipa;
+
+extern struct bfd_link_info link_info __attribute__ ((weak)); /* defined in ld/ldmain.c */
+/*#pragma weak link_info // [CL]*/
+
+#include "ipa_cmdline.h" /* [CL] for used_gp_area */
+
+static struct external_symbols_list ipa_external_symbols;
+
+	/*******************************************************
+		Dummy functions and variables so we don't
+		have to muck with ipa sources.
+
+		
+	 *******************************************************/
+
+char * always_demangle(char *name ATTRIBUTE_UNUSED, char Demangle ATTRIBUTE_UNUSED){return NULL;}
+void read_one_section(int index2 ATTRIBUTE_UNUSED, void *p_void ATTRIBUTE_UNUSED){return;}
+
+void merge_ext(void *p_sym ATTRIBUTE_UNUSED, char *name ATTRIBUTE_UNUSED, int num ATTRIBUTE_UNUSED, void *p_obj ATTRIBUTE_UNUSED) 
+    {return;}
+
+void msg (int type ATTRIBUTE_UNUSED, int msg_id ATTRIBUTE_UNUSED, ...) {return;}
+
+
+	/*******************************************************
+		Function: ld_slookup_mext
+
+		Return pointer to ?? struct.
+	 *******************************************************/
+void *
+ld_slookup_mext(char *name, bfd_boolean is_extern)
+{
+    bfd *abfd = ld_get_cur_obj();
+    struct elf_link_hash_entry *p_hash = NULL;
+
+    if (!is_extern)
+    	p_hash = elf_link_hash_lookup (  elf_hash_table (&link_info), 
+    	    	    	    	    name, 
+				    FALSE, 
+				    FALSE, 
+				    FALSE);
+    else
+    	p_hash = ((struct elf_link_hash_entry *)
+    	    bfd_wrapped_link_hash_lookup(   abfd, 
+    	    	    	    	    	    &link_info, 
+					    name, 
+					    FALSE, 
+					    FALSE, 
+					    FALSE));
+
+    return p_hash;
+
+
+}
+
+	/*******************************************************
+		Function: ld_set_st_idx
+
+		This field cannot be used beyond
+		the pass1 phase.
+	 *******************************************************/
+void
+ld_set_st_idx (void *pext, int st_idx)
+{
+    struct elf_link_hash_entry *p_hash = (struct elf_link_hash_entry *)pext;
+
+    p_hash->ipa_indx = st_idx;
+}
+
+	/*******************************************************
+		Function: ld_get_st_idx
+
+		This field cannot be used beyond
+		the pass1 phase.
+	 *******************************************************/
+int
+ld_get_st_idx (void *pext)
+{
+    struct elf_link_hash_entry *p_hash = (struct elf_link_hash_entry *)pext;
+
+    return p_hash->ipa_indx;
+}
+
+
+	/*******************************************************
+		Function: ld_resolved_to_obj
+
+		
+	 *******************************************************/
+bfd_boolean
+ld_resolved_to_obj (void *pext, void *pobj)
+{
+    struct elf_link_hash_entry *p_hash;
+    bfd *abfd = NULL;
+
+    if (pext)
+    	p_hash = (struct elf_link_hash_entry *)pext;
+    else
+    	p_hash = NULL;
+	
+    switch(p_hash->root.type) {
+
+    	case bfd_link_hash_common:
+	    abfd = p_hash->root.u.c.p->section->owner;
+	    break;
+
+	case bfd_link_hash_undefined:
+	case bfd_link_hash_undefweak:
+	    abfd = p_hash->root.u.undef.abfd;
+	    break;
+
+	case bfd_link_hash_defined:
+	case bfd_link_hash_defweak:
+	  /*	    abfd = (bfd *)p_hash->root.u.def.section;*/
+	  abfd = p_hash->root.ipa_bfd;
+	    break;
+
+	case bfd_link_hash_new:
+	case bfd_link_hash_indirect:
+	case bfd_link_hash_warning:
+	default:
+	    break;
+	    
+    }
+
+    return (abfd == (bfd *)pobj);
+}
+
+
+	/*******************************************************
+		Function: ld_get_section_base
+
+		Return the raw address of the given section
+		the pass1 phase.
+	 *******************************************************/
+char *
+ld_get_section_base (void *pobj, int sect_ndx)
+{
+    const bfd *abfd = (bfd *) pobj;
+    Elf_Internal_Shdr **i_shdrp = elf_elfsections (abfd);
+    Elf_Internal_Shdr *p_shdr = i_shdrp[sect_ndx];
+
+    return (char *)abfd->usrdata+p_shdr->sh_offset;
+}
+
+	/*******************************************************
+		Function: ld_get_section_size
+
+		
+	 *******************************************************/
+unsigned long long
+ld_get_section_size(void *pobj, int sect_ndx)
+{
+    const bfd *abfd = (bfd *) pobj;
+    Elf_Internal_Shdr **i_shdrp = elf_elfsections (abfd);
+
+    return ((unsigned long long)i_shdrp[sect_ndx]->sh_size);
+}
+
+	/*******************************************************
+		Function: ld_get_section_name
+
+		
+	 *******************************************************/
+char *
+ld_get_section_name(void *pobj, int sect_ndx)
+{
+    bfd *abfd = (bfd *) pobj;
+    Elf_Internal_Shdr **i_shdrp = elf_elfsections (abfd);
+    Elf_Internal_Shdr *p_shdr = i_shdrp[sect_ndx];
+    char *tbl = bfd_elf_get_str_section(abfd, 
+    	    	    	    	    	elf_elfheader (abfd)->e_shstrndx);
+
+    return &tbl[p_shdr->sh_name];
+}
+
+	/*******************************************************
+		Function: ld_get_mmap_addr
+
+		
+	 *******************************************************/
+void *
+ld_get_mmap_addr(void *pobj)
+{
+    const bfd *abfd = (bfd *) pobj;
+
+    return (void *)abfd->usrdata;
+    
+}
+
+	/*******************************************************
+		Function: Count_elf_external_gots
+
+		
+	 *******************************************************/
+int 
+Count_elf_external_gots (void)
+{
+    return(20);     /* This is until we figure out how to estimate for ia64 */
+}
+
+	/*******************************************************
+		Function: ipa_set_syms
+
+		dlopen ipa.so and set entry points with
+		dlsym calls.
+
+	 *******************************************************/
+void
+ipa_set_syms(void)
+{
+
+    void *p_handle = NULL;
+    char *p_error = NULL;
+
+#if !defined(__CYGWIN__) && !defined(_WIN32)
+    p_handle = dlopen("ipa.so",RTLD_LAZY);
+#else
+    p_handle = dlopen("ipa.dll",RTLD_LAZY);
+#endif
+    if (!p_handle) {
+    	fputs (dlerror(), stderr);
+    	exit(1);
+    }
+    
+    p_ipa_open_input = dlsym(p_handle,"ipa_open_input");
+    if (!p_ipa_open_input) {
+      if ((p_error = dlerror()) != NULL)  {
+    	fputs(p_error, stderr);
+    	exit(1);
+      }
+    }
+
+    p_ipa_init_link_line = dlsym(p_handle,"ipa_init_link_line");
+    if (!p_ipa_init_link_line) {
+      if ((p_error = dlerror()) != NULL)  {
+    	fputs(p_error, stderr);
+    	exit(1);
+      }
+    }
+
+    p_ipa_add_link_flag = dlsym(p_handle,"ipa_add_link_flag");
+    if (!p_ipa_add_link_flag) {
+      if ((p_error = dlerror()) != NULL)  {
+    	fputs(p_error, stderr);
+    	exit(1);
+      }
+    }
+
+    p_ipa_driver = dlsym(p_handle,"ipa_driver");
+    if (!p_ipa_driver) {
+      if ((p_error = dlerror()) != NULL)  {
+    	fputs(p_error, stderr);
+    	exit(1);
+    }
+    }
+
+    /* [CL]    p_process_whirl64 = dlsym(p_handle,"process_whirl64"); */
+    p_process_whirl64 = dlsym(p_handle,"process_whirl32");
+    if (!p_process_whirl64) {
+      if ((p_error = dlerror()) != NULL)  {
+    	fputs(p_error, stderr);
+    	exit(1);
+      }
+    }
+
+    p_ipa_insert_whirl_marker = dlsym(p_handle,"ipa_insert_whirl_marker");
+    if (!p_ipa_insert_whirl_marker) {
+      if ((p_error = dlerror()) != NULL)  {
+    	fputs(p_error, stderr);
+    	exit(1);
+      }
+    }
+
+    p_Sync_symbol_attributes = dlsym(p_handle,"Sync_symbol_attributes");
+    if (!p_Sync_symbol_attributes) {
+      if ((p_error = dlerror()) != NULL)  {
+    	fputs(p_error, stderr);
+    	exit(1);
+      }
+    }
+
+    p_symbol_comdat = dlsym(p_handle,"symbol_comdat");
+    if (!p_symbol_comdat) {
+      if ((p_error = dlerror()) != NULL)  {
+    	fputs(p_error, stderr);
+    	exit(1);
+      }
+    }
+
+    p_symbol_linkonce = dlsym(p_handle,"symbol_linkonce");
+    if (!p_symbol_linkonce) {
+      if ((p_error = dlerror()) != NULL)  {
+    	fputs(p_error, stderr);
+    	exit(1);
+      }
+    }
+
+    /* [CL] added initialization entry point */
+    p_ipa_initialize_external_symbols = dlsym(p_handle,"ipa_initialize_external_symbols");
+    if (!p_ipa_initialize_external_symbols) {
+      if ((p_error = dlerror()) != NULL)  {
+    	fputs(p_error, stderr);
+    	exit(1);
+      }
+    }
+    /* Initialize the huge list of symbols defined here and used in ipa.so */
+#define IPA_USED(name) ipa_external_symbols.name = &name
+
+    ipa_external_symbols.size = sizeof(ipa_external_symbols);
+    ipa_external_symbols.version = IPA_EXTERNAL_SYMBOLS_VERSION;
+
+    /* pass1.h */
+    IPA_USED(used_gp_area);
+
+    /* ld_ipa_option.h */
+    IPA_USED(ld_ipa_opt);
+/*     IPA_USED(ipacom_flags); */
+    IPA_USED(WB_flags);
+    IPA_USED(Y_flags);
+
+    /* error.h */
+/*     IPA_USED(msg); */
+
+    /* ext_tbl.h */
+    IPA_USED(merge_ext);
+/*     IPA_USED(enter_mext); */
+/*     IPA_USED(slookup_mext); */
+/*     IPA_USED(slookup_mext_idx); */
+/*     IPA_USED(get_mext); */
+/*     IPA_USED(ext_tbl); */
+    IPA_USED(ld_slookup_mext);
+
+    /* obj_file.h */
+/*     IPA_USED(num_ir); */
+/*     IPA_USED(get_next_ir); */
+/*     IPA_USED(is_archive_member); */
+
+    /* process.h */
+    IPA_USED(create_tmpdir);
+    IPA_USED(create_unique_file);
+    IPA_USED(create_unique_file_in_curdir);
+    IPA_USED(add_to_tmp_file_list);
+    IPA_USED(tmpdir);
+/*     IPA_USED(get_command_line); */
+/*     IPA_USED(make_link); */
+
+    /* ld_util.h */
+    IPA_USED(concat_names);
+
+    /* ld_main.h */
+    IPA_USED(arg_count);
+    IPA_USED(arg_vector);
+    IPA_USED(environ_vars);
+    IPA_USED(max_gpa_size);
+
+    /* read.h */
+    IPA_USED(read_one_section);
+/*     IPA_USED(read_headers); */
+/*     IPA_USED(unread_sections); */
+/*     IPA_USED(unread_obj); */
+/*     IPA_USED(objs_mapped_total_size); */
+/*     IPA_USED(copy_section); */
+
+    /* dem.h */
+    IPA_USED(always_demangle);
+
+    /* elfhash.h */
+/*     IPA_USED(elfhash); */
+
+    IPA_USED(ld_get_section_size);
+    IPA_USED(ld_get_section_name);
+    IPA_USED(ld_get_section_base);
+    IPA_USED(ld_get_mmap_addr);
+    /*    IPA_USED(ld_get_sym_attr);*/
+    /*    IPA_USED(ld_is_weak_symbol);*/
+    /*    IPA_USED(ld_get_export);*/
+    IPA_USED(ld_set_st_idx);
+    IPA_USED(ld_get_st_idx);
+    IPA_USED(ld_resolved_to_obj);
+    /*    IPA_USED(cleanup_symtab_for_ipa);*/
+    IPA_USED(Count_elf_external_gots);
+    IPA_USED(outfilename);
+
+    (*p_ipa_initialize_external_symbols)(&ipa_external_symbols);
+}
+
+	/*******************************************************
+		Function: ipa_symbol_sync
+
+		
+
+	 *******************************************************/
+static bfd_boolean
+ipa_symbol_sync(struct bfd_link_hash_entry *p_bfd_link_hash, PTR info ATTRIBUTE_UNUSED)
+{
+    char *name;
+    bfd_boolean is_undef = FALSE;
+    struct elf_link_hash_entry *p_elf_link_hash ;
+    unsigned int result = 0;
+    bfd_boolean is_weak = FALSE;
+
+    name = (char *) p_bfd_link_hash->root.string;
+
+    if (!name)
+    	return(TRUE);
+
+
+    switch (p_bfd_link_hash->type) {
+    	case bfd_link_hash_undefined:
+	    is_undef = TRUE;
+	    break;
+	case bfd_link_hash_undefweak:
+	    is_undef = TRUE;
+	    is_weak = TRUE;
+	    break;
+	case bfd_link_hash_defined:
+	    is_undef = FALSE;
+	    break;
+	case bfd_link_hash_defweak:
+	    is_undef = FALSE;
+	    is_weak = TRUE;
+	    break;
+	case bfd_link_hash_common:
+	    is_undef = FALSE;
+	    result |= OBJ_COMMON;
+	    break;
+	default:
+	    return(TRUE);
+	    break;
+    }
+    
+    p_elf_link_hash = (struct elf_link_hash_entry *)ld_slookup_mext(name,is_undef);
+
+    if (p_elf_link_hash->def_regular) {
+	result |= DEF_IN_OBJ;
+    }
+    if (p_elf_link_hash->ref_regular) {
+	result |= USED_IN_OBJ;
+    }
+    if (p_elf_link_hash->ref_dynamic) {
+	result |= USED_IN_DSO;
+    }
+    if (p_elf_link_hash->def_dynamic) {
+	result |= DEF_IN_DSO;
+    }
+    if (p_elf_link_hash->hidden) {
+    }
+    if (p_elf_link_hash->address_taken) {
+	result |= ADDR_TAKEN_IN_OBJ;
+    }
+
+    if (p_elf_link_hash->ipa_indx != WHIRL_ST_IDX_UNINITIALIZED &&
+    	p_elf_link_hash->ipa_indx != WHIRL_ST_IDX_NOT_AVAILABLE) {
+
+    	(*p_Sync_symbol_attributes) (p_elf_link_hash->ipa_indx, 
+				     result,
+			    	     is_weak,
+				     p_elf_link_hash->other);
+	
+    }
+    
+    return(TRUE);
+}
+
+	/*******************************************************
+		Function: cleanup_symtab_for_ipa
+
+		In -IPA mode, we pass the last bit of info in the
+		merged symbol table that is needed by ipa.so, and
+		then clean up the storage allcoated.
+		
+	 *******************************************************/
+void
+cleanup_symtab_for_ipa (void)
+{
+
+    /* first, synch. up the symbol attributes with IPA's WHIRL symtab */
+
+    bfd_link_hash_traverse (link_info.hash, ipa_symbol_sync, (PTR) NULL);
+
+#if 0
+    /* TODO */
+    /* collect autognum and other info and pass them to ipa */
+    if (threadlocalsyms)
+	mark_all_xlocal_not_gp_rel ();
+
+    /* finally release all unnecessary storage allocated in ld. */
+#endif
+    
+}  /* cleanup_symtab_for_ipa */
+
+
+
+	/*******************************************************
+		Function: 
+
+		
+
+	 *******************************************************/
+
+
+
+
+
+#endif
diff -r -N -u binutils-2.21.51/ld/ipa_ld.h binutils/ld/ipa_ld.h
--- binutils-2.21.51/ld/ipa_ld.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/ipa_ld.h	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,81 @@
+/* THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003 */
+
+#ifndef __IPA_LD_H__
+#define __IPA_LD_H__
+
+#include "ipa_bfd.h"
+
+/* These are taken from ipc_sumtab_merge.h in the ipa tree. */
+
+enum AUX_ST_FLAG
+{
+    // attributes from an Elf symbols
+
+    USED_IN_OBJ		= 0x00000001,	// referenced in an Elf object
+    USED_IN_DSO		= 0x00000002,	// referenced in a DSO
+    DEF_IN_OBJ		= 0x00000004,	// defined in an Elf object
+    DEF_IN_DSO		= 0x00000008,	// defined in a DSO
+    OBJ_COMMON		= 0x00000010,	// defined in OBJ/DSO as common
+    ADDR_TAKEN_IN_OBJ	= 0x00000020,	// address taken by Elf object or dso
+	// Update Print_AUX_ST_flags when adding new attribute
+
+    OBJ_ATTR_MASK	= 0x0000003f,	// mask for the above bits
+
+    // attributes from an ST
+    
+    COMMON_USED_IN_IO   = 0x00000040,	// common block passed to IO routines
+    IGNORE_REFCOUNTS	= 0x00000080	// ignore the mod/ref counts even
+					// when they hit zero
+};
+
+
+
+/* Function declarations
+ */
+ 
+extern char *
+always_demangle(char *, char );
+
+
+extern void read_one_section(int , void *);
+
+extern void 
+merge_ext(void *, char *, int , void *) ;
+
+extern void 
+msg (int , int , ...);
+
+extern void *
+ld_slookup_mext(char *, bfd_boolean);
+
+extern void
+ld_set_st_idx (void *, int);
+
+extern int
+ld_get_st_idx (void *);
+
+extern bfd_boolean
+ld_resolved_to_obj (void *, void *);
+
+extern char *
+ld_get_section_base (void *, int );
+
+extern unsigned long long
+ld_get_section_size(void *, int );
+
+extern char *
+ld_get_section_name(void *, int );
+
+extern void *
+ld_get_mmap_addr(void *);
+
+extern int 
+Count_elf_external_gots (void);
+
+extern void 
+ipa_set_syms (void);
+
+extern void
+cleanup_symtab_for_ipa (void);
+
+#endif /* __IPA_LD_H__ */
diff -r -N -u binutils-2.21.51/ld/ldemul.c binutils/ld/ldemul.c
--- binutils-2.21.51/ld/ldemul.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/ld/ldemul.c	2011-07-06 12:44:26.137253000 +0100
@@ -350,3 +350,19 @@
     entry = (*ld_emulation->new_vers_pattern) (entry);
   return entry;
 }
+
+void
+ldemul_get_secinfo_table_content(s,dot)
+     lang_secinfo_table_statement_type *s;
+     bfd_vma dot;
+{
+  if (ld_emulation->get_secinfo_table_content)
+    ld_emulation->get_secinfo_table_content (s, dot);
+}
+
+void
+ldemul_after_assignment(bfd_boolean *again)
+{
+  if (ld_emulation->after_assignment)
+    ld_emulation->after_assignment (again);
+}
diff -r -N -u binutils-2.21.51/ld/ldemul.h binutils/ld/ldemul.h
--- binutils-2.21.51/ld/ldemul.h	2010-02-23 12:32:54.000000000 +0000
+++ binutils/ld/ldemul.h	2010-06-07 14:41:42.080337000 +0100
@@ -96,6 +96,9 @@
   (char *, struct lang_input_statement_struct *);
 extern struct bfd_elf_version_expr *ldemul_new_vers_pattern
   (struct bfd_elf_version_expr *);
+extern void ldemul_get_secinfo_table_content
+  (struct lang_secinfo_table_statement_struct *, bfd_vma);
+extern void ldemul_after_assignment (bfd_boolean *);
 
 typedef struct ld_emulation_xfer_struct {
   /* Run before parsing the command line and script file.
@@ -196,6 +199,18 @@
   struct bfd_elf_version_expr * (*new_vers_pattern)
     (struct bfd_elf_version_expr *);
 
+  /* Run while getting size of section, to get the section
+     information table content.
+     This callback return true if the section information
+     content has been modified, false otherwise. */
+  void (*get_secinfo_table_content) (struct lang_secinfo_table_statement_struct *, bfd_vma);
+  
+  /* Run when output bfd is ready and call to check whether
+     another pass is expected to re-build output bfd.
+     Parameter AGAIN is set to true if another pass is required
+     for output allocation. */
+  void (*after_assignment) (bfd_boolean *);
+  
 } ld_emulation_xfer_type;
 
 typedef enum {
diff -r -N -u binutils-2.21.51/ld/ldgram.c binutils/ld/ldgram.c
--- binutils-2.21.51/ld/ldgram.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/ld/ldgram.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,4214 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     INT = 258,
-     NAME = 259,
-     LNAME = 260,
-     OREQ = 261,
-     ANDEQ = 262,
-     RSHIFTEQ = 263,
-     LSHIFTEQ = 264,
-     DIVEQ = 265,
-     MULTEQ = 266,
-     MINUSEQ = 267,
-     PLUSEQ = 268,
-     OROR = 269,
-     ANDAND = 270,
-     NE = 271,
-     EQ = 272,
-     GE = 273,
-     LE = 274,
-     RSHIFT = 275,
-     LSHIFT = 276,
-     UNARY = 277,
-     END = 278,
-     ALIGN_K = 279,
-     BLOCK = 280,
-     BIND = 281,
-     QUAD = 282,
-     SQUAD = 283,
-     LONG = 284,
-     SHORT = 285,
-     BYTE = 286,
-     SECTIONS = 287,
-     PHDRS = 288,
-     INSERT_K = 289,
-     AFTER = 290,
-     BEFORE = 291,
-     DATA_SEGMENT_ALIGN = 292,
-     DATA_SEGMENT_RELRO_END = 293,
-     DATA_SEGMENT_END = 294,
-     SORT_BY_NAME = 295,
-     SORT_BY_ALIGNMENT = 296,
-     SORT_BY_INIT_PRIORITY = 297,
-     SIZEOF_HEADERS = 298,
-     OUTPUT_FORMAT = 299,
-     FORCE_COMMON_ALLOCATION = 300,
-     OUTPUT_ARCH = 301,
-     INHIBIT_COMMON_ALLOCATION = 302,
-     SEGMENT_START = 303,
-     INCLUDE = 304,
-     MEMORY = 305,
-     REGION_ALIAS = 306,
-     LD_FEATURE = 307,
-     NOLOAD = 308,
-     DSECT = 309,
-     COPY = 310,
-     INFO = 311,
-     OVERLAY = 312,
-     DEFINED = 313,
-     TARGET_K = 314,
-     SEARCH_DIR = 315,
-     MAP = 316,
-     ENTRY = 317,
-     NEXT = 318,
-     SIZEOF = 319,
-     ALIGNOF = 320,
-     ADDR = 321,
-     LOADADDR = 322,
-     MAX_K = 323,
-     MIN_K = 324,
-     STARTUP = 325,
-     HLL = 326,
-     SYSLIB = 327,
-     FLOAT = 328,
-     NOFLOAT = 329,
-     NOCROSSREFS = 330,
-     ORIGIN = 331,
-     FILL = 332,
-     LENGTH = 333,
-     CREATE_OBJECT_SYMBOLS = 334,
-     INPUT = 335,
-     GROUP = 336,
-     OUTPUT = 337,
-     CONSTRUCTORS = 338,
-     ALIGNMOD = 339,
-     AT = 340,
-     SUBALIGN = 341,
-     PROVIDE = 342,
-     PROVIDE_HIDDEN = 343,
-     AS_NEEDED = 344,
-     CHIP = 345,
-     LIST = 346,
-     SECT = 347,
-     ABSOLUTE = 348,
-     LOAD = 349,
-     NEWLINE = 350,
-     ENDWORD = 351,
-     ORDER = 352,
-     NAMEWORD = 353,
-     ASSERT_K = 354,
-     FORMAT = 355,
-     PUBLIC = 356,
-     DEFSYMEND = 357,
-     BASE = 358,
-     ALIAS = 359,
-     TRUNCATE = 360,
-     REL = 361,
-     INPUT_SCRIPT = 362,
-     INPUT_MRI_SCRIPT = 363,
-     INPUT_DEFSYM = 364,
-     CASE = 365,
-     EXTERN = 366,
-     START = 367,
-     VERS_TAG = 368,
-     VERS_IDENTIFIER = 369,
-     GLOBAL = 370,
-     LOCAL = 371,
-     VERSIONK = 372,
-     INPUT_VERSION_SCRIPT = 373,
-     KEEP = 374,
-     ONLY_IF_RO = 375,
-     ONLY_IF_RW = 376,
-     SPECIAL = 377,
-     EXCLUDE_FILE = 378,
-     CONSTANT = 379,
-     INPUT_DYNAMIC_LIST = 380
-   };
-#endif
-#define INT 258
-#define NAME 259
-#define LNAME 260
-#define OREQ 261
-#define ANDEQ 262
-#define RSHIFTEQ 263
-#define LSHIFTEQ 264
-#define DIVEQ 265
-#define MULTEQ 266
-#define MINUSEQ 267
-#define PLUSEQ 268
-#define OROR 269
-#define ANDAND 270
-#define NE 271
-#define EQ 272
-#define GE 273
-#define LE 274
-#define RSHIFT 275
-#define LSHIFT 276
-#define UNARY 277
-#define END 278
-#define ALIGN_K 279
-#define BLOCK 280
-#define BIND 281
-#define QUAD 282
-#define SQUAD 283
-#define LONG 284
-#define SHORT 285
-#define BYTE 286
-#define SECTIONS 287
-#define PHDRS 288
-#define INSERT_K 289
-#define AFTER 290
-#define BEFORE 291
-#define DATA_SEGMENT_ALIGN 292
-#define DATA_SEGMENT_RELRO_END 293
-#define DATA_SEGMENT_END 294
-#define SORT_BY_NAME 295
-#define SORT_BY_ALIGNMENT 296
-#define SORT_BY_INIT_PRIORITY 297
-#define SIZEOF_HEADERS 298
-#define OUTPUT_FORMAT 299
-#define FORCE_COMMON_ALLOCATION 300
-#define OUTPUT_ARCH 301
-#define INHIBIT_COMMON_ALLOCATION 302
-#define SEGMENT_START 303
-#define INCLUDE 304
-#define MEMORY 305
-#define REGION_ALIAS 306
-#define LD_FEATURE 307
-#define NOLOAD 308
-#define DSECT 309
-#define COPY 310
-#define INFO 311
-#define OVERLAY 312
-#define DEFINED 313
-#define TARGET_K 314
-#define SEARCH_DIR 315
-#define MAP 316
-#define ENTRY 317
-#define NEXT 318
-#define SIZEOF 319
-#define ALIGNOF 320
-#define ADDR 321
-#define LOADADDR 322
-#define MAX_K 323
-#define MIN_K 324
-#define STARTUP 325
-#define HLL 326
-#define SYSLIB 327
-#define FLOAT 328
-#define NOFLOAT 329
-#define NOCROSSREFS 330
-#define ORIGIN 331
-#define FILL 332
-#define LENGTH 333
-#define CREATE_OBJECT_SYMBOLS 334
-#define INPUT 335
-#define GROUP 336
-#define OUTPUT 337
-#define CONSTRUCTORS 338
-#define ALIGNMOD 339
-#define AT 340
-#define SUBALIGN 341
-#define PROVIDE 342
-#define PROVIDE_HIDDEN 343
-#define AS_NEEDED 344
-#define CHIP 345
-#define LIST 346
-#define SECT 347
-#define ABSOLUTE 348
-#define LOAD 349
-#define NEWLINE 350
-#define ENDWORD 351
-#define ORDER 352
-#define NAMEWORD 353
-#define ASSERT_K 354
-#define FORMAT 355
-#define PUBLIC 356
-#define DEFSYMEND 357
-#define BASE 358
-#define ALIAS 359
-#define TRUNCATE 360
-#define REL 361
-#define INPUT_SCRIPT 362
-#define INPUT_MRI_SCRIPT 363
-#define INPUT_DEFSYM 364
-#define CASE 365
-#define EXTERN 366
-#define START 367
-#define VERS_TAG 368
-#define VERS_IDENTIFIER 369
-#define GLOBAL 370
-#define LOCAL 371
-#define VERSIONK 372
-#define INPUT_VERSION_SCRIPT 373
-#define KEEP 374
-#define ONLY_IF_RO 375
-#define ONLY_IF_RW 376
-#define SPECIAL 377
-#define EXCLUDE_FILE 378
-#define CONSTANT 379
-#define INPUT_DYNAMIC_LIST 380
-
-
-
-
-/* Copy the first part of user declarations.  */
-#line 24 "ldgram.y"
-
-/*
-
- */
-
-#define DONTDECLARE_MALLOC
-
-#include "sysdep.h"
-#include "bfd.h"
-#include "bfdlink.h"
-#include "ld.h"
-#include "ldexp.h"
-#include "ldver.h"
-#include "ldlang.h"
-#include "ldfile.h"
-#include "ldemul.h"
-#include "ldmisc.h"
-#include "ldmain.h"
-#include "mri.h"
-#include "ldctor.h"
-#include "ldlex.h"
-
-#ifndef YYDEBUG
-#define YYDEBUG 1
-#endif
-
-static enum section_type sectype;
-static lang_memory_region_type *region;
-
-bfd_boolean ldgram_had_keep = FALSE;
-char *ldgram_vers_current_lang = NULL;
-
-#define ERROR_NAME_MAX 20
-static char *error_names[ERROR_NAME_MAX];
-static int error_index;
-#define PUSH_ERROR(x) if (error_index < ERROR_NAME_MAX) error_names[error_index] = x; error_index++;
-#define POP_ERROR()   error_index--;
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 62 "ldgram.y"
-typedef union YYSTYPE {
-  bfd_vma integer;
-  struct big_int
-    {
-      bfd_vma integer;
-      char *str;
-    } bigint;
-  fill_type *fill;
-  char *name;
-  const char *cname;
-  struct wildcard_spec wildcard;
-  struct wildcard_list *wildcard_list;
-  struct name_list *name_list;
-  int token;
-  union etree_union *etree;
-  struct phdr_info
-    {
-      bfd_boolean filehdr;
-      bfd_boolean phdrs;
-      union etree_union *at;
-      union etree_union *flags;
-    } phdr;
-  struct lang_nocrossref *nocrossref;
-  struct lang_output_section_phdr_list *section_phdr;
-  struct bfd_elf_version_deps *deflist;
-  struct bfd_elf_version_expr *versyms;
-  struct bfd_elf_version_tree *versnode;
-} YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 394 "ldgram.c"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 214 of yacc.c.  */
-#line 406 "ldgram.c"
-
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
-
-# ifndef YYFREE
-#  define YYFREE free
-# endif
-# ifndef YYMALLOC
-#  define YYMALLOC malloc
-# endif
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
-#  endif
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-# endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
-
-
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  short yyss;
-  YYSTYPE yyvs;
-  };
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAXIMUM)
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  register YYSIZE_T yyi;		\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (0)
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (0)
-
-#endif
-
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
-#define YYFINAL  17
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   1914
-
-/* YYNTOKENS -- Number of terminals. */
-#define YYNTOKENS  149
-/* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  126
-/* YYNRULES -- Number of rules. */
-#define YYNRULES  358
-/* YYNRULES -- Number of states. */
-#define YYNSTATES  771
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   380
-
-#define YYTRANSLATE(YYX) 						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,   147,     2,     2,     2,    34,    21,     2,
-      37,   144,    32,    30,   142,    31,     2,    33,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,    16,   143,
-      24,     6,    25,    15,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,   145,     2,   146,    20,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,    57,    19,    58,   148,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     7,     8,     9,    10,    11,    12,    13,    14,    17,
-      18,    22,    23,    26,    27,    28,    29,    35,    36,    38,
-      39,    40,    41,    42,    43,    44,    45,    46,    47,    48,
-      49,    50,    51,    52,    53,    54,    55,    56,    59,    60,
-      61,    62,    63,    64,    65,    66,    67,    68,    69,    70,
-      71,    72,    73,    74,    75,    76,    77,    78,    79,    80,
-      81,    82,    83,    84,    85,    86,    87,    88,    89,    90,
-      91,    92,    93,    94,    95,    96,    97,    98,    99,   100,
-     101,   102,   103,   104,   105,   106,   107,   108,   109,   110,
-     111,   112,   113,   114,   115,   116,   117,   118,   119,   120,
-     121,   122,   123,   124,   125,   126,   127,   128,   129,   130,
-     131,   132,   133,   134,   135,   136,   137,   138,   139,   140,
-     141
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const unsigned short yyprhs[] =
-{
-       0,     0,     3,     6,     9,    12,    15,    18,    20,    21,
-      26,    27,    30,    34,    35,    38,    43,    45,    47,    50,
-      52,    57,    62,    66,    69,    74,    78,    83,    88,    93,
-      98,   103,   106,   109,   112,   117,   122,   125,   128,   131,
-     134,   135,   141,   144,   145,   149,   152,   153,   155,   159,
-     161,   165,   166,   168,   172,   173,   176,   178,   181,   185,
-     186,   189,   192,   193,   195,   197,   199,   201,   203,   205,
-     207,   209,   211,   213,   218,   223,   228,   233,   242,   247,
-     249,   251,   256,   257,   263,   268,   269,   275,   280,   285,
-     289,   293,   300,   305,   307,   311,   314,   316,   320,   323,
-     324,   330,   331,   339,   340,   347,   352,   355,   358,   359,
-     364,   367,   368,   376,   378,   380,   382,   384,   390,   395,
-     400,   408,   416,   424,   432,   441,   446,   449,   451,   455,
-     457,   459,   463,   468,   470,   471,   477,   480,   482,   484,
-     486,   491,   493,   498,   503,   504,   513,   514,   520,   523,
-     525,   526,   528,   530,   532,   534,   536,   538,   540,   543,
-     544,   546,   548,   550,   552,   554,   556,   558,   560,   562,
-     564,   568,   572,   579,   586,   588,   589,   594,   596,   597,
-     601,   603,   604,   612,   613,   619,   623,   627,   628,   632,
-     634,   637,   639,   642,   647,   652,   656,   660,   662,   667,
-     671,   672,   674,   676,   677,   680,   684,   685,   688,   691,
-     695,   700,   703,   706,   709,   713,   717,   721,   725,   729,
-     733,   737,   741,   745,   749,   753,   757,   761,   765,   769,
-     773,   779,   783,   787,   792,   794,   796,   801,   806,   811,
-     816,   821,   826,   831,   838,   845,   852,   857,   864,   869,
-     871,   878,   885,   892,   897,   902,   906,   907,   912,   913,
-     918,   919,   924,   925,   927,   929,   931,   932,   933,   934,
-     935,   936,   937,   957,   958,   959,   960,   961,   962,   981,
-     982,   983,   991,   992,   998,  1000,  1002,  1004,  1006,  1008,
-    1012,  1013,  1016,  1020,  1023,  1030,  1041,  1044,  1046,  1047,
-    1049,  1052,  1053,  1054,  1058,  1059,  1060,  1061,  1062,  1074,
-    1079,  1080,  1083,  1084,  1085,  1092,  1094,  1095,  1099,  1105,
-    1106,  1110,  1111,  1114,  1116,  1119,  1124,  1127,  1128,  1131,
-    1132,  1138,  1140,  1143,  1148,  1154,  1161,  1163,  1166,  1167,
-    1170,  1175,  1180,  1189,  1191,  1193,  1197,  1201,  1202,  1212,
-    1213,  1221,  1223,  1227,  1229,  1233,  1235,  1239,  1240
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const short yyrhs[] =
-{
-     150,     0,    -1,   123,   166,    -1,   124,   154,    -1,   134,
-     263,    -1,   141,   258,    -1,   125,   152,    -1,     4,    -1,
-      -1,   153,     4,     6,   219,    -1,    -1,   155,   156,    -1,
-     156,   157,   111,    -1,    -1,   106,   219,    -1,   106,   219,
-     142,   219,    -1,     4,    -1,   107,    -1,   113,   159,    -1,
-     112,    -1,   117,     4,     6,   219,    -1,   117,     4,   142,
-     219,    -1,   117,     4,   219,    -1,   116,     4,    -1,   108,
-       4,   142,   219,    -1,   108,     4,   219,    -1,   108,     4,
-       6,   219,    -1,    38,     4,     6,   219,    -1,    38,     4,
-     142,   219,    -1,   100,     4,     6,   219,    -1,   100,     4,
-     142,   219,    -1,   109,   161,    -1,   110,   160,    -1,   114,
-       4,    -1,   120,     4,   142,     4,    -1,   120,     4,   142,
-       3,    -1,   119,   219,    -1,   121,     3,    -1,   126,   162,
-      -1,   127,   163,    -1,    -1,    65,   151,   158,   156,    36,
-      -1,   128,     4,    -1,    -1,   159,   142,     4,    -1,   159,
-       4,    -1,    -1,     4,    -1,   160,   142,     4,    -1,     4,
-      -1,   161,   142,     4,    -1,    -1,     4,    -1,   162,   142,
-       4,    -1,    -1,   164,   165,    -1,     4,    -1,   165,     4,
-      -1,   165,   142,     4,    -1,    -1,   167,   168,    -1,   168,
-     169,    -1,    -1,   199,    -1,   176,    -1,   250,    -1,   210,
-      -1,   211,    -1,   213,    -1,   215,    -1,   178,    -1,   265,
-      -1,   143,    -1,    75,    37,     4,   144,    -1,    76,    37,
-     151,   144,    -1,    98,    37,   151,   144,    -1,    60,    37,
-       4,   144,    -1,    60,    37,     4,   142,     4,   142,     4,
-     144,    -1,    62,    37,     4,   144,    -1,    61,    -1,    63,
-      -1,    96,    37,   172,   144,    -1,    -1,    97,   170,    37,
-     172,   144,    -1,    77,    37,   151,   144,    -1,    -1,    65,
-     151,   171,   168,    36,    -1,    91,    37,   216,   144,    -1,
-     127,    37,   163,   144,    -1,    48,    49,     4,    -1,    48,
-      50,     4,    -1,    67,    37,     4,   142,     4,   144,    -1,
-      68,    37,     4,   144,    -1,     4,    -1,   172,   142,     4,
-      -1,   172,     4,    -1,     5,    -1,   172,   142,     5,    -1,
-     172,     5,    -1,    -1,   105,    37,   173,   172,   144,    -1,
-      -1,   172,   142,   105,    37,   174,   172,   144,    -1,    -1,
-     172,   105,    37,   175,   172,   144,    -1,    46,    57,   177,
-      58,    -1,   177,   225,    -1,   177,   178,    -1,    -1,    78,
-      37,     4,   144,    -1,   197,   196,    -1,    -1,   115,   179,
-      37,   219,   142,     4,   144,    -1,     4,    -1,    32,    -1,
-      15,    -1,   180,    -1,   139,    37,   182,   144,   180,    -1,
-      54,    37,   180,   144,    -1,    55,    37,   180,   144,    -1,
-      54,    37,    55,    37,   180,   144,   144,    -1,    54,    37,
-      54,    37,   180,   144,   144,    -1,    55,    37,    54,    37,
-     180,   144,   144,    -1,    55,    37,    55,    37,   180,   144,
-     144,    -1,    54,    37,   139,    37,   182,   144,   180,   144,
-      -1,    56,    37,   180,   144,    -1,   182,   180,    -1,   180,
-      -1,   183,   198,   181,    -1,   181,    -1,     4,    -1,   145,
-     183,   146,    -1,   181,    37,   183,   144,    -1,   184,    -1,
-      -1,   135,    37,   186,   184,   144,    -1,   197,   196,    -1,
-      95,    -1,   143,    -1,    99,    -1,    54,    37,    99,   144,
-      -1,   185,    -1,   192,    37,   217,   144,    -1,    93,    37,
-     193,   144,    -1,    -1,   115,   188,    37,   219,   142,     4,
-     144,   196,    -1,    -1,    65,   151,   189,   191,    36,    -1,
-     190,   187,    -1,   187,    -1,    -1,   190,    -1,    41,    -1,
-      42,    -1,    43,    -1,    44,    -1,    45,    -1,   217,    -1,
-       6,   193,    -1,    -1,    14,    -1,    13,    -1,    12,    -1,
-      11,    -1,    10,    -1,     9,    -1,     8,    -1,     7,    -1,
-     143,    -1,   142,    -1,     4,     6,   217,    -1,     4,   195,
-     217,    -1,   103,    37,     4,     6,   217,   144,    -1,   104,
-      37,     4,     6,   217,   144,    -1,   142,    -1,    -1,    66,
-      57,   200,    58,    -1,   201,    -1,    -1,   201,   198,   202,
-      -1,   202,    -1,    -1,     4,   203,   207,    16,   205,   198,
-     206,    -1,    -1,    65,   151,   204,   200,    36,    -1,    92,
-       6,   217,    -1,    94,     6,   217,    -1,    -1,    37,   208,
-     144,    -1,   209,    -1,   208,   209,    -1,     4,    -1,   147,
-       4,    -1,    86,    37,   151,   144,    -1,    87,    37,   212,
-     144,    -1,    87,    37,   144,    -1,   212,   198,   151,    -1,
-     151,    -1,    88,    37,   214,   144,    -1,   214,   198,   151,
-      -1,    -1,    89,    -1,    90,    -1,    -1,     4,   216,    -1,
-       4,   142,   216,    -1,    -1,   218,   219,    -1,    31,   219,
-      -1,    37,   219,   144,    -1,    79,    37,   219,   144,    -1,
-     147,   219,    -1,    30,   219,    -1,   148,   219,    -1,   219,
-      32,   219,    -1,   219,    33,   219,    -1,   219,    34,   219,
-      -1,   219,    30,   219,    -1,   219,    31,   219,    -1,   219,
-      29,   219,    -1,   219,    28,   219,    -1,   219,    23,   219,
-      -1,   219,    22,   219,    -1,   219,    27,   219,    -1,   219,
-      26,   219,    -1,   219,    24,   219,    -1,   219,    25,   219,
-      -1,   219,    21,   219,    -1,   219,    20,   219,    -1,   219,
-      19,   219,    -1,   219,    15,   219,    16,   219,    -1,   219,
-      18,   219,    -1,   219,    17,   219,    -1,    74,    37,     4,
-     144,    -1,     3,    -1,    59,    -1,    81,    37,     4,   144,
-      -1,    80,    37,     4,   144,    -1,    82,    37,     4,   144,
-      -1,    83,    37,     4,   144,    -1,   140,    37,     4,   144,
-      -1,   109,    37,   219,   144,    -1,    38,    37,   219,   144,
-      -1,    38,    37,   219,   142,   219,   144,    -1,    51,    37,
-     219,   142,   219,   144,    -1,    52,    37,   219,   142,   219,
-     144,    -1,    53,    37,   219,   144,    -1,    64,    37,     4,
-     142,   219,   144,    -1,    39,    37,   219,   144,    -1,     4,
-      -1,    84,    37,   219,   142,   219,   144,    -1,    85,    37,
-     219,   142,   219,   144,    -1,   115,    37,   219,   142,     4,
-     144,    -1,    92,    37,     4,   144,    -1,    94,    37,     4,
-     144,    -1,   101,    25,     4,    -1,    -1,   101,    37,   219,
-     144,    -1,    -1,    38,    37,   219,   144,    -1,    -1,   102,
-      37,   219,   144,    -1,    -1,   136,    -1,   137,    -1,   138,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,     4,   226,   241,
-     221,   222,   223,   227,   224,    57,   228,   191,    58,   229,
-     244,   220,   245,   194,   230,   198,    -1,    -1,    -1,    -1,
-      -1,    -1,    73,   231,   242,   243,   221,   223,   232,    57,
-     233,   246,    58,   234,   244,   220,   245,   194,   235,   198,
-      -1,    -1,    -1,    97,   236,   241,   237,    57,   177,    58,
-      -1,    -1,    65,   151,   238,   177,    36,    -1,    69,    -1,
-      70,    -1,    71,    -1,    72,    -1,    73,    -1,    37,   239,
-     144,    -1,    -1,    37,   144,    -1,   219,   240,    16,    -1,
-     240,    16,    -1,    40,    37,   219,   144,   240,    16,    -1,
-      40,    37,   219,   144,    39,    37,   219,   144,   240,    16,
-      -1,   219,    16,    -1,    16,    -1,    -1,    91,    -1,    25,
-       4,    -1,    -1,    -1,   245,    16,     4,    -1,    -1,    -1,
-      -1,    -1,   246,     4,   247,    57,   191,    58,   248,   245,
-     194,   249,   198,    -1,    47,    57,   251,    58,    -1,    -1,
-     251,   252,    -1,    -1,    -1,     4,   253,   255,   256,   254,
-     143,    -1,   219,    -1,    -1,     4,   257,   256,    -1,   101,
-      37,   219,   144,   256,    -1,    -1,    37,   219,   144,    -1,
-      -1,   259,   260,    -1,   261,    -1,   260,   261,    -1,    57,
-     262,    58,   143,    -1,   271,   143,    -1,    -1,   264,   267,
-      -1,    -1,   266,   133,    57,   267,    58,    -1,   268,    -1,
-     267,   268,    -1,    57,   270,    58,   143,    -1,   129,    57,
-     270,    58,   143,    -1,   129,    57,   270,    58,   269,   143,
-      -1,   129,    -1,   269,   129,    -1,    -1,   271,   143,    -1,
-     131,    16,   271,   143,    -1,   132,    16,   271,   143,    -1,
-     131,    16,   271,   143,   132,    16,   271,   143,    -1,   130,
-      -1,     4,    -1,   271,   143,   130,    -1,   271,   143,     4,
-      -1,    -1,   271,   143,   127,     4,    57,   272,   271,   274,
-      58,    -1,    -1,   127,     4,    57,   273,   271,   274,    58,
-      -1,   131,    -1,   271,   143,   131,    -1,   132,    -1,   271,
-     143,   132,    -1,   127,    -1,   271,   143,   127,    -1,    -1,
-     143,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
-{
-       0,   164,   164,   165,   166,   167,   168,   172,   176,   176,
-     186,   186,   199,   200,   204,   205,   206,   209,   212,   213,
-     214,   216,   218,   220,   222,   224,   226,   228,   230,   232,
-     234,   236,   237,   238,   240,   242,   244,   246,   248,   249,
-     251,   250,   254,   256,   260,   261,   262,   266,   268,   272,
-     274,   279,   280,   281,   286,   286,   291,   293,   295,   300,
-     300,   306,   307,   312,   313,   314,   315,   316,   317,   318,
-     319,   320,   321,   322,   324,   326,   328,   331,   333,   335,
-     337,   339,   341,   340,   344,   347,   346,   350,   354,   355,
-     357,   359,   361,   366,   369,   372,   375,   378,   381,   385,
-     384,   389,   388,   393,   392,   399,   403,   404,   405,   409,
-     411,   412,   412,   420,   424,   428,   435,   441,   447,   453,
-     459,   465,   471,   477,   483,   489,   498,   507,   518,   527,
-     538,   546,   550,   557,   559,   558,   565,   566,   570,   571,
-     576,   581,   582,   587,   591,   591,   595,   594,   601,   602,
-     605,   607,   611,   613,   615,   617,   619,   624,   631,   633,
-     637,   639,   641,   643,   645,   647,   649,   651,   656,   656,
-     661,   665,   673,   677,   685,   685,   689,   692,   692,   695,
-     696,   701,   700,   706,   705,   712,   720,   728,   729,   733,
-     734,   738,   740,   745,   750,   751,   756,   758,   764,   766,
-     768,   772,   774,   780,   783,   792,   803,   803,   809,   811,
-     813,   815,   817,   819,   822,   824,   826,   828,   830,   832,
-     834,   836,   838,   840,   842,   844,   846,   848,   850,   852,
-     854,   856,   858,   860,   862,   864,   867,   869,   871,   873,
-     875,   877,   879,   881,   883,   885,   887,   889,   898,   900,
-     902,   904,   906,   908,   910,   916,   917,   921,   922,   926,
-     927,   931,   932,   936,   937,   938,   939,   942,   946,   949,
-     955,   957,   942,   964,   966,   968,   973,   975,   963,   985,
-     987,   985,   993,   992,   999,  1000,  1001,  1002,  1003,  1007,
-    1008,  1009,  1013,  1014,  1019,  1020,  1025,  1026,  1031,  1032,
-    1037,  1039,  1044,  1047,  1060,  1064,  1069,  1071,  1062,  1079,
-    1082,  1084,  1088,  1089,  1088,  1098,  1143,  1146,  1158,  1167,
-    1170,  1177,  1177,  1189,  1190,  1194,  1198,  1207,  1207,  1221,
-    1221,  1231,  1232,  1236,  1240,  1244,  1251,  1255,  1263,  1266,
-    1270,  1274,  1278,  1285,  1289,  1293,  1297,  1302,  1301,  1315,
-    1314,  1324,  1328,  1332,  1336,  1340,  1344,  1350,  1352
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "INT", "NAME", "LNAME", "'='", "OREQ",
-  "ANDEQ", "RSHIFTEQ", "LSHIFTEQ", "DIVEQ", "MULTEQ", "MINUSEQ", "PLUSEQ",
-  "'?'", "':'", "OROR", "ANDAND", "'|'", "'^'", "'&'", "NE", "EQ", "'<'",
-  "'>'", "GE", "LE", "RSHIFT", "LSHIFT", "'+'", "'-'", "'*'", "'/'", "'%'",
-  "UNARY", "END", "'('", "ALIGN_K", "BLOCK", "BIND", "QUAD", "SQUAD",
-  "LONG", "SHORT", "BYTE", "SECTIONS", "PHDRS", "INSERT_K", "AFTER",
-  "BEFORE", "DATA_SEGMENT_ALIGN", "DATA_SEGMENT_RELRO_END",
-  "DATA_SEGMENT_END", "SORT_BY_NAME", "SORT_BY_ALIGNMENT",
-  "SORT_BY_INIT_PRIORITY", "'{'", "'}'", "SIZEOF_HEADERS", "OUTPUT_FORMAT",
-  "FORCE_COMMON_ALLOCATION", "OUTPUT_ARCH", "INHIBIT_COMMON_ALLOCATION",
-  "SEGMENT_START", "INCLUDE", "MEMORY", "REGION_ALIAS", "LD_FEATURE",
-  "NOLOAD", "DSECT", "COPY", "INFO", "OVERLAY", "DEFINED", "TARGET_K",
-  "SEARCH_DIR", "MAP", "ENTRY", "NEXT", "SIZEOF", "ALIGNOF", "ADDR",
-  "LOADADDR", "MAX_K", "MIN_K", "STARTUP", "HLL", "SYSLIB", "FLOAT",
-  "NOFLOAT", "NOCROSSREFS", "ORIGIN", "FILL", "LENGTH",
-  "CREATE_OBJECT_SYMBOLS", "INPUT", "GROUP", "OUTPUT", "CONSTRUCTORS",
-  "ALIGNMOD", "AT", "SUBALIGN", "PROVIDE", "PROVIDE_HIDDEN", "AS_NEEDED",
-  "CHIP", "LIST", "SECT", "ABSOLUTE", "LOAD", "NEWLINE", "ENDWORD",
-  "ORDER", "NAMEWORD", "ASSERT_K", "FORMAT", "PUBLIC", "DEFSYMEND", "BASE",
-  "ALIAS", "TRUNCATE", "REL", "INPUT_SCRIPT", "INPUT_MRI_SCRIPT",
-  "INPUT_DEFSYM", "CASE", "EXTERN", "START", "VERS_TAG", "VERS_IDENTIFIER",
-  "GLOBAL", "LOCAL", "VERSIONK", "INPUT_VERSION_SCRIPT", "KEEP",
-  "ONLY_IF_RO", "ONLY_IF_RW", "SPECIAL", "EXCLUDE_FILE", "CONSTANT",
-  "INPUT_DYNAMIC_LIST", "','", "';'", "')'", "'['", "']'", "'!'", "'~'",
-  "$accept", "file", "filename", "defsym_expr", "@1", "mri_script_file",
-  "@2", "mri_script_lines", "mri_script_command", "@3", "ordernamelist",
-  "mri_load_name_list", "mri_abs_name_list", "casesymlist",
-  "extern_name_list", "@4", "extern_name_list_body", "script_file", "@5",
-  "ifile_list", "ifile_p1", "@6", "@7", "input_list", "@8", "@9", "@10",
-  "sections", "sec_or_group_p1", "statement_anywhere", "@11",
-  "wildcard_name", "wildcard_spec", "exclude_name_list", "file_NAME_list",
-  "input_section_spec_no_keep", "input_section_spec", "@12", "statement",
-  "@13", "@14", "statement_list", "statement_list_opt", "length",
-  "fill_exp", "fill_opt", "assign_op", "end", "assignment", "opt_comma",
-  "memory", "memory_spec_list_opt", "memory_spec_list", "memory_spec",
-  "@15", "@16", "origin_spec", "length_spec", "attributes_opt",
-  "attributes_list", "attributes_string", "startup", "high_level_library",
-  "high_level_library_NAME_list", "low_level_library",
-  "low_level_library_NAME_list", "floating_point_support",
-  "nocrossref_list", "mustbe_exp", "@17", "exp", "memspec_at_opt",
-  "opt_at", "opt_align", "opt_subalign", "sect_constraint", "section",
-  "@18", "@19", "@20", "@21", "@22", "@23", "@24", "@25", "@26", "@27",
-  "@28", "@29", "@30", "type", "atype", "opt_exp_with_type",
-  "opt_exp_without_type", "opt_nocrossrefs", "memspec_opt", "phdr_opt",
-  "overlay_section", "@31", "@32", "@33", "phdrs", "phdr_list", "phdr",
-  "@34", "@35", "phdr_type", "phdr_qualifiers", "phdr_val",
-  "dynamic_list_file", "@36", "dynamic_list_nodes", "dynamic_list_node",
-  "dynamic_list_tag", "version_script_file", "@37", "version", "@38",
-  "vers_nodes", "vers_node", "verdep", "vers_tag", "vers_defns", "@39",
-  "@40", "opt_semicolon", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,    61,   261,   262,   263,
-     264,   265,   266,   267,   268,    63,    58,   269,   270,   124,
-      94,    38,   271,   272,    60,    62,   273,   274,   275,   276,
-      43,    45,    42,    47,    37,   277,   278,    40,   279,   280,
-     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
-     291,   292,   293,   294,   295,   296,   297,   123,   125,   298,
-     299,   300,   301,   302,   303,   304,   305,   306,   307,   308,
-     309,   310,   311,   312,   313,   314,   315,   316,   317,   318,
-     319,   320,   321,   322,   323,   324,   325,   326,   327,   328,
-     329,   330,   331,   332,   333,   334,   335,   336,   337,   338,
-     339,   340,   341,   342,   343,   344,   345,   346,   347,   348,
-     349,   350,   351,   352,   353,   354,   355,   356,   357,   358,
-     359,   360,   361,   362,   363,   364,   365,   366,   367,   368,
-     369,   370,   371,   372,   373,   374,   375,   376,   377,   378,
-     379,   380,    44,    59,    41,    91,    93,    33,   126
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned short yyr1[] =
-{
-       0,   149,   150,   150,   150,   150,   150,   151,   153,   152,
-     155,   154,   156,   156,   157,   157,   157,   157,   157,   157,
-     157,   157,   157,   157,   157,   157,   157,   157,   157,   157,
-     157,   157,   157,   157,   157,   157,   157,   157,   157,   157,
-     158,   157,   157,   157,   159,   159,   159,   160,   160,   161,
-     161,   162,   162,   162,   164,   163,   165,   165,   165,   167,
-     166,   168,   168,   169,   169,   169,   169,   169,   169,   169,
-     169,   169,   169,   169,   169,   169,   169,   169,   169,   169,
-     169,   169,   170,   169,   169,   171,   169,   169,   169,   169,
-     169,   169,   169,   172,   172,   172,   172,   172,   172,   173,
-     172,   174,   172,   175,   172,   176,   177,   177,   177,   178,
-     178,   179,   178,   180,   180,   180,   181,   181,   181,   181,
-     181,   181,   181,   181,   181,   181,   182,   182,   183,   183,
-     184,   184,   184,   185,   186,   185,   187,   187,   187,   187,
-     187,   187,   187,   187,   188,   187,   189,   187,   190,   190,
-     191,   191,   192,   192,   192,   192,   192,   193,   194,   194,
-     195,   195,   195,   195,   195,   195,   195,   195,   196,   196,
-     197,   197,   197,   197,   198,   198,   199,   200,   200,   201,
-     201,   203,   202,   204,   202,   205,   206,   207,   207,   208,
-     208,   209,   209,   210,   211,   211,   212,   212,   213,   214,
-     214,   215,   215,   216,   216,   216,   218,   217,   219,   219,
-     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
-     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
-     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
-     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
-     219,   219,   219,   219,   219,   220,   220,   221,   221,   222,
-     222,   223,   223,   224,   224,   224,   224,   226,   227,   228,
-     229,   230,   225,   231,   232,   233,   234,   235,   225,   236,
-     237,   225,   238,   225,   239,   239,   239,   239,   239,   240,
-     240,   240,   241,   241,   241,   241,   242,   242,   243,   243,
-     244,   244,   245,   245,   246,   247,   248,   249,   246,   250,
-     251,   251,   253,   254,   252,   255,   256,   256,   256,   257,
-     257,   259,   258,   260,   260,   261,   262,   264,   263,   266,
-     265,   267,   267,   268,   268,   268,   269,   269,   270,   270,
-     270,   270,   270,   271,   271,   271,   271,   272,   271,   273,
-     271,   271,   271,   271,   271,   271,   271,   274,   274
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     1,     0,     4,
-       0,     2,     3,     0,     2,     4,     1,     1,     2,     1,
-       4,     4,     3,     2,     4,     3,     4,     4,     4,     4,
-       4,     2,     2,     2,     4,     4,     2,     2,     2,     2,
-       0,     5,     2,     0,     3,     2,     0,     1,     3,     1,
-       3,     0,     1,     3,     0,     2,     1,     2,     3,     0,
-       2,     2,     0,     1,     1,     1,     1,     1,     1,     1,
-       1,     1,     1,     4,     4,     4,     4,     8,     4,     1,
-       1,     4,     0,     5,     4,     0,     5,     4,     4,     3,
-       3,     6,     4,     1,     3,     2,     1,     3,     2,     0,
-       5,     0,     7,     0,     6,     4,     2,     2,     0,     4,
-       2,     0,     7,     1,     1,     1,     1,     5,     4,     4,
-       7,     7,     7,     7,     8,     4,     2,     1,     3,     1,
-       1,     3,     4,     1,     0,     5,     2,     1,     1,     1,
-       4,     1,     4,     4,     0,     8,     0,     5,     2,     1,
-       0,     1,     1,     1,     1,     1,     1,     1,     2,     0,
-       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-       3,     3,     6,     6,     1,     0,     4,     1,     0,     3,
-       1,     0,     7,     0,     5,     3,     3,     0,     3,     1,
-       2,     1,     2,     4,     4,     3,     3,     1,     4,     3,
-       0,     1,     1,     0,     2,     3,     0,     2,     2,     3,
-       4,     2,     2,     2,     3,     3,     3,     3,     3,     3,
-       3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
-       5,     3,     3,     4,     1,     1,     4,     4,     4,     4,
-       4,     4,     4,     6,     6,     6,     4,     6,     4,     1,
-       6,     6,     6,     4,     4,     3,     0,     4,     0,     4,
-       0,     4,     0,     1,     1,     1,     0,     0,     0,     0,
-       0,     0,    19,     0,     0,     0,     0,     0,    18,     0,
-       0,     7,     0,     5,     1,     1,     1,     1,     1,     3,
-       0,     2,     3,     2,     6,    10,     2,     1,     0,     1,
-       2,     0,     0,     3,     0,     0,     0,     0,    11,     4,
-       0,     2,     0,     0,     6,     1,     0,     3,     5,     0,
-       3,     0,     2,     1,     2,     4,     2,     0,     2,     0,
-       5,     1,     2,     4,     5,     6,     1,     2,     0,     2,
-       4,     4,     8,     1,     1,     3,     3,     0,     9,     0,
-       7,     1,     3,     1,     3,     1,     3,     0,     1
-};
-
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const unsigned short yydefact[] =
-{
-       0,    59,    10,     8,   327,   321,     0,     2,    62,     3,
-      13,     6,     0,     4,     0,     5,     0,     1,    60,    11,
-       0,   338,     0,   328,   331,     0,   322,   323,     0,     0,
-       0,     0,     0,    79,     0,    80,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,   201,   202,     0,
-       0,    82,     0,     0,     0,   111,     0,    72,    61,    64,
-      70,     0,    63,    66,    67,    68,    69,    65,    71,     0,
-      16,     0,     0,     0,     0,    17,     0,     0,     0,    19,
-      46,     0,     0,     0,     0,     0,     0,    51,    54,     0,
-       0,     0,   344,   355,   343,   351,   353,     0,     0,   338,
-     332,   351,   353,     0,     0,   324,   206,   167,   166,   165,
-     164,   163,   162,   161,   160,   206,   108,   310,     0,     0,
-       0,     0,     7,    85,   178,     0,     0,     0,     0,     0,
-       0,     0,     0,   200,   203,     0,     0,     0,     0,     0,
-       0,    54,   169,   168,   110,     0,     0,    40,     0,   234,
-     249,     0,     0,     0,     0,     0,     0,     0,     0,   235,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,    14,     0,    49,    31,
-      47,    32,    18,    33,    23,     0,    36,     0,    37,    52,
-      38,    39,     0,    42,    12,     9,     0,     0,     0,     0,
-     339,     0,     0,   326,   170,     0,   171,     0,     0,    89,
-      90,     0,     0,    62,   181,     0,     0,   175,   180,     0,
-       0,     0,     0,     0,     0,     0,   195,   197,   175,   175,
-     203,     0,    93,    96,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,    13,     0,     0,   212,   208,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-     211,   213,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,    25,     0,     0,    45,     0,     0,
-       0,    22,     0,     0,    56,    55,   349,     0,     0,   333,
-     346,   356,   345,   352,   354,     0,   325,   207,   267,   105,
-       0,   273,   279,   107,   106,   312,   309,   311,     0,    76,
-      78,   329,   187,   183,   176,   174,     0,     0,    92,    73,
-      74,    84,   109,   193,   194,     0,   198,     0,   203,   204,
-      87,    99,    95,    98,     0,     0,    81,     0,    75,   206,
-     206,     0,    88,     0,    27,    28,    43,    29,    30,   209,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-     232,   231,   229,   228,   227,   222,   221,   225,   226,   224,
-     223,   220,   219,   217,   218,   214,   215,   216,    15,    26,
-      24,    50,    48,    44,    20,    21,    35,    34,    53,    57,
-       0,     0,   340,   341,     0,   336,   334,     0,   290,   282,
-       0,   290,     0,     0,    86,     0,     0,   178,   179,     0,
-     196,   199,   205,     0,   103,    94,    97,     0,    83,     0,
-       0,     0,   330,    41,     0,   242,   248,     0,     0,   246,
-       0,   233,   210,   237,   236,   238,   239,     0,     0,   253,
-     254,   241,     0,   240,     0,    58,   357,   354,   347,   337,
-     335,     0,     0,   290,     0,   258,   108,   297,     0,   298,
-     280,   315,   316,     0,   191,     0,     0,   189,     0,     0,
-      91,     0,     0,   101,   172,   173,     0,     0,     0,     0,
-       0,     0,     0,     0,   230,   358,     0,     0,     0,   284,
-     285,   286,   287,   288,   291,     0,     0,     0,     0,   293,
-       0,   260,     0,   296,   299,   258,     0,   319,     0,   313,
-       0,   192,   188,   190,     0,   175,   184,   100,     0,     0,
-     112,   243,   244,   245,   247,   250,   251,   252,   350,     0,
-     357,   289,     0,   292,     0,     0,   262,   283,   262,   108,
-       0,   316,     0,     0,    77,   206,     0,   104,     0,   342,
-       0,   290,     0,     0,     0,   268,   274,     0,     0,   317,
-       0,   314,   185,     0,   182,   102,   348,     0,     0,   257,
-       0,     0,   266,     0,   281,   320,   316,   206,     0,   294,
-     259,     0,   263,   264,   265,     0,   275,   318,   186,     0,
-     261,   269,   304,   290,   150,     0,     0,   130,   115,   114,
-     152,   153,   154,   155,   156,     0,     0,     0,     0,     0,
-     137,   139,   144,     0,     0,   138,     0,   116,     0,   133,
-     141,   149,   151,     0,     0,     0,   305,   276,   295,     0,
-       0,     0,   146,   206,     0,   134,     0,   113,     0,   129,
-     175,     0,   148,   270,   206,   136,     0,   301,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,   150,     0,   157,
-       0,     0,   127,     0,     0,   131,     0,   175,   301,     0,
-     150,     0,   256,     0,     0,   140,     0,   118,     0,     0,
-     119,   125,     0,   143,     0,   113,     0,     0,   126,   128,
-     132,   256,   142,     0,   300,     0,   302,     0,     0,     0,
-       0,     0,   147,     0,   135,   117,   302,   306,     0,   159,
-       0,     0,     0,     0,     0,     0,   159,   302,   255,   206,
-       0,   277,   121,   120,     0,   122,   123,     0,   271,   159,
-     158,   303,   175,   124,   145,   175,   307,   278,   272,   175,
-     308
-};
-
-/* YYDEFGOTO[NTERM-NUM]. */
-static const short yydefgoto[] =
-{
-      -1,     6,   123,    11,    12,     9,    10,    19,    90,   245,
-     182,   181,   179,   190,   191,   192,   305,     7,     8,    18,
-      58,   136,   213,   235,   443,   549,   502,    59,   207,   323,
-     140,   647,   648,   693,   670,   649,   650,   691,   651,   664,
-     687,   652,   653,   654,   688,   751,   115,   144,    61,   696,
-      62,   216,   217,   218,   332,   437,   545,   594,   436,   496,
-     497,    63,    64,   228,    65,   229,    66,   231,   689,   205,
-     250,   726,   531,   566,   585,   615,   324,   428,   602,   624,
-     698,   765,   430,   603,   622,   677,   762,   431,   536,   486,
-     525,   484,   485,   489,   535,   702,   739,   625,   676,   747,
-     769,    67,   208,   327,   432,   573,   492,   539,   571,    15,
-      16,    26,    27,   103,    13,    14,    68,    69,    23,    24,
-     427,    97,    98,   518,   421,   516
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -645
-static const short yypact[] =
-{
-     179,  -645,  -645,  -645,  -645,  -645,    73,  -645,  -645,  -645,
-    -645,  -645,    45,  -645,     5,  -645,    71,  -645,   862,  1685,
-      81,   105,    86,     5,  -645,   121,    71,  -645,   550,    97,
-     131,    90,   145,  -645,   155,  -645,   192,   164,   213,   223,
-     226,   231,   236,   238,   244,   246,   250,  -645,  -645,   255,
-     277,  -645,   278,   279,   280,  -645,   293,  -645,  -645,  -645,
-    -645,   104,  -645,  -645,  -645,  -645,  -645,  -645,  -645,   199,
-    -645,   329,   192,   330,   796,  -645,   331,   339,   341,  -645,
-    -645,   342,   344,   345,   796,   349,   352,   355,  -645,   356,
-     251,   796,  -645,   359,  -645,   354,   357,   310,   233,   105,
-    -645,  -645,  -645,   319,   242,  -645,  -645,  -645,  -645,  -645,
-    -645,  -645,  -645,  -645,  -645,  -645,  -645,  -645,   375,   377,
-     378,   385,  -645,  -645,    34,   387,   388,   391,   192,   192,
-     392,   192,     4,  -645,   394,    30,   362,   192,   406,   407,
-     376,  -645,  -645,  -645,  -645,   360,    26,  -645,    33,  -645,
-    -645,   796,   796,   796,   379,   382,   383,   401,   402,  -645,
-     403,   404,   405,   408,   409,   410,   412,   416,   420,   422,
-     423,   424,   435,   436,   796,   796,  1481,   384,  -645,   282,
-    -645,   292,    15,  -645,  -645,   538,  1865,   302,  -645,  -645,
-     309,  -645,   470,  -645,  -645,  1865,   425,   121,   121,   334,
-     220,   426,   337,   220,  -645,   796,  -645,   397,    40,  -645,
-    -645,   -54,   347,  -645,  -645,   192,   427,    -6,  -645,   346,
-     351,   353,   358,   363,   366,   369,  -645,  -645,   -24,   100,
-      22,   370,  -645,  -645,   444,    16,    30,   372,   477,   480,
-     796,   381,     5,   796,   796,  -645,   796,   796,  -645,  -645,
-    1097,   796,   796,   796,   796,   796,   485,   500,   796,   515,
-     516,   517,   518,   796,   796,   526,   529,   796,   796,   531,
-    -645,  -645,   796,   796,   796,   796,   796,   796,   796,   796,
-     796,   796,   796,   796,   796,   796,   796,   796,   796,   796,
-     796,   796,   796,   796,  1865,   532,   533,  -645,   534,   796,
-     796,  1865,   286,   535,  -645,    23,  -645,   400,   428,  -645,
-    -645,   536,  -645,  -645,  -645,   -58,  -645,  1865,   550,  -645,
-     192,  -645,  -645,  -645,  -645,  -645,  -645,  -645,   541,  -645,
-    -645,   950,   509,  -645,  -645,  -645,    34,   545,  -645,  -645,
-    -645,  -645,  -645,  -645,  -645,   192,  -645,   192,   394,  -645,
-    -645,  -645,  -645,  -645,   513,    36,  -645,    19,  -645,  -645,
-    -645,  1501,  -645,   -10,  1865,  1865,  1708,  1865,  1865,  -645,
-    1077,  1117,  1521,  1541,  1137,   430,   429,  1157,   448,   449,
-     451,   452,  1561,  1607,   454,   459,  1177,  1627,   460,  1709,
-    1733,  1587,  1880,   784,   869,   554,   554,   374,   374,   374,
-     374,   307,   307,   195,   195,  -645,  -645,  -645,  1865,  1865,
-    1865,  -645,  -645,  -645,  1865,  1865,  -645,  -645,  -645,  -645,
-     548,   121,   234,   220,   537,  -645,  -645,   -57,   624,  -645,
-     710,   624,   796,   432,  -645,     3,   589,    34,  -645,   463,
-    -645,  -645,  -645,    30,  -645,  -645,  -645,   571,  -645,   465,
-     466,   562,  -645,  -645,   796,  -645,  -645,   796,   796,  -645,
-     796,  -645,  -645,  -645,  -645,  -645,  -645,   796,   796,  -645,
-    -645,  -645,   607,  -645,   796,  -645,   471,   597,  -645,  -645,
-    -645,   227,   578,  1822,   608,   524,  -645,  -645,  1845,   540,
-    -645,  1865,    21,   622,  -645,   625,     2,  -645,   543,   600,
-    -645,    32,    30,  -645,  -645,  -645,   493,  1205,  1225,  1245,
-    1265,  1285,  1305,   494,  1865,   220,   581,   121,   121,  -645,
-    -645,  -645,  -645,  -645,  -645,   496,   796,   253,   626,  -645,
-     604,   612,   414,  -645,  -645,   524,   588,   614,   615,  -645,
-     512,  -645,  -645,  -645,   652,   523,  -645,  -645,    78,    30,
-    -645,  -645,  -645,  -645,  -645,  -645,  -645,  -645,  -645,   525,
-     471,  -645,  1333,  -645,   796,   623,   557,  -645,   557,  -645,
-     796,    21,   796,   527,  -645,  -645,   572,  -645,   128,   220,
-     609,   222,  1353,   796,   634,  -645,  -645,   450,  1373,  -645,
-    1393,  -645,  -645,   666,  -645,  -645,  -645,   636,   658,  -645,
-    1413,   796,   103,   627,  -645,  -645,    21,  -645,   796,  -645,
-    -645,  1433,  -645,  -645,  -645,   630,  -645,  -645,  -645,  1461,
-    -645,  -645,  -645,   642,    52,    47,   665,   419,  -645,  -645,
-    -645,  -645,  -645,  -645,  -645,   653,   654,   655,   192,   656,
-    -645,  -645,  -645,   657,   659,  -645,   239,  -645,   660,  -645,
-    -645,  -645,    52,   631,   662,   104,  -645,  -645,  -645,   273,
-      59,    60,  -645,  -645,   663,  -645,    60,  -645,   664,  -645,
-      -4,   239,  -645,  -645,  -645,  -645,   638,   677,   673,   674,
-     568,   678,   573,   682,   683,   577,   579,    52,   580,  -645,
-     796,    14,  -645,    18,   230,  -645,   239,   125,   677,   583,
-      52,   718,   628,    60,    60,  -645,    60,  -645,    60,    60,
-    -645,  -645,   689,  -645,  1647,   584,   586,    60,  -645,  -645,
-    -645,   628,  -645,   676,  -645,   706,  -645,   591,   592,    27,
-     593,   594,  -645,   728,  -645,  -645,  -645,  -645,   738,    49,
-     599,   601,    60,   602,   606,   610,    49,  -645,  -645,  -645,
-     740,  -645,  -645,  -645,   611,  -645,  -645,   104,  -645,    49,
-    -645,  -645,   523,  -645,  -645,   523,  -645,  -645,  -645,   523,
-    -645
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const short yypgoto[] =
-{
-    -645,  -645,   -71,  -645,  -645,  -645,  -645,   506,  -645,  -645,
-    -645,  -645,  -645,  -645,   616,  -645,  -645,  -645,  -645,   539,
-    -645,  -645,  -645,  -220,  -645,  -645,  -645,  -645,  -443,   -13,
-    -645,   -60,  -592,    50,    82,    67,  -645,  -645,   107,  -645,
-    -645,  -645,  -611,  -645,    11,  -644,  -645,  -627,  -571,  -214,
-    -645,   328,  -645,   431,  -645,  -645,  -645,  -645,  -645,  -645,
-     270,  -645,  -645,  -645,  -645,  -645,  -645,  -221,  -104,  -645,
-     -74,    54,   235,  -645,   200,  -645,  -645,  -645,  -645,  -645,
-    -645,  -645,  -645,  -645,  -645,  -645,  -645,  -645,  -645,  -645,
-    -645,  -471,   348,  -645,  -645,    75,  -624,  -645,  -645,  -645,
-    -645,  -645,  -645,  -645,  -645,  -645,  -645,  -526,  -645,  -645,
-    -645,  -645,   750,  -645,  -645,  -645,  -645,  -645,   544,   -19,
-    -645,   679,   -12,  -645,  -645,   217
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -330
-static const short yytable[] =
-{
-     176,   147,   204,   336,   100,    60,   494,   494,   122,   349,
-     186,   206,   528,   104,   345,   347,   357,   195,   715,   297,
-     352,   353,   667,   352,   353,   537,   230,   419,   675,   628,
-    -177,   667,   243,   628,   232,   233,   352,   353,   214,   246,
-     445,   446,   628,   532,   325,   589,   629,    21,   452,    20,
-     629,   656,  -177,   655,   669,   749,   627,   222,   223,   629,
-     225,   227,    21,   667,   667,   750,   237,   628,   668,   636,
-     637,   425,   479,    17,   628,   628,   712,   248,   249,   669,
-     617,   655,   352,   353,   629,   426,   480,    91,   328,   723,
-     329,   629,   629,   630,   631,   632,   633,   634,   326,   215,
-     270,   271,   758,   294,   719,   657,   635,   636,   637,    92,
-     598,   301,   746,   683,   684,   766,   655,   638,   335,    22,
-     344,   354,   538,   759,   354,    92,   587,   442,    25,   655,
-     764,   317,   352,   353,    22,   234,   335,   354,   335,   118,
-     119,   447,   695,    99,   333,   639,   542,   640,   226,   495,
-     495,   641,   626,   644,   116,    53,    54,   298,   355,   646,
-     356,   355,   717,   448,   348,   420,   361,   642,   244,   364,
-     365,   742,   367,   368,   355,   247,   547,   370,   371,   372,
-     373,   374,   120,   354,   377,   307,   308,   643,   117,   382,
-     383,   644,   121,   386,   387,   645,   122,   646,   389,   390,
-     391,   392,   393,   394,   395,   396,   397,   398,   399,   400,
-     401,   402,   403,   404,   405,   406,   407,   408,   409,   410,
-     355,   124,   577,   501,   310,   414,   415,   288,   289,   290,
-     149,   150,    93,   354,   667,    94,    95,    96,   310,   612,
-     613,   614,   335,   667,   346,   628,   142,   143,    93,   429,
-     125,    94,   101,   102,   628,   449,   450,   151,   152,   527,
-     126,   597,   629,   127,   153,   154,   155,   335,   128,   720,
-     355,   629,   595,   129,   440,   130,   441,   667,   156,   157,
-     158,   131,   548,   132,   678,   679,   159,   133,   628,   416,
-     417,   160,   134,   668,   636,   637,   519,   520,   521,   522,
-     523,   161,     1,     2,     3,   629,   162,   163,   164,   165,
-     166,   167,   168,     4,   135,   137,   138,   139,    60,   169,
-       5,   170,   519,   520,   521,   522,   523,   678,   679,   578,
-     141,   576,   145,   146,   148,   177,   171,   286,   287,   288,
-     289,   290,   172,   178,   100,   180,   183,   311,   184,   185,
-     312,   313,   314,   187,   483,   188,   488,   483,   491,   189,
-     193,   311,   194,   196,   312,   313,   477,   173,   199,   681,
-     197,   524,   680,   198,   174,   175,   200,   202,   644,   209,
-     507,   210,   211,   508,   509,   203,   510,   149,   150,   212,
-     292,   219,   220,   511,   512,   221,   224,   524,   230,   236,
-     514,   318,   284,   285,   286,   287,   288,   289,   290,   476,
-     238,   239,   681,   240,   151,   152,   251,   242,   318,   252,
-     253,   153,   154,   155,   295,   106,   107,   108,   109,   110,
-     111,   112,   113,   114,   296,   156,   157,   158,   254,   255,
-     256,   257,   258,   159,   302,   259,   260,   261,   160,   262,
-     567,   303,   562,   263,   318,   319,  -113,   264,   161,   265,
-     266,   267,   320,   162,   163,   164,   165,   166,   167,   168,
-     321,   592,   268,   269,   304,    43,   169,   309,   170,   320,
-     316,   351,   306,   359,   315,   334,   360,   321,   337,   375,
-     582,   330,    43,   171,   322,   338,   588,   339,   590,   172,
-      53,    54,   340,   618,   376,   559,   560,   341,   604,   600,
-     342,   322,    55,   343,   350,   320,   358,    53,    54,   378,
-     379,   380,   381,   321,   173,   362,   293,   611,    43,    55,
-     384,   174,   175,   385,   619,   388,   411,   412,   413,   418,
-     424,   149,   150,   422,   299,   433,   435,   322,   767,   439,
-     444,   768,   475,    53,    54,   770,   106,   107,   108,   109,
-     110,   111,   112,   113,   114,    55,   506,   662,   151,   152,
-     699,   423,   460,   461,   493,   153,   154,   155,   280,   281,
-     282,   283,   284,   285,   286,   287,   288,   289,   290,   156,
-     157,   158,   463,   464,   478,   465,   466,   159,   469,   682,
-     685,   686,   160,   470,   473,   498,   692,   500,   503,   504,
-     505,   513,   161,   517,   515,   526,   714,   162,   163,   164,
-     165,   166,   167,   168,   529,   530,   540,   149,   150,   541,
-     169,   534,   170,   718,   682,   544,   546,   550,   557,   558,
-     561,   564,   563,   727,   728,   569,   692,   171,   730,   731,
-     565,   570,   572,   172,   151,   152,   574,   735,   575,   584,
-     583,   481,   154,   155,   482,   335,   593,   596,   579,   718,
-     591,   601,   607,   608,   609,   156,   157,   158,   173,   527,
-     300,   658,   754,   159,   616,   174,   175,   621,   160,   673,
-     659,   660,   661,   663,   665,   700,   666,   671,   161,   674,
-     690,   694,   701,   162,   163,   164,   165,   166,   167,   168,
-     703,   704,   705,   149,   150,   706,   169,   707,   170,   708,
-     709,   710,   724,   711,   713,   732,   487,   722,  -130,   725,
-     734,   738,   745,   171,   737,   740,   741,   743,   744,   172,
-     151,   152,   748,   752,   761,   753,   755,   153,   154,   155,
-     756,   366,   331,   697,   757,   763,   729,   241,   716,   672,
-     760,   156,   157,   158,   173,   499,   543,   438,   586,   159,
-     568,   174,   175,   721,   160,   736,   105,   580,   201,   490,
-       0,     0,     0,     0,   161,     0,   363,     0,     0,   162,
-     163,   164,   165,   166,   167,   168,     0,     0,     0,   149,
-     150,     0,   169,     0,   170,   277,   278,   279,   280,   281,
-     282,   283,   284,   285,   286,   287,   288,   289,   290,   171,
-       0,     0,     0,     0,     0,   172,   151,   152,     0,     0,
-       0,     0,     0,   153,   154,   155,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,   156,   157,   158,
-     173,     0,     0,     0,     0,   159,     0,   174,   175,     0,
-     160,     0,     0,     0,     0,     0,    28,     0,     0,     0,
-     161,     0,     0,     0,     0,   162,   163,   164,   165,   166,
-     167,   168,     0,     0,     0,     0,     0,     0,   169,     0,
-     170,   278,   279,   280,   281,   282,   283,   284,   285,   286,
-     287,   288,   289,   290,     0,   171,     0,     0,    29,    30,
-      31,   172,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,    32,    33,    34,    35,     0,    36,    37,    38,
-      39,     0,     0,     0,     0,     0,   173,    40,    41,    42,
-      43,     0,     0,   174,   175,     0,     0,     0,    44,    45,
-      46,    47,    48,    49,    28,     0,     0,     0,    50,    51,
-      52,     0,     0,     0,     0,    53,    54,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,    55,     0,     0,
-       0,     0,     0,     0,     0,     0,   434,     0,     0,    56,
-       0,     0,     0,     0,     0,  -329,    29,    30,    31,     0,
-       0,     0,     0,     0,     0,    57,     0,     0,     0,     0,
-      32,    33,    34,    35,     0,    36,    37,    38,    39,     0,
-       0,     0,     0,     0,     0,    40,    41,    42,    43,     0,
-       0,     0,     0,     0,     0,     0,    44,    45,    46,    47,
-      48,    49,     0,     0,     0,     0,    50,    51,    52,     0,
-       0,     0,     0,    53,    54,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,    55,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,    56,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,   272,    57,   273,   274,   275,   276,   277,   278,
-     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
-     289,   290,   272,     0,   273,   274,   275,   276,   277,   278,
-     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
-     289,   290,   272,     0,   273,   274,   275,   276,   277,   278,
-     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
-     289,   290,   272,     0,   273,   274,   275,   276,   277,   278,
-     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
-     289,   290,   272,     0,   273,   274,   275,   276,   277,   278,
-     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
-     289,   290,   272,     0,   273,   274,   275,   276,   277,   278,
-     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
-     289,   290,     0,     0,     0,     0,     0,     0,     0,   454,
-     272,   455,   273,   274,   275,   276,   277,   278,   279,   280,
-     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
-     272,   369,   273,   274,   275,   276,   277,   278,   279,   280,
-     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
-     272,   456,   273,   274,   275,   276,   277,   278,   279,   280,
-     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
-     272,   459,   273,   274,   275,   276,   277,   278,   279,   280,
-     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
-     272,   462,   273,   274,   275,   276,   277,   278,   279,   280,
-     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
-     272,   471,   273,   274,   275,   276,   277,   278,   279,   280,
-     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
-       0,     0,     0,     0,     0,     0,     0,     0,   272,   551,
-     273,   274,   275,   276,   277,   278,   279,   280,   281,   282,
-     283,   284,   285,   286,   287,   288,   289,   290,   272,   552,
-     273,   274,   275,   276,   277,   278,   279,   280,   281,   282,
-     283,   284,   285,   286,   287,   288,   289,   290,   272,   553,
-     273,   274,   275,   276,   277,   278,   279,   280,   281,   282,
-     283,   284,   285,   286,   287,   288,   289,   290,   272,   554,
-     273,   274,   275,   276,   277,   278,   279,   280,   281,   282,
-     283,   284,   285,   286,   287,   288,   289,   290,   272,   555,
-     273,   274,   275,   276,   277,   278,   279,   280,   281,   282,
-     283,   284,   285,   286,   287,   288,   289,   290,   272,   556,
-     273,   274,   275,   276,   277,   278,   279,   280,   281,   282,
-     283,   284,   285,   286,   287,   288,   289,   290,     0,     0,
-       0,     0,     0,     0,     0,     0,   272,   581,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,   287,   288,   289,   290,   272,   599,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,   287,   288,   289,   290,   272,   605,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,   287,   288,   289,   290,   272,   606,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,   287,   288,   289,   290,   272,   610,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,   287,   288,   289,   290,   272,   620,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,   287,   288,   289,   290,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,   623,   275,   276,   277,   278,
-     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
-     289,   290,   272,   291,   273,   274,   275,   276,   277,   278,
-     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
-     289,   290,   272,   451,   273,   274,   275,   276,   277,   278,
-     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
-     289,   290,   272,   457,   273,   274,   275,   276,   277,   278,
-     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
-     289,   290,     0,   458,     0,     0,     0,     0,     0,    70,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,   467,     0,     0,     0,     0,     0,     0,
-       0,     0,    70,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,    71,   272,   474,   273,   274,   275,   276,
-     277,   278,   279,   280,   281,   282,   283,   284,   285,   286,
-     287,   288,   289,   290,   453,     0,    71,     0,     0,   468,
-      72,   274,   275,   276,   277,   278,   279,   280,   281,   282,
-     283,   284,   285,   286,   287,   288,   289,   290,     0,   472,
-       0,     0,     0,    72,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,    73,     0,     0,     0,   733,
-       0,    74,    75,    76,    77,    78,   -43,    79,    80,    81,
-       0,    82,    83,     0,    84,    85,    86,     0,    73,     0,
-       0,    87,    88,    89,    74,    75,    76,    77,    78,     0,
-      79,    80,    81,     0,    82,    83,     0,    84,    85,    86,
-       0,     0,     0,     0,    87,    88,    89,   272,     0,   273,
-     274,   275,   276,   277,   278,   279,   280,   281,   282,   283,
-     284,   285,   286,   287,   288,   289,   290,     0,     0,   527,
-     272,   533,   273,   274,   275,   276,   277,   278,   279,   280,
-     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
-     272,     0,   273,   274,   275,   276,   277,   278,   279,   280,
-     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
-     276,   277,   278,   279,   280,   281,   282,   283,   284,   285,
-     286,   287,   288,   289,   290
-};
-
-static const short yycheck[] =
-{
-      74,    72,   106,   217,    23,    18,     4,     4,     4,   230,
-      84,   115,   483,    25,   228,   229,   236,    91,     4,     4,
-       4,     5,     4,     4,     5,     4,     4,     4,   655,    15,
-      36,     4,     6,    15,     4,     5,     4,     5,     4,     6,
-       4,     5,    15,   486,     4,   571,    32,    57,    58,     4,
-      32,     4,    58,   624,   646,     6,     4,   128,   129,    32,
-     131,   132,    57,     4,     4,    16,   137,    15,    54,    55,
-      56,   129,   129,     0,    15,    15,   687,   151,   152,   671,
-     606,   652,     4,     5,    32,   143,   143,     6,   142,   700,
-     144,    32,    32,    41,    42,    43,    44,    45,    58,    65,
-     174,   175,   746,   177,   696,    58,    54,    55,    56,     4,
-     581,   185,   736,    54,    55,   759,   687,    65,   142,   129,
-     144,   105,   101,   747,   105,     4,   569,   348,    57,   700,
-     757,   205,     4,     5,   129,   105,   142,   105,   142,    49,
-      50,   105,   146,    57,   215,    93,   144,    95,   144,   147,
-     147,    99,   623,   139,    57,   103,   104,   142,   142,   145,
-     144,   142,   144,   144,   142,   142,   240,   115,   142,   243,
-     244,   144,   246,   247,   142,   142,   144,   251,   252,   253,
-     254,   255,    37,   105,   258,   197,   198,   135,    57,   263,
-     264,   139,    37,   267,   268,   143,     4,   145,   272,   273,
-     274,   275,   276,   277,   278,   279,   280,   281,   282,   283,
-     284,   285,   286,   287,   288,   289,   290,   291,   292,   293,
-     142,    57,   144,   443,     4,   299,   300,    32,    33,    34,
-       3,     4,   127,   105,     4,   130,   131,   132,     4,   136,
-     137,   138,   142,     4,   144,    15,   142,   143,   127,   320,
-      37,   130,   131,   132,    15,   359,   360,    30,    31,    37,
-      37,    39,    32,    37,    37,    38,    39,   142,    37,   144,
-     142,    32,   144,    37,   345,    37,   347,     4,    51,    52,
-      53,    37,   502,    37,    54,    55,    59,    37,    15,     3,
-       4,    64,    37,    54,    55,    56,    69,    70,    71,    72,
-      73,    74,   123,   124,   125,    32,    79,    80,    81,    82,
-      83,    84,    85,   134,    37,    37,    37,    37,   331,    92,
-     141,    94,    69,    70,    71,    72,    73,    54,    55,   549,
-      37,   545,   133,     4,     4,     4,   109,    30,    31,    32,
-      33,    34,   115,     4,   363,     4,     4,   127,     4,     4,
-     130,   131,   132,     4,   428,     3,   430,   431,   432,     4,
-       4,   127,   111,     4,   130,   131,   132,   140,    58,   139,
-      16,   144,    99,    16,   147,   148,   143,    58,   139,     4,
-     454,     4,     4,   457,   458,   143,   460,     3,     4,     4,
-       6,     4,     4,   467,   468,     4,     4,   144,     4,    37,
-     474,     4,    28,    29,    30,    31,    32,    33,    34,   421,
-       4,     4,   139,    37,    30,    31,    37,    57,     4,    37,
-      37,    37,    38,    39,   142,     6,     7,     8,     9,    10,
-      11,    12,    13,    14,   142,    51,    52,    53,    37,    37,
-      37,    37,    37,    59,   142,    37,    37,    37,    64,    37,
-      36,   142,   526,    37,     4,    58,    37,    37,    74,    37,
-      37,    37,    65,    79,    80,    81,    82,    83,    84,    85,
-      73,   575,    37,    37,     4,    78,    92,   143,    94,    65,
-     143,    37,    57,     6,    58,    58,     6,    73,   142,     4,
-     564,   144,    78,   109,    97,   144,   570,   144,   572,   115,
-     103,   104,   144,   607,     4,   517,   518,   144,    58,   583,
-     144,    97,   115,   144,   144,    65,   144,   103,   104,     4,
-       4,     4,     4,    73,   140,   144,   142,   601,    78,   115,
-       4,   147,   148,     4,   608,     4,     4,     4,     4,     4,
-       4,     3,     4,   143,     6,     4,    37,    97,   762,     4,
-      37,   765,     4,   103,   104,   769,     6,     7,     8,     9,
-      10,    11,    12,    13,    14,   115,     4,   638,    30,    31,
-     674,   143,   142,   144,   142,    37,    38,    39,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,    51,
-      52,    53,   144,   144,    57,   144,   144,    59,   144,   659,
-     660,   661,    64,   144,   144,    16,   666,   144,    37,   144,
-     144,     4,    74,    16,   143,    37,   690,    79,    80,    81,
-      82,    83,    84,    85,    16,   101,     4,     3,     4,     4,
-      92,    91,    94,   693,   694,    92,    36,   144,   144,    58,
-     144,    37,    16,   703,   704,    57,   706,   109,   708,   709,
-      38,    37,    37,   115,    30,    31,   144,   717,     6,   102,
-      37,    37,    38,    39,    40,   142,    94,    58,   143,   729,
-     143,    37,     6,    37,    16,    51,    52,    53,   140,    37,
-     142,    16,   742,    59,    57,   147,   148,    57,    64,    58,
-      37,    37,    37,    37,    37,    57,    37,    37,    74,    37,
-      37,    37,    25,    79,    80,    81,    82,    83,    84,    85,
-      37,    37,   144,     3,     4,    37,    92,   144,    94,    37,
-      37,   144,     4,   144,   144,    36,    16,   144,   144,   101,
-     144,    25,     4,   109,    58,   144,   144,   144,   144,   115,
-      30,    31,     4,   144,     4,   144,   144,    37,    38,    39,
-     144,   245,   213,   671,   144,   144,   706,   141,   691,   652,
-     749,    51,    52,    53,   140,   437,   496,   336,   568,    59,
-     535,   147,   148,   698,    64,   721,    26,   560,    99,   431,
-      -1,    -1,    -1,    -1,    74,    -1,   242,    -1,    -1,    79,
-      80,    81,    82,    83,    84,    85,    -1,    -1,    -1,     3,
-       4,    -1,    92,    -1,    94,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,   109,
-      -1,    -1,    -1,    -1,    -1,   115,    30,    31,    -1,    -1,
-      -1,    -1,    -1,    37,    38,    39,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    51,    52,    53,
-     140,    -1,    -1,    -1,    -1,    59,    -1,   147,   148,    -1,
-      64,    -1,    -1,    -1,    -1,    -1,     4,    -1,    -1,    -1,
-      74,    -1,    -1,    -1,    -1,    79,    80,    81,    82,    83,
-      84,    85,    -1,    -1,    -1,    -1,    -1,    -1,    92,    -1,
-      94,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    -1,   109,    -1,    -1,    46,    47,
-      48,   115,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    60,    61,    62,    63,    -1,    65,    66,    67,
-      68,    -1,    -1,    -1,    -1,    -1,   140,    75,    76,    77,
-      78,    -1,    -1,   147,   148,    -1,    -1,    -1,    86,    87,
-      88,    89,    90,    91,     4,    -1,    -1,    -1,    96,    97,
-      98,    -1,    -1,    -1,    -1,   103,   104,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,   115,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    36,    -1,    -1,   127,
-      -1,    -1,    -1,    -1,    -1,   133,    46,    47,    48,    -1,
-      -1,    -1,    -1,    -1,    -1,   143,    -1,    -1,    -1,    -1,
-      60,    61,    62,    63,    -1,    65,    66,    67,    68,    -1,
-      -1,    -1,    -1,    -1,    -1,    75,    76,    77,    78,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    86,    87,    88,    89,
-      90,    91,    -1,    -1,    -1,    -1,    96,    97,    98,    -1,
-      -1,    -1,    -1,   103,   104,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,   115,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,   127,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    15,   143,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    15,    -1,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    15,    -1,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    15,    -1,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    15,    -1,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    15,    -1,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   142,
-      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    15,   144,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    15,   144,    17,    18,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    15,   144,    17,    18,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    15,   144,    17,    18,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    15,   144,    17,    18,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    15,   144,    17,    18,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    15,   144,    17,    18,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,   144,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    15,   142,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    15,   142,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    15,   142,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    -1,   142,    -1,    -1,    -1,    -1,    -1,     4,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,   142,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,     4,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    38,    15,    16,    17,    18,    19,    20,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    36,    -1,    38,    -1,    -1,   142,
-      65,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    -1,   142,
-      -1,    -1,    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,   100,    -1,    -1,    -1,   142,
-      -1,   106,   107,   108,   109,   110,   111,   112,   113,   114,
-      -1,   116,   117,    -1,   119,   120,   121,    -1,   100,    -1,
-      -1,   126,   127,   128,   106,   107,   108,   109,   110,    -1,
-     112,   113,   114,    -1,   116,   117,    -1,   119,   120,   121,
-      -1,    -1,    -1,    -1,   126,   127,   128,    15,    -1,    17,
-      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    33,    34,    -1,    -1,    37,
-      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,    -1,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
-      30,    31,    32,    33,    34
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const unsigned short yystos[] =
-{
-       0,   123,   124,   125,   134,   141,   150,   166,   167,   154,
-     155,   152,   153,   263,   264,   258,   259,     0,   168,   156,
-       4,    57,   129,   267,   268,    57,   260,   261,     4,    46,
-      47,    48,    60,    61,    62,    63,    65,    66,    67,    68,
-      75,    76,    77,    78,    86,    87,    88,    89,    90,    91,
-      96,    97,    98,   103,   104,   115,   127,   143,   169,   176,
-     178,   197,   199,   210,   211,   213,   215,   250,   265,   266,
-       4,    38,    65,   100,   106,   107,   108,   109,   110,   112,
-     113,   114,   116,   117,   119,   120,   121,   126,   127,   128,
-     157,     6,     4,   127,   130,   131,   132,   270,   271,    57,
-     268,   131,   132,   262,   271,   261,     6,     7,     8,     9,
-      10,    11,    12,    13,    14,   195,    57,    57,    49,    50,
-      37,    37,     4,   151,    57,    37,    37,    37,    37,    37,
-      37,    37,    37,    37,    37,    37,   170,    37,    37,    37,
-     179,    37,   142,   143,   196,   133,     4,   151,     4,     3,
-       4,    30,    31,    37,    38,    39,    51,    52,    53,    59,
-      64,    74,    79,    80,    81,    82,    83,    84,    85,    92,
-      94,   109,   115,   140,   147,   148,   219,     4,     4,   161,
-       4,   160,   159,     4,     4,     4,   219,     4,     3,     4,
-     162,   163,   164,     4,   111,   219,     4,    16,    16,    58,
-     143,   270,    58,   143,   217,   218,   217,   177,   251,     4,
-       4,     4,     4,   171,     4,    65,   200,   201,   202,     4,
-       4,     4,   151,   151,     4,   151,   144,   151,   212,   214,
-       4,   216,     4,     5,   105,   172,    37,   151,     4,     4,
-      37,   163,    57,     6,   142,   158,     6,   142,   219,   219,
-     219,    37,    37,    37,    37,    37,    37,    37,    37,    37,
-      37,    37,    37,    37,    37,    37,    37,    37,    37,    37,
-     219,   219,    15,    17,    18,    19,    20,    21,    22,    23,
-      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
-      34,   142,     6,   142,   219,   142,   142,     4,   142,     6,
-     142,   219,   142,   142,     4,   165,    57,   271,   271,   143,
-       4,   127,   130,   131,   132,    58,   143,   219,     4,    58,
-      65,    73,    97,   178,   225,     4,    58,   252,   142,   144,
-     144,   168,   203,   151,    58,   142,   198,   142,   144,   144,
-     144,   144,   144,   144,   144,   198,   144,   198,   142,   216,
-     144,    37,     4,     5,   105,   142,   144,   172,   144,     6,
-       6,   219,   144,   267,   219,   219,   156,   219,   219,   144,
-     219,   219,   219,   219,   219,     4,     4,   219,     4,     4,
-       4,     4,   219,   219,     4,     4,   219,   219,     4,   219,
-     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
-     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
-     219,     4,     4,     4,   219,   219,     3,     4,     4,     4,
-     142,   273,   143,   143,     4,   129,   143,   269,   226,   151,
-     231,   236,   253,     4,    36,    37,   207,   204,   202,     4,
-     151,   151,   216,   173,    37,     4,     5,   105,   144,   217,
-     217,   142,    58,    36,   142,   144,   144,   142,   142,   144,
-     142,   144,   144,   144,   144,   144,   144,   142,   142,   144,
-     144,   144,   142,   144,    16,     4,   271,   132,    57,   129,
-     143,    37,    40,   219,   240,   241,   238,    16,   219,   242,
-     241,   219,   255,   142,     4,   147,   208,   209,    16,   200,
-     144,   172,   175,    37,   144,   144,     4,   219,   219,   219,
-     219,   219,   219,     4,   219,   143,   274,    16,   272,    69,
-      70,    71,    72,    73,   144,   239,    37,    37,   240,    16,
-     101,   221,   177,    16,    91,   243,   237,     4,   101,   256,
-       4,     4,   144,   209,    92,   205,    36,   144,   172,   174,
-     144,   144,   144,   144,   144,   144,   144,   144,    58,   271,
-     271,   144,   219,    16,    37,    38,   222,    36,   221,    57,
-      37,   257,    37,   254,   144,     6,   198,   144,   172,   143,
-     274,   144,   219,    37,   102,   223,   223,   177,   219,   256,
-     219,   143,   217,    94,   206,   144,    58,    39,   240,   144,
-     219,    37,   227,   232,    58,   144,   144,     6,    37,    16,
-     144,   219,   136,   137,   138,   224,    57,   256,   217,   219,
-     144,    57,   233,   144,   228,   246,   240,     4,    15,    32,
-      41,    42,    43,    44,    45,    54,    55,    56,    65,    93,
-      95,    99,   115,   135,   139,   143,   145,   180,   181,   184,
-     185,   187,   190,   191,   192,   197,     4,    58,    16,    37,
-      37,    37,   151,    37,   188,    37,    37,     4,    54,   181,
-     183,    37,   187,    58,    37,   196,   247,   234,    54,    55,
-      99,   139,   180,    54,    55,   180,   180,   189,   193,   217,
-      37,   186,   180,   182,    37,   146,   198,   183,   229,   217,
-      57,    25,   244,    37,    37,   144,    37,   144,    37,    37,
-     144,   144,   191,   144,   219,     4,   184,   144,   180,   181,
-     144,   244,   144,   191,     4,   101,   220,   180,   180,   182,
-     180,   180,    36,   142,   144,   180,   220,    58,    25,   245,
-     144,   144,   144,   144,   144,     4,   245,   248,     4,     6,
-      16,   194,   144,   144,   180,   144,   144,   144,   194,   245,
-     193,     4,   235,   144,   196,   230,   194,   198,   198,   249,
-     198
-};
-
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-
-#define YYFAIL		goto yyerrlab
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
-      YYERROR;							\
-    }								\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
-
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
-#endif
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
-#endif
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (0)
-
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
-
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_stack_print (short *bottom, short *top)
-#else
-static void
-yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
-#endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (0)
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_reduce_print (int yyrule)
-#else
-static void
-yy_reduce_print (yyrule)
-    int yyrule;
-#endif
-{
-  int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
-yystrlen (const char *yystr)
-#   else
-yystrlen (yystr)
-     const char *yystr;
-#   endif
-{
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
-    continue;
-
-  return yys - yystr - 1;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-#   if defined (__STDC__) || defined (__cplusplus)
-yystpcpy (char *yydest, const char *yysrc)
-#   else
-yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
-{
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-#endif /* !YYERROR_VERBOSE */
-
-
-
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  if (yytype < YYNTOKENS)
-    {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-  switch (yytype)
-    {
-      default:
-        break;
-    }
-  YYFPRINTF (yyoutput, ")");
-}
-
-#endif /* ! YYDEBUG */
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yydestruct (yytype, yyvaluep)
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  switch (yytype)
-    {
-
-      default:
-        break;
-    }
-}
-
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM);
-# else
-int yyparse ();
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-
-/* The lookahead symbol.  */
-int yychar;
-
-/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int
-yyparse (void)
-#else
-int
-yyparse ()
-
-#endif
-#endif
-{
-  
-  register int yystate;
-  register int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss;
-  yyvsp = yyvs;
-
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-	/* Give user a chance to reallocate the stack. Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
-
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-
-		    &yystacksize);
-
-	yyss = yyss1;
-	yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
-      {
-	short *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyoverflowlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
-    {
-        case 8:
-#line 176 "ldgram.y"
-    { ldlex_defsym(); }
-    break;
-
-  case 9:
-#line 178 "ldgram.y"
-    {
-		  ldlex_popstate();
-		  lang_add_assignment (exp_defsym (yyvsp[-2].name, yyvsp[0].etree));
-		}
-    break;
-
-  case 10:
-#line 186 "ldgram.y"
-    {
-		  ldlex_mri_script ();
-		  PUSH_ERROR (_("MRI style script"));
-		}
-    break;
-
-  case 11:
-#line 191 "ldgram.y"
-    {
-		  ldlex_popstate ();
-		  mri_draw_tree ();
-		  POP_ERROR ();
-		}
-    break;
-
-  case 16:
-#line 206 "ldgram.y"
-    {
-			einfo(_("%P%F: unrecognised keyword in MRI style script '%s'\n"),yyvsp[0].name);
-			}
-    break;
-
-  case 17:
-#line 209 "ldgram.y"
-    {
-			config.map_filename = "-";
-			}
-    break;
-
-  case 20:
-#line 215 "ldgram.y"
-    { mri_public(yyvsp[-2].name, yyvsp[0].etree); }
-    break;
-
-  case 21:
-#line 217 "ldgram.y"
-    { mri_public(yyvsp[-2].name, yyvsp[0].etree); }
-    break;
-
-  case 22:
-#line 219 "ldgram.y"
-    { mri_public(yyvsp[-1].name, yyvsp[0].etree); }
-    break;
-
-  case 23:
-#line 221 "ldgram.y"
-    { mri_format(yyvsp[0].name); }
-    break;
-
-  case 24:
-#line 223 "ldgram.y"
-    { mri_output_section(yyvsp[-2].name, yyvsp[0].etree);}
-    break;
-
-  case 25:
-#line 225 "ldgram.y"
-    { mri_output_section(yyvsp[-1].name, yyvsp[0].etree);}
-    break;
-
-  case 26:
-#line 227 "ldgram.y"
-    { mri_output_section(yyvsp[-2].name, yyvsp[0].etree);}
-    break;
-
-  case 27:
-#line 229 "ldgram.y"
-    { mri_align(yyvsp[-2].name,yyvsp[0].etree); }
-    break;
-
-  case 28:
-#line 231 "ldgram.y"
-    { mri_align(yyvsp[-2].name,yyvsp[0].etree); }
-    break;
-
-  case 29:
-#line 233 "ldgram.y"
-    { mri_alignmod(yyvsp[-2].name,yyvsp[0].etree); }
-    break;
-
-  case 30:
-#line 235 "ldgram.y"
-    { mri_alignmod(yyvsp[-2].name,yyvsp[0].etree); }
-    break;
-
-  case 33:
-#line 239 "ldgram.y"
-    { mri_name(yyvsp[0].name); }
-    break;
-
-  case 34:
-#line 241 "ldgram.y"
-    { mri_alias(yyvsp[-2].name,yyvsp[0].name,0);}
-    break;
-
-  case 35:
-#line 243 "ldgram.y"
-    { mri_alias (yyvsp[-2].name, 0, (int) yyvsp[0].bigint.integer); }
-    break;
-
-  case 36:
-#line 245 "ldgram.y"
-    { mri_base(yyvsp[0].etree); }
-    break;
-
-  case 37:
-#line 247 "ldgram.y"
-    { mri_truncate ((unsigned int) yyvsp[0].bigint.integer); }
-    break;
-
-  case 40:
-#line 251 "ldgram.y"
-    { ldlex_script (); ldfile_open_command_file(yyvsp[0].name); }
-    break;
-
-  case 41:
-#line 253 "ldgram.y"
-    { ldlex_popstate (); }
-    break;
-
-  case 42:
-#line 255 "ldgram.y"
-    { lang_add_entry (yyvsp[0].name, FALSE); }
-    break;
-
-  case 44:
-#line 260 "ldgram.y"
-    { mri_order(yyvsp[0].name); }
-    break;
-
-  case 45:
-#line 261 "ldgram.y"
-    { mri_order(yyvsp[0].name); }
-    break;
-
-  case 47:
-#line 267 "ldgram.y"
-    { mri_load(yyvsp[0].name); }
-    break;
-
-  case 48:
-#line 268 "ldgram.y"
-    { mri_load(yyvsp[0].name); }
-    break;
-
-  case 49:
-#line 273 "ldgram.y"
-    { mri_only_load(yyvsp[0].name); }
-    break;
-
-  case 50:
-#line 275 "ldgram.y"
-    { mri_only_load(yyvsp[0].name); }
-    break;
-
-  case 51:
-#line 279 "ldgram.y"
-    { yyval.name = NULL; }
-    break;
-
-  case 54:
-#line 286 "ldgram.y"
-    { ldlex_expression (); }
-    break;
-
-  case 55:
-#line 288 "ldgram.y"
-    { ldlex_popstate (); }
-    break;
-
-  case 56:
-#line 292 "ldgram.y"
-    { ldlang_add_undef (yyvsp[0].name, FALSE); }
-    break;
-
-  case 57:
-#line 294 "ldgram.y"
-    { ldlang_add_undef (yyvsp[0].name, FALSE); }
-    break;
-
-  case 58:
-#line 296 "ldgram.y"
-    { ldlang_add_undef (yyvsp[0].name, FALSE); }
-    break;
-
-  case 59:
-#line 300 "ldgram.y"
-    { ldlex_both(); }
-    break;
-
-  case 60:
-#line 302 "ldgram.y"
-    { ldlex_popstate(); }
-    break;
-
-  case 73:
-#line 323 "ldgram.y"
-    { lang_add_target(yyvsp[-1].name); }
-    break;
-
-  case 74:
-#line 325 "ldgram.y"
-    { ldfile_add_library_path (yyvsp[-1].name, FALSE); }
-    break;
-
-  case 75:
-#line 327 "ldgram.y"
-    { lang_add_output(yyvsp[-1].name, 1); }
-    break;
-
-  case 76:
-#line 329 "ldgram.y"
-    { lang_add_output_format (yyvsp[-1].name, (char *) NULL,
-					    (char *) NULL, 1); }
-    break;
-
-  case 77:
-#line 332 "ldgram.y"
-    { lang_add_output_format (yyvsp[-5].name, yyvsp[-3].name, yyvsp[-1].name, 1); }
-    break;
-
-  case 78:
-#line 334 "ldgram.y"
-    { ldfile_set_output_arch (yyvsp[-1].name, bfd_arch_unknown); }
-    break;
-
-  case 79:
-#line 336 "ldgram.y"
-    { command_line.force_common_definition = TRUE ; }
-    break;
-
-  case 80:
-#line 338 "ldgram.y"
-    { command_line.inhibit_common_definition = TRUE ; }
-    break;
-
-  case 82:
-#line 341 "ldgram.y"
-    { lang_enter_group (); }
-    break;
-
-  case 83:
-#line 343 "ldgram.y"
-    { lang_leave_group (); }
-    break;
-
-  case 84:
-#line 345 "ldgram.y"
-    { lang_add_map(yyvsp[-1].name); }
-    break;
-
-  case 85:
-#line 347 "ldgram.y"
-    { ldlex_script (); ldfile_open_command_file(yyvsp[0].name); }
-    break;
-
-  case 86:
-#line 349 "ldgram.y"
-    { ldlex_popstate (); }
-    break;
-
-  case 87:
-#line 351 "ldgram.y"
-    {
-		  lang_add_nocrossref (yyvsp[-1].nocrossref);
-		}
-    break;
-
-  case 89:
-#line 356 "ldgram.y"
-    { lang_add_insert (yyvsp[0].name, 0); }
-    break;
-
-  case 90:
-#line 358 "ldgram.y"
-    { lang_add_insert (yyvsp[0].name, 1); }
-    break;
-
-  case 91:
-#line 360 "ldgram.y"
-    { lang_memory_region_alias (yyvsp[-3].name, yyvsp[-1].name); }
-    break;
-
-  case 92:
-#line 362 "ldgram.y"
-    { lang_ld_feature (yyvsp[-1].name); }
-    break;
-
-  case 93:
-#line 367 "ldgram.y"
-    { lang_add_input_file(yyvsp[0].name,lang_input_file_is_search_file_enum,
-				 (char *)NULL); }
-    break;
-
-  case 94:
-#line 370 "ldgram.y"
-    { lang_add_input_file(yyvsp[0].name,lang_input_file_is_search_file_enum,
-				 (char *)NULL); }
-    break;
-
-  case 95:
-#line 373 "ldgram.y"
-    { lang_add_input_file(yyvsp[0].name,lang_input_file_is_search_file_enum,
-				 (char *)NULL); }
-    break;
-
-  case 96:
-#line 376 "ldgram.y"
-    { lang_add_input_file(yyvsp[0].name,lang_input_file_is_l_enum,
-				 (char *)NULL); }
-    break;
-
-  case 97:
-#line 379 "ldgram.y"
-    { lang_add_input_file(yyvsp[0].name,lang_input_file_is_l_enum,
-				 (char *)NULL); }
-    break;
-
-  case 98:
-#line 382 "ldgram.y"
-    { lang_add_input_file(yyvsp[0].name,lang_input_file_is_l_enum,
-				 (char *)NULL); }
-    break;
-
-  case 99:
-#line 385 "ldgram.y"
-    { yyval.integer = add_DT_NEEDED_for_regular; add_DT_NEEDED_for_regular = TRUE; }
-    break;
-
-  case 100:
-#line 387 "ldgram.y"
-    { add_DT_NEEDED_for_regular = yyvsp[-2].integer; }
-    break;
-
-  case 101:
-#line 389 "ldgram.y"
-    { yyval.integer = add_DT_NEEDED_for_regular; add_DT_NEEDED_for_regular = TRUE; }
-    break;
-
-  case 102:
-#line 391 "ldgram.y"
-    { add_DT_NEEDED_for_regular = yyvsp[-2].integer; }
-    break;
-
-  case 103:
-#line 393 "ldgram.y"
-    { yyval.integer = add_DT_NEEDED_for_regular; add_DT_NEEDED_for_regular = TRUE; }
-    break;
-
-  case 104:
-#line 395 "ldgram.y"
-    { add_DT_NEEDED_for_regular = yyvsp[-2].integer; }
-    break;
-
-  case 109:
-#line 410 "ldgram.y"
-    { lang_add_entry (yyvsp[-1].name, FALSE); }
-    break;
-
-  case 111:
-#line 412 "ldgram.y"
-    {ldlex_expression ();}
-    break;
-
-  case 112:
-#line 413 "ldgram.y"
-    { ldlex_popstate ();
-		  lang_add_assignment (exp_assert (yyvsp[-3].etree, yyvsp[-1].name)); }
-    break;
-
-  case 113:
-#line 421 "ldgram.y"
-    {
-			  yyval.cname = yyvsp[0].name;
-			}
-    break;
-
-  case 114:
-#line 425 "ldgram.y"
-    {
-			  yyval.cname = "*";
-			}
-    break;
-
-  case 115:
-#line 429 "ldgram.y"
-    {
-			  yyval.cname = "?";
-			}
-    break;
-
-  case 116:
-#line 436 "ldgram.y"
-    {
-			  yyval.wildcard.name = yyvsp[0].cname;
-			  yyval.wildcard.sorted = none;
-			  yyval.wildcard.exclude_name_list = NULL;
-			}
-    break;
-
-  case 117:
-#line 442 "ldgram.y"
-    {
-			  yyval.wildcard.name = yyvsp[0].cname;
-			  yyval.wildcard.sorted = none;
-			  yyval.wildcard.exclude_name_list = yyvsp[-2].name_list;
-			}
-    break;
-
-  case 118:
-#line 448 "ldgram.y"
-    {
-			  yyval.wildcard.name = yyvsp[-1].cname;
-			  yyval.wildcard.sorted = by_name;
-			  yyval.wildcard.exclude_name_list = NULL;
-			}
-    break;
-
-  case 119:
-#line 454 "ldgram.y"
-    {
-			  yyval.wildcard.name = yyvsp[-1].cname;
-			  yyval.wildcard.sorted = by_alignment;
-			  yyval.wildcard.exclude_name_list = NULL;
-			}
-    break;
-
-  case 120:
-#line 460 "ldgram.y"
-    {
-			  yyval.wildcard.name = yyvsp[-2].cname;
-			  yyval.wildcard.sorted = by_name_alignment;
-			  yyval.wildcard.exclude_name_list = NULL;
-			}
-    break;
-
-  case 121:
-#line 466 "ldgram.y"
-    {
-			  yyval.wildcard.name = yyvsp[-2].cname;
-			  yyval.wildcard.sorted = by_name;
-			  yyval.wildcard.exclude_name_list = NULL;
-			}
-    break;
-
-  case 122:
-#line 472 "ldgram.y"
-    {
-			  yyval.wildcard.name = yyvsp[-2].cname;
-			  yyval.wildcard.sorted = by_alignment_name;
-			  yyval.wildcard.exclude_name_list = NULL;
-			}
-    break;
-
-  case 123:
-#line 478 "ldgram.y"
-    {
-			  yyval.wildcard.name = yyvsp[-2].cname;
-			  yyval.wildcard.sorted = by_alignment;
-			  yyval.wildcard.exclude_name_list = NULL;
-			}
-    break;
-
-  case 124:
-#line 484 "ldgram.y"
-    {
-			  yyval.wildcard.name = yyvsp[-1].cname;
-			  yyval.wildcard.sorted = by_name;
-			  yyval.wildcard.exclude_name_list = yyvsp[-3].name_list;
-			}
-    break;
-
-  case 125:
-#line 490 "ldgram.y"
-    {
-			  yyval.wildcard.name = yyvsp[-1].cname;
-			  yyval.wildcard.sorted = by_init_priority;
-			  yyval.wildcard.exclude_name_list = NULL;
-			}
-    break;
-
-  case 126:
-#line 499 "ldgram.y"
-    {
-			  struct name_list *tmp;
-			  tmp = (struct name_list *) xmalloc (sizeof *tmp);
-			  tmp->name = yyvsp[0].cname;
-			  tmp->next = yyvsp[-1].name_list;
-			  yyval.name_list = tmp;
-			}
-    break;
-
-  case 127:
-#line 508 "ldgram.y"
-    {
-			  struct name_list *tmp;
-			  tmp = (struct name_list *) xmalloc (sizeof *tmp);
-			  tmp->name = yyvsp[0].cname;
-			  tmp->next = NULL;
-			  yyval.name_list = tmp;
-			}
-    break;
-
-  case 128:
-#line 519 "ldgram.y"
-    {
-			  struct wildcard_list *tmp;
-			  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
-			  tmp->next = yyvsp[-2].wildcard_list;
-			  tmp->spec = yyvsp[0].wildcard;
-			  yyval.wildcard_list = tmp;
-			}
-    break;
-
-  case 129:
-#line 528 "ldgram.y"
-    {
-			  struct wildcard_list *tmp;
-			  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
-			  tmp->next = NULL;
-			  tmp->spec = yyvsp[0].wildcard;
-			  yyval.wildcard_list = tmp;
-			}
-    break;
-
-  case 130:
-#line 539 "ldgram.y"
-    {
-			  struct wildcard_spec tmp;
-			  tmp.name = yyvsp[0].name;
-			  tmp.exclude_name_list = NULL;
-			  tmp.sorted = none;
-			  lang_add_wild (&tmp, NULL, ldgram_had_keep);
-			}
-    break;
-
-  case 131:
-#line 547 "ldgram.y"
-    {
-			  lang_add_wild (NULL, yyvsp[-1].wildcard_list, ldgram_had_keep);
-			}
-    break;
-
-  case 132:
-#line 551 "ldgram.y"
-    {
-			  lang_add_wild (&yyvsp[-3].wildcard, yyvsp[-1].wildcard_list, ldgram_had_keep);
-			}
-    break;
-
-  case 134:
-#line 559 "ldgram.y"
-    { ldgram_had_keep = TRUE; }
-    break;
-
-  case 135:
-#line 561 "ldgram.y"
-    { ldgram_had_keep = FALSE; }
-    break;
-
-  case 137:
-#line 567 "ldgram.y"
-    {
- 		lang_add_attribute(lang_object_symbols_statement_enum);
-	      	}
-    break;
-
-  case 139:
-#line 572 "ldgram.y"
-    {
-
-		  lang_add_attribute(lang_constructors_statement_enum);
-		}
-    break;
-
-  case 140:
-#line 577 "ldgram.y"
-    {
-		  constructors_sorted = TRUE;
-		  lang_add_attribute (lang_constructors_statement_enum);
-		}
-    break;
-
-  case 142:
-#line 583 "ldgram.y"
-    {
-			  lang_add_data ((int) yyvsp[-3].integer, yyvsp[-1].etree);
-			}
-    break;
-
-  case 143:
-#line 588 "ldgram.y"
-    {
-			  lang_add_fill (yyvsp[-1].fill);
-			}
-    break;
-
-  case 144:
-#line 591 "ldgram.y"
-    {ldlex_expression ();}
-    break;
-
-  case 145:
-#line 592 "ldgram.y"
-    { ldlex_popstate ();
-			  lang_add_assignment (exp_assert (yyvsp[-4].etree, yyvsp[-2].name)); }
-    break;
-
-  case 146:
-#line 595 "ldgram.y"
-    { ldlex_script (); ldfile_open_command_file(yyvsp[0].name); }
-    break;
-
-  case 147:
-#line 597 "ldgram.y"
-    { ldlex_popstate (); }
-    break;
-
-  case 152:
-#line 612 "ldgram.y"
-    { yyval.integer = yyvsp[0].token; }
-    break;
-
-  case 153:
-#line 614 "ldgram.y"
-    { yyval.integer = yyvsp[0].token; }
-    break;
-
-  case 154:
-#line 616 "ldgram.y"
-    { yyval.integer = yyvsp[0].token; }
-    break;
-
-  case 155:
-#line 618 "ldgram.y"
-    { yyval.integer = yyvsp[0].token; }
-    break;
-
-  case 156:
-#line 620 "ldgram.y"
-    { yyval.integer = yyvsp[0].token; }
-    break;
-
-  case 157:
-#line 625 "ldgram.y"
-    {
-		  yyval.fill = exp_get_fill (yyvsp[0].etree, 0, "fill value");
-		}
-    break;
-
-  case 158:
-#line 632 "ldgram.y"
-    { yyval.fill = yyvsp[0].fill; }
-    break;
-
-  case 159:
-#line 633 "ldgram.y"
-    { yyval.fill = (fill_type *) 0; }
-    break;
-
-  case 160:
-#line 638 "ldgram.y"
-    { yyval.token = '+'; }
-    break;
-
-  case 161:
-#line 640 "ldgram.y"
-    { yyval.token = '-'; }
-    break;
-
-  case 162:
-#line 642 "ldgram.y"
-    { yyval.token = '*'; }
-    break;
-
-  case 163:
-#line 644 "ldgram.y"
-    { yyval.token = '/'; }
-    break;
-
-  case 164:
-#line 646 "ldgram.y"
-    { yyval.token = LSHIFT; }
-    break;
-
-  case 165:
-#line 648 "ldgram.y"
-    { yyval.token = RSHIFT; }
-    break;
-
-  case 166:
-#line 650 "ldgram.y"
-    { yyval.token = '&'; }
-    break;
-
-  case 167:
-#line 652 "ldgram.y"
-    { yyval.token = '|'; }
-    break;
-
-  case 170:
-#line 662 "ldgram.y"
-    {
-		  lang_add_assignment (exp_assign (yyvsp[-2].name, yyvsp[0].etree));
-		}
-    break;
-
-  case 171:
-#line 666 "ldgram.y"
-    {
-		  lang_add_assignment (exp_assign (yyvsp[-2].name,
-						   exp_binop (yyvsp[-1].token,
-							      exp_nameop (NAME,
-									  yyvsp[-2].name),
-							      yyvsp[0].etree)));
-		}
-    break;
-
-  case 172:
-#line 674 "ldgram.y"
-    {
-		  lang_add_assignment (exp_provide (yyvsp[-3].name, yyvsp[-1].etree, FALSE));
-		}
-    break;
-
-  case 173:
-#line 678 "ldgram.y"
-    {
-		  lang_add_assignment (exp_provide (yyvsp[-3].name, yyvsp[-1].etree, TRUE));
-		}
-    break;
-
-  case 181:
-#line 701 "ldgram.y"
-    { region = lang_memory_region_lookup (yyvsp[0].name, TRUE); }
-    break;
-
-  case 182:
-#line 704 "ldgram.y"
-    {}
-    break;
-
-  case 183:
-#line 706 "ldgram.y"
-    { ldlex_script (); ldfile_open_command_file(yyvsp[0].name); }
-    break;
-
-  case 184:
-#line 708 "ldgram.y"
-    { ldlex_popstate (); }
-    break;
-
-  case 185:
-#line 713 "ldgram.y"
-    {
-		  region->origin = exp_get_vma (yyvsp[0].etree, 0, "origin");
-		  region->current = region->origin;
-		}
-    break;
-
-  case 186:
-#line 721 "ldgram.y"
-    {
-		  region->length = exp_get_vma (yyvsp[0].etree, -1, "length");
-		}
-    break;
-
-  case 187:
-#line 728 "ldgram.y"
-    { /* dummy action to avoid bison 1.25 error message */ }
-    break;
-
-  case 191:
-#line 739 "ldgram.y"
-    { lang_set_flags (region, yyvsp[0].name, 0); }
-    break;
-
-  case 192:
-#line 741 "ldgram.y"
-    { lang_set_flags (region, yyvsp[0].name, 1); }
-    break;
-
-  case 193:
-#line 746 "ldgram.y"
-    { lang_startup(yyvsp[-1].name); }
-    break;
-
-  case 195:
-#line 752 "ldgram.y"
-    { ldemul_hll((char *)NULL); }
-    break;
-
-  case 196:
-#line 757 "ldgram.y"
-    { ldemul_hll(yyvsp[0].name); }
-    break;
-
-  case 197:
-#line 759 "ldgram.y"
-    { ldemul_hll(yyvsp[0].name); }
-    break;
-
-  case 199:
-#line 767 "ldgram.y"
-    { ldemul_syslib(yyvsp[0].name); }
-    break;
-
-  case 201:
-#line 773 "ldgram.y"
-    { lang_float(TRUE); }
-    break;
-
-  case 202:
-#line 775 "ldgram.y"
-    { lang_float(FALSE); }
-    break;
-
-  case 203:
-#line 780 "ldgram.y"
-    {
-		  yyval.nocrossref = NULL;
-		}
-    break;
-
-  case 204:
-#line 784 "ldgram.y"
-    {
-		  struct lang_nocrossref *n;
-
-		  n = (struct lang_nocrossref *) xmalloc (sizeof *n);
-		  n->name = yyvsp[-1].name;
-		  n->next = yyvsp[0].nocrossref;
-		  yyval.nocrossref = n;
-		}
-    break;
-
-  case 205:
-#line 793 "ldgram.y"
-    {
-		  struct lang_nocrossref *n;
-
-		  n = (struct lang_nocrossref *) xmalloc (sizeof *n);
-		  n->name = yyvsp[-2].name;
-		  n->next = yyvsp[0].nocrossref;
-		  yyval.nocrossref = n;
-		}
-    break;
-
-  case 206:
-#line 803 "ldgram.y"
-    { ldlex_expression (); }
-    break;
-
-  case 207:
-#line 805 "ldgram.y"
-    { ldlex_popstate (); yyval.etree=yyvsp[0].etree;}
-    break;
-
-  case 208:
-#line 810 "ldgram.y"
-    { yyval.etree = exp_unop ('-', yyvsp[0].etree); }
-    break;
-
-  case 209:
-#line 812 "ldgram.y"
-    { yyval.etree = yyvsp[-1].etree; }
-    break;
-
-  case 210:
-#line 814 "ldgram.y"
-    { yyval.etree = exp_unop ((int) yyvsp[-3].integer,yyvsp[-1].etree); }
-    break;
-
-  case 211:
-#line 816 "ldgram.y"
-    { yyval.etree = exp_unop ('!', yyvsp[0].etree); }
-    break;
-
-  case 212:
-#line 818 "ldgram.y"
-    { yyval.etree = yyvsp[0].etree; }
-    break;
-
-  case 213:
-#line 820 "ldgram.y"
-    { yyval.etree = exp_unop ('~', yyvsp[0].etree);}
-    break;
-
-  case 214:
-#line 823 "ldgram.y"
-    { yyval.etree = exp_binop ('*', yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 215:
-#line 825 "ldgram.y"
-    { yyval.etree = exp_binop ('/', yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 216:
-#line 827 "ldgram.y"
-    { yyval.etree = exp_binop ('%', yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 217:
-#line 829 "ldgram.y"
-    { yyval.etree = exp_binop ('+', yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 218:
-#line 831 "ldgram.y"
-    { yyval.etree = exp_binop ('-' , yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 219:
-#line 833 "ldgram.y"
-    { yyval.etree = exp_binop (LSHIFT , yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 220:
-#line 835 "ldgram.y"
-    { yyval.etree = exp_binop (RSHIFT , yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 221:
-#line 837 "ldgram.y"
-    { yyval.etree = exp_binop (EQ , yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 222:
-#line 839 "ldgram.y"
-    { yyval.etree = exp_binop (NE , yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 223:
-#line 841 "ldgram.y"
-    { yyval.etree = exp_binop (LE , yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 224:
-#line 843 "ldgram.y"
-    { yyval.etree = exp_binop (GE , yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 225:
-#line 845 "ldgram.y"
-    { yyval.etree = exp_binop ('<' , yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 226:
-#line 847 "ldgram.y"
-    { yyval.etree = exp_binop ('>' , yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 227:
-#line 849 "ldgram.y"
-    { yyval.etree = exp_binop ('&' , yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 228:
-#line 851 "ldgram.y"
-    { yyval.etree = exp_binop ('^' , yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 229:
-#line 853 "ldgram.y"
-    { yyval.etree = exp_binop ('|' , yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 230:
-#line 855 "ldgram.y"
-    { yyval.etree = exp_trinop ('?' , yyvsp[-4].etree, yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 231:
-#line 857 "ldgram.y"
-    { yyval.etree = exp_binop (ANDAND , yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 232:
-#line 859 "ldgram.y"
-    { yyval.etree = exp_binop (OROR , yyvsp[-2].etree, yyvsp[0].etree); }
-    break;
-
-  case 233:
-#line 861 "ldgram.y"
-    { yyval.etree = exp_nameop (DEFINED, yyvsp[-1].name); }
-    break;
-
-  case 234:
-#line 863 "ldgram.y"
-    { yyval.etree = exp_bigintop (yyvsp[0].bigint.integer, yyvsp[0].bigint.str); }
-    break;
-
-  case 235:
-#line 865 "ldgram.y"
-    { yyval.etree = exp_nameop (SIZEOF_HEADERS,0); }
-    break;
-
-  case 236:
-#line 868 "ldgram.y"
-    { yyval.etree = exp_nameop (ALIGNOF,yyvsp[-1].name); }
-    break;
-
-  case 237:
-#line 870 "ldgram.y"
-    { yyval.etree = exp_nameop (SIZEOF,yyvsp[-1].name); }
-    break;
-
-  case 238:
-#line 872 "ldgram.y"
-    { yyval.etree = exp_nameop (ADDR,yyvsp[-1].name); }
-    break;
-
-  case 239:
-#line 874 "ldgram.y"
-    { yyval.etree = exp_nameop (LOADADDR,yyvsp[-1].name); }
-    break;
-
-  case 240:
-#line 876 "ldgram.y"
-    { yyval.etree = exp_nameop (CONSTANT,yyvsp[-1].name); }
-    break;
-
-  case 241:
-#line 878 "ldgram.y"
-    { yyval.etree = exp_unop (ABSOLUTE, yyvsp[-1].etree); }
-    break;
-
-  case 242:
-#line 880 "ldgram.y"
-    { yyval.etree = exp_unop (ALIGN_K,yyvsp[-1].etree); }
-    break;
-
-  case 243:
-#line 882 "ldgram.y"
-    { yyval.etree = exp_binop (ALIGN_K,yyvsp[-3].etree,yyvsp[-1].etree); }
-    break;
-
-  case 244:
-#line 884 "ldgram.y"
-    { yyval.etree = exp_binop (DATA_SEGMENT_ALIGN, yyvsp[-3].etree, yyvsp[-1].etree); }
-    break;
-
-  case 245:
-#line 886 "ldgram.y"
-    { yyval.etree = exp_binop (DATA_SEGMENT_RELRO_END, yyvsp[-1].etree, yyvsp[-3].etree); }
-    break;
-
-  case 246:
-#line 888 "ldgram.y"
-    { yyval.etree = exp_unop (DATA_SEGMENT_END, yyvsp[-1].etree); }
-    break;
-
-  case 247:
-#line 890 "ldgram.y"
-    { /* The operands to the expression node are
-			     placed in the opposite order from the way
-			     in which they appear in the script as
-			     that allows us to reuse more code in
-			     fold_binary.  */
-			  yyval.etree = exp_binop (SEGMENT_START,
-					  yyvsp[-1].etree,
-					  exp_nameop (NAME, yyvsp[-3].name)); }
-    break;
-
-  case 248:
-#line 899 "ldgram.y"
-    { yyval.etree = exp_unop (ALIGN_K,yyvsp[-1].etree); }
-    break;
-
-  case 249:
-#line 901 "ldgram.y"
-    { yyval.etree = exp_nameop (NAME,yyvsp[0].name); }
-    break;
-
-  case 250:
-#line 903 "ldgram.y"
-    { yyval.etree = exp_binop (MAX_K, yyvsp[-3].etree, yyvsp[-1].etree ); }
-    break;
-
-  case 251:
-#line 905 "ldgram.y"
-    { yyval.etree = exp_binop (MIN_K, yyvsp[-3].etree, yyvsp[-1].etree ); }
-    break;
-
-  case 252:
-#line 907 "ldgram.y"
-    { yyval.etree = exp_assert (yyvsp[-3].etree, yyvsp[-1].name); }
-    break;
-
-  case 253:
-#line 909 "ldgram.y"
-    { yyval.etree = exp_nameop (ORIGIN, yyvsp[-1].name); }
-    break;
-
-  case 254:
-#line 911 "ldgram.y"
-    { yyval.etree = exp_nameop (LENGTH, yyvsp[-1].name); }
-    break;
-
-  case 255:
-#line 916 "ldgram.y"
-    { yyval.name = yyvsp[0].name; }
-    break;
-
-  case 256:
-#line 917 "ldgram.y"
-    { yyval.name = 0; }
-    break;
-
-  case 257:
-#line 921 "ldgram.y"
-    { yyval.etree = yyvsp[-1].etree; }
-    break;
-
-  case 258:
-#line 922 "ldgram.y"
-    { yyval.etree = 0; }
-    break;
-
-  case 259:
-#line 926 "ldgram.y"
-    { yyval.etree = yyvsp[-1].etree; }
-    break;
-
-  case 260:
-#line 927 "ldgram.y"
-    { yyval.etree = 0; }
-    break;
-
-  case 261:
-#line 931 "ldgram.y"
-    { yyval.etree = yyvsp[-1].etree; }
-    break;
-
-  case 262:
-#line 932 "ldgram.y"
-    { yyval.etree = 0; }
-    break;
-
-  case 263:
-#line 936 "ldgram.y"
-    { yyval.token = ONLY_IF_RO; }
-    break;
-
-  case 264:
-#line 937 "ldgram.y"
-    { yyval.token = ONLY_IF_RW; }
-    break;
-
-  case 265:
-#line 938 "ldgram.y"
-    { yyval.token = SPECIAL; }
-    break;
-
-  case 266:
-#line 939 "ldgram.y"
-    { yyval.token = 0; }
-    break;
-
-  case 267:
-#line 942 "ldgram.y"
-    { ldlex_expression(); }
-    break;
-
-  case 268:
-#line 946 "ldgram.y"
-    { ldlex_popstate (); ldlex_script (); }
-    break;
-
-  case 269:
-#line 949 "ldgram.y"
-    {
-			  lang_enter_output_section_statement(yyvsp[-8].name, yyvsp[-6].etree,
-							      sectype,
-							      yyvsp[-4].etree, yyvsp[-3].etree, yyvsp[-5].etree, yyvsp[-1].token);
-			}
-    break;
-
-  case 270:
-#line 955 "ldgram.y"
-    { ldlex_popstate (); ldlex_expression (); }
-    break;
-
-  case 271:
-#line 957 "ldgram.y"
-    {
-		  ldlex_popstate ();
-		  lang_leave_output_section_statement (yyvsp[0].fill, yyvsp[-3].name, yyvsp[-1].section_phdr, yyvsp[-2].name);
-		}
-    break;
-
-  case 272:
-#line 962 "ldgram.y"
-    {}
-    break;
-
-  case 273:
-#line 964 "ldgram.y"
-    { ldlex_expression (); }
-    break;
-
-  case 274:
-#line 966 "ldgram.y"
-    { ldlex_popstate (); ldlex_script (); }
-    break;
-
-  case 275:
-#line 968 "ldgram.y"
-    {
-			  lang_enter_overlay (yyvsp[-5].etree, yyvsp[-2].etree);
-			}
-    break;
-
-  case 276:
-#line 973 "ldgram.y"
-    { ldlex_popstate (); ldlex_expression (); }
-    break;
-
-  case 277:
-#line 975 "ldgram.y"
-    {
-			  ldlex_popstate ();
-			  lang_leave_overlay (yyvsp[-11].etree, (int) yyvsp[-12].integer,
-					      yyvsp[0].fill, yyvsp[-3].name, yyvsp[-1].section_phdr, yyvsp[-2].name);
-			}
-    break;
-
-  case 279:
-#line 985 "ldgram.y"
-    { ldlex_expression (); }
-    break;
-
-  case 280:
-#line 987 "ldgram.y"
-    {
-		  ldlex_popstate ();
-		  lang_add_assignment (exp_assign (".", yyvsp[0].etree));
-		}
-    break;
-
-  case 282:
-#line 993 "ldgram.y"
-    { ldlex_script (); ldfile_open_command_file(yyvsp[0].name); }
-    break;
-
-  case 283:
-#line 995 "ldgram.y"
-    { ldlex_popstate (); }
-    break;
-
-  case 284:
-#line 999 "ldgram.y"
-    { sectype = noload_section; }
-    break;
-
-  case 285:
-#line 1000 "ldgram.y"
-    { sectype = noalloc_section; }
-    break;
-
-  case 286:
-#line 1001 "ldgram.y"
-    { sectype = noalloc_section; }
-    break;
-
-  case 287:
-#line 1002 "ldgram.y"
-    { sectype = noalloc_section; }
-    break;
-
-  case 288:
-#line 1003 "ldgram.y"
-    { sectype = noalloc_section; }
-    break;
-
-  case 290:
-#line 1008 "ldgram.y"
-    { sectype = normal_section; }
-    break;
-
-  case 291:
-#line 1009 "ldgram.y"
-    { sectype = normal_section; }
-    break;
-
-  case 292:
-#line 1013 "ldgram.y"
-    { yyval.etree = yyvsp[-2].etree; }
-    break;
-
-  case 293:
-#line 1014 "ldgram.y"
-    { yyval.etree = (etree_type *)NULL;  }
-    break;
-
-  case 294:
-#line 1019 "ldgram.y"
-    { yyval.etree = yyvsp[-3].etree; }
-    break;
-
-  case 295:
-#line 1021 "ldgram.y"
-    { yyval.etree = yyvsp[-7].etree; }
-    break;
-
-  case 296:
-#line 1025 "ldgram.y"
-    { yyval.etree = yyvsp[-1].etree; }
-    break;
-
-  case 297:
-#line 1026 "ldgram.y"
-    { yyval.etree = (etree_type *) NULL;  }
-    break;
-
-  case 298:
-#line 1031 "ldgram.y"
-    { yyval.integer = 0; }
-    break;
-
-  case 299:
-#line 1033 "ldgram.y"
-    { yyval.integer = 1; }
-    break;
-
-  case 300:
-#line 1038 "ldgram.y"
-    { yyval.name = yyvsp[0].name; }
-    break;
-
-  case 301:
-#line 1039 "ldgram.y"
-    { yyval.name = DEFAULT_MEMORY_REGION; }
-    break;
-
-  case 302:
-#line 1044 "ldgram.y"
-    {
-		  yyval.section_phdr = NULL;
-		}
-    break;
-
-  case 303:
-#line 1048 "ldgram.y"
-    {
-		  struct lang_output_section_phdr_list *n;
-
-		  n = ((struct lang_output_section_phdr_list *)
-		       xmalloc (sizeof *n));
-		  n->name = yyvsp[0].name;
-		  n->used = FALSE;
-		  n->next = yyvsp[-2].section_phdr;
-		  yyval.section_phdr = n;
-		}
-    break;
-
-  case 305:
-#line 1064 "ldgram.y"
-    {
-			  ldlex_script ();
-			  lang_enter_overlay_section (yyvsp[0].name);
-			}
-    break;
-
-  case 306:
-#line 1069 "ldgram.y"
-    { ldlex_popstate (); ldlex_expression (); }
-    break;
-
-  case 307:
-#line 1071 "ldgram.y"
-    {
-			  ldlex_popstate ();
-			  lang_leave_overlay_section (yyvsp[0].fill, yyvsp[-1].section_phdr);
-			}
-    break;
-
-  case 312:
-#line 1088 "ldgram.y"
-    { ldlex_expression (); }
-    break;
-
-  case 313:
-#line 1089 "ldgram.y"
-    { ldlex_popstate (); }
-    break;
-
-  case 314:
-#line 1091 "ldgram.y"
-    {
-		  lang_new_phdr (yyvsp[-5].name, yyvsp[-3].etree, yyvsp[-2].phdr.filehdr, yyvsp[-2].phdr.phdrs, yyvsp[-2].phdr.at,
-				 yyvsp[-2].phdr.flags);
-		}
-    break;
-
-  case 315:
-#line 1099 "ldgram.y"
-    {
-		  yyval.etree = yyvsp[0].etree;
-
-		  if (yyvsp[0].etree->type.node_class == etree_name
-		      && yyvsp[0].etree->type.node_code == NAME)
-		    {
-		      const char *s;
-		      unsigned int i;
-		      static const char * const phdr_types[] =
-			{
-			  "PT_NULL", "PT_LOAD", "PT_DYNAMIC",
-			  "PT_INTERP", "PT_NOTE", "PT_SHLIB",
-			  "PT_PHDR", "PT_TLS"
-			};
-
-		      s = yyvsp[0].etree->name.name;
-		      for (i = 0;
-			   i < sizeof phdr_types / sizeof phdr_types[0];
-			   i++)
-			if (strcmp (s, phdr_types[i]) == 0)
-			  {
-			    yyval.etree = exp_intop (i);
-			    break;
-			  }
-		      if (i == sizeof phdr_types / sizeof phdr_types[0])
-			{
-			  if (strcmp (s, "PT_GNU_EH_FRAME") == 0)
-			    yyval.etree = exp_intop (0x6474e550);
-			  else if (strcmp (s, "PT_GNU_STACK") == 0)
-			    yyval.etree = exp_intop (0x6474e551);
-			  else
-			    {
-			      einfo (_("\
-%X%P:%S: unknown phdr type `%s' (try integer literal)\n"),
-				     s);
-			      yyval.etree = exp_intop (0);
-			    }
-			}
-		    }
-		}
-    break;
-
-  case 316:
-#line 1143 "ldgram.y"
-    {
-		  memset (&yyval.phdr, 0, sizeof (struct phdr_info));
-		}
-    break;
-
-  case 317:
-#line 1147 "ldgram.y"
-    {
-		  yyval.phdr = yyvsp[0].phdr;
-		  if (strcmp (yyvsp[-2].name, "FILEHDR") == 0 && yyvsp[-1].etree == NULL)
-		    yyval.phdr.filehdr = TRUE;
-		  else if (strcmp (yyvsp[-2].name, "PHDRS") == 0 && yyvsp[-1].etree == NULL)
-		    yyval.phdr.phdrs = TRUE;
-		  else if (strcmp (yyvsp[-2].name, "FLAGS") == 0 && yyvsp[-1].etree != NULL)
-		    yyval.phdr.flags = yyvsp[-1].etree;
-		  else
-		    einfo (_("%X%P:%S: PHDRS syntax error at `%s'\n"), yyvsp[-2].name);
-		}
-    break;
-
-  case 318:
-#line 1159 "ldgram.y"
-    {
-		  yyval.phdr = yyvsp[0].phdr;
-		  yyval.phdr.at = yyvsp[-2].etree;
-		}
-    break;
-
-  case 319:
-#line 1167 "ldgram.y"
-    {
-		  yyval.etree = NULL;
-		}
-    break;
-
-  case 320:
-#line 1171 "ldgram.y"
-    {
-		  yyval.etree = yyvsp[-1].etree;
-		}
-    break;
-
-  case 321:
-#line 1177 "ldgram.y"
-    {
-		  ldlex_version_file ();
-		  PUSH_ERROR (_("dynamic list"));
-		}
-    break;
-
-  case 322:
-#line 1182 "ldgram.y"
-    {
-		  ldlex_popstate ();
-		  POP_ERROR ();
-		}
-    break;
-
-  case 326:
-#line 1199 "ldgram.y"
-    {
-		  lang_append_dynamic_list (yyvsp[-1].versyms);
-		}
-    break;
-
-  case 327:
-#line 1207 "ldgram.y"
-    {
-		  ldlex_version_file ();
-		  PUSH_ERROR (_("VERSION script"));
-		}
-    break;
-
-  case 328:
-#line 1212 "ldgram.y"
-    {
-		  ldlex_popstate ();
-		  POP_ERROR ();
-		}
-    break;
-
-  case 329:
-#line 1221 "ldgram.y"
-    {
-		  ldlex_version_script ();
-		}
-    break;
-
-  case 330:
-#line 1225 "ldgram.y"
-    {
-		  ldlex_popstate ();
-		}
-    break;
-
-  case 333:
-#line 1237 "ldgram.y"
-    {
-		  lang_register_vers_node (NULL, yyvsp[-2].versnode, NULL);
-		}
-    break;
-
-  case 334:
-#line 1241 "ldgram.y"
-    {
-		  lang_register_vers_node (yyvsp[-4].name, yyvsp[-2].versnode, NULL);
-		}
-    break;
-
-  case 335:
-#line 1245 "ldgram.y"
-    {
-		  lang_register_vers_node (yyvsp[-5].name, yyvsp[-3].versnode, yyvsp[-1].deflist);
-		}
-    break;
-
-  case 336:
-#line 1252 "ldgram.y"
-    {
-		  yyval.deflist = lang_add_vers_depend (NULL, yyvsp[0].name);
-		}
-    break;
-
-  case 337:
-#line 1256 "ldgram.y"
-    {
-		  yyval.deflist = lang_add_vers_depend (yyvsp[-1].deflist, yyvsp[0].name);
-		}
-    break;
-
-  case 338:
-#line 1263 "ldgram.y"
-    {
-		  yyval.versnode = lang_new_vers_node (NULL, NULL);
-		}
-    break;
-
-  case 339:
-#line 1267 "ldgram.y"
-    {
-		  yyval.versnode = lang_new_vers_node (yyvsp[-1].versyms, NULL);
-		}
-    break;
-
-  case 340:
-#line 1271 "ldgram.y"
-    {
-		  yyval.versnode = lang_new_vers_node (yyvsp[-1].versyms, NULL);
-		}
-    break;
-
-  case 341:
-#line 1275 "ldgram.y"
-    {
-		  yyval.versnode = lang_new_vers_node (NULL, yyvsp[-1].versyms);
-		}
-    break;
-
-  case 342:
-#line 1279 "ldgram.y"
-    {
-		  yyval.versnode = lang_new_vers_node (yyvsp[-5].versyms, yyvsp[-1].versyms);
-		}
-    break;
-
-  case 343:
-#line 1286 "ldgram.y"
-    {
-		  yyval.versyms = lang_new_vers_pattern (NULL, yyvsp[0].name, ldgram_vers_current_lang, FALSE);
-		}
-    break;
-
-  case 344:
-#line 1290 "ldgram.y"
-    {
-		  yyval.versyms = lang_new_vers_pattern (NULL, yyvsp[0].name, ldgram_vers_current_lang, TRUE);
-		}
-    break;
-
-  case 345:
-#line 1294 "ldgram.y"
-    {
-		  yyval.versyms = lang_new_vers_pattern (yyvsp[-2].versyms, yyvsp[0].name, ldgram_vers_current_lang, FALSE);
-		}
-    break;
-
-  case 346:
-#line 1298 "ldgram.y"
-    {
-		  yyval.versyms = lang_new_vers_pattern (yyvsp[-2].versyms, yyvsp[0].name, ldgram_vers_current_lang, TRUE);
-		}
-    break;
-
-  case 347:
-#line 1302 "ldgram.y"
-    {
-			  yyval.name = ldgram_vers_current_lang;
-			  ldgram_vers_current_lang = yyvsp[-1].name;
-			}
-    break;
-
-  case 348:
-#line 1307 "ldgram.y"
-    {
-			  struct bfd_elf_version_expr *pat;
-			  for (pat = yyvsp[-2].versyms; pat->next != NULL; pat = pat->next);
-			  pat->next = yyvsp[-8].versyms;
-			  yyval.versyms = yyvsp[-2].versyms;
-			  ldgram_vers_current_lang = yyvsp[-3].name;
-			}
-    break;
-
-  case 349:
-#line 1315 "ldgram.y"
-    {
-			  yyval.name = ldgram_vers_current_lang;
-			  ldgram_vers_current_lang = yyvsp[-1].name;
-			}
-    break;
-
-  case 350:
-#line 1320 "ldgram.y"
-    {
-			  yyval.versyms = yyvsp[-2].versyms;
-			  ldgram_vers_current_lang = yyvsp[-3].name;
-			}
-    break;
-
-  case 351:
-#line 1325 "ldgram.y"
-    {
-		  yyval.versyms = lang_new_vers_pattern (NULL, "global", ldgram_vers_current_lang, FALSE);
-		}
-    break;
-
-  case 352:
-#line 1329 "ldgram.y"
-    {
-		  yyval.versyms = lang_new_vers_pattern (yyvsp[-2].versyms, "global", ldgram_vers_current_lang, FALSE);
-		}
-    break;
-
-  case 353:
-#line 1333 "ldgram.y"
-    {
-		  yyval.versyms = lang_new_vers_pattern (NULL, "local", ldgram_vers_current_lang, FALSE);
-		}
-    break;
-
-  case 354:
-#line 1337 "ldgram.y"
-    {
-		  yyval.versyms = lang_new_vers_pattern (yyvsp[-2].versyms, "local", ldgram_vers_current_lang, FALSE);
-		}
-    break;
-
-  case 355:
-#line 1341 "ldgram.y"
-    {
-		  yyval.versyms = lang_new_vers_pattern (NULL, "extern", ldgram_vers_current_lang, FALSE);
-		}
-    break;
-
-  case 356:
-#line 1345 "ldgram.y"
-    {
-		  yyval.versyms = lang_new_vers_pattern (yyvsp[-2].versyms, "extern", ldgram_vers_current_lang, FALSE);
-		}
-    break;
-
-
-    }
-
-/* Line 1000 of yacc.c.  */
-#line 3976 "ldgram.c"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
-	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
-
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
-	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
-      else
-	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
-	  yychar = YYEMPTY;
-
-	}
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
-     goto yyerrorlab;
-#endif
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-	YYABORT;
-
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
-  *++yyvsp = yylval;
-
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-yyreturn:
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-  return yyresult;
-}
-
-
-#line 1355 "ldgram.y"
-
-void
-yyerror(arg)
-     const char *arg;
-{
-  if (ldfile_assumed_script)
-    einfo (_("%P:%s: file format not recognized; treating as linker script\n"),
-	   ldfile_input_filename);
-  if (error_index > 0 && error_index < ERROR_NAME_MAX)
-     einfo ("%P%F:%S: %s in %s\n", arg, error_names[error_index-1]);
-  else
-     einfo ("%P%F:%S: %s\n", arg);
-}
-
diff -r -N -u binutils-2.21.51/ld/ldgram.h binutils/ld/ldgram.h
--- binutils-2.21.51/ld/ldgram.h	2011-04-13 08:41:36.000000000 +0100
+++ binutils/ld/ldgram.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,324 +0,0 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     INT = 258,
-     NAME = 259,
-     LNAME = 260,
-     OREQ = 261,
-     ANDEQ = 262,
-     RSHIFTEQ = 263,
-     LSHIFTEQ = 264,
-     DIVEQ = 265,
-     MULTEQ = 266,
-     MINUSEQ = 267,
-     PLUSEQ = 268,
-     OROR = 269,
-     ANDAND = 270,
-     NE = 271,
-     EQ = 272,
-     GE = 273,
-     LE = 274,
-     RSHIFT = 275,
-     LSHIFT = 276,
-     UNARY = 277,
-     END = 278,
-     ALIGN_K = 279,
-     BLOCK = 280,
-     BIND = 281,
-     QUAD = 282,
-     SQUAD = 283,
-     LONG = 284,
-     SHORT = 285,
-     BYTE = 286,
-     SECTIONS = 287,
-     PHDRS = 288,
-     INSERT_K = 289,
-     AFTER = 290,
-     BEFORE = 291,
-     DATA_SEGMENT_ALIGN = 292,
-     DATA_SEGMENT_RELRO_END = 293,
-     DATA_SEGMENT_END = 294,
-     SORT_BY_NAME = 295,
-     SORT_BY_ALIGNMENT = 296,
-     SORT_BY_INIT_PRIORITY = 297,
-     SIZEOF_HEADERS = 298,
-     OUTPUT_FORMAT = 299,
-     FORCE_COMMON_ALLOCATION = 300,
-     OUTPUT_ARCH = 301,
-     INHIBIT_COMMON_ALLOCATION = 302,
-     SEGMENT_START = 303,
-     INCLUDE = 304,
-     MEMORY = 305,
-     REGION_ALIAS = 306,
-     LD_FEATURE = 307,
-     NOLOAD = 308,
-     DSECT = 309,
-     COPY = 310,
-     INFO = 311,
-     OVERLAY = 312,
-     DEFINED = 313,
-     TARGET_K = 314,
-     SEARCH_DIR = 315,
-     MAP = 316,
-     ENTRY = 317,
-     NEXT = 318,
-     SIZEOF = 319,
-     ALIGNOF = 320,
-     ADDR = 321,
-     LOADADDR = 322,
-     MAX_K = 323,
-     MIN_K = 324,
-     STARTUP = 325,
-     HLL = 326,
-     SYSLIB = 327,
-     FLOAT = 328,
-     NOFLOAT = 329,
-     NOCROSSREFS = 330,
-     ORIGIN = 331,
-     FILL = 332,
-     LENGTH = 333,
-     CREATE_OBJECT_SYMBOLS = 334,
-     INPUT = 335,
-     GROUP = 336,
-     OUTPUT = 337,
-     CONSTRUCTORS = 338,
-     ALIGNMOD = 339,
-     AT = 340,
-     SUBALIGN = 341,
-     PROVIDE = 342,
-     PROVIDE_HIDDEN = 343,
-     AS_NEEDED = 344,
-     CHIP = 345,
-     LIST = 346,
-     SECT = 347,
-     ABSOLUTE = 348,
-     LOAD = 349,
-     NEWLINE = 350,
-     ENDWORD = 351,
-     ORDER = 352,
-     NAMEWORD = 353,
-     ASSERT_K = 354,
-     FORMAT = 355,
-     PUBLIC = 356,
-     DEFSYMEND = 357,
-     BASE = 358,
-     ALIAS = 359,
-     TRUNCATE = 360,
-     REL = 361,
-     INPUT_SCRIPT = 362,
-     INPUT_MRI_SCRIPT = 363,
-     INPUT_DEFSYM = 364,
-     CASE = 365,
-     EXTERN = 366,
-     START = 367,
-     VERS_TAG = 368,
-     VERS_IDENTIFIER = 369,
-     GLOBAL = 370,
-     LOCAL = 371,
-     VERSIONK = 372,
-     INPUT_VERSION_SCRIPT = 373,
-     KEEP = 374,
-     ONLY_IF_RO = 375,
-     ONLY_IF_RW = 376,
-     SPECIAL = 377,
-     EXCLUDE_FILE = 378,
-     CONSTANT = 379,
-     INPUT_DYNAMIC_LIST = 380
-   };
-#endif
-#define INT 258
-#define NAME 259
-#define LNAME 260
-#define OREQ 261
-#define ANDEQ 262
-#define RSHIFTEQ 263
-#define LSHIFTEQ 264
-#define DIVEQ 265
-#define MULTEQ 266
-#define MINUSEQ 267
-#define PLUSEQ 268
-#define OROR 269
-#define ANDAND 270
-#define NE 271
-#define EQ 272
-#define GE 273
-#define LE 274
-#define RSHIFT 275
-#define LSHIFT 276
-#define UNARY 277
-#define END 278
-#define ALIGN_K 279
-#define BLOCK 280
-#define BIND 281
-#define QUAD 282
-#define SQUAD 283
-#define LONG 284
-#define SHORT 285
-#define BYTE 286
-#define SECTIONS 287
-#define PHDRS 288
-#define INSERT_K 289
-#define AFTER 290
-#define BEFORE 291
-#define DATA_SEGMENT_ALIGN 292
-#define DATA_SEGMENT_RELRO_END 293
-#define DATA_SEGMENT_END 294
-#define SORT_BY_NAME 295
-#define SORT_BY_ALIGNMENT 296
-#define SORT_BY_INIT_PRIORITY 297
-#define SIZEOF_HEADERS 298
-#define OUTPUT_FORMAT 299
-#define FORCE_COMMON_ALLOCATION 300
-#define OUTPUT_ARCH 301
-#define INHIBIT_COMMON_ALLOCATION 302
-#define SEGMENT_START 303
-#define INCLUDE 304
-#define MEMORY 305
-#define REGION_ALIAS 306
-#define LD_FEATURE 307
-#define NOLOAD 308
-#define DSECT 309
-#define COPY 310
-#define INFO 311
-#define OVERLAY 312
-#define DEFINED 313
-#define TARGET_K 314
-#define SEARCH_DIR 315
-#define MAP 316
-#define ENTRY 317
-#define NEXT 318
-#define SIZEOF 319
-#define ALIGNOF 320
-#define ADDR 321
-#define LOADADDR 322
-#define MAX_K 323
-#define MIN_K 324
-#define STARTUP 325
-#define HLL 326
-#define SYSLIB 327
-#define FLOAT 328
-#define NOFLOAT 329
-#define NOCROSSREFS 330
-#define ORIGIN 331
-#define FILL 332
-#define LENGTH 333
-#define CREATE_OBJECT_SYMBOLS 334
-#define INPUT 335
-#define GROUP 336
-#define OUTPUT 337
-#define CONSTRUCTORS 338
-#define ALIGNMOD 339
-#define AT 340
-#define SUBALIGN 341
-#define PROVIDE 342
-#define PROVIDE_HIDDEN 343
-#define AS_NEEDED 344
-#define CHIP 345
-#define LIST 346
-#define SECT 347
-#define ABSOLUTE 348
-#define LOAD 349
-#define NEWLINE 350
-#define ENDWORD 351
-#define ORDER 352
-#define NAMEWORD 353
-#define ASSERT_K 354
-#define FORMAT 355
-#define PUBLIC 356
-#define DEFSYMEND 357
-#define BASE 358
-#define ALIAS 359
-#define TRUNCATE 360
-#define REL 361
-#define INPUT_SCRIPT 362
-#define INPUT_MRI_SCRIPT 363
-#define INPUT_DEFSYM 364
-#define CASE 365
-#define EXTERN 366
-#define START 367
-#define VERS_TAG 368
-#define VERS_IDENTIFIER 369
-#define GLOBAL 370
-#define LOCAL 371
-#define VERSIONK 372
-#define INPUT_VERSION_SCRIPT 373
-#define KEEP 374
-#define ONLY_IF_RO 375
-#define ONLY_IF_RW 376
-#define SPECIAL 377
-#define EXCLUDE_FILE 378
-#define CONSTANT 379
-#define INPUT_DYNAMIC_LIST 380
-
-
-
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 62 "ldgram.y"
-typedef union YYSTYPE {
-  bfd_vma integer;
-  struct big_int
-    {
-      bfd_vma integer;
-      char *str;
-    } bigint;
-  fill_type *fill;
-  char *name;
-  const char *cname;
-  struct wildcard_spec wildcard;
-  struct wildcard_list *wildcard_list;
-  struct name_list *name_list;
-  int token;
-  union etree_union *etree;
-  struct phdr_info
-    {
-      bfd_boolean filehdr;
-      bfd_boolean phdrs;
-      union etree_union *at;
-      union etree_union *flags;
-    } phdr;
-  struct lang_nocrossref *nocrossref;
-  struct lang_output_section_phdr_list *section_phdr;
-  struct bfd_elf_version_deps *deflist;
-  struct bfd_elf_version_expr *versyms;
-  struct bfd_elf_version_tree *versnode;
-} YYSTYPE;
-/* Line 1275 of yacc.c.  */
-#line 316 "ldgram.h"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-extern YYSTYPE yylval;
-
-
-
diff -r -N -u binutils-2.21.51/ld/ldgram.y binutils/ld/ldgram.y
--- binutils-2.21.51/ld/ldgram.y	2011-04-13 08:41:36.000000000 +0100
+++ binutils/ld/ldgram.y	2011-07-06 12:44:26.137253000 +0100
@@ -49,6 +49,10 @@
 
 static enum section_type sectype;
 static lang_memory_region_type *region;
+static flagword secattr = SECATTR_NOFLAGS;
+union etree_union *max_endaddress;
+union etree_union *padding;
+char *algo_name;
 
 bfd_boolean ldgram_had_keep = FALSE;
 char *ldgram_vers_current_lang = NULL;
@@ -148,6 +152,9 @@
 %token CHIP LIST SECT ABSOLUTE  LOAD NEWLINE ENDWORD ORDER NAMEWORD ASSERT_K
 %token FORMAT PUBLIC DEFSYMEND BASE ALIAS TRUNCATE REL
 %token INPUT_SCRIPT INPUT_MRI_SCRIPT INPUT_DEFSYM CASE EXTERN START
+%token CREATE_SECINIT_TABLE
+%token CREATE_MEMINFO
+%token NOINIT NOBITS MAX_ENDADDRESS PAD CLEAR COMPRESS
 %token <name> VERS_TAG VERS_IDENTIFIER
 %token GLOBAL LOCAL VERSIONK INPUT_VERSION_SCRIPT
 %token KEEP ONLY_IF_RO ONLY_IF_RW SPECIAL
@@ -573,6 +580,14 @@
 
 		  lang_add_attribute(lang_constructors_statement_enum);
 		}
+       |       CREATE_SECINIT_TABLE
+               {
+                 lang_add_secinfo_table();
+               }
+       |       CREATE_MEMINFO
+               {
+                 lang_add_meminfo();
+               }
 	| SORT_BY_NAME '(' CONSTRUCTORS ')'
 		{
 		  constructors_sorted = TRUE;
@@ -947,9 +962,21 @@
 		sect_constraint
 		'{'
 			{
-			  lang_enter_output_section_statement($1, $3,
-							      sectype,
-							      $5, $6, $4, $8);
+			  lang_output_section_statement_type *os;
+
+			  if (padding)
+			    secattr |= SECATTR_NOBITS;
+
+			  os = lang_enter_output_section_statement($1, $3,
+								   sectype, secattr, max_endaddress, algo_name,
+								   $5, $6, $4, $8);
+			  if (padding)
+			    {
+			      lang_add_assignment (exp_assign(".",
+							      exp_binop( '+',exp_nameop(NAME, "."),
+									 padding)));
+			      os->fill = 0;
+			    }
 			}
 		statement_list_opt
  		'}' { ldlex_popstate (); ldlex_expression (); }
@@ -966,7 +993,7 @@
 			{ ldlex_popstate (); ldlex_script (); }
 		'{'
 			{
-			  lang_enter_overlay ($3, $6);
+			  lang_enter_overlay ($3, $6, secattr);
 			}
 		overlay_section
 		'}'
@@ -1010,20 +1037,20 @@
 	;
 
 opt_exp_with_type:
-		exp atype ':'		{ $$ = $1; }
-	|	atype ':'		{ $$ = (etree_type *)NULL;  }
+		exp atype opt_secattr_list ':'		{ $$ = $1; }
+	|	atype opt_secattr_list ':'		{ $$ = (etree_type *)NULL;  }
 	|	/* The BIND cases are to support the gcc svr3.ifile
 		   script.  They aren't intended to implement full
 		   support for the BIND keyword.  I'm not even sure
 		   what BIND is supposed to mean.  */
-		BIND '(' exp ')' atype ':' { $$ = $3; }
-	|	BIND '(' exp ')' BLOCK '(' exp ')' atype ':'
+		BIND '(' exp ')' atype opt_secattr_list ':' { $$ = $3; }
+	|	BIND '(' exp ')' BLOCK '(' exp ')' atype opt_secattr_list ':'
 		{ $$ = $3; }
 	;
 
 opt_exp_without_type:
-		exp ':'		{ $$ = $1; }
-	|	':'		{ $$ = (etree_type *) NULL;  }
+		exp opt_secattr_list ':'		{ $$ = $1; }
+	|	opt_secattr_list ':'		{ $$ = (etree_type *) NULL;  }
 	;
 
 opt_nocrossrefs:
@@ -1063,7 +1090,7 @@
 		NAME
 			{
 			  ldlex_script ();
-			  lang_enter_overlay_section ($2);
+			  lang_enter_overlay_section ($2, SECATTR_NOFLAGS);
 			}
 		'{' statement_list_opt '}'
 			{ ldlex_popstate (); ldlex_expression (); }
@@ -1075,6 +1102,26 @@
 		opt_comma
 	;
 
+opt_secattr_list:
+               {
+                 secattr        = SECATTR_NOFLAGS;
+                 max_endaddress = (etree_type *)NULL;
+                 padding        = (etree_type *)NULL;
+                  algo_name      = NULL;
+               }
+               /* EMPTY */
+       |       opt_secattr_list opt_secattr
+       ;
+
+opt_secattr:
+               NOINIT                     { secattr |= SECATTR_NOINIT; }
+       |       NOBITS                     { secattr |= SECATTR_NOBITS; }
+       |       CLEAR                      { secattr |= SECATTR_CLEAR;  }
+       |       MAX_ENDADDRESS '(' exp ')' { max_endaddress = $3; }
+       |       PAD '(' exp ')'            { padding        = $3; }
+       |       COMPRESS '(' NAME ')'      { algo_name      = $3; }
+       ;
+
 phdrs:
 		PHDRS '{' phdr_list '}'
 	;
diff -r -N -u binutils-2.21.51/ld/ld.h binutils/ld/ld.h
--- binutils-2.21.51/ld/ld.h	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/ld.h	2011-07-06 12:44:26.137253000 +0100
@@ -255,6 +255,12 @@
      parameter.  */
   bfd_boolean has_shared;
 
+  /* If true, build section information table */
+  bfd_boolean build_secinfo_table;
+  
+  /* If true, code for decompression should be integrated inside the binary */
+  bfd_boolean get_decompression_code;
+
   /* If TRUE, build constructors.  */
   bfd_boolean build_constructors;
 
diff -r -N -u binutils-2.21.51/ld/ldlang.c binutils/ld/ldlang.c
--- binutils-2.21.51/ld/ldlang.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/ldlang.c	2011-07-06 12:44:26.137253000 +0100
@@ -46,10 +46,25 @@
 #include "plugin.h"
 #endif /* ENABLE_PLUGINS */
 
+#ifdef IPA_LINK
+#include "ipa_ld.h"
+#endif
+
 #ifndef offsetof
 #define offsetof(TYPE, MEMBER) ((size_t) & (((TYPE*) 0)->MEMBER))
 #endif
 
+#ifdef IPA_LINK
+extern bfd_boolean is_ipa;
+
+extern bfd_boolean
+ipa_is_whirl(bfd *);
+
+extern void
+ipa_process_whirl ( bfd *);
+
+#endif
+
 /* Locals variables.  */
 static struct obstack stat_obstack;
 static struct obstack map_obstack;
@@ -60,7 +75,9 @@
 static bfd_boolean placed_commons = FALSE;
 static bfd_boolean stripped_excluded_sections = FALSE;
 static lang_output_section_statement_type *default_common_section;
+lang_secinfo_table_statement_type *lang_secinfo_table_statement = NULL;
 static bfd_boolean map_option_f;
+static bfd_boolean process_first_pass;
 static bfd_vma print_dot;
 static lang_input_statement_type *first_file;
 static const char *current_target;
@@ -91,6 +108,15 @@
 static void lang_finalize_version_expr_head
   (struct bfd_elf_version_expr_head *);
 
+static void print_secinfo_table_statement
+  PARAMS ((lang_secinfo_table_statement_type *s,
+           lang_output_section_statement_type *os));
+
+static void lang_create_secinfo_table PARAMS ((lang_output_section_statement_type *));
+
+static void print_meminfo_statement PARAMS ((lang_meminfo_statement_type *,
+                                            lang_output_section_statement_type *));
+
 /* Exported variables.  */
 const char *output_target;
 lang_output_section_statement_type *abs_output_section;
@@ -971,6 +997,17 @@
 	case lang_fill_statement_enum:
 	case lang_insert_statement_enum:
 	  break;
+	case lang_secinfo_table_statement_enum:
+	  /* (sgr): add specific code here: TO BE INSERTED */
+          if (!config.build_secinfo_table)
+            break;
+          lang_for_each_statement_worker (func, s->secinfo_table_statement.symbols.head);
+          lang_for_each_statement_worker (func, s->secinfo_table_statement.content.head);
+          break;
+	case lang_meminfo_statement_enum:
+	  lang_for_each_statement_worker (func, s->meminfo_statement.symbols.head);
+	  lang_for_each_statement_worker (func, s->meminfo_statement.content.head);
+          break;
 	default:
 	  FAIL ();
 	  break;
@@ -1465,6 +1502,9 @@
 
   entry->s.output_section_statement.name = name;
   entry->s.output_section_statement.constraint = constraint;
+  entry->s.output_section_statement.secattr = SECATTR_NOFLAGS;
+  entry->s.output_section_statement.max_endaddress = (etree_type *)NULL;
+
   return &entry->s.output_section_statement;
 }
 
@@ -1762,6 +1802,8 @@
 	case lang_output_statement_enum:
 	case lang_group_statement_enum:
 	case lang_insert_statement_enum:
+	case lang_secinfo_table_statement_enum:
+	case lang_meminfo_statement_enum:
 	  continue;
 	}
       break;
@@ -1799,6 +1841,7 @@
   os_tail = ((lang_output_section_statement_type **)
 	     lang_output_section_statement.tail);
   os = lang_enter_output_section_statement (secname, address, normal_section,
+					    0, NULL, NULL, 
                                             NULL, NULL, NULL, constraint);
 
   ps = NULL;
@@ -2160,6 +2203,11 @@
       get_userdata (s->bfd_section) = new_userdata;
     }
 
+  /* Force flags for a nobits section if section attribute 'NOBITS'
+     is set at link time */
+  if (s->secattr & SECATTR_NOBITS)
+    s->bfd_section->flags |= SEC_ALLOC;
+
   /* If there is a base address, make sure that any sections it might
      mention are initialized.  */
   if (s->addr_tree != NULL)
@@ -2393,6 +2441,15 @@
   /* Add a section reference to the list.  */
   new_section = new_stat (lang_input_section, ptr);
   new_section->section = section;
+
+  /* Force flags for a nobits section if section attribute 'NOBITS'
+     is set at link time */
+  if ((output->secattr & SECATTR_NOBITS)
+      && (output->bfd_section->flags & (SEC_LOAD | SEC_DATA | SEC_HAS_CONTENTS)))
+      /* Trying to force an output section to be NOBITS since there are
+	 data in it */
+      einfo (_("%P: %B: warning: trying to put section `%s' to a section marked as nobits\n"),
+	     section->owner, bfd_section_name(section->owner, section));
 }
 
 /* Handle wildcard sorting.  This returns the lang_input_section which
@@ -2809,6 +2866,22 @@
   else
     einfo (_("%F%B: could not read symbols: %E\n"), entry->the_bfd);
 
+#ifdef IPA_LINK
+  if (is_ipa) {
+    switch (bfd_get_format (entry->the_bfd)) {
+    default:
+      break;
+
+    case bfd_object:
+      ld_set_cur_obj(entry->the_bfd);
+      if (ipa_is_whirl(entry->the_bfd)) {
+	ipa_process_whirl(entry->the_bfd);
+      }
+      break;
+    }
+  }
+#endif
+
   return entry->loaded;
 }
 
@@ -3422,6 +3495,51 @@
     }
 }
 
+/* Run through the list of statment to find a place for
+   the section information table.
+   The placement process is as follow:
+     . at the beginning of the '.secinfo' output section,
+     . at the beginning of the '.rodata' output section,
+     . create '.secinfo' table and place the '.secinfo' at the end
+       of this section. */
+
+typedef struct secinfo_table_placement_policy_struct {
+  const char *section_name;
+  bfd_boolean create_section_anyway;
+} secinfo_table_placement_policy_type;
+
+/* Definition of PT_LOAD for elf binaries */
+#ifndef PT_LOAD
+#define PT_LOAD 1
+#endif
+
+static void
+lang_place_secinfo_table(void)
+{
+
+#ifndef NO_SECINFO_SUPPORT
+  bfd_boolean has_secinfo_table;
+
+  if (link_info.relocatable == TRUE)
+    /* No symbol provided for relocatable object files */
+    return;
+
+  has_secinfo_table = (lang_secinfo_table_statement != NULL) && (config.build_secinfo_table);
+  lang_add_assignment(exp_assign("_has_secinit_table",
+				 exp_intop((has_secinfo_table) ? 1 : 0)));
+
+  if (!has_secinfo_table)
+    {
+      /* Section information table is not expected */
+      lang_add_assignment(exp_assign("_secinit_table",
+				     exp_intop(0)));
+      return;
+    }
+  /* (pp) disable secinfo table creation if the linker script does not specify it */
+#endif
+}
+
+
 /* Run through the list of undefineds created above and place them
    into the linker hash table as undefined symbols belonging to the
    script file.  */
@@ -3587,6 +3705,18 @@
 					target,
 					os);
 	  break;
+        case lang_meminfo_statement_enum:
+	  if (os != NULL
+	      && os->bfd_section == NULL)
+	    init_os (os, 0);
+	  break;
+	case lang_secinfo_table_statement_enum:
+          if (!config.build_secinfo_table)
+            break;
+	  if (os != NULL
+	      && os->bfd_section == NULL)
+	    init_os (os, 0);
+	  break;
 	case lang_data_statement_enum:
 	  /* Make sure that any sections mentioned in the expression
 	     are initialized.  */
@@ -3910,6 +4040,7 @@
 {
   asection *section = output_section_statement->bfd_section;
   int len;
+  int element_no = 0;
 
   if (output_section_statement != abs_output_section)
     {
@@ -3933,8 +4064,18 @@
 
 	  minfo ("0x%V %W", section->vma, section->size);
 
+          if (output_section_statement->max_endaddress != NULL)
+	    {
+	      bfd_vma addr;
+
+              addr = exp_get_abs_int(output_section_statement->max_endaddress,
+				     0, "max end address");
+              minfo (_(" max end address 0x%V"), addr);
+              element_no++;
+            }
+
 	  if (section->vma != section->lma)
-	    minfo (_(" load address 0x%V"), section->lma);
+	    minfo (_("%s load address 0x%V"), element_no ? "," : "", section->lma);
 
 	  if (output_section_statement->update_dot_tree != NULL)
 	    exp_fold_tree (output_section_statement->update_dot_tree,
@@ -4305,6 +4446,73 @@
   print_nl ();
 }
 
+/* Print a secinfo table statement. */
+static void
+print_secinfo_table_statement(lang_secinfo_table_statement_type *s,
+                              lang_output_section_statement_type *os)
+{
+  static const char *name = "CREATE_SECINIT_TABLE";
+  int len;
+
+  if (!config.build_secinfo_table)
+    return;
+
+  print_statement_list (s->symbols.head, os);
+
+  minfo (" %s", name);
+
+  len = strlen (name);
+  if (len >= SECTION_NAME_MAP_LENGTH - 1)
+    {
+      print_nl ();
+      len = 0;
+    }
+  while (len < SECTION_NAME_MAP_LENGTH)
+    {
+      print_space ();
+      ++len;
+    }
+
+  minfo ("0x%V %W", s->origin, s->size);
+
+  print_nl ();
+
+  /* Those lines print the content of secinfo table as a
+     set of language statements. */
+#if 0
+  print_statement_list (s->content.head, os);
+#endif
+}
+
+static void
+print_meminfo_statement(lang_meminfo_statement_type *s,
+                       lang_output_section_statement_type *os)
+{
+  static const char *name = "CREATE_MEMINFO";
+  int len;
+
+  print_statement_list (s->symbols.head, os);
+
+  minfo (" %s", name);
+
+  len = strlen (name);
+  if (len >= SECTION_NAME_MAP_LENGTH - 1)
+    {
+      print_nl ();
+      len = 0;
+    }
+  while (len < SECTION_NAME_MAP_LENGTH)
+    {
+      print_space ();
+      ++len;
+    }
+
+  minfo ("0x%V %W", s->origin, s->size);
+
+  print_nl ();
+}
+
+
 /* Print a reloc statement.  */
 
 static void
@@ -4475,6 +4683,12 @@
     case lang_object_symbols_statement_enum:
       minfo (" CREATE_OBJECT_SYMBOLS\n");
       break;
+    case lang_secinfo_table_statement_enum:
+      print_secinfo_table_statement(&s->secinfo_table_statement, os);
+      break;
+    case lang_meminfo_statement_enum:
+      print_meminfo_statement(&s->meminfo_statement, os);
+      break;
     case lang_fill_statement_enum:
       print_fill_statement (&s->fill_statement);
       break;
@@ -5314,6 +5528,29 @@
 				      fill, dot, relax, check_regions);
 	  break;
 
+	  /* what we have to do when computing the section
+	     information table: TO BE INSERTED. */
+        case lang_secinfo_table_statement_enum:
+          if (!config.build_secinfo_table)
+            break;
+          dot = lang_size_sections_1 (&s->secinfo_table_statement.symbols.head,
+				      output_section_statement,
+				      fill, dot, relax, check_regions);
+          s->secinfo_table_statement.origin = dot;
+          ldemul_get_secinfo_table_content(&s->secinfo_table_statement, dot);
+          dot = lang_size_sections_1 (&s->secinfo_table_statement.content.head,
+				      output_section_statement,
+				      fill, dot, relax, check_regions);
+          s->secinfo_table_statement.size =
+	    dot - s->secinfo_table_statement.origin;
+          break;
+
+        case lang_meminfo_statement_enum:
+	  lang_size_sections_1 (&s->meminfo_statement.content.head,
+				output_section_statement,
+				fill, dot, relax, check_regions);
+          break;
+
 	case lang_insert_statement_enum:
 	  break;
 
@@ -5602,6 +5839,24 @@
 	case lang_address_statement_enum:
 	  break;
 
+        case lang_secinfo_table_statement_enum:
+          /* insert code for secinfo assignements here
+	     TO BE INSERTED. */
+          if (!config.build_secinfo_table)
+            break;
+          dot = lang_do_assignments_1 (s->secinfo_table_statement.symbols.head,
+				       current_os, fill, dot);
+          dot = lang_do_assignments_1 (s->secinfo_table_statement.content.head,
+				       current_os, fill, dot);
+          break;
+
+        case lang_meminfo_statement_enum:
+	  dot = lang_do_assignments_1 (s->meminfo_statement.symbols.head,
+				       current_os, fill, dot);
+	  dot = lang_do_assignments_1 (s->meminfo_statement.content.head,
+				       current_os, fill, dot);
+          break;
+
 	default:
 	  FAIL ();
 	  break;
@@ -5670,6 +5925,36 @@
   struct bfd_link_hash_entry *h;
   bfd_boolean warn;
 
+  /* Check again max_endaddress for output section */
+  lang_statement_union_type *u;
+  lang_output_section_statement_type *os;
+
+  for (u = lang_output_section_statement.head;
+       u != (lang_statement_union_type *) NULL;
+       u = (lang_statement_union_type *) os->next)
+    {
+      bfd_vma result;
+      bfd_vma endaddress;
+
+      os = &u->output_section_statement;
+
+      if ((os->bfd_section == NULL)
+          || (os->bfd_section->size == 0))
+        continue;
+
+      endaddress = os->bfd_section->vma + os->bfd_section->size - 1;
+
+      result = exp_get_vma (os->max_endaddress,
+                            endaddress,
+                            "MAX_ENDADDRESS");
+
+      if (result < endaddress)
+        {
+          einfo (_("%X%S: error: size of section %s too big according to the maximum end address allowed (0x%V)\n"),
+                 os->name, result);
+        }
+    }
+
   if ((link_info.relocatable && !link_info.gc_sections)
       || (link_info.shared && !link_info.executable))
     warn = entry_from_cmdline;
@@ -6020,6 +6305,10 @@
 			      || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0))
 			os->addr_tree = exp_intop (0);
 		      lang_add_section (&os->children, s, os);
+		      einfo("%P: warning: section %s of %B attached by default to output section %s\n",
+			    s->name,
+			    s->owner,
+			    s->output_section->name);
 		    }
 		}
 	    }
@@ -6159,12 +6448,21 @@
 lang_enter_output_section_statement (const char *output_section_statement_name,
 				     etree_type *address_exp,
 				     enum section_type sectype,
+				     flagword secattr,
+				     etree_type *max_endaddress,
+				     const char *algo_name,
 				     etree_type *align,
 				     etree_type *subalign,
 				     etree_type *ebase,
 				     int constraint)
 {
   lang_output_section_statement_type *os;
+  const char *secname = output_section_statement_name;
+  char *start_sym;
+  char *start_prefix = "__stm_begin_";
+  short size;
+  short skip = 0;
+  char *algo_proc_name_prefix = "__decompress_";
 
   os = lang_output_section_statement_lookup (output_section_statement_name,
 					     constraint, TRUE);
@@ -6179,6 +6477,27 @@
     os->flags = SEC_NO_FLAGS;
   else
     os->flags = SEC_NEVER_LOAD;
+
+  os->secattr = secattr;
+  os->max_endaddress = max_endaddress;
+
+  if (algo_name) {
+    os->algo_name = (char *) xmalloc(MAX_NAME_LEN);
+    strncpy(os->algo_name, algo_name, MAX_NAME_LEN);
+    if (strlen(algo_name) > MAX_NAME_LEN) {
+      einfo (_("%P: warning : compression algorithm name limited to %d characters, truncating %s to %s\n"),
+	     MAX_NAME_LEN, algo_name, os->algo_name);
+    }
+    os->algo_proc_name = (char *) xmalloc(MAX_NAME_LEN + strlen(algo_proc_name_prefix));
+    sprintf (os->algo_proc_name, "%s%s", algo_proc_name_prefix, os->algo_name);
+    if (config.get_decompression_code) {
+	ldlang_add_undef(os->algo_proc_name, FALSE);
+    }
+  } else {
+    os->algo_name = NULL;
+    os->algo_proc_name = NULL;
+  }
+
   os->block_value = 1;
 
   /* Make next things chain into subchain of this.  */
@@ -6190,6 +6509,21 @@
     topower (exp_get_value_int (align, -1, "section alignment"));
 
   os->load_base = ebase;
+
+  /* Do not try to attach an assigment operation to the special
+     DISCARD section */
+  if (strcmp (secname, DISCARD_SECTION_NAME) != 0) {
+    if (*secname == '.') {
+          skip = 1;
+    }
+    size = strlen(start_prefix) + strlen(secname+skip) + 1;
+    start_sym = (char *) xmalloc (size);
+    sprintf (start_sym, "%s%s", start_prefix, secname+skip);
+#if 0
+    lang_add_assignment (exp_assign (start_sym,exp_nameop (NAME, ".")));
+#endif
+  }
+
   return os;
 }
 
@@ -6201,6 +6535,7 @@
   new_stmt = new_stat (lang_output_statement, stat_ptr);
   new_stmt->name = output_filename;
 
+  lang_place_secinfo_table();
 }
 
 /* Reset the current counters in the regions.  */
@@ -6305,6 +6640,44 @@
     bfd_gc_sections (link_info.output_bfd, &link_info);
 }
 
+/* (sgr)
+   Place input data to a stable status useful to
+   start size sections getting and assignments done.
+
+   This consists of:
+      . removing all padding statement inserted within the
+        previous allocation (if any),
+      . resetting sizes and addresses of output bfd
+        sections,
+      . resetting internal counter of memory regions. */
+
+static void
+lang_disable_padding_statement (lang_statement_union_type *s)
+{
+  if (s->header.type == lang_padding_statement_enum)
+    s->padding_statement.size = 0;
+}
+
+static void
+lang_prepare_size_and_assignment (bfd_boolean first_pass)
+{
+  asection *section;
+
+  if (first_pass)
+    return;
+
+  /* All padding statement size set to 0 to disable them */
+  lang_for_each_statement_worker (lang_disable_padding_statement,
+                                  statement_list.head);
+
+  /* Reset output bfd sections */
+  for (section = link_info.output_bfd->sections; section; section = section->next)
+    section->rawsize = section->size = 0;
+
+  /* Reset memory regions */
+  lang_reset_memory_regions ();
+}
+
 /* Worker for lang_find_relro_sections_1.  */
 
 static void
@@ -6505,6 +6878,8 @@
 void
 lang_process (void)
 {
+  bfd_boolean assign_again;
+
   /* Finalize dynamic list.  */
   if (link_info.dynamic_list)
     lang_finalize_version_expr_head (&link_info.dynamic_list->head);
@@ -6588,6 +6963,11 @@
   if (entry_symbol.name == NULL)
     link_info.gc_sym_list = ldlang_undef_chain_list_head;
 
+#ifdef IPA_LINK
+  if (is_ipa)
+    return;
+#endif
+
   ldemul_after_open ();
 
   bfd_section_already_linked_table_free ();
@@ -6656,6 +7036,10 @@
      section positions, since they will affect SIZEOF_HEADERS.  */
   lang_record_phdrs ();
 
+do {
+
+  lang_prepare_size_and_assignment (process_first_pass);
+
   /* Check relro sections.  */
   if (link_info.relro && ! link_info.relocatable)
     lang_find_relro_sections ();
@@ -6674,6 +7058,16 @@
      of all the symbols.  */
   lang_do_assignments (lang_final_phase_enum);
 
+  /* See if anything special should be done now we know how
+     everything is. */
+  assign_again = FALSE;
+  ldemul_after_assignment (&assign_again);
+
+  /* We are sure now that it is not the first pass */
+  process_first_pass = FALSE;
+
+} while (assign_again);
+
   ldemul_finish ();
 
   /* Make sure that the section addresses make sense.  */
@@ -6852,6 +7246,109 @@
   new_statement (attribute, sizeof (lang_statement_header_type), stat_ptr);
 }
 
+/* add code to handle a secinfo structure */
+static
+void
+lang_create_secinfo_table (lang_output_section_statement_type *output_section)
+{
+  lang_statement_list_type *crt_stat_ptr;
+
+  if (link_info.relocatable
+      || (lang_secinfo_table_statement != NULL)
+      || !config.build_secinfo_table)
+    /* this directive of command file is ignored when
+       producing a relocatable object file. */
+    return;
+
+  lang_secinfo_table_statement = new_stat (lang_secinfo_table_statement, stat_ptr);
+  lang_list_init( &lang_secinfo_table_statement->symbols );
+  lang_list_init( &lang_secinfo_table_statement->content );
+  lang_secinfo_table_statement->output_section = output_section;
+  lang_secinfo_table_statement->origin = (bfd_vma)0;
+
+  crt_stat_ptr = stat_ptr;
+
+  stat_ptr = &lang_secinfo_table_statement->symbols;
+  lang_add_assignment (exp_assign("_secinit_table", exp_nameop(NAME, ".")));
+
+#if 1
+  stat_ptr = &lang_secinfo_table_statement->content;
+  lang_add_data(SHORT, exp_intop(0xdead));
+#endif
+
+  stat_ptr = crt_stat_ptr;
+}
+
+void
+lang_add_secinfo_table()
+{
+  lang_create_secinfo_table(current_section);
+}
+
+#define MAX_MEMINFO_NAME_LEN 32
+
+void lang_add_meminfo ()
+{
+  lang_meminfo_statement_type *meminfo_stmt   = NULL;
+  lang_statement_list_type    *saved_stat_ptr = NULL;
+  lang_memory_region_type     *mem            = NULL;
+  bfd_vma                      size           = 0;
+
+  meminfo_stmt = new_stat(lang_meminfo_statement, stat_ptr);
+
+  lang_list_init(&meminfo_stmt->symbols);
+  lang_list_init(&meminfo_stmt->content);
+
+  meminfo_stmt->output_section = current_section;
+  meminfo_stmt->origin         = (bfd_vma)0x0;
+
+  /* Save the current statement-pointer to
+     add some assignement/data elsewhere. CV */
+  saved_stat_ptr = stat_ptr;
+
+  /* Go back to the symbols list statement to
+     add the definition of "__meminfo_start". CV */
+  stat_ptr = &meminfo_stmt->symbols;
+  lang_add_assignment (exp_assign("__meminfo_start",
+				  exp_nameop (LOADADDR, meminfo_stmt->output_section->name)));
+
+  stat_ptr = &meminfo_stmt->content;
+  for (mem = lang_memory_region_list; mem != NULL; mem = mem->next, size++) {
+    int i = 0;
+    char name[MAX_MEMINFO_NAME_LEN];
+
+    memset(name, 0, sizeof(name));
+
+    lang_add_data(LONG, exp_intop(mem->origin));
+    lang_add_data(LONG, exp_intop(mem->length));
+    lang_add_data(LONG, exp_intop(mem->flags));
+    lang_add_data(LONG, exp_intop(mem->not_flags));
+
+    if (strlen(mem->name_list.name) > MAX_MEMINFO_NAME_LEN) {
+      einfo(_("%P: warning: the name of memory region `%s' will be truncated in .meminfo\n"), mem->name_list.name);
+    }
+
+    strncpy(name, mem->name_list.name, MAX_MEMINFO_NAME_LEN);
+
+    /* Be aware name[32] does not include the terminating '\0' character,
+       because its size is fixed. CV */
+    for (i = 0; i < MAX_MEMINFO_NAME_LEN; i++) {
+      lang_add_data(BYTE, exp_intop(name[i]));
+    }
+  }
+
+  /* Go back to the symbols list statement to
+     add the definition of "__meminfo_end". CV */
+  stat_ptr = &meminfo_stmt->symbols;
+  lang_add_assignment (exp_assign("__meminfo_end",
+				  exp_binop ('+',
+					     exp_nameop (LOADADDR, meminfo_stmt->output_section->name),
+					     exp_nameop (SIZEOF, meminfo_stmt->output_section->name))));
+
+  /* Restore the original statement-pointer. CV */
+  stat_ptr = saved_stat_ptr;
+}
+
 void
 lang_startup (const char *name)
 {
@@ -6900,7 +7397,15 @@
       && strcmp (memspec, DEFAULT_MEMORY_REGION) == 0)
     *region = *lma_region;
   else
-    *region = lang_memory_region_lookup (memspec, FALSE);
+    {
+      *region = lang_memory_region_lookup (memspec, FALSE);
+      /* warn if the region was not defined through a memory command */
+          if (((*region)->length==~(bfd_size_type) 0) && strcmp (memspec, "*default*") != 0)
+	    {
+	      einfo (_("%P: warning: memory region `%s' has not been specified!\n"),
+		     memspec);
+	    }
+    }
 
   if (have_lma && lma_memspec != 0)
     einfo (_("%X%P:%S: section has both a load address and a load region\n"));
@@ -6911,6 +7416,26 @@
 				     lang_output_section_phdr_list *phdrs,
 				     const char *lma_memspec)
 {
+  const char *secname = current_section->name;
+  char *stop_sym;
+  char *stop_prefix = "__stm_end_";
+  short size;
+  short skip = 0;
+
+  /* Do not try to attach an assigment operation to the special
+     DISCARD section */
+  if (strcmp (secname, DISCARD_SECTION_NAME) != 0) {
+    if (*secname == '.') {
+      skip = 1;
+    }
+    size = strlen(stop_prefix) + strlen(secname+skip) + 1;
+    stop_sym = (char *) xmalloc (size);
+    sprintf (stop_sym, "%s%s", stop_prefix, secname+skip);
+#if 0
+    lang_add_assignment (exp_assign (stop_sym,exp_nameop (NAME, ".")));
+#endif
+  }
+
   lang_get_regions (&current_section->region,
 		    &current_section->lma_region,
 		    memspec, lma_memspec,
@@ -7060,6 +7585,23 @@
   pop_stat_ptr ();
 }
 
+/* Find a phdr in the list of currently recorded program
+   headers. Returns NULL if the program header is not found. */
+
+struct lang_phdr *
+lang_phdr_find(name)
+     const char *name;
+{
+  struct lang_phdr *p;
+
+  for (p = lang_phdr_list; p; p = p->next)
+    if (strcmp (p->name, name) == 0)
+      /* this segment header already exist */
+      return p;
+
+  return (struct lang_phdr *)0;
+}
+
 /* Add a new program header.  This is called for each entry in a PHDRS
    command in a linker script.  */
 
@@ -7260,10 +7802,13 @@
 
 static struct overlay_list *overlay_list;
 
+/* Which type of initialization for this overlay */
+static flagword overlay_attr;
+
 /* Start handling an overlay.  */
 
 void
-lang_enter_overlay (etree_type *vma_expr, etree_type *subalign)
+lang_enter_overlay (etree_type *vma_expr, etree_type *subalign, flagword secattr)
 {
   /* The grammar should prevent nested overlays from occurring.  */
   ASSERT (overlay_vma == NULL
@@ -7272,6 +7817,7 @@
 
   overlay_vma = vma_expr;
   overlay_subalign = subalign;
+  overlay_attr = secattr;
 }
 
 /* Start a section in an overlay.  We handle this by calling
@@ -7279,12 +7825,22 @@
    lang_leave_overlay sets up the LMA and memory regions.  */
 
 void
-lang_enter_overlay_section (const char *name)
+lang_enter_overlay_section (const char *name, flagword secattr)
 {
   struct overlay_list *n;
   etree_type *size;
 
+  /* Which initialize provided for this section, depending
+     on the general overlay section init type and section init
+     type provided for this section. */
+  if (overlay_attr & SECATTR_NOINIT)
+    secattr |= SECATTR_NOINIT;
+  else
+    /* Initialize the first none-init section provided. */
+    overlay_attr |= SECATTR_NOINIT;
+
   lang_enter_output_section_statement (name, overlay_vma, overlay_section,
+				       secattr, NULL, NULL,
 				       0, overlay_subalign, 0, 0);
 
   /* If this is the first section, then base the VMA of future
diff -r -N -u binutils-2.21.51/ld/ldlang.h binutils/ld/ldlang.h
--- binutils-2.21.51/ld/ldlang.h	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/ldlang.h	2011-07-06 12:44:26.137253000 +0100
@@ -83,7 +83,9 @@
   lang_padding_statement_enum,
   lang_group_statement_enum,
   lang_insert_statement_enum,
-  lang_constructors_statement_enum
+  lang_constructors_statement_enum,
+  lang_secinfo_table_statement_enum,
+  lang_meminfo_statement_enum
 };
 
 typedef struct lang_statement_header_struct
@@ -120,6 +122,12 @@
   noalloc_section
 };
 
+#define SECATTR_NOFLAGS 0x00
+#define SECATTR_NOINIT  0x01
+#define SECATTR_NOBITS  0x02
+#define SECATTR_CLEAR   0x04
+#define MAX_NAME_LEN 8
+
 /* This structure holds a list of program headers describing
    segments in which this section should be placed.  */
 
@@ -138,11 +146,15 @@
   struct lang_output_section_statement_struct *prev;
   const char *name;
   asection *bfd_section;
+  flagword secattr;
   lang_memory_region_type *region;
   lang_memory_region_type *lma_region;
   fill_type *fill;
   union etree_union *addr_tree;
   union etree_union *load_base;
+  union etree_union *max_endaddress;
+  char *algo_name;
+  char *algo_proc_name;
 
   /* If non-null, an expression to evaluate after setting the section's
      size.  The expression is evaluated inside REGION (above) with '.'
@@ -367,6 +379,29 @@
   lang_statement_list_type children;
 } lang_group_statement_type;
 
+/* A secinfo statement collects internal data section
+   built by the emulation mode. */
+
+typedef struct lang_secinfo_table_statement_struct {
+  lang_statement_header_type header;
+  lang_statement_list_type symbols;
+  lang_statement_list_type content;
+  lang_output_section_statement_type *output_section;
+  bfd_vma origin;
+  bfd_size_type size;
+} lang_secinfo_table_statement_type;
+
+/* The 'meminfo' statement is used to embed memory region information
+   into a section. */
+typedef struct lang_meminfo_statement_struct {
+  lang_statement_header_type header;
+  lang_statement_list_type symbols;
+  lang_statement_list_type content;
+  lang_output_section_statement_type *output_section;
+  bfd_vma origin;
+  bfd_size_type size;
+} lang_meminfo_statement_type;
+
 typedef struct
 {
   lang_statement_header_type header;
@@ -393,6 +428,8 @@
   lang_padding_statement_type padding_statement;
   lang_group_statement_type group_statement;
   lang_insert_statement_type insert_statement;
+  lang_secinfo_table_statement_type secinfo_table_statement;
+  lang_meminfo_statement_type meminfo_statement;
 } lang_statement_union_type;
 
 /* This structure holds information about a program header, from the
@@ -460,6 +497,8 @@
   lang_output_section_statement_type **os_tail;
 };
 
+extern lang_secinfo_table_statement_type *lang_secinfo_table_statement;
+extern lang_meminfo_statement_type *lang_meminfo_statement;
 extern const char *output_target;
 extern lang_output_section_statement_type *abs_output_section;
 extern lang_statement_list_type lang_output_section_statement;
@@ -495,6 +534,9 @@
   (const char *output_section_statement_name,
    etree_type *address_exp,
    enum section_type sectype,
+   flagword secattr,
+   etree_type *max_endaddress,
+   const char *algo_name,
    etree_type *align,
    etree_type *subalign,
    etree_type *, int);
@@ -526,6 +568,8 @@
   (const char *);
 extern void lang_float
   (bfd_boolean);
+extern void lang_add_secinfo_table PARAMS ((void));
+extern void lang_add_meminfo PARAMS ((void));
 extern void lang_leave_output_section_statement
   (fill_type *, const char *, lang_output_section_phdr_list *,
    const char *);
@@ -607,6 +651,7 @@
   (void);
 extern void lang_leave_group
   (void);
+extern struct lang_phdr *lang_phdr_find PARAMS ((const char *));
 extern void lang_add_section
   (lang_statement_list_type *, asection *,
    lang_output_section_statement_type *);
@@ -616,9 +661,9 @@
 extern void lang_add_nocrossref
   (lang_nocrossref_type *);
 extern void lang_enter_overlay
-  (etree_type *, etree_type *);
+  (etree_type *, etree_type *, flagword);
 extern void lang_enter_overlay_section
-  (const char *);
+  (const char *, flagword);
 extern void lang_leave_overlay_section
   (fill_type *, lang_output_section_phdr_list *);
 extern void lang_leave_overlay
diff -r -N -u binutils-2.21.51/ld/ldlex.c binutils/ld/ldlex.c
--- binutils-2.21.51/ld/ldlex.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/ld/ldlex.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,4050 +0,0 @@
-/* A lexical scanner generated by flex */
-
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
- */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-
-#include <stdio.h>
-#include <unistd.h>
-
-
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
-
-
-#ifdef __cplusplus
-
-#include <stdlib.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_PROTOS
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yy_start = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yy_start - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#define YY_BUF_SIZE 16384
-
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-
-extern int yyleng;
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
-
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-	};
-
-static YY_BUFFER_STATE yy_current_buffer = 0;
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- */
-#define YY_CURRENT_BUFFER yy_current_buffer
-
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
-
-typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
-
-#define YY_NUM_RULES 192
-#define YY_END_OF_BUFFER 193
-static yyconst short int yy_accept[1637] =
-    {   0,
-        0,    0,  172,  172,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,  193,  192,
-      190,  175,  174,   32,  190,  172,   38,   29,   44,   43,
-       34,   35,   28,   36,  172,   37,    8,    8,   45,   46,
-       39,   40,   27,   33,  172,  172,  172,  172,  172,  172,
-      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
-      172,  172,  172,  172,   10,    9,  172,  117,  115,  172,
-       42,   30,   41,   31,  191,  175,   32,  191,  170,   38,
-       29,   44,   43,   34,   35,   28,   36,  170,   37,    8,
-        8,   45,   46,   39,   40,   27,   33,  170,  170,  170,
-
-      170,  170,  170,  170,  170,  170,  170,  170,  170,  170,
-      170,  170,   10,    9,  170,  170,   42,   30,   41,   31,
-      168,   36,  168,   37,    8,    8,  168,  168,  168,  168,
-      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
-      168,  168,  168,  168,  168,  168,  168,  117,  115,  168,
-       31,    4,    3,    2,    4,    5,  129,   32,  128,  167,
-       34,   35,   28,   36,  167,   37,    8,    8,   45,   46,
-       40,   33,  167,  167,  167,  167,  167,  167,  167,  167,
-      167,  167,  167,  167,   10,    9,  167,  167,  167,  167,
-      167,  167,  167,  167,  167,  167,  167,   31,  189,  187,
-
-      188,  190,  182,  181,  176,  183,  184,  180,  180,  180,
-      180,  185,  186,  175,  172,   15,    0,  173,    8,   26,
-       24,   22,   20,   21,    1,   23,    8,    8,  172,   18,
-       17,   14,   16,   19,  172,  172,  172,  172,  172,  121,
-      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
-      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
-      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
-      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
-      172,  172,  172,  172,  172,  172,  172,  172,   25,   13,
-       15,  170,    6,   22,   20,   21,    0,    1,   23,    8,
-
-        0,    7,    7,    8,    7,   14,  170,    7,    7,    7,
-      170,  170,  121,    7,  170,  170,    7,  170,  170,  170,
-        7,  170,  170,  170,  170,  170,  170,  170,  170,  170,
-      170,  170,  170,  170,  170,  170,  170,  170,    7,  170,
-      168,    8,    0,   23,    8,    0,  168,  168,  168,  168,
-      168,  121,  168,  168,  168,  168,  168,  168,  168,  168,
-      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
-      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
-      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
-      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
-
-      168,    4,    4,  128,  128,  167,    6,  130,   22,  131,
-      167,    7,    7,    7,  167,  167,  167,    7,  167,    7,
-        7,  167,  167,  167,  167,  167,  167,  167,  167,    7,
-      167,  167,  167,    7,  167,    7,    7,  167,  167,  167,
-      167,  167,  167,  167,  167,  189,  188,  181,  180,    0,
-      180,  180,  180,   11,   12,  172,  172,  172,  172,  172,
-      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
-      172,  172,  172,  172,  172,  172,  172,  172,   92,  172,
-      172,  172,  172,  172,  172,  172,  172,  172,  172,   71,
-      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
-
-      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
-      172,  172,  172,  172,  172,  172,  172,  118,  116,  172,
-        8,  171,    8,  170,    7,  170,  170,  170,  170,  170,
-      170,  170,  170,  170,  170,  170,  170,  170,  170,  170,
-      170,  170,   62,   63,  170,  170,  170,  170,  170,  170,
-      170,  170,  170,  170,  170,  170,  170,    8,  169,  168,
-      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
-      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
-      168,  168,   92,  168,  168,  168,  168,  168,  168,  168,
-      168,  168,  168,   71,   62,  168,   63,  168,  168,  168,
-
-      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
-      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
-      168,  168,  168,  118,  116,  168,    4,    8,  167,  167,
-      167,  167,  167,  132,  167,  167,  167,  167,  167,  167,
-      167,  167,  167,  167,  167,  167,  167,  167,  167,  149,
-      167,  167,  167,  167,  167,  167,  167,  167,  167,  167,
-      180,  180,  180,  172,   59,  172,  172,  172,  172,  172,
-       53,  172,   99,  172,  109,  172,  172,  172,  172,  172,
-      172,  172,   88,  172,  172,  172,  172,  110,  172,  172,
-      172,  125,  172,  172,  172,   97,  172,   67,  172,  172,
-
-      172,  172,  172,  172,  172,  172,  172,   95,  172,  172,
-      172,  172,  172,  172,  105,  172,  172,  172,  172,  172,
-      172,  172,  172,  172,  170,   59,  170,  170,  170,   53,
-      170,  170,  109,  170,  170,  170,  170,  170,  170,  110,
-      125,  170,  170,   67,  170,  170,  170,  170,  170,  170,
-      170,  170,  170,  170,  170,  170,  168,   59,  168,  168,
-      168,  168,  168,   53,  168,   99,  168,  109,  168,  168,
-      168,  168,  168,  168,  168,   88,  168,  168,  168,  168,
-      110,  168,  168,  168,  125,  168,  168,  168,   97,  168,
-       67,  168,  168,  168,  168,  168,  168,  168,  168,  168,
-
-       95,  168,  168,  168,  168,  168,  168,  105,  168,  168,
-      168,  168,  168,  168,  168,  168,  168,  167,  167,  167,
-      136,  144,  135,  167,  167,  146,  139,  142,  167,  167,
-      147,  167,  167,  167,  167,  167,  153,  161,  152,  167,
-      167,  164,  156,  159,  167,  167,  165,  167,  167,  180,
-      180,  180,  172,   86,   55,  172,  172,  172,   52,  172,
-      172,  172,  172,  108,   65,  172,  172,   94,  172,   77,
-      172,  172,   76,  172,  172,  172,  172,  172,  172,  172,
-      172,  172,  172,  172,  172,  120,  172,  172,  172,  172,
-      172,   98,  172,  172,  172,   96,  172,  172,  172,  172,
-
-      172,  172,  172,  170,   55,  170,  170,   52,  170,  170,
-      170,  108,  170,   77,  170,  170,  170,  170,  170,  170,
-      170,  170,  170,  170,  170,  170,  170,  170,  170,  168,
-       86,   55,  168,  168,  168,   52,  168,  168,  168,  168,
-      108,   65,  168,  168,   94,  168,   77,  168,  168,   76,
-      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
-      168,  168,  120,  168,  168,  168,  168,  168,   98,  168,
-      168,  168,   96,  168,  168,  168,  168,  168,  168,  168,
-      167,  137,  134,  167,  167,  146,  146,  141,  167,  145,
-      167,  167,  154,  151,  167,  167,  164,  164,  158,  167,
-
-      163,  167,  180,  180,  178,  172,  172,   64,  172,   87,
-      172,  172,  172,  172,  172,  172,   66,  172,  172,  172,
-       85,  172,   54,  172,   47,  172,  172,  107,  172,   50,
-       75,  172,  172,  172,  172,  172,  172,   72,  172,  172,
-      172,  172,   93,   73,  172,  172,  172,  170,  170,   64,
-      170,  170,  170,  170,  170,  170,   54,  170,  170,  107,
-      170,   50,  170,  170,  170,   72,  170,  170,  170,  170,
-      168,  168,   64,  168,   87,  168,  168,  168,  168,  168,
-      168,   66,  168,  168,  168,   85,  168,   54,  168,   47,
-      168,  168,  107,  168,   50,   75,  168,  168,  168,  168,
-
-      168,  168,   72,  168,  168,  168,  168,   93,   73,  168,
-      168,  168,  167,  167,   66,  143,  140,  167,  167,  167,
-      162,  160,  157,  167,  179,  177,  172,   61,  172,  172,
-      172,  172,  172,   79,  172,  172,  119,  172,  172,  172,
-      172,  100,  172,  172,  102,  123,  172,  172,  172,  172,
-      172,  172,  114,   89,  172,   51,  172,  172,  170,   61,
-      170,  170,  170,   79,  170,  119,  170,  170,  170,  111,
-      123,  170,  170,  114,  170,  170,  170,  168,   61,  168,
-      168,  168,  168,  168,   79,  168,  168,  119,  168,  168,
-      168,  168,  100,  168,  168,  102,  123,  168,  168,  168,
-
-      168,  168,  168,  114,   89,  168,   51,  168,  168,  167,
-      167,  167,  167,  167,  167,  148,  172,  127,  172,  172,
-      172,  172,  172,  172,  172,   60,  172,  172,  172,  172,
-      172,  172,  172,   84,  172,  172,  172,  122,  166,  172,
-      148,  170,  127,  170,  170,   60,  170,  170,  170,  170,
-      170,  122,  166,  170,  148,  168,  127,  168,  168,  168,
-      168,  168,  168,  168,   60,  168,  168,  168,  168,  168,
-      168,  168,   84,  168,  168,  168,  122,  166,  168,  148,
-      133,  138,  166,  150,  155,   78,  172,  172,  172,  172,
-      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
-
-      172,  172,  172,  172,  172,  172,   78,  170,  170,  170,
-      170,  170,  170,  170,  170,   78,  168,  168,  168,  168,
-      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
-      168,  168,  168,  168,  168,  168,  172,  172,  172,  172,
-      172,  172,   49,  172,  112,  113,  172,  172,  172,  172,
-       74,  172,  172,  172,  172,  172,  172,  170,  170,  170,
-      112,  113,  170,  170,  170,  170,  168,  168,  168,  168,
-      168,  168,   49,  168,  112,  113,  168,  168,  168,  168,
-       74,  168,  168,  168,  168,  168,  168,  172,  172,  172,
-      172,  172,  172,  101,   91,  172,  172,  172,  172,  172,
-
-      172,  172,  172,  172,  170,  170,  101,  170,  170,  170,
-      170,  168,  168,  168,  168,  168,  168,  101,   91,  168,
-      168,  168,  168,  168,  168,  168,  168,  168,   81,  172,
-      172,  126,  172,  172,  172,  172,   48,  172,  172,  172,
-      172,  103,  172,  170,  126,  170,  170,  170,  170,   81,
-      168,  168,  126,  168,  168,  168,  168,   48,  168,  168,
-      168,  168,  103,  168,  172,  172,  172,  172,   90,  172,
-       70,  172,  172,  172,  172,  170,  170,   70,  170,  170,
-      168,  168,  168,  168,   90,  168,   70,  168,  168,  168,
-      168,  172,  172,  172,  172,  172,  172,  124,   69,  172,
-
-      172,   68,  170,  170,  170,  124,   69,   68,  168,  168,
-      168,  168,  168,  168,  124,   69,  168,  168,   68,  172,
-      172,  172,  172,  172,  172,  172,  172,  170,  170,  170,
-      168,  168,  168,  168,  168,  168,  168,  168,  172,  172,
-       58,  172,  172,  172,  172,  172,  170,   58,  170,  168,
-      168,   58,  168,  168,  168,  168,  168,  172,  172,  172,
-      172,  172,  104,  172,  170,  170,  168,  168,  168,  168,
-      168,  104,  168,  172,   56,  172,  172,  172,  172,   56,
-      170,  168,   56,  168,  168,  168,  168,  172,  172,  172,
-      172,  172,  170,  168,  168,  168,  168,  168,  172,  172,
-
-      172,  172,  172,  170,  168,  168,  168,  168,  168,   80,
-      172,  172,  172,  106,  170,   80,  168,  168,  168,  106,
-       57,  172,  172,   57,   57,  168,  168,   82,  172,   82,
-      168,  172,  168,   83,   83,    0
-    } ;
-
-static yyconst int yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    4,    5,    6,    7,    8,    9,    1,   10,
-       11,   12,   13,   14,   15,   16,   17,   18,   19,   19,
-       19,   19,   19,   19,   19,   19,   19,   20,   21,   22,
-       23,   24,   25,    1,   26,   27,   28,   29,   30,   31,
-       32,   33,   34,   35,   36,   37,   38,   39,   40,   41,
-       42,   43,   44,   45,   46,   47,   48,   49,   50,   51,
-       52,   53,   54,   55,   56,    1,   57,   58,   59,   60,
-
-       61,   62,   63,   64,   65,   16,   66,   67,   68,   69,
-       70,   71,   16,   72,   73,   74,   75,   16,   16,   76,
-       16,   77,   78,   79,   80,   81,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst int yy_meta[82] =
-    {   0,
-        1,    1,    2,    3,    1,    1,    4,    1,    1,    1,
-        1,    3,    5,    6,    7,    8,    9,   10,   10,    7,
-        1,    1,    6,    1,    3,   10,   10,   10,   10,   10,
-       10,    8,    8,    8,    8,    8,    8,    8,    8,    8,
-        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
-        8,    7,    4,    7,    3,    8,   10,   10,   10,   10,
-       10,   10,    8,    8,    8,    8,    8,    8,    8,    8,
-        8,    8,    8,    8,    8,    8,    8,    1,    1,    1,
-        9
-    } ;
-
-static yyconst short int yy_base[1661] =
-    {   0,
-        0,    0,    0,    0,   81,    0,  162,    0,  243,  323,
-      403,    0,  271,  273,  484,  565,  646,  727, 2561, 2562,
-     2562, 2558, 2562, 2536, 2553,  791, 2562,  260, 2562, 2562,
-     2534, 2533,    0, 2532,    0,  247,  321,  492,    0, 2562,
-      249, 2531,  257,    0,  255,  257,  253,  259,  262,  268,
-     2510, 2515, 2512, 2520,  280,  286,  274,  315,  317, 2503,
-     2518,  350, 2521, 2516,    0,    0, 2487, 2483, 2471, 2477,
-     2562,  290, 2562,    0, 2562, 2539, 2517, 2534,  836, 2562,
-      343, 2562, 2562, 2515, 2514, 2562,  296,    0,  294,  881,
-      306, 2562, 2562,  342, 2513,  344, 2562,  940,  487,  506,
-
-      565,  577,  571, 2492, 2495, 2503,  341,  359,  346,  476,
-     2489,  488, 2562, 2562,  644, 2466, 2562,  295, 2562,    0,
-      999,  477,    0,  376,  735,  747,  596,  511,  313,  567,
-      478,  515, 2487, 2492, 2489, 2497,  599,  573,  517,  591,
-      599, 2480, 2495,  645, 2498, 2493, 2464, 2460, 2448, 2454,
-        0, 1044, 2562, 2562,    0, 2562, 2562, 2495, 2514, 1089,
-     2493, 2492, 2562, 2491,    0, 2490,    0,  464, 2562,    0,
-     2489, 2562, 1134,  635,  666,  647,  667,  671,  339, 2485,
-     2467, 2463,  551, 2465, 2562, 2562,  685,  730,  732,  694,
-      754,  455, 2450, 2434, 2430,  498, 2432,    0, 2501, 2562,
-
-        0, 2490, 2562,    0, 2562, 2562, 2562, 2481,  536,  534,
-      630, 2562, 2562, 2498,    0,    0, 2494, 2562,  736, 2562,
-     2562,    0,    0,    0,    0,    0,  757,    0,    0, 2475,
-     2562,    0, 2562, 2474, 2452, 2466, 2449, 2459,  580,    0,
-     2461, 2452, 2450, 2444,  641, 2458, 2442, 2455, 2455, 2439,
-      669, 2446, 2442, 2438, 2440, 2442,  798, 2448, 2421, 2437,
-      657, 2434, 2436, 2424,  727, 2435, 2437, 2425, 2439, 2439,
-     2427, 2440, 2433,  691, 2424, 2412, 2419, 2431, 2414, 2433,
-     2431, 2413, 2413, 2412, 2381, 2384, 2389, 2374, 2562, 2562,
-     2562,    0, 1193, 2562, 2562, 2562,    0, 2562, 2562,  477,
-
-      809,    0, 2562, 2562,    0, 2562,  842,  845,  889,    0,
-     2416,  712,    0,  917, 2410, 2408,  679,  949,  976, 2417,
-     2418, 2405,  711, 2414, 2404, 2416, 2392, 2401, 2390,  673,
-     2401, 2403, 2406, 2395, 2402, 2382, 2402, 2404,  995, 2353,
-        0, 1244,    0,    0,  884,    0, 2385, 2399, 2382, 2392,
-      736,    0, 2394, 2385, 2383, 2377,  721, 2391, 2375, 2388,
-     2388, 2372,  733, 2379, 2375, 2371, 2373, 2375,  802, 2381,
-     2354, 2370,  760,  564, 2370, 2368, 2357,  900, 2368, 2370,
-     2358, 2372, 2372, 2360, 2373, 2366,  806, 2357, 2345, 2352,
-     2364, 2347, 2366, 2364, 2346, 2346, 2345, 2314, 2317, 2322,
-
-     2307,    0, 1295, 2380, 2562,    0, 1346,    0,    0,    0,
-      678,  888,  833,    0, 2348,  928,  937, 2347, 2351, 2334,
-     2335, 2333, 2350, 2337, 2345, 2346, 2344, 2345, 2324,  851,
-     2304,  854,  969, 2303, 2307, 2292, 2293, 2291, 2306, 2294,
-     2301, 2302, 2300, 2301, 2282, 2354,    0,    0, 2335, 2334,
-      762,  836,  757, 2562, 2562, 2313, 2309, 2321, 2318, 2319,
-     2309, 2307, 2317, 2317, 2314, 2299, 2292, 2315, 2314, 2305,
-     2310, 2294, 2299, 2305, 2297, 2307, 2304, 2285,    0, 2293,
-     2289, 2294, 2281, 2296, 2284, 2293, 2291, 2293, 2289,    0,
-     2280, 2274, 2275, 2280, 2276, 2265, 2282, 2272, 2269, 2268,
-
-     2263, 2280, 2274, 2264, 2261, 2267, 2261, 2273, 2257, 2273,
-     2274, 2256, 2272, 2260, 2264, 2251, 2224,    0,    0, 2232,
-        0,    0,  998, 2252, 1004, 2259, 2260, 2250, 2259, 2259,
-     2242, 2235, 2258, 1049, 2255, 2245, 2235, 2243, 2239, 2237,
-     2245, 2247,    0,    0, 2230, 2231, 2233, 2222, 2239, 2227,
-     2222, 2230, 2237, 2238, 2239, 2194, 2202,    0,    0, 2222,
-     2218, 2230, 2227, 2228, 2218, 2216, 2226, 2226, 2223, 2208,
-     2201, 2224, 2223, 2214, 2219, 2203, 2208, 2214, 2206, 2216,
-     2213, 2194,    0, 2202, 2198, 2203, 2190, 2205, 2193, 2202,
-     2200, 2202, 2198,    0,    0, 2189,    0, 2183, 2184, 2189,
-
-     2185, 2174, 2191, 2181, 2178, 2177, 2172, 2189, 2183, 2173,
-     2170, 2176, 2170, 2182, 2166, 2182, 2183, 2165, 2181, 2169,
-     2173, 2160, 2133,    0,    0, 2141,    0,    0, 2161,  897,
-     2170, 2169, 2157,    0, 2167, 2158, 2150, 2165, 2163, 2162,
-     2154, 2145, 2146, 2149, 2117,  925, 2125, 2124, 2113,    0,
-     2122, 2114, 2107, 2120, 2118, 2117, 2110, 2102, 2103, 2105,
-      615,  933,  258, 2136,    0, 2129, 2132, 2127, 2139, 2125,
-        0, 2131,    0, 2121,    0, 2120, 2108, 2124, 2117, 2111,
-     2114, 2116,    0, 2113, 2127, 2115, 2109,    0, 2127, 2108,
-     2109,    0, 2121, 2105, 2123,    0, 2105,    0, 2107, 2106,
-
-     2119, 2088, 2109, 2096, 2104, 2096, 2105,    0, 2098, 2109,
-     2102, 2105, 2089, 2093, 2076, 2097, 2101, 2084, 2091, 2093,
-     2096, 2091, 2057, 2053, 2085,    0, 2082, 2077, 2089,    0,
-     2082, 2072,    0, 2060, 2076, 2069, 2067, 2071, 2065,    0,
-        0, 2065, 2083,    0, 2068, 2081, 2050, 2071, 2067, 2069,
-     2072, 2061, 2066, 2062, 2031, 2027, 2059,    0, 2052, 2055,
-     2050, 2062, 2048,    0, 2054,    0, 2044,    0, 2043, 2031,
-     2047, 2040, 2034, 2037, 2039,    0, 2036, 2050, 2038, 2024,
-        0, 2033, 2005, 1997,    0, 1997, 1978, 1994,    0, 1976,
-        0, 1975, 1965, 1969, 1929, 1945, 1917, 1925, 1917,  226,
-
-        0,  332,  366,  364,  461,  467,  502,  575,  619,  629,
-      632,  697,  745,  767,  764,  733,  742,  777,  793,  801,
-        0,    0,    0,  798,  818, 1414,    0,    0,  814,  825,
-        0,  816,  840,  806,  803,  811,    0,    0,    0,  811,
-      827, 1494,    0,    0,  820,  836,    0,  830,  846,  915,
-      955,  893,  890,    0,  908,  911,  933,  949,    0,  966,
-      953,  946,  965,    0,    0,  979,  972,    0,  958,    0,
-      986,  985,    0,  978, 1009, 1004, 1009,  993, 1000, 1019,
-     1017, 1016, 1012, 1007, 1027,    0, 1025, 1016, 1032, 1027,
-     1030,    0, 1046, 1052, 1054,    0, 1035, 1048, 1057, 1040,
-
-     1047, 1013, 1027, 1044, 1051, 1047, 1065,    0, 1070, 1053,
-     1068,    0, 1070,    0, 1071, 1076, 1081, 1067, 1083, 1079,
-     1075, 1095, 1093, 1084, 1093, 1099, 1092, 1052, 1066, 1083,
-        0, 1090, 1086, 1102, 1103,    0, 1111, 1104, 1091, 1106,
-        0,    0, 1109, 1100,    0, 1084,    0, 1112, 1108,    0,
-     1098, 1118, 1112, 1126, 1106, 1113, 1132, 1130, 1132, 1129,
-     1124, 1144,    0, 1143, 1134, 1142, 1136, 1138,    0, 1147,
-     1152, 1154,    0, 1135, 1148, 1157, 1140, 1146, 1112, 1126,
-     1143,    0, 1152, 1158, 1154,    0, 1574,    0, 1172,    0,
-     1175, 1127,    0, 1135, 1136, 1132,    0, 1654,    0, 1148,
-
-        0, 1151, 1189, 1193, 1194, 1170, 1185,    0, 1188,    0,
-     1179, 1179, 1170, 1197, 1199, 1200,    0, 1204, 1203, 1189,
-        0, 1190,    0, 1207,    0, 1193, 1193,    0, 1208,    0,
-     1184, 1191, 1212, 1187, 1188, 1206, 1201, 1191, 1198, 1212,
-     1215, 1225,    0,    0, 1225, 1191, 1210, 1222, 1237,    0,
-     1240, 1237, 1247, 1249, 1249, 1251,    0, 1254, 1240,    0,
-     1254,    0, 1236, 1257, 1243, 1233, 1253, 1259, 1218, 1237,
-     1249, 1264,    0, 1267,    0, 1258, 1252, 1243, 1270, 1278,
-     1278,    0, 1281, 1281, 1270,    0, 1271,    0, 1288,    0,
-     1274, 1274,    0, 1289,    0, 1271, 1278, 1299, 1274, 1276,
-
-     1295, 1290, 1280, 1287, 1301, 1298, 1308,    0,    0, 1302,
-     1268, 1287, 1299, 1305,    0,    0,    0, 1301, 1273, 1278,
-        0,    0,    0, 1275, 1330, 1331, 1328,    0, 1329, 1315,
-     1334, 1326, 1335,    0, 1312, 1329,    0, 1314, 1325, 1335,
-     1336,    0, 1324, 1355,    0, 1327, 1359, 1358, 1344, 1333,
-     1357, 1335,    0,    0, 1353,    0, 1332, 1330, 1365,    0,
-     1366, 1352, 1366,    0, 1343,    0, 1357, 1358, 1346,    0,
-     1353, 1354, 1378,    0, 1374, 1356, 1357, 1397,    0, 1399,
-     1385, 1403, 1392, 1401,    0, 1378, 1400,    0, 1385, 1396,
-     1400, 1401,    0, 1389, 1420,    0, 1391, 1422, 1420, 1406,
-
-     1396, 1420, 1398,    0,    0, 1416,    0, 1395, 1393, 1428,
-     1430, 1430, 1400, 1402, 1402,    0, 1435,    0, 1420, 1439,
-     1429, 1437, 1432, 1443, 1429,    0, 1443, 1431, 1432, 1436,
-     1444, 1441, 1445,    0, 1436, 1451, 1475,    0,    0, 1421,
-        0, 1454,    0, 1446, 1454,    0, 1456, 1444, 1455, 1445,
-     1460,    0,    0, 1430,    0, 1468,    0, 1462, 1483, 1473,
-     1481, 1475, 1492, 1478,    0, 1492, 1480, 1481, 1485, 1493,
-     1490, 1494,    0, 1485, 1500, 1505,    0,    0, 1471,    0,
-        0,    0,    0,    0,    0,    0, 1493, 1499, 1505, 1502,
-     1499, 1498, 1510, 1510, 1502, 1515, 1502, 1512, 1513, 1505,
-
-     1506, 1526, 1516, 1515, 1529, 1499,    0, 1527, 1524, 1528,
-     1520, 1527, 1517, 1537, 1507,    0, 1525, 1531, 1537, 1535,
-     1532, 1531, 1547, 1550, 1552, 1559, 1546, 1556, 1557, 1550,
-     1549, 1575, 1565, 1564, 1578, 1548, 1563, 1577, 1569, 1572,
-     1570, 1573,    0, 1568,    0,    0, 1580, 1576, 1586, 1590,
-        0, 1591, 1589, 1585, 1586, 1583, 1562, 1584, 1587, 1581,
-        0,    0, 1597, 1601, 1599, 1570, 1588, 1602, 1594, 1597,
-     1595, 1598,    0, 1593,    0,    0, 1605, 1601, 1611, 1615,
-        0, 1616, 1614, 1610, 1611, 1608, 1587, 1604, 1621, 1605,
-     1621, 1618, 1623,    0,    0, 1641, 1640, 1626, 1628, 1642,
-
-     1641, 1629, 1650, 1620, 1637, 1653,    0, 1655, 1642, 1656,
-     1626, 1644, 1661, 1645, 1661, 1653, 1655,    0,    0, 1668,
-     1666, 1652, 1654, 1668, 1667, 1655, 1671, 1641,    0, 1658,
-     1648,    0, 1649, 1666, 1662, 1678,    0, 1665, 1668, 1673,
-     1657,    0, 1642, 1659,    0, 1686, 1672, 1675, 1647,    0,
-     1675, 1665,    0, 1666, 1683, 1679, 1695,    0, 1681, 1684,
-     1689, 1673,    0, 1658, 1675, 1709, 1710, 1698,    0, 1699,
-        0, 1696, 1703, 1701, 1670, 1718, 1706,    0, 1702, 1674,
-     1693, 1724, 1725, 1714,    0, 1716,    0, 1712, 1719, 1717,
-     1686, 1716, 1725, 1724, 1734, 1728, 1710,    0,    0, 1738,
-
-     1726,    0, 1733, 1732, 1742,    0,    0,    0, 1729, 1737,
-     1736, 1746, 1740, 1722,    0,    0, 1749, 1737,    0, 1731,
-     1748, 1754, 1747, 1748, 1760, 1748, 1754, 1755, 1761, 1754,
-     1742, 1759, 1765, 1758, 1759, 1771, 1759, 1765, 1762, 1769,
-        0, 1759, 1763, 1767, 1760, 1766, 1775,    0, 1765, 1771,
-     1778,    0, 1768, 1772, 1776, 1769, 1775, 1789, 1778, 1778,
-     1791, 1783,    0, 1778, 1783, 1783, 1797, 1786, 1786, 1799,
-     1791,    0, 1786, 1790,    0, 1775, 1806, 1793, 1800,    0,
-     1779, 1796,    0, 1781, 1812, 1799, 1806, 1804, 1812, 1798,
-     1816, 1800, 1816, 1810, 1818, 1804, 1822, 1806, 1808, 1814,
-
-     1820, 1829, 1806, 1818, 1814, 1820, 1826, 1835, 1812,    0,
-     1834, 1824, 1820,    0, 1837,    0, 1838, 1828, 1824,    0,
-        0, 1831, 1837,    0,    0, 1833, 1839,    0, 1834,    0,
-     1835, 1837, 1838,    0,    0, 2562, 1877, 1887, 1897, 1907,
-     1917, 1925, 1935, 1942, 1949, 1956, 1966, 1973, 1983, 1993,
-     2003, 2006, 2014, 2021, 1938, 2028, 2038, 2048, 2058, 2068
-    } ;
-
-static yyconst short int yy_def[1661] =
-    {   0,
-     1637, 1637, 1636,    3, 1636,    5, 1636,    7, 1638, 1638,
-     1636,   11, 1639, 1639, 1640, 1640, 1641, 1641, 1636, 1636,
-     1636, 1636, 1636, 1642, 1643, 1642, 1636, 1636, 1636, 1636,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1636,
-     1636, 1642, 1636, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1636, 1636, 1636, 1642, 1636, 1636, 1636, 1643, 1644, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1644, 1644, 1636,
-       90, 1636, 1636, 1636, 1636, 1636, 1636, 1644,   98,   98,
-
-       98,   98,   98, 1644, 1644, 1644, 1644, 1644, 1644, 1644,
-     1644, 1644, 1636, 1636,   98, 1644, 1636, 1636, 1636, 1644,
-     1645, 1636, 1645, 1645, 1636, 1636, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1646, 1636, 1636, 1646, 1636, 1636, 1636, 1647, 1648,
-     1649, 1636, 1636, 1636, 1648, 1648,   90,   90, 1636, 1650,
-     1636, 1636, 1648,  173,  173,  173,  173,  173, 1648, 1648,
-     1648, 1648, 1648, 1648, 1636, 1636,  173,  173,  173,  173,
-      173, 1648, 1648, 1648, 1648, 1648, 1648, 1648, 1636, 1636,
-
-     1651, 1636, 1636, 1652, 1636, 1636, 1636, 1653, 1653, 1653,
-     1653, 1636, 1636, 1636, 1642, 1642, 1643, 1636,   26, 1636,
-     1636, 1642, 1642, 1642, 1642, 1642, 1642, 1642,   26, 1636,
-     1636, 1642, 1636, 1636, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1636, 1636,
-     1636, 1644, 1644, 1636, 1636, 1636, 1654, 1636, 1636,   90,
-
-       90,  301, 1636, 1636, 1655, 1636,   98,   98,   98, 1644,
-     1644, 1644, 1644,   98, 1644, 1644, 1644,   98,   98, 1644,
-     1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644,
-     1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644,   98, 1644,
-     1645, 1645, 1656, 1645, 1636, 1655, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-
-     1645, 1646, 1646, 1647, 1636, 1648, 1648, 1649, 1649, 1650,
-      173,  173,  173, 1648, 1648,  173,  173, 1648, 1648, 1648,
-     1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648,  173,
-     1648,  173,  173, 1648, 1648, 1648, 1648, 1648, 1648, 1648,
-     1648, 1648, 1648, 1648, 1648, 1636, 1651, 1652, 1653, 1636,
-     1653, 1653, 1653, 1636, 1636, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1644, 1654, 1655, 1644,   98, 1644, 1644, 1644, 1644, 1644,
-     1644, 1644, 1644,   98, 1644, 1644, 1644, 1644, 1644, 1644,
-     1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644,
-     1644, 1644, 1644, 1644, 1644, 1644, 1644, 1645, 1656, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1646, 1648, 1648, 1648,
-     1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648,
-     1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648,
-     1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648,
-     1653, 1653, 1653, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1644, 1644, 1644, 1644, 1644, 1644,
-     1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644,
-     1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644,
-     1644, 1644, 1644, 1644, 1644, 1644, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1648, 1648, 1648,
-     1648, 1648, 1648, 1648, 1648, 1657, 1648, 1648, 1648, 1648,
-     1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648,
-     1648, 1658, 1648, 1648, 1648, 1648, 1648, 1648, 1648, 1653,
-     1653, 1653, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-
-     1642, 1642, 1642, 1644, 1644, 1644, 1644, 1644, 1644, 1644,
-     1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644,
-     1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1648, 1648, 1648, 1648, 1648, 1659, 1657, 1648, 1648, 1648,
-     1648, 1648, 1648, 1648, 1648, 1648, 1660, 1658, 1648, 1648,
-
-     1648, 1648, 1653, 1653, 1653, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1644, 1644, 1644,
-     1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644,
-     1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1648, 1648, 1648, 1648, 1648, 1648, 1648, 1648,
-     1648, 1648, 1648, 1648, 1653, 1653, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1644, 1644,
-     1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644,
-     1644, 1644, 1644, 1644, 1644, 1644, 1644, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1648,
-     1648, 1648, 1648, 1648, 1648, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644, 1644,
-     1644, 1644, 1644, 1644, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1648,
-     1648, 1648, 1648, 1648, 1648, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-
-     1642, 1642, 1642, 1642, 1642, 1642, 1644, 1644, 1644, 1644,
-     1644, 1644, 1644, 1644, 1644, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1644, 1644, 1644,
-     1644, 1644, 1644, 1644, 1644, 1644, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-
-     1642, 1642, 1642, 1642, 1644, 1644, 1644, 1644, 1644, 1644,
-     1644, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1644, 1644, 1644, 1644, 1644, 1644, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1645, 1642, 1642, 1642, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1644, 1644, 1644, 1644, 1644,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645,
-     1645, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642, 1642,
-
-     1642, 1642, 1644, 1644, 1644, 1644, 1644, 1644, 1645, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1642, 1644, 1644, 1644,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1642, 1644, 1644, 1644, 1645,
-     1645, 1645, 1645, 1645, 1645, 1645, 1645, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1644, 1644, 1645, 1645, 1645, 1645,
-     1645, 1645, 1645, 1642, 1642, 1642, 1642, 1642, 1642, 1644,
-     1644, 1645, 1645, 1645, 1645, 1645, 1645, 1642, 1642, 1642,
-     1642, 1642, 1644, 1645, 1645, 1645, 1645, 1645, 1642, 1642,
-
-     1642, 1642, 1642, 1644, 1645, 1645, 1645, 1645, 1645, 1642,
-     1642, 1642, 1642, 1642, 1644, 1645, 1645, 1645, 1645, 1645,
-     1642, 1642, 1642, 1644, 1645, 1645, 1645, 1642, 1642, 1645,
-     1645, 1642, 1645, 1642, 1645,    0, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636
-    } ;
-
-static yyconst short int yy_nxt[2644] =
-    {   0,
-       21,   22,   23,   24,   25,   21,   26,   27,   28,   29,
-       30,   31,   32,   33,   34,   35,   36,   37,   38,   39,
-       40,   41,   42,   43,   44,   45,   46,   47,   48,   49,
-       50,   51,   52,   53,   35,   54,   55,   56,   57,   58,
-       59,   60,   61,   62,   63,   35,   64,   35,   35,   35,
-       35,   65,   35,   66,   35,   35,   67,   35,   35,   35,
-       35,   35,   35,   35,   35,   35,   68,   35,   35,   69,
-       35,   35,   70,   35,   35,   35,   35,   71,   72,   73,
-       74,   75,   76,   23,   77,   78,   75,   79,   80,   81,
-       82,   83,   84,   85,   86,   87,   88,   89,   90,   91,
-
-       92,   93,   94,   95,   96,   97,   98,   99,  100,  101,
-      102,  103,  104,   88,  105,   88,  106,  107,  108,  109,
-      110,  111,   88,   88,  112,   88,   88,   88,   88,   88,
-       88,   88,  113,   88,  114,   75,   88,  115,  103,  103,
-      103,  103,  103,   88,   88,   88,   88,   88,   88,   88,
-       88,   88,   88,  116,   88,   88,   88,   88,  117,  118,
-      119,  120,   75,   76,   23,   77,   78,   75,  121,   80,
-       81,   82,   83,   84,   85,   86,  122,  123,  124,  125,
-      126,   92,   93,   94,   95,   96,   97,  127,  128,  129,
-      130,  131,  132,  133,  134,  135,  123,  136,  137,  138,
-
-      139,  140,  141,  142,  143,  144,  145,  123,  146,  123,
-      123,  123,  123,  113,  123,  114,   75,  123,  147,  123,
-      123,  123,  123,  123,  123,  123,  123,  123,  148,  123,
-      123,  149,  123,  123,  150,  123,  123,  123,  123,  117,
-      118,  119,  151,   75,   75,   20,   75,   75,   75,  152,
-       75,   75,   75,   75,   75,  153,   75,  154,  225,  964,
-      125,  126,   75,   75,   75,  156,   75,   75,  220,  226,
-      230,  231,  199,  200,  199,  200,  201,  450,  201,  233,
-      234,  235,  221,  236,  247,  237,  241,  202,  248,  202,
-      242,  238,  245,  243,   75,  246,   75,   75,  239,  240,
-
-      250,  252,  249,  264,  253,  298,  244,  254,  259,  260,
-      251,  262,  289,  265,  852,  263,  299,  289,  296,  261,
-       75,   75,   75,   75,   75,   20,   75,   75,   75,  152,
-       75,   75,   75,   75,   75,  153,   75,  154,  227,  227,
-      125,  126,   75,   75,   75,  156,   75,   75,  203,  270,
-      203,  220,  357,  266,  303,  358,  228,  267,  228,  271,
-      268,  269,  297,  230,  231,  221,  233,  234,  290,  229,
-      325,  965,  422,  290,   75,  329,   75,   75,  423,  274,
-      326,  303,  275,  276,  327,  330,  228,  298,  228,  277,
-      278,  279,  328,  966,  280,  281,  229,  967,  344,  282,
-
-       75,   75,   75,   21,   22,  157,  158,   21,  159,  160,
-       27,   28,   29,   30,  161,  162,  163,  164,  165,  166,
-      167,  168,  169,  170,   41,  171,   43,  172,  173,  174,
-      175,  176,  177,  178,  165,  165,  165,  165,  165,  179,
-      165,  180,  181,  182,  165,  165,  183,  184,  165,  165,
-      165,  165,  165,  165,  185,  165,  186,   21,  165,  187,
-      188,  189,  176,  190,  191,  165,  165,  165,  165,  192,
-      165,  193,  194,  195,  165,  196,  197,  165,  165,  165,
-       71,   72,   73,  198,   21,  199,  200,   21,   21,  201,
-      968,   21,   21,   21,   21,   21,   21,  205,   21,  296,
-
-      202,   21,   21,  205,  205,   21,   21,   21,   21,  227,
-      227,  969,  303,  314,  331,  314,  362,  335,  332,  438,
-      315,  336,  333,  316,  439,  303,  363,  228,  337,  228,
-      292,  292,  314,  338,  314,   21,   21,   21,   21,  303,
-      353,  970,  292,  343,  354,  317,  377,  355,  364,  292,
-      292,  365,  303,  450,  366,  450,  378,  228,  443,  228,
-      356,  206,   21,  207,   21,   21,  199,  200,   21,   21,
-      201,  444,   21,   21,   21,   21,   21,   21,  205,   21,
-      427,  202,   21,   21,  205,  205,   21,   21,   21,   21,
-      318,  314,  359,  314,  319,  428,  360,  314,  374,  314,
-
-      452,  292,  375,  314,  594,  314,  376,  292,  320,  292,
-      361,  451,  595,  292,  292,  292,   21,   21,   21,   21,
-      292,  292,  347,  460,  348,  321,  349,  371,  372,  379,
-      971,  383,  350,  380,  450,  461,  381,  382,  373,  351,
-      352,  384,  206,   21,  207,   21,   21,  199,  200,  450,
-       25,  201,  972,   21,   21,   21,   21,  973,   21,  205,
-      416,  413,  202,   21,   21,  205,  205,   21,   21,   21,
-      314,  406,  314,  413,  387,  850,  974,  388,  389,  466,
-      292,  467,  488,  406,  390,  391,  392,  292,  292,  393,
-      394,  417,  413,  413,  395,  489,  473,  413,  418,  453,
-
-      546,  339,  406,  406,  413,  419,  209,  406,  210,  547,
-      421,  413,  211,  474,  406,  420,  504,  531,  505,  532,
-      413,  406,  506,  212,   21,  213,   21,   21,  199,  200,
-      406,   25,  201,  975,   21,   21,   21,   21,  538,   21,
-      205,  539,  430,  202,   21,   21,  205,  205,   21,   21,
-       21,  431,  345,  345,  493,  527,  413,  494,  413,  570,
-      577,  571,  435,  495,  345,  345,  406,  528,  406,  436,
-      304,  228,  304,  228,  227,  227,  450,  578,  976,  564,
-      413,  450,  304,  346,  304,  592,  432,  209,  433,  210,
-      406,  565,  228,  211,  228,  434,  977,  978,  593,  979,
-
-      304,  228,  304,  228,  212,   21,  213,   21,  219,  219,
-      346,  980,  304,  981,  304,  663,  219,  219,  219,  219,
-      219,  219,  228,  437,  228,  480,  301,  301,  481,  584,
-      482,  610,  585,  611,  586,  661,  982,  612,  483,  983,
-      984,  484,  587,  985, 1636,  588, 1636,  219,  219,  219,
-      219,  219,  219,  293,  293,  450,  988,  303,  989,  413,
-      990,  293,  293,  293,  293,  293,  293,  991,  314,  406,
-      314,  314,  992,  314, 1636,  993, 1636,  413,  292,  994,
-      413,  292,  995,  996,  303,  292,  292,  406,  524,  292,
-      406,  999,  293,  293,  293,  293,  293,  293,  300,  300,
-
-     1000,  345,  345, 1001, 1002,  662,  301,  302,  301,  302,
-      301,  301,  450,  303,  413,  314,  304,  525,  304,  304,
-      303,  304,  819,  645,  406,  292,  647,  599,  820,  305,
-      600,  629,  292,  292,  450, 1006,  601,  301,  302,  301,
-      302,  301,  301,  314,  303,  314,  304, 1007,  304,  304,
-      303,  304,  450,  292,  413, 1008,  305,  307,  307, 1005,
-      292,  292, 1009,  413,  406,  307,  308,  307,  309,  307,
-      307,  631,  310,  406,  450,  314,  311,  314, 1010,  310,
-      632,  835, 1013,  312,  313,  292, 1003,  836,  310, 1014,
-      851, 1011,  292,  533, 1015,  413,  307,  314,  307,  314,
-
-      307,  307,  314,  310,  314,  406,  534, 1016, 1012,  310,
-     1017, 1004,  292, 1018, 1019,  310,  342,  342, 1020,  292,
-      292,  314, 1021,  314,  342,  342,  342,  342,  342,  342,
-      314,  292,  314,  304, 1022,  304, 1023, 1024,  292,  292,
-      292,  648, 1025, 1026, 1027, 1028,  726,  292,  292, 1029,
-     1030, 1031, 1032, 1033, 1034,  342,  342,  342,  342,  342,
-      342,  403,  403,  304, 1035,  304, 1036,  556, 1037,  403,
-      403,  403,  403,  403,  403,  314, 1038,  314, 1039, 1040,
-     1041, 1042,  735, 1043, 1044,  292, 1045, 1046, 1047, 1048,
-     1049, 1050,  292,  292, 1051, 1052, 1053, 1054, 1055, 1056,
-
-      403,  403,  403,  403,  403,  403,  407,  407, 1057, 1058,
-     1059, 1060, 1061, 1062,  407,  407,  407,  407,  407,  407,
-     1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072,
-     1073, 1074, 1075, 1078, 1079, 1080, 1076, 1081, 1082, 1083,
-     1084, 1085, 1086, 1087, 1088,  407,  407,  407,  407,  407,
-      407,  411,  411, 1077, 1089, 1090, 1091, 1092, 1093,  411,
-      412,  411,  413,  411,  411, 1094,  414, 1095, 1096, 1097,
-      415, 1098, 1099,  414, 1100, 1101, 1102, 1103, 1104, 1105,
-     1106, 1107,  414, 1108, 1109, 1110, 1111, 1112, 1113, 1114,
-      411,  413,  411,  413,  411,  411, 1115,  414, 1116, 1117,
-
-     1118, 1119, 1120,  414, 1121, 1122, 1123, 1124,  450,  414,
-      293,  293,  450,  450, 1127, 1128, 1129, 1130,  293,  293,
-      293,  293,  293,  293, 1131, 1132, 1133, 1134,  521, 1135,
-      521, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144,
-     1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153,  293,
-      293,  293,  293,  293,  293, 1154, 1155, 1125,  521, 1126,
-      521,  342,  342, 1156, 1157, 1158, 1159, 1160, 1161,  342,
-      342,  342,  342,  342,  342, 1162, 1163, 1164, 1165,  558,
-     1166,  558, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174,
-     1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184,
-
-      342,  342,  342,  342,  342,  342, 1185, 1186, 1187,  558,
-     1188,  558,  403,  403, 1189, 1190, 1191, 1192, 1193, 1194,
-      403,  403,  403,  403,  403,  403, 1195, 1196, 1197, 1198,
-      627, 1199,  627, 1200, 1201, 1202, 1203, 1204, 1205, 1206,
-     1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215,  450,
-      450,  403,  403,  403,  403,  403,  403, 1216, 1217, 1218,
-      627, 1219,  627,  407,  407, 1220, 1221, 1222, 1223, 1224,
-     1225,  407,  407,  407,  407,  407,  407, 1226, 1227, 1228,
-     1229,  628, 1231,  628, 1232, 1230, 1233, 1234, 1235, 1236,
-     1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246,
-
-     1247, 1248,  407,  407,  407,  407,  407,  407, 1249, 1250,
-     1251,  628, 1252,  628,  986,  986, 1253,  986,  986,  986,
-     1254,  986,  986,  986,  986,  986, 1255,  986, 1256, 1257,
-     1258, 1259, 1260, 1261,  986,  986,  986,  986,  986, 1262,
-     1263, 1264, 1265, 1266, 1267, 1268, 1270, 1271, 1272, 1273,
-     1269, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282,
-     1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290,  986, 1291,
-     1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301,
-     1302, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314,
-     1315,  986,  986,  986,  997,  997, 1316,  997,  997,  997,
-
-     1303,  997,  997,  997,  997,  997, 1317,  997, 1304, 1318,
-     1319, 1320, 1321, 1305,  997,  997,  997,  997,  997, 1322,
-     1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332,
-     1333, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1334, 1343,
-     1344, 1345, 1347, 1335, 1348, 1349, 1350, 1351,  997, 1346,
-     1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361,
-     1363, 1364, 1365, 1366, 1367, 1368, 1369, 1362, 1370, 1371,
-     1372,  997,  997,  997,  986,  986, 1373,  986,  986,  986,
-     1374,  986,  986,  986,  986,  986, 1377,  986, 1378, 1379,
-     1380, 1375, 1381, 1382,  986,  986,  986,  986,  986, 1376,
-
-     1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392,
-     1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402,
-     1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410,  986, 1411,
-     1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421,
-     1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431,
-     1432,  986,  986,  986,  997,  997, 1433,  997,  997,  997,
-     1434,  997,  997,  997,  997,  997, 1435,  997, 1436, 1437,
-     1438, 1439, 1440, 1441,  997,  997,  997,  997,  997, 1442,
-     1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452,
-     1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462,
-
-     1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470,  997, 1471,
-     1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481,
-     1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491,
-     1492,  997,  997,  997, 1493, 1496, 1497, 1498, 1494, 1499,
-     1500, 1501, 1502, 1503, 1506, 1507, 1508, 1504, 1509, 1510,
-     1513, 1495, 1514, 1511, 1515, 1516, 1517, 1518, 1519, 1520,
-     1505, 1521, 1522, 1523, 1524, 1525, 1512, 1526, 1527, 1528,
-     1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538,
-     1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548,
-     1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558,
-
-     1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568,
-     1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578,
-     1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588,
-     1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598,
-     1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608,
-     1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618,
-     1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628,
-     1629, 1630, 1631, 1632, 1633, 1634, 1635,   20,   20,   20,
-       20,   20,   20,   20,   20,   20,   20,  155,  155,  155,
-      155,  155,  155,  155,  155,  155,  155,   21,   21,   21,
-
-       21,   21,   21,   21,   21,   21,   21,  204,  204,  204,
-      204,  204,  204,  204,  204,  204,  204,  208,  208,  208,
-      208,  208,  208,  208,  208,  208,  208,  215,  215,  215,
-      215,  215,  215,  215,  215,  217,  217,  217,  217,  217,
-      217,  217,  217,  217,  217,  292,  292,  523,  292,  292,
-      292,  292,  341,  341,  341,  341,  341,  341,  341,  402,
-      963,  962,  961,  402,  402,  402,  404,  404,  404,  404,
-      404,  404,  404,  404,  404,  404,  406,  406,  960,  406,
-      406,  406,  406,  408,  959,  408,  408,  408,  408,  408,
-      408,  408,  408,  410,  958,  410,  410,  410,  410,  410,
-
-      410,  410,  410,  447,  957,  447,  447,  447,  447,  447,
-      447,  447,  447,  448,  956,  448,  449,  449,  955,  954,
-      449,  449,  953,  449,  522,  522,  952,  522,  522,  522,
-      522,  559,  559,  559,  559,  559,  559,  559,  987,  951,
-      987,  987,  987,  987,  987,  987,  987,  987,  998,  950,
-      998,  998,  998,  998,  998,  998,  998,  998,  986,  949,
-      986,  986,  986,  986,  986,  986,  986,  986,  997,  948,
-      997,  997,  997,  997,  997,  997,  997,  997,  947,  946,
-      945,  944,  943,  942,  941,  940,  939,  938,  937,  936,
-      935,  934,  933,  932,  931,  930,  929,  928,  927,  926,
-
-      925,  924,  923,  922,  921,  920,  919,  918,  917,  916,
-      915,  914,  913,  912,  911,  910,  909,  908,  907,  906,
-      905,  904,  903,  902,  901,  900,  899,  898,  897,  896,
-      895,  894,  893,  892,  891,  890,  889,  888,  887,  886,
-      885,  884,  883,  882,  881,  880,  879,  878,  877,  876,
-      875,  874,  873,  872,  871,  870,  869,  868,  867,  866,
-      865,  864,  863,  862,  861,  860,  859,  858,  857,  856,
-      855,  854,  853,  849,  848,  847,  846,  845,  844,  843,
-      842,  841,  840,  839,  838,  837,  834,  833,  832,  831,
-      830,  829,  828,  827,  826,  825,  824,  823,  822,  821,
-
-      818,  817,  816,  815,  814,  813,  812,  811,  810,  809,
-      808,  807,  806,  805,  804,  803,  802,  801,  800,  799,
-      798,  797,  796,  795,  794,  793,  792,  791,  790,  789,
-      788,  787,  786,  785,  784,  783,  782,  781,  780,  779,
-      778,  777,  776,  775,  774,  773,  772,  771,  770,  769,
-      768,  767,  766,  765,  764,  763,  762,  761,  760,  759,
-      758,  757,  756,  755,  754,  753,  752,  751,  750,  749,
-      748,  747,  746,  745,  744,  743,  742,  741,  740,  739,
-      738,  737,  736,  734,  733,  732,  731,  730,  729,  728,
-      727,  725,  724,  723,  722,  721,  720,  719,  718,  717,
-
-      716,  715,  714,  713,  712,  711,  710,  709,  708,  707,
-      706,  705,  704,  703,  702,  701,  700,  699,  698,  697,
-      696,  695,  694,  693,  692,  691,  690,  689,  688,  687,
-      686,  685,  684,  683,  682,  681,  680,  679,  678,  677,
-      676,  675,  674,  673,  672,  671,  670,  669,  668,  667,
-      666,  665,  664,  449,  450,  446,  660,  659,  658,  657,
-      656,  655,  654,  653,  652,  651,  650,  649,  646,  644,
-      643,  642,  641,  640,  639,  638,  637,  636,  635,  634,
-      633,  630,  405,  626,  625,  624,  623,  622,  621,  620,
-      619,  618,  617,  616,  615,  614,  613,  609,  608,  607,
-
-      606,  605,  604,  603,  602,  598,  597,  596,  591,  590,
-      589,  583,  582,  581,  580,  579,  576,  575,  574,  573,
-      572,  569,  568,  567,  566,  563,  562,  561,  560,  557,
-      555,  554,  553,  552,  551,  550,  549,  548,  545,  544,
-      543,  542,  541,  540,  537,  536,  535,  530,  529,  526,
-      520,  519,  518,  517,  516,  515,  514,  513,  512,  511,
-      510,  509,  508,  507,  503,  502,  501,  500,  499,  498,
-      497,  496,  492,  491,  490,  487,  486,  485,  479,  478,
-      477,  476,  475,  472,  471,  470,  469,  468,  465,  464,
-      463,  462,  459,  458,  457,  456,  455,  454,  218,  214,
-
-      450,  298,  446,  445,  442,  441,  440,  429,  426,  425,
-      424,  306,  299,  296,  295,  409,  405,  291,  401,  400,
-      399,  398,  397,  396,  386,  385,  370,  369,  368,  367,
-      340,  334,  324,  323,  322,  306,  295,  294,  218,  291,
-      214,  288,  287,  286,  285,  284,  283,  273,  272,  258,
-      257,  256,  255,  232,  224,  223,  222,  218,  216,  214,
-     1636,   19, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636
-    } ;
-
-static yyconst short int yy_chk[2644] =
-    {   0,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-
-        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    7,    7,    7,    7,    7,    7,    7,    7,
-        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
-        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
-        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
-
-        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
-        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
-        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
-        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
-        7,    7,    7,    9,    9,    9,    9,    9,    9,    9,
-        9,    9,    9,    9,    9,    9,    9,    9,   36,  800,
-        9,    9,    9,    9,    9,    9,    9,    9,   28,   36,
-       41,   41,   13,   13,   14,   14,   13,  663,   14,   43,
-       43,   45,   28,   45,   48,   45,   46,   13,   48,   14,
-       46,   45,   47,   46,    9,   47,    9,    9,   45,   45,
-
-       49,   50,   48,   57,   50,   89,   46,   50,   55,   55,
-       49,   56,   72,   57,  663,   56,   89,  118,   87,   55,
-        9,    9,    9,   10,   10,   10,   10,   10,   10,   10,
-       10,   10,   10,   10,   10,   10,   10,   10,   37,   37,
-       10,   10,   10,   10,   10,   10,   10,   10,   13,   59,
-       14,   81,  129,   58,   91,  129,   37,   58,   37,   59,
-       58,   58,   87,   94,   94,   81,   96,   96,   72,   37,
-      107,  802,  179,  118,   10,  109,   10,   10,  179,   62,
-      107,   91,   62,   62,  108,  109,   37,  124,   37,   62,
-       62,   62,  108,  803,   62,   62,   37,  804,  124,   62,
-
-       10,   10,   10,   11,   11,   11,   11,   11,   11,   11,
-       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
-       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
-       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
-       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
-       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
-       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
-       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
-       11,   11,   11,   11,   15,   15,   15,   15,   15,   15,
-      805,   15,   15,   15,   15,   15,   15,   15,   15,  122,
-
-       15,   15,   15,   15,   15,   15,   15,   15,   15,   38,
-       38,  806,  168,   99,  110,   99,  131,  112,  110,  192,
-       99,  112,  110,   99,  192,  300,  131,   38,  112,   38,
-       99,   99,  100,  112,  100,   15,   15,   15,   15,  168,
-      128,  807,  100,  122,  128,  100,  139,  128,  132,  100,
-      100,  132,  300,  210,  132,  209,  139,   38,  196,   38,
-      128,   15,   15,   15,   15,   16,   16,   16,   16,   16,
-       16,  196,   16,   16,   16,   16,   16,   16,   16,   16,
-      183,   16,   16,   16,   16,   16,   16,   16,   16,   16,
-      101,  101,  130,  101,  101,  183,  130,  103,  138,  103,
-
-      210,  101,  138,  102,  374,  102,  138,  103,  101,  101,
-      130,  209,  374,  102,  103,  103,   16,   16,   16,   16,
-      102,  102,  127,  239,  127,  102,  127,  137,  137,  140,
-      808,  141,  127,  140,  661,  239,  140,  140,  137,  127,
-      127,  141,   16,   16,   16,   16,   17,   17,   17,  211,
-       17,   17,  809,   17,   17,   17,   17,  810,   17,   17,
-      174,  174,   17,   17,   17,   17,   17,   17,   17,   17,
-      115,  174,  115,  176,  144,  661,  811,  144,  144,  245,
-      115,  245,  261,  176,  144,  144,  144,  115,  115,  144,
-      144,  175,  175,  177,  144,  261,  251,  178,  175,  211,
-
-      330,  115,  175,  177,  411,  177,   17,  178,   17,  330,
-      178,  187,   17,  251,  411,  177,  274,  317,  274,  317,
-      190,  187,  274,   17,   17,   17,   17,   18,   18,   18,
-      190,   18,   18,  812,   18,   18,   18,   18,  323,   18,
-       18,  323,  187,   18,   18,   18,   18,   18,   18,   18,
-       18,  187,  125,  125,  265,  312,  188,  265,  189,  357,
-      363,  357,  190,  265,  126,  126,  188,  312,  189,  190,
-      125,  219,  125,  219,  227,  227,  453,  363,  813,  351,
-      191,  451,  126,  125,  126,  373,  188,   18,  189,   18,
-      191,  351,  227,   18,  227,  189,  814,  815,  373,  816,
-
-      125,  219,  125,  219,   18,   18,   18,   18,   26,   26,
-      125,  817,  126,  818,  126,  453,   26,   26,   26,   26,
-       26,   26,  227,  191,  227,  257,  301,  301,  257,  369,
-      257,  387,  369,  387,  369,  451,  819,  387,  257,  820,
-      824,  257,  369,  825,  301,  369,  301,   26,   26,   26,
-       26,   26,   26,   79,   79,  452,  829,  301,  830,  413,
-      832,   79,   79,   79,   79,   79,   79,  833,  307,  413,
-      307,  308,  834,  308,  301,  835,  301,  430,  307,  836,
-      432,  308,  840,  841,  301,  307,  307,  430,  308,  308,
-      432,  845,   79,   79,   79,   79,   79,   79,   90,   90,
-
-      846,  345,  345,  848,  849,  452,   90,   90,   90,   90,
-       90,   90,  852,   90,  412,  309,   90,  309,   90,  345,
-       90,  345,  630,  430,  412,  309,  432,  378,  630,   90,
-      378,  412,  309,  309,  850,  853,  378,   90,   90,   90,
-       90,   90,   90,  314,   90,  314,   90,  855,   90,  345,
-       90,  345,  662,  314,  416,  856,   90,   98,   98,  852,
-      314,  314,  857,  417,  416,   98,   98,   98,   98,   98,
-       98,  416,   98,  417,  851,  318,   98,  318,  858,   98,
-      417,  646,  861,   98,   98,  318,  850,  646,   98,  862,
-      662,  860,  318,  318,  863,  433,   98,   98,   98,   98,
-
-       98,   98,  319,   98,  319,  433,  319,  866,  860,   98,
-      867,  851,  319,  869,  871,   98,  121,  121,  872,  319,
-      319,  339,  874,  339,  121,  121,  121,  121,  121,  121,
-      525,  339,  525,  523,  875,  523,  876,  877,  339,  339,
-      525,  433,  878,  879,  880,  881,  525,  525,  525,  882,
-      883,  884,  885,  887,  888,  121,  121,  121,  121,  121,
-      121,  152,  152,  523,  889,  523,  890,  339,  891,  152,
-      152,  152,  152,  152,  152,  534,  893,  534,  894,  895,
-      897,  898,  534,  899,  900,  534,  901,  902,  903,  904,
-      905,  906,  534,  534,  907,  909,  910,  911,  913,  915,
-
-      152,  152,  152,  152,  152,  152,  160,  160,  916,  917,
-      918,  919,  920,  921,  160,  160,  160,  160,  160,  160,
-      922,  923,  924,  925,  926,  927,  928,  929,  930,  932,
-      933,  934,  935,  938,  939,  940,  937,  943,  944,  946,
-      948,  949,  951,  952,  953,  160,  160,  160,  160,  160,
-      160,  173,  173,  937,  954,  955,  956,  957,  958,  173,
-      173,  173,  173,  173,  173,  959,  173,  960,  961,  962,
-      173,  964,  965,  173,  966,  967,  968,  970,  971,  972,
-      974,  975,  173,  976,  977,  978,  979,  980,  981,  983,
-      173,  173,  173,  173,  173,  173,  984,  173,  985,  989,
-
-      991,  992,  994,  173,  995,  996, 1000, 1002, 1003,  173,
-      293,  293, 1004, 1005, 1006, 1007, 1009, 1011,  293,  293,
-      293,  293,  293,  293, 1012, 1013, 1014, 1015,  293, 1016,
-      293, 1018, 1019, 1020, 1022, 1024, 1026, 1027, 1029, 1031,
-     1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040,  293,
-      293,  293,  293,  293,  293, 1041, 1042, 1003,  293, 1004,
-      293,  342,  342, 1045, 1046, 1047, 1048, 1049, 1051,  342,
-      342,  342,  342,  342,  342, 1052, 1053, 1054, 1055,  342,
-     1056,  342, 1058, 1059, 1061, 1063, 1064, 1065, 1066, 1067,
-     1068, 1069, 1070, 1071, 1072, 1074, 1076, 1077, 1078, 1079,
-
-      342,  342,  342,  342,  342,  342, 1080, 1081, 1083,  342,
-     1084,  342,  403,  403, 1085, 1087, 1089, 1091, 1092, 1094,
-      403,  403,  403,  403,  403,  403, 1096, 1097, 1098, 1099,
-      403, 1100,  403, 1101, 1102, 1103, 1104, 1105, 1106, 1107,
-     1110, 1111, 1112, 1113, 1114, 1118, 1119, 1120, 1124, 1125,
-     1126,  403,  403,  403,  403,  403,  403, 1127, 1129, 1130,
-      403, 1131,  403,  407,  407, 1132, 1133, 1135, 1136, 1138,
-     1139,  407,  407,  407,  407,  407,  407, 1140, 1141, 1143,
-     1144,  407, 1146,  407, 1147, 1144, 1148, 1149, 1150, 1151,
-     1152, 1155, 1157, 1158, 1159, 1161, 1162, 1163, 1165, 1167,
-
-     1168, 1169,  407,  407,  407,  407,  407,  407, 1171, 1172,
-     1173,  407, 1175,  407,  826,  826, 1176,  826,  826,  826,
-     1177,  826,  826,  826,  826,  826, 1178,  826, 1180, 1181,
-     1182, 1183, 1184, 1186,  826,  826,  826,  826,  826, 1187,
-     1189, 1190, 1191, 1192, 1194, 1195, 1197, 1198, 1199, 1200,
-     1195, 1201, 1202, 1203, 1206, 1208, 1209, 1210, 1211, 1212,
-     1213, 1214, 1215, 1217, 1219, 1220, 1221, 1222,  826, 1223,
-     1224, 1225, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1235,
-     1236, 1240, 1242, 1244, 1245, 1247, 1248, 1249, 1250, 1251,
-     1254,  826,  826,  826,  842,  842, 1256,  842,  842,  842,
-
-     1237,  842,  842,  842,  842,  842, 1258,  842, 1237, 1259,
-     1260, 1261, 1262, 1237,  842,  842,  842,  842,  842, 1263,
-     1264, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1274, 1275,
-     1276, 1279, 1287, 1288, 1289, 1290, 1291, 1292, 1276, 1293,
-     1294, 1295, 1296, 1276, 1297, 1298, 1299, 1300,  842, 1295,
-     1301, 1302, 1303, 1304, 1305, 1306, 1308, 1309, 1310, 1311,
-     1312, 1313, 1314, 1315, 1317, 1318, 1319, 1311, 1320, 1321,
-     1322,  842,  842,  842,  987,  987, 1323,  987,  987,  987,
-     1324,  987,  987,  987,  987,  987, 1326,  987, 1327, 1328,
-     1329, 1325, 1330, 1331,  987,  987,  987,  987,  987, 1325,
-
-     1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341,
-     1342, 1344, 1347, 1348, 1349, 1350, 1352, 1353, 1354, 1355,
-     1356, 1357, 1358, 1359, 1360, 1363, 1364, 1365,  987, 1366,
-     1367, 1368, 1369, 1370, 1371, 1372, 1374, 1377, 1378, 1379,
-     1380, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390,
-     1391,  987,  987,  987,  998,  998, 1392,  998,  998,  998,
-     1393,  998,  998,  998,  998,  998, 1396,  998, 1397, 1398,
-     1399, 1400, 1401, 1402,  998,  998,  998,  998,  998, 1403,
-     1404, 1405, 1406, 1408, 1409, 1410, 1411, 1412, 1413, 1414,
-     1415, 1416, 1417, 1420, 1421, 1422, 1423, 1424, 1425, 1426,
-
-     1427, 1428, 1430, 1431, 1433, 1434, 1435, 1436,  998, 1438,
-     1439, 1440, 1441, 1443, 1444, 1446, 1447, 1448, 1449, 1451,
-     1452, 1454, 1455, 1456, 1457, 1459, 1460, 1461, 1462, 1464,
-     1465,  998,  998,  998, 1466, 1467, 1468, 1470, 1466, 1472,
-     1473, 1474, 1475, 1476, 1477, 1479, 1480, 1476, 1481, 1482,
-     1483, 1466, 1484, 1482, 1486, 1488, 1489, 1490, 1491, 1492,
-     1476, 1493, 1494, 1495, 1496, 1497, 1482, 1500, 1501, 1503,
-     1504, 1505, 1509, 1510, 1511, 1512, 1513, 1514, 1517, 1518,
-     1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529,
-     1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539,
-
-     1540, 1542, 1543, 1544, 1545, 1546, 1547, 1549, 1550, 1551,
-     1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562,
-     1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1573, 1574,
-     1576, 1577, 1578, 1579, 1581, 1582, 1584, 1585, 1586, 1587,
-     1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597,
-     1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607,
-     1608, 1609, 1611, 1612, 1613, 1615, 1617, 1618, 1619, 1622,
-     1623, 1626, 1627, 1629, 1631, 1632, 1633, 1637, 1637, 1637,
-     1637, 1637, 1637, 1637, 1637, 1637, 1637, 1638, 1638, 1638,
-     1638, 1638, 1638, 1638, 1638, 1638, 1638, 1639, 1639, 1639,
-
-     1639, 1639, 1639, 1639, 1639, 1639, 1639, 1640, 1640, 1640,
-     1640, 1640, 1640, 1640, 1640, 1640, 1640, 1641, 1641, 1641,
-     1641, 1641, 1641, 1641, 1641, 1641, 1641, 1642, 1642, 1642,
-     1642, 1642, 1642, 1642, 1642, 1643, 1643, 1643, 1643, 1643,
-     1643, 1643, 1643, 1643, 1643, 1644, 1644, 1655, 1644, 1644,
-     1644, 1644, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1646,
-      799,  798,  797, 1646, 1646, 1646, 1647, 1647, 1647, 1647,
-     1647, 1647, 1647, 1647, 1647, 1647, 1648, 1648,  796, 1648,
-     1648, 1648, 1648, 1649,  795, 1649, 1649, 1649, 1649, 1649,
-     1649, 1649, 1649, 1650,  794, 1650, 1650, 1650, 1650, 1650,
-
-     1650, 1650, 1650, 1651,  793, 1651, 1651, 1651, 1651, 1651,
-     1651, 1651, 1651, 1652,  792, 1652, 1653, 1653,  790,  788,
-     1653, 1653,  787, 1653, 1654, 1654,  786, 1654, 1654, 1654,
-     1654, 1656, 1656, 1656, 1656, 1656, 1656, 1656, 1657,  784,
-     1657, 1657, 1657, 1657, 1657, 1657, 1657, 1657, 1658,  783,
-     1658, 1658, 1658, 1658, 1658, 1658, 1658, 1658, 1659,  782,
-     1659, 1659, 1659, 1659, 1659, 1659, 1659, 1659, 1660,  780,
-     1660, 1660, 1660, 1660, 1660, 1660, 1660, 1660,  779,  778,
-      777,  775,  774,  773,  772,  771,  770,  769,  767,  765,
-      763,  762,  761,  760,  759,  757,  756,  755,  754,  753,
-
-      752,  751,  750,  749,  748,  747,  746,  745,  743,  742,
-      739,  738,  737,  736,  735,  734,  732,  731,  729,  728,
-      727,  725,  724,  723,  722,  721,  720,  719,  718,  717,
-      716,  715,  714,  713,  712,  711,  710,  709,  707,  706,
-      705,  704,  703,  702,  701,  700,  699,  697,  695,  694,
-      693,  691,  690,  689,  687,  686,  685,  684,  682,  681,
-      680,  679,  678,  677,  676,  674,  672,  670,  669,  668,
-      667,  666,  664,  660,  659,  658,  657,  656,  655,  654,
-      653,  652,  651,  649,  648,  647,  645,  644,  643,  642,
-      641,  640,  639,  638,  637,  636,  635,  633,  632,  631,
-
-      629,  626,  623,  622,  621,  620,  619,  618,  617,  616,
-      615,  614,  613,  612,  611,  610,  609,  608,  607,  606,
-      605,  604,  603,  602,  601,  600,  599,  598,  596,  593,
-      592,  591,  590,  589,  588,  587,  586,  585,  584,  582,
-      581,  580,  579,  578,  577,  576,  575,  574,  573,  572,
-      571,  570,  569,  568,  567,  566,  565,  564,  563,  562,
-      561,  560,  557,  556,  555,  554,  553,  552,  551,  550,
-      549,  548,  547,  546,  545,  542,  541,  540,  539,  538,
-      537,  536,  535,  533,  532,  531,  530,  529,  528,  527,
-      526,  524,  520,  517,  516,  515,  514,  513,  512,  511,
-
-      510,  509,  508,  507,  506,  505,  504,  503,  502,  501,
-      500,  499,  498,  497,  496,  495,  494,  493,  492,  491,
-      489,  488,  487,  486,  485,  484,  483,  482,  481,  480,
-      478,  477,  476,  475,  474,  473,  472,  471,  470,  469,
-      468,  467,  466,  465,  464,  463,  462,  461,  460,  459,
-      458,  457,  456,  450,  449,  446,  445,  444,  443,  442,
-      441,  440,  439,  438,  437,  436,  435,  434,  431,  429,
-      428,  427,  426,  425,  424,  423,  422,  421,  420,  419,
-      418,  415,  404,  401,  400,  399,  398,  397,  396,  395,
-      394,  393,  392,  391,  390,  389,  388,  386,  385,  384,
-
-      383,  382,  381,  380,  379,  377,  376,  375,  372,  371,
-      370,  368,  367,  366,  365,  364,  362,  361,  360,  359,
-      358,  356,  355,  354,  353,  350,  349,  348,  347,  340,
-      338,  337,  336,  335,  334,  333,  332,  331,  329,  328,
-      327,  326,  325,  324,  322,  321,  320,  316,  315,  311,
-      288,  287,  286,  285,  284,  283,  282,  281,  280,  279,
-      278,  277,  276,  275,  273,  272,  271,  270,  269,  268,
-      267,  266,  264,  263,  262,  260,  259,  258,  256,  255,
-      254,  253,  252,  250,  249,  248,  247,  246,  244,  243,
-      242,  241,  238,  237,  236,  235,  234,  230,  217,  214,
-
-      208,  202,  199,  197,  195,  194,  193,  184,  182,  181,
-      180,  171,  166,  164,  162,  161,  159,  158,  150,  149,
-      148,  147,  146,  145,  143,  142,  136,  135,  134,  133,
-      116,  111,  106,  105,  104,   95,   85,   84,   78,   77,
-       76,   70,   69,   68,   67,   64,   63,   61,   60,   54,
-       53,   52,   51,   42,   34,   32,   31,   25,   24,   22,
-       19, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636, 1636,
-     1636, 1636, 1636
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "ldlex.l"
-#define INITIAL 0
-#define YY_NO_UNPUT 1
-#line 4 "ldlex.l"
-
-/* Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
-   Free Software Foundation, Inc.
-   Written by Steve Chamberlain of Cygnus Support.
-
-   This file is part of the GNU Binutils.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-#include "bfd.h"
-#include "safe-ctype.h"
-#include "bfdlink.h"
-#include "ld.h"
-#include "ldmisc.h"
-#include "ldexp.h"
-#include "ldlang.h"
-#include <ldgram.h>
-#include "ldfile.h"
-#include "ldlex.h"
-#include "ldmain.h"
-#include "libiberty.h"
-
-/* The type of top-level parser input.
-   yylex and yyparse (indirectly) both check this.  */
-input_type parser_input;
-
-/* Line number in the current input file.
-   (FIXME Actually, it doesn't appear to get reset for each file?)  */
-unsigned int lineno = 1;
-
-/* The string we are currently lexing, or NULL if we are reading a
-   file.  */
-const char *lex_string = NULL;
-
-/* Support for flex reading from more than one input file (stream).
-   `include_stack' is flex's input state for each open file;
-   `file_name_stack' is the file names.  `lineno_stack' is the current
-   line numbers.
-
-   If `include_stack_ptr' is 0, we haven't started reading anything yet.
-   Otherwise, stack elements 0 through `include_stack_ptr - 1' are valid.  */
-
-#undef YY_INPUT
-#define YY_INPUT(buf,result,max_size) result = yy_input (buf, max_size)
-
-#ifndef YY_NO_UNPUT
-#define YY_NO_UNPUT
-#endif
-
-#define MAX_INCLUDE_DEPTH 10
-static YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
-static const char *file_name_stack[MAX_INCLUDE_DEPTH];
-static unsigned int lineno_stack[MAX_INCLUDE_DEPTH];
-static unsigned int include_stack_ptr = 0;
-static int vers_node_nesting = 0;
-
-static int yy_input (char *, int);
-static void comment (void);
-static void lex_warn_invalid (char *where, char *what);
-
-/* STATES
-	EXPRESSION	definitely in an expression
-	SCRIPT		definitely in a script
-	BOTH		either EXPRESSION or SCRIPT
-	DEFSYMEXP	in an argument to -defsym
-        MRI             in an MRI script
-	VERS_START	starting a Sun style mapfile
-	VERS_SCRIPT	a Sun style mapfile
-	VERS_NODE	a node within a Sun style mapfile
-*/
-#define RTOKEN(x)  {  yylval.token = x; return x; }
-
-/* Some versions of flex want this.  */
-#ifndef yywrap
-int yywrap (void) { return 1; }
-#endif
-#define SCRIPT 1
-
-#define EXPRESSION 2
-
-#define BOTH 3
-
-#define DEFSYMEXP 4
-
-#define MRI 5
-
-#define VERS_START 6
-
-#define VERS_SCRIPT 7
-
-#define VERS_NODE 8
-
-#line 1600 "ldlex.c"
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
-#else
-extern int yywrap YY_PROTO(( void ));
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
-
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
-#endif
-
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
-		{ \
-		int c = '*', n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-YY_DECL
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp = NULL, *yy_bp = NULL;
-	register int yy_act;
-
-#line 120 "ldlex.l"
-
-
-  if (parser_input != input_selected)
-    {
-      /* The first token of the input determines the initial parser state.  */
-      input_type t = parser_input;
-      parser_input = input_selected;
-      switch (t)
-	{
-	case input_script: return INPUT_SCRIPT; break;
-	case input_mri_script: return INPUT_MRI_SCRIPT; break;
-	case input_version_script: return INPUT_VERSION_SCRIPT; break;
-	case input_dynamic_list: return INPUT_DYNAMIC_LIST; break;
-	case input_defsym: return INPUT_DEFSYM; break;
-	default: abort ();
-	}
-    }
-
-#line 1770 "ldlex.c"
-
-	if ( yy_init )
-		{
-		yy_init = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-
-		yy_load_buffer_state();
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yy_start;
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 1637 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 2562 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-
-do_action:	/* This label is used only to access EOF actions. */
-
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 138 "ldlex.l"
-{ comment (); }
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 141 "ldlex.l"
-{ RTOKEN('-');}
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 142 "ldlex.l"
-{ RTOKEN('+');}
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 143 "ldlex.l"
-{ yylval.name = xstrdup (yytext); return NAME; }
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 144 "ldlex.l"
-{ RTOKEN('='); }
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 146 "ldlex.l"
-{
-  				yylval.integer = bfd_scan_vma (yytext + 1, 0, 16);
-				yylval.bigint.str = NULL;
-				return INT;
-			}
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 152 "ldlex.l"
-{
-				   int ibase ;
-				   switch (yytext[yyleng - 1]) {
-				    case 'X':
-				    case 'x':
-				    case 'H':
-				    case 'h':
-				     ibase = 16;
-				     break;
-				    case 'O':
-				    case 'o':
-				     ibase = 8;
-				     break;
-				    case 'B':
-				    case 'b':
-				     ibase = 2;
-				     break;
-				    default:
-				     ibase = 10;
-				   }
-				   yylval.integer = bfd_scan_vma (yytext, 0,
-								  ibase);
-				   yylval.bigint.str = NULL;
-				   return INT;
-				 }
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 177 "ldlex.l"
-{
-				  char *s = yytext;
-				  int ibase = 0;
-
-				  if (*s == '$')
-				    {
-				      ++s;
-				      ibase = 16;
-				    }
-				  yylval.integer = bfd_scan_vma (s, 0, ibase);
-				  yylval.bigint.str = NULL;
-				  if (yytext[yyleng - 1] == 'M'
-				      || yytext[yyleng - 1] == 'm')
-				    {
-				      yylval.integer *= 1024 * 1024;
-				    }
-				  else if (yytext[yyleng - 1] == 'K'
-				      || yytext[yyleng - 1]=='k')
-				    {
-				      yylval.integer *= 1024;
-				    }
-				  else if (yytext[0] == '0'
-					   && (yytext[1] == 'x'
-					       || yytext[1] == 'X'))
-				    {
-				      yylval.bigint.str = xstrdup (yytext + 2);
-				    }
-				  return INT;
-				}
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 206 "ldlex.l"
-{ RTOKEN(']');}
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 207 "ldlex.l"
-{ RTOKEN('[');}
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 208 "ldlex.l"
-{ RTOKEN(LSHIFTEQ);}
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 209 "ldlex.l"
-{ RTOKEN(RSHIFTEQ);}
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 210 "ldlex.l"
-{ RTOKEN(OROR);}
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 211 "ldlex.l"
-{ RTOKEN(EQ);}
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 212 "ldlex.l"
-{ RTOKEN(NE);}
-	YY_BREAK
-case 16:
-YY_RULE_SETUP
-#line 213 "ldlex.l"
-{ RTOKEN(GE);}
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 214 "ldlex.l"
-{ RTOKEN(LE);}
-	YY_BREAK
-case 18:
-YY_RULE_SETUP
-#line 215 "ldlex.l"
-{ RTOKEN(LSHIFT);}
-	YY_BREAK
-case 19:
-YY_RULE_SETUP
-#line 216 "ldlex.l"
-{ RTOKEN(RSHIFT);}
-	YY_BREAK
-case 20:
-YY_RULE_SETUP
-#line 217 "ldlex.l"
-{ RTOKEN(PLUSEQ);}
-	YY_BREAK
-case 21:
-YY_RULE_SETUP
-#line 218 "ldlex.l"
-{ RTOKEN(MINUSEQ);}
-	YY_BREAK
-case 22:
-YY_RULE_SETUP
-#line 219 "ldlex.l"
-{ RTOKEN(MULTEQ);}
-	YY_BREAK
-case 23:
-YY_RULE_SETUP
-#line 220 "ldlex.l"
-{ RTOKEN(DIVEQ);}
-	YY_BREAK
-case 24:
-YY_RULE_SETUP
-#line 221 "ldlex.l"
-{ RTOKEN(ANDEQ);}
-	YY_BREAK
-case 25:
-YY_RULE_SETUP
-#line 222 "ldlex.l"
-{ RTOKEN(OREQ);}
-	YY_BREAK
-case 26:
-YY_RULE_SETUP
-#line 223 "ldlex.l"
-{ RTOKEN(ANDAND);}
-	YY_BREAK
-case 27:
-YY_RULE_SETUP
-#line 224 "ldlex.l"
-{ RTOKEN('>');}
-	YY_BREAK
-case 28:
-YY_RULE_SETUP
-#line 225 "ldlex.l"
-{ RTOKEN(',');}
-	YY_BREAK
-case 29:
-YY_RULE_SETUP
-#line 226 "ldlex.l"
-{ RTOKEN('&');}
-	YY_BREAK
-case 30:
-YY_RULE_SETUP
-#line 227 "ldlex.l"
-{ RTOKEN('|');}
-	YY_BREAK
-case 31:
-YY_RULE_SETUP
-#line 228 "ldlex.l"
-{ RTOKEN('~');}
-	YY_BREAK
-case 32:
-YY_RULE_SETUP
-#line 229 "ldlex.l"
-{ RTOKEN('!');}
-	YY_BREAK
-case 33:
-YY_RULE_SETUP
-#line 230 "ldlex.l"
-{ RTOKEN('?');}
-	YY_BREAK
-case 34:
-YY_RULE_SETUP
-#line 231 "ldlex.l"
-{ RTOKEN('*');}
-	YY_BREAK
-case 35:
-YY_RULE_SETUP
-#line 232 "ldlex.l"
-{ RTOKEN('+');}
-	YY_BREAK
-case 36:
-YY_RULE_SETUP
-#line 233 "ldlex.l"
-{ RTOKEN('-');}
-	YY_BREAK
-case 37:
-YY_RULE_SETUP
-#line 234 "ldlex.l"
-{ RTOKEN('/');}
-	YY_BREAK
-case 38:
-YY_RULE_SETUP
-#line 235 "ldlex.l"
-{ RTOKEN('%');}
-	YY_BREAK
-case 39:
-YY_RULE_SETUP
-#line 236 "ldlex.l"
-{ RTOKEN('<');}
-	YY_BREAK
-case 40:
-YY_RULE_SETUP
-#line 237 "ldlex.l"
-{ RTOKEN('=');}
-	YY_BREAK
-case 41:
-YY_RULE_SETUP
-#line 238 "ldlex.l"
-{ RTOKEN('}') ; }
-	YY_BREAK
-case 42:
-YY_RULE_SETUP
-#line 239 "ldlex.l"
-{ RTOKEN('{'); }
-	YY_BREAK
-case 43:
-YY_RULE_SETUP
-#line 240 "ldlex.l"
-{ RTOKEN(')');}
-	YY_BREAK
-case 44:
-YY_RULE_SETUP
-#line 241 "ldlex.l"
-{ RTOKEN('(');}
-	YY_BREAK
-case 45:
-YY_RULE_SETUP
-#line 242 "ldlex.l"
-{ RTOKEN(':'); }
-	YY_BREAK
-case 46:
-YY_RULE_SETUP
-#line 243 "ldlex.l"
-{ RTOKEN(';');}
-	YY_BREAK
-case 47:
-YY_RULE_SETUP
-#line 244 "ldlex.l"
-{ RTOKEN(MEMORY);}
-	YY_BREAK
-case 48:
-YY_RULE_SETUP
-#line 245 "ldlex.l"
-{ RTOKEN(REGION_ALIAS);}
-	YY_BREAK
-case 49:
-YY_RULE_SETUP
-#line 246 "ldlex.l"
-{ RTOKEN(LD_FEATURE);}
-	YY_BREAK
-case 50:
-YY_RULE_SETUP
-#line 247 "ldlex.l"
-{ RTOKEN(ORIGIN);}
-	YY_BREAK
-case 51:
-YY_RULE_SETUP
-#line 248 "ldlex.l"
-{ RTOKEN(VERSIONK);}
-	YY_BREAK
-case 52:
-YY_RULE_SETUP
-#line 249 "ldlex.l"
-{ RTOKEN(BLOCK);}
-	YY_BREAK
-case 53:
-YY_RULE_SETUP
-#line 250 "ldlex.l"
-{ RTOKEN(BIND);}
-	YY_BREAK
-case 54:
-YY_RULE_SETUP
-#line 251 "ldlex.l"
-{ RTOKEN(LENGTH);}
-	YY_BREAK
-case 55:
-YY_RULE_SETUP
-#line 252 "ldlex.l"
-{ RTOKEN(ALIGN_K);}
-	YY_BREAK
-case 56:
-YY_RULE_SETUP
-#line 253 "ldlex.l"
-{ RTOKEN(DATA_SEGMENT_ALIGN);}
-	YY_BREAK
-case 57:
-YY_RULE_SETUP
-#line 254 "ldlex.l"
-{ RTOKEN(DATA_SEGMENT_RELRO_END);}
-	YY_BREAK
-case 58:
-YY_RULE_SETUP
-#line 255 "ldlex.l"
-{ RTOKEN(DATA_SEGMENT_END);}
-	YY_BREAK
-case 59:
-YY_RULE_SETUP
-#line 256 "ldlex.l"
-{ RTOKEN(ADDR);}
-	YY_BREAK
-case 60:
-YY_RULE_SETUP
-#line 257 "ldlex.l"
-{ RTOKEN(LOADADDR);}
-	YY_BREAK
-case 61:
-YY_RULE_SETUP
-#line 258 "ldlex.l"
-{ RTOKEN(ALIGNOF); }
-	YY_BREAK
-case 62:
-YY_RULE_SETUP
-#line 259 "ldlex.l"
-{ RTOKEN(MAX_K); }
-	YY_BREAK
-case 63:
-YY_RULE_SETUP
-#line 260 "ldlex.l"
-{ RTOKEN(MIN_K); }
-	YY_BREAK
-case 64:
-YY_RULE_SETUP
-#line 261 "ldlex.l"
-{ RTOKEN(ASSERT_K); }
-	YY_BREAK
-case 65:
-YY_RULE_SETUP
-#line 262 "ldlex.l"
-{ RTOKEN(ENTRY);}
-	YY_BREAK
-case 66:
-YY_RULE_SETUP
-#line 263 "ldlex.l"
-{ RTOKEN(EXTERN);}
-	YY_BREAK
-case 67:
-YY_RULE_SETUP
-#line 264 "ldlex.l"
-{ RTOKEN(NEXT);}
-	YY_BREAK
-case 68:
-YY_RULE_SETUP
-#line 265 "ldlex.l"
-{ RTOKEN(SIZEOF_HEADERS);}
-	YY_BREAK
-case 69:
-YY_RULE_SETUP
-#line 266 "ldlex.l"
-{ RTOKEN(SIZEOF_HEADERS);}
-	YY_BREAK
-case 70:
-YY_RULE_SETUP
-#line 267 "ldlex.l"
-{ RTOKEN(SEGMENT_START);}
-	YY_BREAK
-case 71:
-YY_RULE_SETUP
-#line 268 "ldlex.l"
-{ RTOKEN(MAP);}
-	YY_BREAK
-case 72:
-YY_RULE_SETUP
-#line 269 "ldlex.l"
-{ RTOKEN(SIZEOF);}
-	YY_BREAK
-case 73:
-YY_RULE_SETUP
-#line 270 "ldlex.l"
-{ RTOKEN(TARGET_K);}
-	YY_BREAK
-case 74:
-YY_RULE_SETUP
-#line 271 "ldlex.l"
-{ RTOKEN(SEARCH_DIR);}
-	YY_BREAK
-case 75:
-YY_RULE_SETUP
-#line 272 "ldlex.l"
-{ RTOKEN(OUTPUT);}
-	YY_BREAK
-case 76:
-YY_RULE_SETUP
-#line 273 "ldlex.l"
-{ RTOKEN(INPUT);}
-	YY_BREAK
-case 77:
-YY_RULE_SETUP
-#line 274 "ldlex.l"
-{ RTOKEN(GROUP);}
-	YY_BREAK
-case 78:
-YY_RULE_SETUP
-#line 275 "ldlex.l"
-{ RTOKEN(AS_NEEDED);}
-	YY_BREAK
-case 79:
-YY_RULE_SETUP
-#line 276 "ldlex.l"
-{ RTOKEN(DEFINED);}
-	YY_BREAK
-case 80:
-YY_RULE_SETUP
-#line 277 "ldlex.l"
-{ RTOKEN(CREATE_OBJECT_SYMBOLS);}
-	YY_BREAK
-case 81:
-YY_RULE_SETUP
-#line 278 "ldlex.l"
-{ RTOKEN( CONSTRUCTORS);}
-	YY_BREAK
-case 82:
-YY_RULE_SETUP
-#line 279 "ldlex.l"
-{ RTOKEN(FORCE_COMMON_ALLOCATION);}
-	YY_BREAK
-case 83:
-YY_RULE_SETUP
-#line 280 "ldlex.l"
-{ RTOKEN(INHIBIT_COMMON_ALLOCATION);}
-	YY_BREAK
-case 84:
-YY_RULE_SETUP
-#line 281 "ldlex.l"
-{ RTOKEN(SECTIONS);}
-	YY_BREAK
-case 85:
-YY_RULE_SETUP
-#line 282 "ldlex.l"
-{ RTOKEN(INSERT_K);}
-	YY_BREAK
-case 86:
-YY_RULE_SETUP
-#line 283 "ldlex.l"
-{ RTOKEN(AFTER);}
-	YY_BREAK
-case 87:
-YY_RULE_SETUP
-#line 284 "ldlex.l"
-{ RTOKEN(BEFORE);}
-	YY_BREAK
-case 88:
-YY_RULE_SETUP
-#line 285 "ldlex.l"
-{ RTOKEN(FILL);}
-	YY_BREAK
-case 89:
-YY_RULE_SETUP
-#line 286 "ldlex.l"
-{ RTOKEN(STARTUP);}
-	YY_BREAK
-case 90:
-YY_RULE_SETUP
-#line 287 "ldlex.l"
-{ RTOKEN(OUTPUT_FORMAT);}
-	YY_BREAK
-case 91:
-YY_RULE_SETUP
-#line 288 "ldlex.l"
-{ RTOKEN( OUTPUT_ARCH);}
-	YY_BREAK
-case 92:
-YY_RULE_SETUP
-#line 289 "ldlex.l"
-{ RTOKEN(HLL);}
-	YY_BREAK
-case 93:
-YY_RULE_SETUP
-#line 290 "ldlex.l"
-{ RTOKEN(SYSLIB);}
-	YY_BREAK
-case 94:
-YY_RULE_SETUP
-#line 291 "ldlex.l"
-{ RTOKEN(FLOAT);}
-	YY_BREAK
-case 95:
-YY_RULE_SETUP
-#line 292 "ldlex.l"
-{ RTOKEN( QUAD);}
-	YY_BREAK
-case 96:
-YY_RULE_SETUP
-#line 293 "ldlex.l"
-{ RTOKEN( SQUAD);}
-	YY_BREAK
-case 97:
-YY_RULE_SETUP
-#line 294 "ldlex.l"
-{ RTOKEN( LONG);}
-	YY_BREAK
-case 98:
-YY_RULE_SETUP
-#line 295 "ldlex.l"
-{ RTOKEN( SHORT);}
-	YY_BREAK
-case 99:
-YY_RULE_SETUP
-#line 296 "ldlex.l"
-{ RTOKEN( BYTE);}
-	YY_BREAK
-case 100:
-YY_RULE_SETUP
-#line 297 "ldlex.l"
-{ RTOKEN(NOFLOAT);}
-	YY_BREAK
-case 101:
-YY_RULE_SETUP
-#line 298 "ldlex.l"
-{ RTOKEN(NOCROSSREFS);}
-	YY_BREAK
-case 102:
-YY_RULE_SETUP
-#line 299 "ldlex.l"
-{ RTOKEN(OVERLAY); }
-	YY_BREAK
-case 103:
-YY_RULE_SETUP
-#line 300 "ldlex.l"
-{ RTOKEN(SORT_BY_NAME); }
-	YY_BREAK
-case 104:
-YY_RULE_SETUP
-#line 301 "ldlex.l"
-{ RTOKEN(SORT_BY_ALIGNMENT); }
-	YY_BREAK
-case 105:
-YY_RULE_SETUP
-#line 302 "ldlex.l"
-{ RTOKEN(SORT_BY_NAME); }
-	YY_BREAK
-case 106:
-YY_RULE_SETUP
-#line 303 "ldlex.l"
-{ RTOKEN(SORT_BY_INIT_PRIORITY); }
-	YY_BREAK
-case 107:
-YY_RULE_SETUP
-#line 304 "ldlex.l"
-{ RTOKEN(NOLOAD);}
-	YY_BREAK
-case 108:
-YY_RULE_SETUP
-#line 305 "ldlex.l"
-{ RTOKEN(DSECT);}
-	YY_BREAK
-case 109:
-YY_RULE_SETUP
-#line 306 "ldlex.l"
-{ RTOKEN(COPY);}
-	YY_BREAK
-case 110:
-YY_RULE_SETUP
-#line 307 "ldlex.l"
-{ RTOKEN(INFO);}
-	YY_BREAK
-case 111:
-YY_RULE_SETUP
-#line 308 "ldlex.l"
-{ RTOKEN(OVERLAY);}
-	YY_BREAK
-case 112:
-YY_RULE_SETUP
-#line 309 "ldlex.l"
-{ RTOKEN(ONLY_IF_RO); }
-	YY_BREAK
-case 113:
-YY_RULE_SETUP
-#line 310 "ldlex.l"
-{ RTOKEN(ONLY_IF_RW); }
-	YY_BREAK
-case 114:
-YY_RULE_SETUP
-#line 311 "ldlex.l"
-{ RTOKEN(SPECIAL); }
-	YY_BREAK
-case 115:
-YY_RULE_SETUP
-#line 312 "ldlex.l"
-{ RTOKEN(ORIGIN);}
-	YY_BREAK
-case 116:
-YY_RULE_SETUP
-#line 313 "ldlex.l"
-{ RTOKEN(ORIGIN);}
-	YY_BREAK
-case 117:
-YY_RULE_SETUP
-#line 314 "ldlex.l"
-{ RTOKEN( LENGTH);}
-	YY_BREAK
-case 118:
-YY_RULE_SETUP
-#line 315 "ldlex.l"
-{ RTOKEN( LENGTH);}
-	YY_BREAK
-case 119:
-YY_RULE_SETUP
-#line 316 "ldlex.l"
-{ RTOKEN(INCLUDE);}
-	YY_BREAK
-case 120:
-YY_RULE_SETUP
-#line 317 "ldlex.l"
-{ RTOKEN (PHDRS); }
-	YY_BREAK
-case 121:
-YY_RULE_SETUP
-#line 318 "ldlex.l"
-{ RTOKEN(AT);}
-	YY_BREAK
-case 122:
-YY_RULE_SETUP
-#line 319 "ldlex.l"
-{ RTOKEN(SUBALIGN);}
-	YY_BREAK
-case 123:
-YY_RULE_SETUP
-#line 320 "ldlex.l"
-{ RTOKEN(PROVIDE); }
-	YY_BREAK
-case 124:
-YY_RULE_SETUP
-#line 321 "ldlex.l"
-{ RTOKEN(PROVIDE_HIDDEN); }
-	YY_BREAK
-case 125:
-YY_RULE_SETUP
-#line 322 "ldlex.l"
-{ RTOKEN(KEEP); }
-	YY_BREAK
-case 126:
-YY_RULE_SETUP
-#line 323 "ldlex.l"
-{ RTOKEN(EXCLUDE_FILE); }
-	YY_BREAK
-case 127:
-YY_RULE_SETUP
-#line 324 "ldlex.l"
-{ RTOKEN(CONSTANT);}
-	YY_BREAK
-case 128:
-YY_RULE_SETUP
-#line 325 "ldlex.l"
-{ ++ lineno; }
-	YY_BREAK
-case 129:
-YY_RULE_SETUP
-#line 326 "ldlex.l"
-{ ++ lineno;  RTOKEN(NEWLINE); }
-	YY_BREAK
-case 130:
-YY_RULE_SETUP
-#line 327 "ldlex.l"
-{ /* Mri comment line */ }
-	YY_BREAK
-case 131:
-YY_RULE_SETUP
-#line 328 "ldlex.l"
-{ /* Mri comment line */ }
-	YY_BREAK
-case 132:
-YY_RULE_SETUP
-#line 329 "ldlex.l"
-{ RTOKEN(ENDWORD); }
-	YY_BREAK
-case 133:
-YY_RULE_SETUP
-#line 330 "ldlex.l"
-{ RTOKEN(ALIGNMOD);}
-	YY_BREAK
-case 134:
-YY_RULE_SETUP
-#line 331 "ldlex.l"
-{ RTOKEN(ALIGN_K);}
-	YY_BREAK
-case 135:
-YY_RULE_SETUP
-#line 332 "ldlex.l"
-{ RTOKEN(CHIP); }
-	YY_BREAK
-case 136:
-YY_RULE_SETUP
-#line 333 "ldlex.l"
-{ RTOKEN(BASE); }
-	YY_BREAK
-case 137:
-YY_RULE_SETUP
-#line 334 "ldlex.l"
-{ RTOKEN(ALIAS); }
-	YY_BREAK
-case 138:
-YY_RULE_SETUP
-#line 335 "ldlex.l"
-{ RTOKEN(TRUNCATE); }
-	YY_BREAK
-case 139:
-YY_RULE_SETUP
-#line 336 "ldlex.l"
-{ RTOKEN(LOAD); }
-	YY_BREAK
-case 140:
-YY_RULE_SETUP
-#line 337 "ldlex.l"
-{ RTOKEN(PUBLIC); }
-	YY_BREAK
-case 141:
-YY_RULE_SETUP
-#line 338 "ldlex.l"
-{ RTOKEN(ORDER); }
-	YY_BREAK
-case 142:
-YY_RULE_SETUP
-#line 339 "ldlex.l"
-{ RTOKEN(NAMEWORD); }
-	YY_BREAK
-case 143:
-YY_RULE_SETUP
-#line 340 "ldlex.l"
-{ RTOKEN(FORMAT); }
-	YY_BREAK
-case 144:
-YY_RULE_SETUP
-#line 341 "ldlex.l"
-{ RTOKEN(CASE); }
-	YY_BREAK
-case 145:
-YY_RULE_SETUP
-#line 342 "ldlex.l"
-{ RTOKEN(START); }
-	YY_BREAK
-case 146:
-YY_RULE_SETUP
-#line 343 "ldlex.l"
-{ RTOKEN(LIST); /* LIST and ignore to end of line */ }
-	YY_BREAK
-case 147:
-YY_RULE_SETUP
-#line 344 "ldlex.l"
-{ RTOKEN(SECT); }
-	YY_BREAK
-case 148:
-YY_RULE_SETUP
-#line 345 "ldlex.l"
-{ RTOKEN(ABSOLUTE); }
-	YY_BREAK
-case 149:
-YY_RULE_SETUP
-#line 346 "ldlex.l"
-{ RTOKEN(ENDWORD); }
-	YY_BREAK
-case 150:
-YY_RULE_SETUP
-#line 347 "ldlex.l"
-{ RTOKEN(ALIGNMOD);}
-	YY_BREAK
-case 151:
-YY_RULE_SETUP
-#line 348 "ldlex.l"
-{ RTOKEN(ALIGN_K);}
-	YY_BREAK
-case 152:
-YY_RULE_SETUP
-#line 349 "ldlex.l"
-{ RTOKEN(CHIP); }
-	YY_BREAK
-case 153:
-YY_RULE_SETUP
-#line 350 "ldlex.l"
-{ RTOKEN(BASE); }
-	YY_BREAK
-case 154:
-YY_RULE_SETUP
-#line 351 "ldlex.l"
-{ RTOKEN(ALIAS); }
-	YY_BREAK
-case 155:
-YY_RULE_SETUP
-#line 352 "ldlex.l"
-{ RTOKEN(TRUNCATE); }
-	YY_BREAK
-case 156:
-YY_RULE_SETUP
-#line 353 "ldlex.l"
-{ RTOKEN(LOAD); }
-	YY_BREAK
-case 157:
-YY_RULE_SETUP
-#line 354 "ldlex.l"
-{ RTOKEN(PUBLIC); }
-	YY_BREAK
-case 158:
-YY_RULE_SETUP
-#line 355 "ldlex.l"
-{ RTOKEN(ORDER); }
-	YY_BREAK
-case 159:
-YY_RULE_SETUP
-#line 356 "ldlex.l"
-{ RTOKEN(NAMEWORD); }
-	YY_BREAK
-case 160:
-YY_RULE_SETUP
-#line 357 "ldlex.l"
-{ RTOKEN(FORMAT); }
-	YY_BREAK
-case 161:
-YY_RULE_SETUP
-#line 358 "ldlex.l"
-{ RTOKEN(CASE); }
-	YY_BREAK
-case 162:
-YY_RULE_SETUP
-#line 359 "ldlex.l"
-{ RTOKEN(EXTERN); }
-	YY_BREAK
-case 163:
-YY_RULE_SETUP
-#line 360 "ldlex.l"
-{ RTOKEN(START); }
-	YY_BREAK
-case 164:
-YY_RULE_SETUP
-#line 361 "ldlex.l"
-{ RTOKEN(LIST); /* LIST and ignore to end of line */ }
-	YY_BREAK
-case 165:
-YY_RULE_SETUP
-#line 362 "ldlex.l"
-{ RTOKEN(SECT); }
-	YY_BREAK
-case 166:
-YY_RULE_SETUP
-#line 363 "ldlex.l"
-{ RTOKEN(ABSOLUTE); }
-	YY_BREAK
-case 167:
-YY_RULE_SETUP
-#line 365 "ldlex.l"
-{
-/* Filename without commas, needed to parse mri stuff */
-				 yylval.name = xstrdup (yytext);
-				  return NAME;
-				}
-	YY_BREAK
-case 168:
-YY_RULE_SETUP
-#line 372 "ldlex.l"
-{
-				 yylval.name = xstrdup (yytext);
-				  return NAME;
-				}
-	YY_BREAK
-case 169:
-YY_RULE_SETUP
-#line 376 "ldlex.l"
-{
-				  yylval.name = xstrdup (yytext + 2);
-				  return LNAME;
-				}
-	YY_BREAK
-case 170:
-YY_RULE_SETUP
-#line 380 "ldlex.l"
-{
-				 yylval.name = xstrdup (yytext);
-				  return NAME;
-				}
-	YY_BREAK
-case 171:
-YY_RULE_SETUP
-#line 384 "ldlex.l"
-{
-				  yylval.name = xstrdup (yytext + 2);
-				  return LNAME;
-				}
-	YY_BREAK
-case 172:
-YY_RULE_SETUP
-#line 388 "ldlex.l"
-{
-		/* Annoyingly, this pattern can match comments, and we have
-		   longest match issues to consider.  So if the first two
-		   characters are a comment opening, put the input back and
-		   try again.  */
-		if (yytext[0] == '/' && yytext[1] == '*')
-		  {
-		    yyless (2);
-		    comment ();
-		  }
-		else
-		  {
-		    yylval.name = xstrdup (yytext);
-		    return NAME;
-		  }
-	}
-	YY_BREAK
-case 173:
-YY_RULE_SETUP
-#line 405 "ldlex.l"
-{
-					/* No matter the state, quotes
-					   give what's inside */
-					yylval.name = xstrdup (yytext + 1);
-					yylval.name[yyleng - 2] = 0;
-					return NAME;
-				}
-	YY_BREAK
-case 174:
-YY_RULE_SETUP
-#line 412 "ldlex.l"
-{ lineno++;}
-	YY_BREAK
-case 175:
-YY_RULE_SETUP
-#line 413 "ldlex.l"
-{ }
-	YY_BREAK
-case 176:
-YY_RULE_SETUP
-#line 415 "ldlex.l"
-{ return *yytext; }
-	YY_BREAK
-case 177:
-YY_RULE_SETUP
-#line 417 "ldlex.l"
-{ RTOKEN(GLOBAL); }
-	YY_BREAK
-case 178:
-YY_RULE_SETUP
-#line 419 "ldlex.l"
-{ RTOKEN(LOCAL); }
-	YY_BREAK
-case 179:
-YY_RULE_SETUP
-#line 421 "ldlex.l"
-{ RTOKEN(EXTERN); }
-	YY_BREAK
-case 180:
-YY_RULE_SETUP
-#line 423 "ldlex.l"
-{ yylval.name = xstrdup (yytext);
-				  return VERS_IDENTIFIER; }
-	YY_BREAK
-case 181:
-YY_RULE_SETUP
-#line 426 "ldlex.l"
-{ yylval.name = xstrdup (yytext);
-				  return VERS_TAG; }
-	YY_BREAK
-case 182:
-YY_RULE_SETUP
-#line 429 "ldlex.l"
-{ BEGIN(VERS_SCRIPT); return *yytext; }
-	YY_BREAK
-case 183:
-YY_RULE_SETUP
-#line 431 "ldlex.l"
-{ BEGIN(VERS_NODE);
-				  vers_node_nesting = 0;
-				  return *yytext;
-				}
-	YY_BREAK
-case 184:
-YY_RULE_SETUP
-#line 435 "ldlex.l"
-{ return *yytext; }
-	YY_BREAK
-case 185:
-YY_RULE_SETUP
-#line 436 "ldlex.l"
-{ vers_node_nesting++; return *yytext; }
-	YY_BREAK
-case 186:
-YY_RULE_SETUP
-#line 437 "ldlex.l"
-{ if (--vers_node_nesting < 0)
-				    BEGIN(VERS_SCRIPT);
-				  return *yytext;
-				}
-	YY_BREAK
-case 187:
-YY_RULE_SETUP
-#line 442 "ldlex.l"
-{ lineno++; }
-	YY_BREAK
-case 188:
-YY_RULE_SETUP
-#line 444 "ldlex.l"
-{ /* Eat up comments */ }
-	YY_BREAK
-case 189:
-YY_RULE_SETUP
-#line 446 "ldlex.l"
-{ /* Eat up whitespace */ }
-	YY_BREAK
-case YY_STATE_EOF(INITIAL):
-case YY_STATE_EOF(SCRIPT):
-case YY_STATE_EOF(EXPRESSION):
-case YY_STATE_EOF(BOTH):
-case YY_STATE_EOF(DEFSYMEXP):
-case YY_STATE_EOF(MRI):
-case YY_STATE_EOF(VERS_START):
-case YY_STATE_EOF(VERS_SCRIPT):
-case YY_STATE_EOF(VERS_NODE):
-#line 448 "ldlex.l"
-{
-  include_stack_ptr--;
-
-  if (include_stack_ptr == 0)
-  {
-    yyterminate ();
-  }
-  else
-  {
-    yy_switch_to_buffer (include_stack[include_stack_ptr]);
-  }
-
-  ldfile_input_filename = file_name_stack[include_stack_ptr - 1];
-  lineno = lineno_stack[include_stack_ptr];
-
-  return END;
-}
-	YY_BREAK
-case 190:
-YY_RULE_SETUP
-#line 466 "ldlex.l"
-lex_warn_invalid (" in script", yytext);
-	YY_BREAK
-case 191:
-YY_RULE_SETUP
-#line 467 "ldlex.l"
-lex_warn_invalid (" in expression", yytext);
-	YY_BREAK
-case 192:
-YY_RULE_SETUP
-#line 469 "ldlex.l"
-ECHO;
-	YY_BREAK
-#line 2942 "ldlex.c"
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state();
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer() )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap() )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of yylex */
-
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
-
-	else
-		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
-
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
-#endif
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
-
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	if ( yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
-
-	return ret_val;
-	}
-
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-static yy_state_type yy_get_previous_state()
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 1637 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-	}
-
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 1637 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 1636);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
-
-
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
-
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
-
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
-
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput()
-#else
-static int input()
-#endif
-	{
-	int c;
-
-	*yy_c_buf_p = yy_hold_char;
-
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
-
-			switch ( yy_get_next_buffer() )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/* fall through */
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap() )
-						return EOF;
-
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
-
-	return c;
-	}
-#endif /* YY_NO_INPUT */
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
-
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
-		return;
-
-	if ( yy_current_buffer )
-		{
-		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
-
-
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
-	if ( ! b )
-		return;
-
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
-
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
-
-	{
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
-	{
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
-	}
-
-
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b );
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
-#endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
-
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
-
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
-
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
-
-
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
-
-
-/* Internal utility routines. */
-
-#ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-	}
-#endif
-
-#ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-	}
-#endif
-
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
-
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 469 "ldlex.l"
-
-
-
-/* Switch flex to reading script file NAME, open on FILE,
-   saving the current input info on the include stack.  */
-
-void
-lex_push_file (FILE *file, const char *name)
-{
-  if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
-    {
-      einfo ("%F:includes nested too deeply\n");
-    }
-  file_name_stack[include_stack_ptr] = name;
-  lineno_stack[include_stack_ptr] = lineno;
-  include_stack[include_stack_ptr] = YY_CURRENT_BUFFER;
-
-  include_stack_ptr++;
-  lineno = 1;
-  yyin = file;
-  yy_switch_to_buffer (yy_create_buffer (yyin, YY_BUF_SIZE));
-}
-
-/* Return a newly created flex input buffer containing STRING,
-   which is SIZE bytes long.  */
-
-static YY_BUFFER_STATE
-yy_create_string_buffer (const char *string, size_t size)
-{
-  YY_BUFFER_STATE b;
-
-  /* Calls to m-alloc get turned by sed into xm-alloc.  */
-  b = malloc (sizeof (struct yy_buffer_state));
-  b->yy_input_file = 0;
-  b->yy_buf_size = size;
-
-  /* yy_ch_buf has to be 2 characters longer than the size given because
-     we need to put in 2 end-of-buffer characters.  */
-  b->yy_ch_buf = malloc ((unsigned) (b->yy_buf_size + 3));
-
-  b->yy_ch_buf[0] = '\n';
-  strcpy (b->yy_ch_buf+1, string);
-  b->yy_ch_buf[size+1] = YY_END_OF_BUFFER_CHAR;
-  b->yy_ch_buf[size+2] = YY_END_OF_BUFFER_CHAR;
-  b->yy_n_chars = size+1;
-  b->yy_buf_pos = &b->yy_ch_buf[1];
-
-  b->yy_is_our_buffer = 1;
-  b->yy_is_interactive = 0;
-  b->yy_at_bol = 1;
-  b->yy_fill_buffer = 0;
-
-  /* flex 2.4.7 changed the interface.  FIXME: We should not be using
-     a flex internal interface in the first place!  */
-#ifdef YY_BUFFER_NEW
-  b->yy_buffer_status = YY_BUFFER_NEW;
-#else
-  b->yy_eof_status = EOF_NOT_SEEN;
-#endif
-
-  return b;
-}
-
-/* Switch flex to reading from STRING, saving the current input info
-   on the include stack.  */
-
-void
-lex_redirect (const char *string)
-{
-  YY_BUFFER_STATE tmp;
-
-  yy_init = 0;
-  if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
-    {
-      einfo("%F: macros nested too deeply\n");
-    }
-  file_name_stack[include_stack_ptr] = "redirect";
-  lineno_stack[include_stack_ptr] = lineno;
-  include_stack[include_stack_ptr] = YY_CURRENT_BUFFER;
-  include_stack_ptr++;
-  lineno = 1;
-  tmp = yy_create_string_buffer (string, strlen (string));
-  yy_switch_to_buffer (tmp);
-}
-
-/* Functions to switch to a different flex start condition,
-   saving the current start condition on `state_stack'.  */
-
-static int state_stack[MAX_INCLUDE_DEPTH * 2];
-static int *state_stack_p = state_stack;
-
-void
-ldlex_script (void)
-{
-  *(state_stack_p)++ = yy_start;
-  BEGIN (SCRIPT);
-}
-
-void
-ldlex_mri_script (void)
-{
-  *(state_stack_p)++ = yy_start;
-  BEGIN (MRI);
-}
-
-void
-ldlex_version_script (void)
-{
-  *(state_stack_p)++ = yy_start;
-  BEGIN (VERS_START);
-}
-
-void
-ldlex_version_file (void)
-{
-  *(state_stack_p)++ = yy_start;
-  BEGIN (VERS_SCRIPT);
-}
-
-void
-ldlex_defsym (void)
-{
-  *(state_stack_p)++ = yy_start;
-  BEGIN (DEFSYMEXP);
-}
-
-void
-ldlex_expression (void)
-{
-  *(state_stack_p)++ = yy_start;
-  BEGIN (EXPRESSION);
-}
-
-void
-ldlex_both (void)
-{
-  *(state_stack_p)++ = yy_start;
-  BEGIN (BOTH);
-}
-
-void
-ldlex_popstate (void)
-{
-  yy_start = *(--state_stack_p);
-}
-
-
-/* Place up to MAX_SIZE characters in BUF and return
-   either the number of characters read, or 0 to indicate EOF.  */
-
-static int
-yy_input (char *buf, int max_size)
-{
-  int result = 0;
-  if (YY_CURRENT_BUFFER->yy_input_file)
-    {
-      if (yyin)
-	{
-	  result = fread (buf, 1, max_size, yyin);
-	  if (result < max_size && ferror (yyin))
-	    einfo ("%F%P: read in flex scanner failed\n");
-	}
-    }
-  return result;
-}
-
-/* Eat the rest of a C-style comment.  */
-
-static void
-comment (void)
-{
-  int c;
-
-  while (1)
-  {
-    c = input();
-    while (c != '*' && c != EOF)
-    {
-      if (c == '\n')
-	lineno++;
-      c = input();
-    }
-
-    if (c == '*')
-    {
-      c = input();
-      while (c == '*')
-       c = input();
-      if (c == '/')
-       break;			/* found the end */
-    }
-
-    if (c == '\n')
-      lineno++;
-
-    if (c == EOF)
-    {
-      einfo( "%F%P: EOF in comment\n");
-      break;
-    }
-  }
-}
-
-/* Warn the user about a garbage character WHAT in the input
-   in context WHERE.  */
-
-static void
-lex_warn_invalid (char *where, char *what)
-{
-  char buf[5];
-
-  /* If we have found an input file whose format we do not recognize,
-     and we are therefore treating it as a linker script, and we find
-     an invalid character, then most likely this is a real object file
-     of some different format.  Treat it as such.  */
-  if (ldfile_assumed_script)
-    {
-      bfd_set_error (bfd_error_file_not_recognized);
-      einfo ("%F%s: file not recognized: %E\n", ldfile_input_filename);
-    }
-
-  if (! ISPRINT (*what))
-    {
-      sprintf (buf, "\\%03o", *(unsigned char *) what);
-      what = buf;
-    }
-
-  einfo ("%P:%S: ignoring invalid character `%s'%s\n", what, where);
-}
diff -r -N -u binutils-2.21.51/ld/ldlex.l binutils/ld/ldlex.l
--- binutils-2.21.51/ld/ldlex.l	2011-04-13 08:41:36.000000000 +0100
+++ binutils/ld/ldlex.l	2011-07-06 12:44:26.137253000 +0100
@@ -297,6 +297,14 @@
 <BOTH,SCRIPT>"NOFLOAT"			{ RTOKEN(NOFLOAT);}
 <EXPRESSION,BOTH,SCRIPT>"NOCROSSREFS"	{ RTOKEN(NOCROSSREFS);}
 <BOTH,SCRIPT>"OVERLAY"			{ RTOKEN(OVERLAY); }
+<BOTH,SCRIPT>"CREATE_SECINIT_TABLE"     { RTOKEN(CREATE_SECINIT_TABLE);}
+<BOTH,SCRIPT>"CREATE_MEMINFO"          { RTOKEN(CREATE_MEMINFO);}
+<EXPRESSION,BOTH,SCRIPT>"NOINIT"        { RTOKEN(NOINIT);}
+<EXPRESSION,BOTH,SCRIPT>"NOBITS"        { RTOKEN(NOBITS);}
+<EXPRESSION,BOTH,SCRIPT>"MAX_ENDADDRESS" { RTOKEN(MAX_ENDADDRESS);}
+<EXPRESSION,BOTH,SCRIPT>"PAD"           { RTOKEN(PAD);}
+<EXPRESSION,BOTH,SCRIPT>"COMPRESS"      { RTOKEN(COMPRESS);}
+<EXPRESSION,BOTH,SCRIPT>"CLEAR"         { RTOKEN(CLEAR);}
 <BOTH,SCRIPT>"SORT_BY_NAME"		{ RTOKEN(SORT_BY_NAME); }
 <BOTH,SCRIPT>"SORT_BY_ALIGNMENT"	{ RTOKEN(SORT_BY_ALIGNMENT); }
 <BOTH,SCRIPT>"SORT"			{ RTOKEN(SORT_BY_NAME); }
diff -r -N -u binutils-2.21.51/ld/ldmain.c binutils/ld/ldmain.c
--- binutils-2.21.51/ld/ldmain.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/ldmain.c	2011-07-06 12:44:26.137253000 +0100
@@ -46,6 +46,13 @@
 #include "libbfd.h"
 #endif /* ENABLE_PLUGINS */
 
+#ifdef IPA_LINK
+#include "ipa_ld.h"
+#include "ipa_cmdline.h"
+#include "ipa_bfd.h" /* [CL] needed for symbol_comdat() */
+#include "elf-bfd.h" /* [CL] needed to support comdat: need to get ipa_indx */
+#endif
+
 /* Somewhere above, sys/stat.h got included.  */
 #if !defined(S_ISDIR) && defined(S_IFDIR)
 #define	S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
@@ -153,6 +160,20 @@
   (struct bfd_link_info *, struct bfd_link_hash_entry *,
    bfd *, asection *, bfd_vma, flagword, const char *);
 
+#ifdef IPA_LINK
+extern bfd_boolean is_ipa;
+
+/* I have to call this through ld because otherwise
+   ipa_ld.o will get pulled in whether it is wanted
+   or not. */
+extern int ld_set_ndx(bfd *abfd);
+#if 0
+{
+  return ipa_set_ndx(abfd);
+}
+#endif
+#endif
+
 static struct bfd_link_callbacks link_callbacks =
 {
   add_archive_element,
@@ -185,12 +206,21 @@
     unlink_if_ordinary (output_filename);
 }
 
+#ifdef IPA_LINK
+int
+main (int argc, char **argv, char **envp)
+#else
 int
 main (int argc, char **argv)
+#endif
 {
   char *emulation;
   long start_time = get_run_time ();
 
+#ifdef IPA_LINK
+  ipa_search_command_line(argc,argv,envp);
+#endif
+
 #if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
   setlocale (LC_MESSAGES, "");
 #endif
@@ -254,6 +284,8 @@
   config.make_executable = TRUE;
   config.magic_demand_paged = TRUE;
   config.text_read_only = TRUE;
+  config.build_secinfo_table = FALSE;
+  config.get_decompression_code = TRUE;
 
   command_line.warn_mismatch = TRUE;
   command_line.warn_search_mismatch = TRUE;
@@ -281,6 +313,9 @@
   link_info.relax_pass = 1;
   link_info.pei386_auto_import = -1;
   link_info.spare_dynamic_tags = 5;
+  /* TB: For building a relocateable with pcrel relocs against local
+     symbol */
+  link_info.relocatable_with_pcrel_resolved = FALSE;
   link_info.path_separator = ':';
 
   ldfile_add_arch ("");
@@ -301,6 +336,10 @@
 
   if (link_info.relocatable)
     {
+      /* section information table is build only for
+	 non relocateable files */
+      config.build_secinfo_table = FALSE;
+
       if (command_line.check_section_addresses < 0)
 	command_line.check_section_addresses = 0;
       if (link_info.shared)
@@ -461,6 +500,13 @@
 
   lang_process ();
 
+#ifdef IPA_LINK
+  if (is_ipa) {
+    cleanup_symtab_for_ipa();
+    (*p_ipa_driver) (ipa_argc, ipa_argv);
+  }
+#endif
+
   /* Print error messages for any missing symbols, for any warning
      symbols, and possibly multiple definitions.  */
   if (link_info.relocatable)
@@ -951,6 +997,17 @@
       abort ();
     }
 
+#ifdef IPA_LINK
+  /* [DF] Moved from linker.c due to source reorg. in 2.21.51 */
+  /* [CL] support comdat attribute: redefinition
+     of a symbol with the comdat attribute is allowed.
+     It will be fully resolved by the final link pass */
+  if (is_ipa && ipa_is_whirl(nbfd) &&
+      (*p_symbol_comdat)(((struct elf_link_hash_entry*)h)->ipa_indx)) {
+      return TRUE;
+  }
+#endif
+
   /* Ignore a redefinition of an absolute symbol to the
      same value; it's harmless.  */
   if (h->type == bfd_link_hash_defined
diff -r -N -u binutils-2.21.51/ld/ld.texinfo binutils/ld/ld.texinfo
--- binutils-2.21.51/ld/ld.texinfo	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/ld.texinfo	2011-07-06 12:44:26.137253000 +0100
@@ -1425,6 +1425,12 @@
 necessary.  This may be required if @command{ld} runs out of memory space
 while linking a large executable.
 
+@kindex --no-secinit-table
+@item --no-secinit-table
+@command{ld} normally provides a table which is used to initialize memory.
+This option tells @command{ld} that it should not build this table. In this
+case, the script command CREATE_SECINIT_TABLE has no effect.
+
 @kindex --no-undefined
 @kindex -z defs
 @item --no-undefined
@@ -3668,7 +3674,7 @@
 The full description of an output section looks like this:
 @smallexample
 @group
-@var{section} [@var{address}] [(@var{type})] :
+@var{section} [@var{address}] [(@var{type})] [@var{flags}] :
   [AT(@var{lma})]
   [ALIGN(@var{section_align})]
   [SUBALIGN(@var{subsection_align})]
@@ -4194,6 +4200,128 @@
 commands.
 
 @table @code
+@kindex CREATE_SECINIT_TABLE
+@item CREATE_SECINIT_TABLE
+The command tells the linker to create special information used for memory 
+initialization and called the Secinit table. The Secinit table describes
+which memory regions are to be initialized and how.
+
+@smallexample
+MEMORY 
+@{ ROM : ORIGIN = 0x0000, LENGTH = 0x1000 
+  RAM : ORIGIN = 0x1000, LENGTH = 0x1000
+@}
+SECTIONS
+@{
+  .text : @{ *(.text) @} > ROM
+  .secinit : @{ CREATE_SECINIT_TABLE @} > ROM
+  .data : @{ *(.data) @} > RAM
+  .bss : @{ *(.bss) @} > RAM
+@}
+@end smallexample
+
+In this example the linker will put the secinit table content in the .secinit 
+section. The secinit table MUST NOT be placed in a section that is expected to
+be initialized at run-time.
+
+@kindex CREATE_MEMINFO
+@item CREATE_MEMINFO
+The command @code{CREATE_MEMINFO} creates two symbols named
+``__meminfo_start'' and ``__meminfo_end'', and a table where
+entries are in the following format :
+
+@table @asis
+@item origin
+32 bits unsigned
+@item length
+32 bits unsigned
+@item flags
+32 bits unsigned
+@item not_flags
+32 bits unsigned
+@item name
+32 x 8 bits unsigned (not including the terminating '\0' character, but padded
+with trailing '\0' if needed)
+@end table
+
+@ref{MEMORY} describes flags (and the meaning of @code{not_flags}), their values
+can be extracted from the declaration of @code{struct sec} in @file{bfd.h} :
+
+@table @asis
+@item read-only (R)
+0x10
+@item read/write (W)
+0x40
+@item executable (X)
+0x20
+@item allocatable (A)
+0x01
+@item initialized (I or L)
+0x02
+@end table
+
+For instance, this memory description 
+@smallexample
+MEMORY
+@{
+   mem4bss  (w!l) : ORIGIN = 0x00000000, LENGTH = 0x00010000
+   mem4text (xw)  : ORIGIN = 0x40000000, LENGTH = 0x00300000
+@}
+@end smallexample
+will produce these entries :
+@smallexample
+origin    := 0x00000000
+length    := 0x00010000
+flags     := 0x40
+not_flags := 0x02
+name      := 'm' 'e' 'm' '4' 'b' 's' 's' '\0'x25
+
+origin    := 0x40000000
+length    := 0x00300000
+flags     := 0x20 | 0x40
+not_flags := 0x00
+name      := 'm' 'e' 'm' '4' 't' 'e' 'x' 't' '\0'x24
+@end smallexample
+
+This allows loaders and runners to check if the memory description
+(used to create an executable) is compatible with the target.
+
+The following fragment of linker-script is an example for loaders :
+@smallexample
+SECTIONS
+@{
+  [...]
+  .meminfo (NOLOAD) : @{ CREATE_MEMINFO @}
+  [...]
+@}
+@end smallexample
+
+The following fragment of linker-script is an example for runners :
+@smallexample
+SECTIONS
+@{
+  [...]
+  .meminfo : @{ CREATE_MEMINFO @} > data
+  [...]
+@}
+@end smallexample
+
+The following fragment of C code is an example for runners :
+@smallexample
+extern int _meminfo_start;
+extern int _meminfo_end;
+
+int main(void)
+@{
+  return printf("0x%x and 0x%x\n",
+                &_meminfo_start,
+                &_meminfo_end);
+@}
+@end smallexample
+
+Don't forget to use a single leading @code{_} (for C code) and to add @code{&}
+to read the value of the start/end of the memory information.
+
 @kindex CREATE_OBJECT_SYMBOLS
 @cindex input filename symbols
 @cindex filename symbols
@@ -4305,7 +4433,7 @@
 
 @smallexample
 @group
-@var{section} [@var{address}] [(@var{type})] :
+@var{section} [@var{address}] [(@var{type})] [@var{flags}] :
   [AT(@var{lma})]
   [ALIGN(@var{section_align})]
   [SUBALIGN(@var{subsection_align})]
@@ -4324,6 +4452,7 @@
 
 @menu
 * Output Section Type::		Output section type
+* Output Section Flags::       Output section type
 * Output Section LMA::		Output section LMA
 * Forced Output Alignment::	Forced Output Alignment
 * Forced Input Alignment::	Forced Input Alignment
@@ -4369,6 +4498,40 @@
 @end group
 @end smallexample
 
+@node Output Section Flags
+@subsubsection Output section Flags
+Each output section may have flags. The following flags are defined:
+
+@table @code
+@item NOINIT
+The section should be marked as not initialized, so that no entry will be put
+in the section information table in order to initialize the section at runtime.
+@item CLEAR
+The section should be marked as a clear section, so that the section content 
+will be filled with 0 at startup. However, this flag does not imply NOBITS flag
+for the section.
+@item NOBITS
+The output section will be marked as nobits, i.e. the output section will 
+contain no data and it will take no place in the output file. The linker will
+emit a warning message if an input section containing data is placed in an 
+output section marked as NOBITS. In this case, the flag of the output section 
+will not be changed and the NOBITS flag will be ignored.
+@item MAX_ENDADDRESS(exp)
+Check wether a section does not go over a maximum address specified by the 
+expression exp. If the last address of a section is greater than the value 
+of exp, the linker will emit an error. The expression exp does not allow the 
+use of the dot '.' symbol.
+@item PAD(exp)
+The PAD flag is a shortcut to specify a NOBITS section of size exp.
+@smallexample
+  .heap PAD(24k) : @{  @} > RAM
+
+is equivalent to :
+
+ .heap NOBITS :  @{ . += 24K;  @} > RAM
+@end smallexample
+@end table
+
 @node Output Section LMA
 @subsubsection Output Section LMA
 @kindex AT>@var{lma_region}
diff -r -N -u binutils-2.21.51/ld/ldver.c binutils/ld/ldver.c
--- binutils-2.21.51/ld/ldver.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/ld/ldver.c	2011-07-06 12:44:26.137253000 +0100
@@ -31,6 +31,7 @@
 #include "ldfile.h"
 #include "ldemul.h"
 #include "ldmain.h"
+#include "ST_version.h"
 
 void
 ldversion (int noisy)
@@ -58,4 +59,6 @@
 	  ptr++;
 	}
     }
+  printf (_("STMicroelectronics ld: Version %s %s\n"),
+	  ST_BINUTILS_VERSION, ST_BINUTILS_VERSION_DATE);
 }
diff -r -N -u binutils-2.21.51/ld/lexsup.c binutils/ld/lexsup.c
--- binutils-2.21.51/ld/lexsup.c	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/lexsup.c	2011-07-06 12:44:26.137253000 +0100
@@ -175,6 +175,22 @@
   OPTION_PLUGIN_OPT,
 #endif /* ENABLE_PLUGINS */
   OPTION_DEFAULT_SCRIPT,
+  OPTION_NO_SECINFO_TABLE,
+  OPTION_NO_DECOMPRESSION_CODE,
+  OPTION_RESOLVE_PCREL_RELOCS,
+#ifdef IPA_LINK
+  OPTION_KEEP,
+  OPTION_SHOW,
+  OPTION_IPA,
+  OPTION_DEFAULT_GROUP,
+  OPTION_IPA_GROUP,
+  OPTION_INLINE_GROUP,
+  OPTION_INTERNAL_GROUP,
+  OPTION_AR_MEMBERS,
+  OPTION_IPACOM,
+  OPTION_OPT_GROUP,
+  OPTION_TENV_GROUP
+#endif
 };
 
 /* The long options.  This structure is used for both the option
@@ -609,6 +625,54 @@
     TWO_DASHES },
   { {"wrap", required_argument, NULL, OPTION_WRAP},
     '\0', N_("SYMBOL"), N_("Use wrapper functions for SYMBOL"), TWO_DASHES },
+
+  { {"no-secinit-table", no_argument, NULL, OPTION_NO_SECINFO_TABLE},
+      '\0', NULL, N_("Don't generate section initialization table"),
+      TWO_DASHES },
+
+  { {"no-decompression-code", no_argument, NULL, OPTION_NO_DECOMPRESSION_CODE},
+      '\0', NULL, N_("Don't pull decompression code inside the generated binary"),
+      TWO_DASHES },
+
+  { {"resolve-pcrel-relocs", no_argument, NULL, OPTION_RESOLVE_PCREL_RELOCS},
+      '\0', NULL, N_("Resolve pc-relative relocations against local symbols"),
+      TWO_DASHES }
+
+#ifdef IPA_LINK
+    ,
+  { {"ipa", no_argument, NULL, OPTION_IPA},
+      '\0', NULL, "Use Inter Procedural Analysis", TWO_DASHES },
+
+  { {"show", no_argument, NULL, OPTION_SHOW},
+      '\0', NULL, "If IPA then show phases, otherwise unused", ONE_DASH },
+
+  { {"keep", no_argument, NULL, OPTION_KEEP},
+      '\0', NULL, "Don't delete intermediate files", TWO_DASHES },
+
+  { {"DEFAULT", no_argument, NULL, OPTION_DEFAULT_GROUP},
+      '\0', NULL, "Message about xxxxxx", TWO_DASHES },
+
+  { {"IPA:", no_argument, NULL, OPTION_IPA_GROUP},
+      '\0', NULL, "Options passed to IPA", TWO_DASHES },
+
+  { {"INLINE:", no_argument, NULL, OPTION_INLINE_GROUP},
+      '\0', NULL, "Options passed to inliner during ipa phase", TWO_DASHES },
+
+  { {"INTERNAL:", no_argument, NULL, OPTION_INTERNAL_GROUP},
+      '\0', NULL, "Non-user options passed to the backend during ipa phase", TWO_DASHES },
+
+  { {"ar_members", required_argument, NULL, OPTION_AR_MEMBERS},
+      '\0', NULL, "Designates specific objects within an archive", TWO_DASHES },
+
+  { {"ipacom", no_argument, NULL, OPTION_IPACOM},
+      '\0', NULL, "Message about xxxxxx", TWO_DASHES },
+
+  { {"OPT:", no_argument, NULL, OPTION_OPT_GROUP},
+      '\0', NULL, "Optimization options passed to backend during ipa phase", TWO_DASHES },
+
+  { {"TENV:", no_argument, NULL, OPTION_TENV_GROUP},
+      '\0', NULL, "Target environment options passed to backend during ipa phase", TWO_DASHES }
+#endif
 };
 
 #define OPTION_COUNT ARRAY_SIZE (ld_options)
@@ -1510,6 +1574,27 @@
 	  ingroup--;
 	  break;
 
+#ifdef IPA_LINK
+	  /* These are options that just get passed to ipa */
+        case OPTION_KEEP:
+        case OPTION_DEFAULT_GROUP:
+        case OPTION_IPA_GROUP:
+        case OPTION_INLINE_GROUP:
+        case OPTION_INTERNAL_GROUP:
+        case OPTION_IPACOM:
+        case OPTION_OPT_GROUP:
+        case OPTION_TENV_GROUP:
+        case OPTION_IPA:
+        case OPTION_SHOW:
+          break;
+
+        case OPTION_AR_MEMBERS:
+          lang_add_input_file ( optarg,
+                                lang_input_file_is_file_enum,
+                                (char *) NULL);
+          break;
+#endif
+
 	case OPTION_INIT:
 	  link_info.init_function = optarg;
 	  break;
@@ -1518,6 +1603,20 @@
 	  link_info.fini_function = optarg;
 	  break;
 
+       case OPTION_NO_SECINFO_TABLE:
+         config.build_secinfo_table = FALSE;
+         break;
+
+	case OPTION_NO_DECOMPRESSION_CODE:
+	  config.get_decompression_code = FALSE;
+	  break;
+
+	  /* TB: Add option to resolved PC relative relocation against
+	     local symbol */
+	case OPTION_RESOLVE_PCREL_RELOCS:
+	  link_info.relocatable_with_pcrel_resolved = TRUE;
+	  break;
+
 	case OPTION_REDUCE_MEMORY_OVERHEADS:
 	  link_info.reduce_memory_overheads = TRUE;
 	  if (config.hash_table_size == 0)
diff -r -N -u binutils-2.21.51/ld/Makefile.am binutils/ld/Makefile.am
--- binutils-2.21.51/ld/Makefile.am	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/Makefile.am	2011-07-06 12:44:26.137253000 +0100
@@ -451,7 +451,9 @@
 	ew65.c \
 	ez80.c \
 	ez8001.c \
-	ez8002.c
+	ez8002.c \
+	eelf32_lx.c \
+        eelf32_lx_linux.c
 
 ALL_EMULATIONS = $(ALL_EMULATION_SOURCES:.c=.@OBJEXT@)
 
@@ -498,12 +500,14 @@
 CFILES = ldctor.c ldemul.c ldexp.c ldfile.c ldlang.c \
 	ldmain.c ldmisc.c ldver.c ldwrite.c lexsup.c \
 	mri.c ldcref.c pe-dll.c pep-dll.c ldlex-wrapper.c \
-	$(PLUGIN_C)
+	$(PLUGIN_C) \
+	ipa_ld.c ipa_cmdline.c \
 
 HFILES = ld.h ldctor.h ldemul.h ldexp.h ldfile.h \
 	ldlang.h ldlex.h ldmain.h ldmisc.h ldver.h \
 	ldwrite.h mri.h deffile.h pe-dll.h pep-dll.h \
-	elf-hints-local.h $(PLUGIN_H)
+	elf-hints-local.h $(PLUGIN_H) \
+	ipa_ld.h ipa_cmdline.h
 
 GENERATED_CFILES = ldgram.c ldlex.c deffilep.c
 GENERATED_HFILES = ldgram.h ldemul-list.h deffilep.h
@@ -515,7 +519,8 @@
 OFILES = ldgram.@OBJEXT@ ldlex-wrapper.@OBJEXT@ lexsup.@OBJEXT@ ldlang.@OBJEXT@ \
 	mri.@OBJEXT@ ldctor.@OBJEXT@ ldmain.@OBJEXT@ $(PLUGIN_OBJECT) \
 	ldwrite.@OBJEXT@ ldexp.@OBJEXT@  ldemul.@OBJEXT@ ldver.@OBJEXT@ ldmisc.@OBJEXT@ \
-	ldfile.@OBJEXT@ ldcref.@OBJEXT@ ${EMULATION_OFILES} ${EMUL_EXTRA_OFILES}
+	ldfile.@OBJEXT@ ldcref.@OBJEXT@ ${EMULATION_OFILES} ${EMUL_EXTRA_OFILES} \
+	ipa_ld.@OBJEXT@ ipa_cmdline.@OBJEXT@
 
 STAGESTUFF = *.@OBJEXT@ ldscripts/* e*.c
 
@@ -852,6 +857,14 @@
 eelf32_i960.c: $(srcdir)/emulparams/elf32_i960.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32_i960 "$(tdir_elf32_i960)"
+eelf32_lx.c: $(srcdir)/emulparams/elf32_lx.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/lxelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_lx "$(tdir_elf32_lx)"
+eelf32_lx_linux.c: $(srcdir)/emulparams/elf32_lx_linux.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/lxelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_lx_linux "$(tdir_elf32_lx_linux)"
 eelf32_sparc.c: $(srcdir)/emulparams/elf32_sparc.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32_sparc "$(tdir_elf32_sparc)"
@@ -2010,7 +2023,8 @@
 EXTRA_ld_new_SOURCES += pep-dll.c pe-dll.c
 
 ld_new_SOURCES = ldgram.y ldlex-wrapper.c lexsup.c ldlang.c mri.c ldctor.c ldmain.c \
-	ldwrite.c ldexp.c ldemul.c ldver.c ldmisc.c ldfile.c ldcref.c $(PLUGIN_C)
+	ldwrite.c ldexp.c ldemul.c ldver.c ldmisc.c ldfile.c ldcref.c $(PLUGIN_C) \
+	ipa_cmdline.c ipa_ld.c
 ld_new_DEPENDENCIES = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $(LIBINTL_DEP)
 ld_new_LDADD = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $(LIBINTL)
 
@@ -2028,7 +2042,7 @@
 	runtest=$(RUNTEST); \
 	if $(SHELL) -c "$$runtest --version" > /dev/null 2>&1; then \
 	  $$runtest --tool $(DEJATOOL) --srcdir $${srcroot}/testsuite \
-		CC="$(CC_FOR_TARGET)" CFLAGS="$(CFLAGS)" \
+		CC="$(CC_FOR_TARGET)" CFLAGS="$(FLAGS_FOR_TARGET)" \
 		CXX="$(CXX_FOR_TARGET)" CXXFLAGS="$(CXXFLAGS)" \
 		CC_FOR_HOST="$(CC)" CFLAGS_FOR_HOST="$(CFLAGS)" \
 		OFILES="$(OFILES)" BFDLIB="$(TESTBFDLIB)" \
@@ -2038,6 +2052,30 @@
 	else echo "WARNING: could not find \`runtest'" 1>&2; :;\
 	fi
 
+site.exp: Makefile
+	@echo 'Making a new site.exp file...'
+	@test ! -f site.bak || rm -f site.bak
+	@echo '## these variables are automatically generated by make ##' > $@-t
+	@echo '# Do not edit here.  If you wish to override these values' >> $@-t
+	@echo '# edit the last section' >> $@-t
+	@echo 'set tool $(DEJATOOL)' >> $@-t
+	@echo 'set srcdir $(srcdir)' >> $@-t
+	@echo 'set objdir' `pwd` >> $@-t
+	@echo 'set host_alias $(host_alias)' >> $@-t
+	@echo 'set host_triplet $(host_triplet)' >> $@-t
+	@echo 'set target_alias $(target_alias)' >> $@-t
+	@echo 'set target_triplet $(target_triplet)' >> $@-t
+	@echo 'set build_alias $(build_alias)' >> $@-t
+	@echo 'set build_triplet $(build_triplet)' >> $@-t
+	@echo 'set target_list ${target_alias}' >> $@-t
+	@echo 'set boards_dir ${srcdir}/../boards' >> $@-t
+	@echo 'set SIM "$(SIM)"' >> $@-t
+	@echo 'set CC_FOR_TARGET "$(CC_FOR_TARGET)"' >> $@-t
+	@echo '## All variables above are generated by configure. Do Not Edit ##' >> $@-t
+	@test ! -f site.exp || sed '1,/^## All variables above are.*##/ d' site.exp >> $@-t
+	@test ! -f site.exp || mv site.exp site.bak
+	@mv $@-t site.exp
+
 # Rules for testing by relinking ld itself.
 # A similar test is in the testsuite.  This target is for ease of use
 # when porting ld.
diff -r -N -u binutils-2.21.51/ld/Makefile.in binutils/ld/Makefile.in
--- binutils-2.21.51/ld/Makefile.in	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/Makefile.in	2011-07-06 12:44:26.137253000 +0100
@@ -90,7 +90,33 @@
 	ldctor.$(OBJEXT) ldmain.$(OBJEXT) ldwrite.$(OBJEXT) \
 	ldexp.$(OBJEXT) ldemul.$(OBJEXT) ldver.$(OBJEXT) \
 	ldmisc.$(OBJEXT) ldfile.$(OBJEXT) ldcref.$(OBJEXT) \
-	$(am__objects_1)
+	$(am__objects_1) \
+	ipa_cmdline.$(OBJEXT) ipa_ld.$(OBJEXT)
+
+# Specific cases for OPEN64 IPA support on Cygwin and Linux
+ld_new_LDFLAGS_cygwin_st200 = `                \
+  case "@host@" in                     \
+    *-*-cygwin*)                       \
+    case "@target@" in                 \
+      lx-*-elf32)                      \
+        echo "-Wl,--stack,9437184"     \
+        ;;                             \
+    esac                               \
+    ;;                                 \
+  esac`
+
+ld_new_LDFLAGS_linux_st200 = `         \
+  case "@host@" in                     \
+    *-*-linux*)                                \
+    case "@target@" in                 \
+      lx-*-elf32)                      \
+        echo "-ldl"                    \
+        ;;                             \
+    esac                               \
+    ;;                                 \
+  esac`
+ld_new_LDFLAGS += $(ld_new_LDFLAGS_cygwin_st200) $(ld_new_LDFLAGS_linux_st200)
+
 ld_new_OBJECTS = $(am_ld_new_OBJECTS)
 am__DEPENDENCIES_1 =
 DEFAULT_INCLUDES = -I.@am__isrc@
@@ -179,6 +205,7 @@
 CATALOGS = @CATALOGS@
 CATOBJEXT = @CATOBJEXT@
 CC = @CC@
+SIM= @SIM@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CPP = @CPP@
@@ -757,7 +784,9 @@
 	ew65.c \
 	ez80.c \
 	ez8001.c \
-	ez8002.c
+	ez8002.c \
+	eelf32_lx.c \
+        eelf32_lx_linux.c
 
 ALL_EMULATIONS = $(ALL_EMULATION_SOURCES:.c=.@OBJEXT@)
 ALL_64_EMULATION_SOURCES = \
@@ -802,12 +831,14 @@
 CFILES = ldctor.c ldemul.c ldexp.c ldfile.c ldlang.c \
 	ldmain.c ldmisc.c ldver.c ldwrite.c lexsup.c \
 	mri.c ldcref.c pe-dll.c pep-dll.c ldlex-wrapper.c \
-	$(PLUGIN_C)
+	$(PLUGIN_C) \
+	ipa_ld.c ipa_cmdline.c
 
 HFILES = ld.h ldctor.h ldemul.h ldexp.h ldfile.h \
 	ldlang.h ldlex.h ldmain.h ldmisc.h ldver.h \
 	ldwrite.h mri.h deffile.h pe-dll.h pep-dll.h \
-	elf-hints-local.h $(PLUGIN_H)
+	elf-hints-local.h $(PLUGIN_H) \
+	ipa_ld.h ipa_cmdline.h
 
 GENERATED_CFILES = ldgram.c ldlex.c deffilep.c
 GENERATED_HFILES = ldgram.h ldemul-list.h deffilep.h
@@ -818,7 +849,8 @@
 OFILES = ldgram.@OBJEXT@ ldlex-wrapper.@OBJEXT@ lexsup.@OBJEXT@ ldlang.@OBJEXT@ \
 	mri.@OBJEXT@ ldctor.@OBJEXT@ ldmain.@OBJEXT@ $(PLUGIN_OBJECT) \
 	ldwrite.@OBJEXT@ ldexp.@OBJEXT@  ldemul.@OBJEXT@ ldver.@OBJEXT@ ldmisc.@OBJEXT@ \
-	ldfile.@OBJEXT@ ldcref.@OBJEXT@ ${EMULATION_OFILES} ${EMUL_EXTRA_OFILES}
+	ldfile.@OBJEXT@ ldcref.@OBJEXT@ ${EMULATION_OFILES} ${EMUL_EXTRA_OFILES} \
+	ipa_ld.@OBJEXT@ ipa_cmdline.@OBJEXT@
 
 STAGESTUFF = *.@OBJEXT@ ldscripts/* e*.c
 
@@ -840,7 +872,8 @@
 EXTRA_ld_new_SOURCES = deffilep.y ldlex.l pep-dll.c pe-dll.c \
 	$(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES)
 ld_new_SOURCES = ldgram.y ldlex-wrapper.c lexsup.c ldlang.c mri.c ldctor.c ldmain.c \
-	ldwrite.c ldexp.c ldemul.c ldver.c ldmisc.c ldfile.c ldcref.c $(PLUGIN_C)
+	ldwrite.c ldexp.c ldemul.c ldver.c ldmisc.c ldfile.c ldcref.c $(PLUGIN_C) \
+	ipa_cmdline.c ipa_ld.c
 
 ld_new_DEPENDENCIES = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $(LIBINTL_DEP)
 ld_new_LDADD = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $(LIBINTL)
@@ -1402,6 +1435,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pe-dll.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pep-dll.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/plugin.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ipa_cmdline.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ipa_ld.Po@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
@@ -1756,25 +1791,6 @@
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-site.exp: Makefile
-	@echo 'Making a new site.exp file...'
-	@echo '## these variables are automatically generated by make ##' >site.tmp
-	@echo '# Do not edit here.  If you wish to override these values' >>site.tmp
-	@echo '# edit the last section' >>site.tmp
-	@echo 'set srcdir $(srcdir)' >>site.tmp
-	@echo "set objdir `pwd`" >>site.tmp
-	@echo 'set build_alias "$(build_alias)"' >>site.tmp
-	@echo 'set build_triplet $(build_triplet)' >>site.tmp
-	@echo 'set host_alias "$(host_alias)"' >>site.tmp
-	@echo 'set host_triplet $(host_triplet)' >>site.tmp
-	@echo 'set target_alias "$(target_alias)"' >>site.tmp
-	@echo 'set target_triplet $(target_triplet)' >>site.tmp
-	@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp
-	@test ! -f site.exp || \
-	  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp
-	@-rm -f site.bak
-	@test ! -f site.exp || mv site.exp site.bak
-	@mv site.tmp site.exp
 
 distclean-DEJAGNU:
 	-rm -f site.exp site.bak
@@ -2303,6 +2319,14 @@
 eelf32_sparc.c: $(srcdir)/emulparams/elf32_sparc.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32_sparc "$(tdir_elf32_sparc)"
+eelf32_lx.c: $(srcdir)/emulparams/elf32_lx.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/lxelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_lx "$(tdir_elf32_lx)"
+eelf32_lx_linux.c: $(srcdir)/emulparams/elf32_lx_linux.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/lxelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_lx_linux "$(tdir_elf32_lx_linux)"
 eelf32_sparc_sol2.c: $(srcdir)/emulparams/elf32_sparc_sol2.sh \
   $(srcdir)/emulparams/elf32_sparc.sh \
   $(srcdir)/emulparams/solaris2.sh \
@@ -3460,7 +3484,7 @@
 	runtest=$(RUNTEST); \
 	if $(SHELL) -c "$$runtest --version" > /dev/null 2>&1; then \
 	  $$runtest --tool $(DEJATOOL) --srcdir $${srcroot}/testsuite \
-		CC="$(CC_FOR_TARGET)" CFLAGS="$(CFLAGS)" \
+		CC="$(CC_FOR_TARGET)" CFLAGS="$(FLAGS_FOR_TARGET)" \
 		CXX="$(CXX_FOR_TARGET)" CXXFLAGS="$(CXXFLAGS)" \
 		CC_FOR_HOST="$(CC)" CFLAGS_FOR_HOST="$(CFLAGS)" \
 		OFILES="$(OFILES)" BFDLIB="$(TESTBFDLIB)" \
@@ -3470,6 +3494,30 @@
 	else echo "WARNING: could not find \`runtest'" 1>&2; :;\
 	fi
 
+site.exp: Makefile
+	@echo 'Making a new site.exp file...'
+	@test ! -f site.bak || rm -f site.bak
+	@echo '## these variables are automatically generated by make ##' > $@-t
+	@echo '# Do not edit here.  If you wish to override these values' >> $@-t
+	@echo '# edit the last section' >> $@-t
+	@echo 'set tool $(DEJATOOL)' >> $@-t
+	@echo 'set srcdir $(srcdir)' >> $@-t
+	@echo 'set objdir' `pwd` >> $@-t
+	@echo 'set host_alias $(host_alias)' >> $@-t
+	@echo 'set host_triplet $(host_triplet)' >> $@-t
+	@echo 'set target_alias $(target_alias)' >> $@-t
+	@echo 'set target_triplet $(target_triplet)' >> $@-t
+	@echo 'set build_alias $(build_alias)' >> $@-t
+	@echo 'set build_triplet $(build_triplet)' >> $@-t
+	@echo 'set target_list ${target_alias}' >> $@-t
+	@echo 'set boards_dir ${srcdir}/../boards' >> $@-t
+	@echo 'set SIM "$(SIM)"' >> $@-t
+	@echo 'set CC_FOR_TARGET "$(CC_FOR_TARGET)"' >> $@-t
+	@echo '## All variables above are generated by configure. Do Not Edit ##' >> $@-t
+	@test ! -f site.exp || sed '1,/^## All variables above are.*##/ d' site.exp >> $@-t
+	@test ! -f site.exp || mv site.exp site.bak
+	@mv $@-t site.exp
+
 # Rules for testing by relinking ld itself.
 # A similar test is in the testsuite.  This target is for ease of use
 # when porting ld.
diff -r -N -u binutils-2.21.51/ld/mri.c binutils/ld/mri.c
--- binutils-2.21.51/ld/mri.c	2011-04-13 08:41:36.000000000 +0100
+++ binutils/ld/mri.c	2011-07-06 12:44:26.137253000 +0100
@@ -208,6 +208,7 @@
 
 	  lang_enter_output_section_statement (p->name, base,
 					       p->ok_to_load ? normal_section : noload_section,
+					       SECATTR_NOFLAGS, NULL, NULL,
 					       align, subalign, NULL, 0);
 	  base = 0;
 	  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
diff -r -N -u binutils-2.21.51/ld/scripttempl/elflx.sc binutils/ld/scripttempl/elflx.sc
--- binutils-2.21.51/ld/scripttempl/elflx.sc	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/scripttempl/elflx.sc	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,438 @@
+### THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+
+###
+### (c) Copyright Hewlett-Packard Company 1999-2003
+### 
+### This program is free software; you can redistribute it and/or
+### modify it under the terms of the GNU General Public License
+### as published by the Free Software Foundation; either version
+### 2 of the License, or (at your option) any later version.
+###
+### This program is distributed in the hope that it will be useful,
+### but WITHOUT ANY WARRANTY; without even the implied warranty of
+### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+### General Public License for more details.
+### 
+### You should have received a copy of the GNU General Public License
+### along with this program; if not, write to the Free Software
+### Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+###
+
+###
+### Linker script for LX emulatory
+### Author: Geoffrey Brown
+### Modified by: Giuseppe Desoli HPLC Cambridge May 1999
+###
+
+### 
+### static char sccs_id[] = "@(#)elflx.sc	1.19 11/10/00 15:43:02";
+### 
+
+MEMDEF="
+/*
+ * Set up memory
+ */
+/*
+* MEMORY
+* {
+*  reset_flash	: ORIGIN = 0x0, LENGTH = 4K
+*  boot		: ORIGIN = 0x1000, LENGTH = 64K
+*  ram		: ORIGIN = 0x8000000, LENGTH = 32M
+* }
+*/ "
+
+BOOTSECS="
+  /*==============*/
+  /* boot section */
+  /*==============*/
+   ${RELOCATING+/* Use  RESET_ADDRESS if it has been specified (on command line) */
+   RESET_ADDRESS = DEFINED(RESET_ADDRESS) ? RESET_ADDRESS : 0;}
+   .boot_reset   ${RELOCATING-0} ${RELOCATING+ RESET_ADDRESS} :
+	 {
+	   *(.boot_reset)
+	   ${RELOCATING+. = ALIGN(8);}
+           ${RELOCATING+_eboot_reset = .;}
+	 } ${RELOCATING+/* @> reset_flash@ */ }
+
+    ${RELOCATING+/* Use BOOT_ADDRESS if it has been specified (on command line) */
+    BOOT_ADDRESS = DEFINED(BOOT_ADDRESS) ? BOOT_ADDRESS : 0x1000;}
+    .boot   ${RELOCATING-0} ${RELOCATING+ BOOT_ADDRESS} :
+         {
+           *(.boot)
+	   ${RELOCATING+. = ALIGN(8);}
+           ${RELOCATING+_eboot = .;}
+         } ${RELOCATING+/* @> boot@ */ }
+
+"
+TEXT_SECTION="
+   ${RELOCATING+/* Use TEXT_BASE if it has been specified (on command line) */ 
+   TEXT_BASE = DEFINED(TEXT_BASE) ? TEXT_BASE : 0x08000000;}
+   .text   ${RELOCATING-0} ${RELOCATING+ TEXT_BASE} :"
+
+TEXT_SECTION_CRYPTO="
+  ${RELOCATING+/* Use TEXT_BASE if it has been specified (on command line) */
+  TEXT_BASE = DEFINED(TEXT_BASE) ? TEXT_BASE : 0x08000000;
+
+  /* *** Alignment support *** */
+  /* This will force alignment to a 32 byte boundary
+  if _text_align is defined to be 0x20 */
+  _text_align = (DEFINED(_text_align) ? _text_align : 0x1);
+  /* *** End Alignment support *** */
+  . = TEXT_BASE;}
+  .text ${RELOCATING-0} ${RELOCATING+ALIGN(_text_align)} :
+"
+TEXT_SECTION_SHLIB="
+  ${CREATE_SHLIB+.text :}
+"
+
+TEXT_SECTION_SHLIB_CRYPTO="
+  /* *** Alignment support *** */
+  /* This will force alignment to a 32 byte boundary
+  if _text_align is defined to be 0x20 */
+  _text_align = (DEFINED(_text_align) ? _text_align : 0x1);
+  /* *** End Alignment support *** */
+
+  .text ALIGN(_text_align):
+"
+
+CRYPTO_TEXT_SECTION_END_ALIGN="
+    /* Ensure the end of each text-like section is at least 
+    on a word boundary if we are going to
+    have a .post_text_reserve section */
+    . = (DEFINED(_post_text_reserve) ? ALIGN(4) : .);
+"
+CRYPTO_POST_TEXT_RES="
+  __etext = .;
+
+  /* *** Alignment support *** */
+  /* This will reserve a number of bytes after the text sections in a new
+     section. */
+  .post_text_reserve :
+  {
+    ${CREATE_SHLIB+_post_text_res = (DEFINED(_post_text_reserve) ? ABSOLUTE(_post_text_reserve) : 0);
+    . += _post_text_res;}
+    ${CREATE_SHLIB-_post_text_reserve = (DEFINED(_post_text_reserve) ? _post_text_reserve : 0);
+    . += _post_text_reserve;}
+  } /* @> ram@ */ = 0xDEADADDA
+  /* *** End Alignment support *** */
+"
+RODATA_SECTION="
+  /*=============*/
+  /* rodata section */
+  /*=============*/
+   .rodata ${RELOCATING-0} :
+"
+
+RODATA_SECTION_CRYPTO="
+  ${RELOCATING+/* *** Alignment support *** */
+  /* This will force alignment to a 32 byte boundary
+  if _rodata_align is defined to be 0x20 */
+  _rodata_align = (DEFINED(_rodata_align) ? _rodata_align : 8);
+  /* *** End Alignment support *** */}
+  /*=============*/
+  /* rodata section */
+  /*=============*/
+   .rodata ${RELOCATING-0} ${RELOCATING+ALIGN(_rodata_align)} :
+"
+CRYPTO_RODATA_SECTION_END_ALIGN="
+    /* Ensure the end of rodata is at least on a word boundary if we are going to
+       have a .post_rodata_reserve section */
+    . = (DEFINED(_post_rodata_reserve) ? ALIGN(4) : .);
+"
+CRYPTO_POST_RODATA_RES="
+  __erodata = .;
+  /* *** Alignment support *** */
+  /* This will reserve a number of bytes after the rodata sections in a new
+     section. */
+  .post_rodata_reserve :
+  {
+    ${CREATE_SHLIB+_post_rodata_res = (DEFINED(_post_rodata_reserve) ? ABSOLUTE(_post_rodata_reserve) : 0);
+    . += _post_rodata_res;}
+    ${CREATE_SHLIB-_post_rodata_reserve = (DEFINED(_post_rodata_reserve) ? _post_rodata_reserve : 0);
+    . += _post_rodata_reserve;}
+  } /* @> ram@ */ = 0xDEADADDA 
+  /* *** End Alignment support *** */
+"
+
+INTERP="
+   .interp     : { *(.interp) } /* @> ram@ */
+"
+
+DYNHDRS=". = 0 + SIZEOF_HEADERS;"
+
+DYNSEC="
+   /*==============================*/
+   /* dynamic section (read/write) */
+   /*==============================*/
+   .dynamic : {    *(.dynamic) } /* @> ram@ */ "
+
+DYNSECS="
+/*=================================================== */
+/* Dynamic sections. Put into text segment (readonly) */
+/*=================================================== */
+   ${CREATE_SHLIB-${RELOCATING+${INTERP}}}
+   .hash       : { *(.hash) } /* @> ram@ */
+   .dynsym     : { *(.dynsym) } /* @> ram@ */
+   .dynstr     : { *(.dynstr) } /* @> ram@ */
+   .rel.dyn    :
+        {
+          *(.rel.init)
+          *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)
+          *(.rel.fini)
+          *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)
+          *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)
+          *(.rel.ctors)
+          *(.rel.dtors)
+          *(.rel.rtos.ctors)
+          *(.rel.rtos.dtors)
+          *(.rel.got)
+          *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)
+        }  /* @> ram@ */
+   .rela.dyn   :
+        {
+          *(.rela.init)
+          *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)
+          *(.rela.fini)
+          *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)
+          *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)
+          *(.rela.ctors)
+          *(.rela.dtors)
+          *(.rela.rtos.ctors)
+          *(.rela.rtos.dtors)
+          *(.rela.got)
+          *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)
+        } /* @> ram@ */
+   .rel.plt    : { *(.rel.plt) } /* @> ram@ */
+   .rela.plt   : { *(.rela.plt) } /* @> ram@ */ "
+
+
+
+cat << EOF
+OUTPUT_FORMAT("${OUTPUT_FORMAT}", "${BIG_OUTPUT_FORMAT}", "${LITTLE_OUTPUT_FORMAT}")
+OUTPUT_ARCH(${ARCH})
+ENTRY(__start)
+
+${CREATE_SHLIB-${RELOCATING+${MEMDEF}}}
+
+${RELOCATING+
+/* import board mapping definition using search rule -L$BOARDDIR */
+/* @INCLUDE board.ld@ */
+/* import soc mapping definition using search rule -L$SOCDIR */
+/* @INCLUDE soc.ld@ */
+/* import core mapping definition using search rule -L$COREDIR */
+/* @INCLUDE core.ld@ */
+}
+
+${RELOCATING-
+/* import board mapping definition using search rule -L$BOARDDIR */
+/* @INCLUDE board_r.ld@ */
+/* import soc mapping definition using search rule -L$SOCDIR */
+/* @INCLUDE soc_r.ld@ */
+/* import core mapping definition using search rule -L$COREDIR */
+/* @INCLUDE core_r.ld@ */
+}
+
+/*
+ * Define the sections
+ */
+SECTIONS
+
+{
+   ${CREATE_SHLIB-${BOOTSECS}}
+
+   ${CREATE_SHLIB+${DYNHDRS}}
+
+   ${CREATE_SHLIB+${DYNSECS}}
+
+  /*==============*/
+  /* text section */
+  /*==============*/
+
+
+  ${CREATE_SHLIB-${TEXT_SECTION_CRYPTO}}
+  ${CREATE_SHLIB+${TEXT_SECTION_SHLIB_CRYPTO}}
+ 	 {
+           ${RELOCATING+__stext = .;}
+           /*
+            *  The typical boot code behaviour is to jump to the beginning 
+	    *  of the .text section. Be careful that in this case the
+	    *  crt0.o module must be linked in first position.
+	    */
+
+	  ${RELOCATING+. = ALIGN(8);}
+          ${RELOCATING+__text_start = .;}
+
+	  ${RELOCATING+CREATE_OBJECT_SYMBOLS}
+	  *(.text)
+	  ${RELOCATING+*(.text.*)}
+
+	  /* .gnu.warning sections are handled specially by elf32.em.  */
+	  *(.gnu.warning)
+	  ${RELOCATING+*(.gnu.linkonce.t.*)}
+
+	  ${RELOCATING+. = ALIGN(8);}
+          ${RELOCATING+_etext = .;}
+        } ${RELOCATING+/* @> ram@ */ = ${NOP-0}}
+
+   .plt ${RELOCATING-0}  : 
+        {
+	 *(.plt)
+	 ${RELOCATING+${CRYPTO_TEXT_SECTION_END_ALIGN}}
+	} ${RELOCATING+/* @> ram@ */ = 0}
+
+  /*=============*/
+  /* .init section */
+  /*=============*/
+
+   .init ${RELOCATING-0} :
+	{
+	  KEEP (*(.init))
+	  ${RELOCATING+${CRYPTO_TEXT_SECTION_END_ALIGN}}
+        } ${RELOCATING+/* @> ram@ */ = ${NOP-0}}
+
+  /*=============*/
+  /* .finit section */
+  /*=============*/
+
+   .fini ${RELOCATING-0} :
+	{
+	  KEEP (*(.fini))
+	  ${RELOCATING+${CRYPTO_TEXT_SECTION_END_ALIGN}}
+        } ${RELOCATING+/* @> ram@ */ = ${NOP-0}}
+
+   ${RELOCATING+${CRYPTO_POST_TEXT_RES}}
+
+   ${RODATA_SECTION_CRYPTO}
+       {
+        ${RELOCATING+__srodata = .;}
+
+	*(.rodata)
+	${RELOCATING+*(.rodata.*)}
+	${RELOCATING+*(.gnu.linkonce.r.*)}
+	${RELOCATING+${CRYPTO_RODATA_SECTION_END_ALIGN}}
+       } ${RELOCATING+/* @> ram@ */ = 0 }
+
+   ${RELOCATING+${CRYPTO_POST_RODATA_RES}}
+
+  /*==============================*/
+  /* exceptions tables */
+  /*==============================*/
+  .except_table ${RELOCATING-0} : 
+       { 
+        *(.except_table)
+       } ${RELOCATING+/* @> ram@ */ }
+
+  /DISCARD/  : { ${RELOCATING+*(.except_table_supp);} } 
+
+  .eh_frame ${RELOCATING-0} :
+       {
+        ${RELOCATING+ . = ALIGN(4);}
+        KEEP(*(.eh_frame))
+       } ${RELOCATING+/* @> ram@ */ }
+
+  /*==============*/
+  /* ctors section */
+  /*==============*/
+   .ctors ${RELOCATING-0} :
+       {
+        KEEP (*(.ctors))
+       } ${RELOCATING+/* @> ram@ */ }
+
+  /*==============*/
+  /* dtors section */
+  /*==============*/
+   .dtors ${RELOCATING-0} :
+       {
+        KEEP (*(.dtors))
+       } ${RELOCATING+/* @> ram@ */ }
+
+  /*====================*/
+  /* .rtos.ctors section */
+  /*====================*/
+   .rtos.ctors ${RELOCATING-0} :
+       {
+	PROVIDE(__rtos_ctors = .);
+        KEEP (*(.rtos.ctors))
+	PROVIDE(__rtos_ctors_end = .);
+       } ${RELOCATING+/* @> ram@ */ }
+
+  /*====================*/
+  /* .rtos.dtors section */
+  /*====================*/
+   .rtos.dtors ${RELOCATING-0} :
+       {
+	PROVIDE(__rtos_dtors = .);
+        KEEP (*(.rtos.dtors))
+	PROVIDE(__rtos_dtors_end = .);
+       } ${RELOCATING+/* @> ram@ */ }
+
+   ${CREATE_SHLIB-${RELOCATING+${DYNSECS}}}
+
+  /*==============*/
+  /* data section */
+  /*==============*/
+
+   .data ${RELOCATING-0} :
+        {	
+          ${RELOCATING+. = ALIGN(4);}
+          ${RELOCATING+_data_start = .;}
+	  *(.data)
+	  ${RELOCATING+*(.data.*)}
+	  ${RELOCATING+*(.gnu.linkonce.d.*)}
+          ${RELOCATING+*(.got.plt)}
+          ${RELOCATING+*(.got)}
+          ${RELOCATING+. = ALIGN(4);}
+          ${RELOCATING+_edata = .;}
+        } ${RELOCATING+/* @> ram@ */ }
+
+   ${RELOCATING+${DYNSEC}}
+
+  /*=============*/
+  /* bss section */
+  /*=============*/
+
+   .bss ${RELOCATING-0} :
+       {
+        ${RELOCATING+. = ALIGN(4);}
+	${RELOCATING+_bss_start = .;}
+	*(.bss)
+	${RELOCATING+*(.bss.*)}
+	${RELOCATING+*(.dynbss)}
+	*(COMMON)
+        ${RELOCATING+*(.gnu.linkonce.b.*)}
+	${RELOCATING+. = ALIGN(4);}
+	${RELOCATING+_ebss = .;}
+	${RELOCATING+_end = .;}
+       } ${RELOCATING+/* @> ram@ */ }
+
+  /* DWARF2 debugging sections */
+  .debug_info       0 : { *(.debug_info) }
+  .debug_line       0 : { *(.debug_line) }
+  .debug_abbrev     0 : { *(.debug_abbrev) }
+  .debug_frame      0 : { *(.debug_frame) }
+  .debug_aranges    0 : { *(.debug_aranges) }
+  .debug_pubnames   0 : { *(.debug_pubnames) }
+  .debug_str        0 : { *(.debug_str) }
+  .debug_funcnames  0 : { *(.debug_funcnames) }
+  .debug_typenames  0 : { *(.debug_typenames) }
+  .debug_varnames   0 : { *(.debug_varnames) }
+  .debug_weaknames  0 : { *(.debug_weaknames) }
+  .debug_macinfo    0 : { *(.debug_macinfo) }
+  .debug_loc        0 : { *(.debug_loc) }
+
+  /* Stabs debugging sections.  */
+
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+  .LX.unwind 0 : { *(.LX.unwind) }
+  .LX.unwind_info 0 : { *(.LX.unwind_info) }		
+
+  /DISCARD/ : { ${RELOCATING+ *(.profile_info);} }
+
+}
+EOF
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-elf/eh5.d binutils/ld/testsuite/ld-elf/eh5.d
--- binutils-2.21.51/ld/testsuite/ld-elf/eh5.d	2010-02-23 12:32:54.000000000 +0000
+++ binutils/ld/testsuite/ld-elf/eh5.d	2010-06-07 14:41:42.080337000 +0100
@@ -1,7 +1,7 @@
 #source: eh5.s
 #source: eh5a.s
 #source: eh5b.s
-#ld:
+#ld: -e _start
 #readelf: -wf
 #target: cfi
 #notarget: alpha* hppa64*
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-elfcomm/elfcomm.exp binutils/ld/testsuite/ld-elfcomm/elfcomm.exp
--- binutils-2.21.51/ld/testsuite/ld-elfcomm/elfcomm.exp	2011-04-13 08:41:36.000000000 +0100
+++ binutils/ld/testsuite/ld-elfcomm/elfcomm.exp	2011-07-06 12:44:26.137253000 +0100
@@ -183,11 +183,20 @@
 
 # Explicitly use "-fcommon" so that even if $CFLAGS includes
 # "-fno-common", these tests are compiled as expected.
+if ![istarget lx-*-*] {
 if {   ![ld_compile "$CC $CFLAGS -fcommon" $srcdir/$subdir/common1a.c tmpdir/common1a.o]
     || ![ld_compile "$CC $CFLAGS -fcommon" $srcdir/$subdir/common1b.c tmpdir/common1b.o] } {
     unresolved $test1
     return
 }
+} else {
+# -fcommon not supported by Open64 for ST2xx
+if {   ![ld_compile "$CC $CFLAGS" $srcdir/$subdir/common1a.c tmpdir/common1a.o]
+    || ![ld_compile "$CC $CFLAGS" $srcdir/$subdir/common1b.c tmpdir/common1b.o] } {
+    unresolved $test1
+    return
+}
+}
 
 global ld
 global link_output
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-gc/gc.c binutils/ld/testsuite/ld-gc/gc.c
--- binutils-2.21.51/ld/testsuite/ld-gc/gc.c	2009-08-14 07:58:38.000000000 +0100
+++ binutils/ld/testsuite/ld-gc/gc.c	2010-06-07 14:41:42.080337000 +0100
@@ -1,6 +1,55 @@
+/* Open64 compiler doesn't yet supports -ffunction-sections. 
+   Use __attribute((section...)) instead */
+#ifdef __open64__
 int unused_var = 7;
 int used_var = 7;
 
+int unused_func (int v) __attribute__((section(".text.unused_func")));
+int used_func (int v) __attribute__((section(".text.used_func")));
+int main (void) __attribute__ ((section(".text.main")));
+void dummy_func (void) __attribute__((section(".text.dummy_func")));
+
+int
+unused_func (int v)
+{
+  return 3 * unused_var;
+}
+
+int
+__attribute__((noinline))
+used_func (int v)
+{
+  return 2 * used_var;
+}
+
+int
+main (void)
+{
+  return used_func (5);
+}
+
+void
+dummy_func (void)
+{
+  /* These are here in case the target prepends an underscore to
+     the start of function names.  They are inside a dummy function
+     so that they will appear at the end of gcc's assembler output,
+     after the definitions of main() and used_func(), rather than
+     at the beginning of the file.  */
+
+  __asm__(".ifndef main\n\
+.global main\n\
+.set main, _main\n\
+.endif");
+
+  __asm__(".ifndef used_func\n\
+.global used_func\n\
+.set used_func, _used_func\n\
+.endif");
+}
+#else /* Original: gcc */
+int used_var = 7;
+
 int
 unused_func (int v)
 {
@@ -39,3 +88,4 @@
 .set used_func, _used_func\n\
 .endif");
 }
+#endif
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-gc/noent.d binutils/ld/testsuite/ld-gc/noent.d
--- binutils-2.21.51/ld/testsuite/ld-gc/noent.d	2008-09-09 14:32:02.000000000 +0100
+++ binutils/ld/testsuite/ld-gc/noent.d	2010-05-25 12:04:31.134734000 +0100
@@ -1,3 +1,3 @@
 # name: --gc-sections -r without -e
-# ld: --gc-sections -r
+# ld: --gc-sections -r -T../ld-scripts/default-script.t
 # error: gc-sections requires either an entry or an undefined symbol
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/aa.exp binutils/ld/testsuite/ld-lx/aa.exp
--- binutils-2.21.51/ld/testsuite/ld-lx/aa.exp	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/aa.exp	2006-09-11 14:24:11.021723000 +0100
@@ -0,0 +1,54 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Copyright (C) 2003 STMicroelectronics, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# dejagnu@gnu.org
+
+if ![istarget lx-*-*] {
+    return
+}
+
+set testsimple "Shared library creation, little-endian"
+
+if ![ld_assemble $as "-EL $srcdir/$subdir/aashared.s" tmpdir/aashared.o] {
+    unresolved $testsimple
+} else { if ![ld_simple_link $ld libaashared.so "-EL -shared tmpdir/aashared.o"] {
+    fail $testsimple
+} else {
+    pass $testsimple
+} }
+
+set testsimple "Shared library creation, big-endian"
+
+if ![ld_assemble $as "-EB $srcdir/$subdir/aashared.s" tmpdir/aashared.o] {
+    unresolved $testsimple
+} else { if ![ld_simple_link $ld libaasharedbig.so "-EB -shared tmpdir/aashared.o"] {
+    fail $testsimple
+} else {
+    pass $testsimple
+} }
+
+set testsimple "Shared library creation, st240"
+
+if ![ld_assemble $as "-mcore=st240 -EL $srcdir/$subdir/aashared.s" tmpdir/aashared.o] {
+    unresolved $testsimple
+} else { if ![ld_simple_link $ld libaasharedst240.so "-EL -shared tmpdir/aashared.o"] {
+    fail $testsimple
+} else {
+    pass $testsimple
+} }
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/aashared.s binutils/ld/testsuite/ld-lx/aashared.s
--- binutils-2.21.51/ld/testsuite/ld-lx/aashared.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/aashared.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,44 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#  Shared library that exports a data symbol foo.
+	.data
+foo:	.long 23
+	.global foo
+	.type foo, @object
+	.size foo, 4
+
+	.weak environ
+	.type eniron,@object
+	.size environ,4
+	environ = __environ
+	.weak _environ
+	.type _environ,@object
+	.size _environ,4
+	_environ = __environ
+	
+__environ:
+	.global __environ
+	.type __environ,@object
+	.size __environ,4
+	.word 0
+
+	.text
+	.proc
+foofun:
+	.global foofun
+	return $r63
+	;;
+	.endp
+
+__tls_get_addr:
+	.global __tls_get_addr
+	.type __tls_get_addr,@function
+	return $r63
+
+	
+	.section .tdata,"awT"
+	.align 4
+tfoo:	.long 42
+	.global tfoo
+	.type foo, @object
+	.size foo, 4
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/combreloc-1a.d binutils/ld/testsuite/ld-lx/combreloc-1a.d
--- binutils-2.21.51/ld/testsuite/ld-lx/combreloc-1a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/combreloc-1a.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,20 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2008
+#comment: Test that orphan reloc sections are merged into .rel.dyn with
+#comment: -z combreloc.
+#source: combreloc-1.s
+#as: -EL
+#ld: -EL -shared -e _start -z combreloc
+#readelf: -r
+#name: combreloc-1a test that dynamic relocation sections are combined with combreloc
+#notarget: *-*-linux*
+
+Relocation section \'\.rela\.dyn\' at offset 0x328 contains 4 entries:
+ Offset     Info    Type            Sym\.Value  Sym\. Name \+ Addend
+00000400  00000e02 R_LX_32           00000368   _start \+ 0
+00000414  00000e02 R_LX_32           00000368   _start \+ 0
+00000418  00000e02 R_LX_32           00000368   _start \+ 0
+0000041c  00000e02 R_LX_32           00000368   _start \+ 0
+
+Relocation section \'\.rela\.plt\' at offset 0x358 contains 1 entries:
+ Offset     Info    Type            Sym\.Value  Sym\. Name \+ Addend
+00000410  00001419 R_LX_JMP_SLOT     00000398   foo \+ 0
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/combreloc-1b.d binutils/ld/testsuite/ld-lx/combreloc-1b.d
--- binutils-2.21.51/ld/testsuite/ld-lx/combreloc-1b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/combreloc-1b.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,25 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2008
+#comment: -z nocombreloc.
+#source: combreloc-1.s
+#as: -EL
+#ld: -EL -shared -e _start -z nocombreloc
+#readelf: -r
+#name: combreloc-1b test that dynamic relocation sections are not combined with nocombreloc
+#notarget: *-*-linux*
+
+Relocation section \'\.rela\.dyn\' at offset 0x328 contains 2 entries:
+ Offset     Info    Type            Sym\.Value  Sym\. Name \+ Addend
+00000400  00000e02 R_LX_32           00000368   _start \+ 0
+00000414  00000e02 R_LX_32           00000368   _start \+ 0
+
+Relocation section \'\.rela__libc_subfreeres\' at offset 0x340 contains 1 entries:
+ Offset     Info    Type            Sym\.Value  Sym\. Name \+ Addend
+00000418  00000e02 R_LX_32           00000368   _start \+ 0
+
+Relocation section \'\.rela__libc_atexit\' at offset 0x34c contains 1 entries:
+ Offset     Info    Type            Sym\.Value  Sym\. Name \+ Addend
+0000041c  00000e02 R_LX_32           00000368   _start \+ 0
+
+Relocation section \'\.rela\.plt\' at offset 0x358 contains 1 entries:
+ Offset     Info    Type            Sym\.Value  Sym\. Name \+ Addend
+00000410  00001419 R_LX_JMP_SLOT     00000398   foo \+ 0
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/combreloc-1.s binutils/ld/testsuite/ld-lx/combreloc-1.s
--- binutils-2.21.51/ld/testsuite/ld-lx/combreloc-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/combreloc-1.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,28 @@
+	.text
+	.globl	_start, foo
+	.type	_start,@function
+_start:
+        stw 8[$r12] = $r63
+        call $r63 = L?.gpinit_0
+         ;;
+L?.gpinit_0:
+        stw 12[$r12] = $r14
+        add $r14 = $r63, @neggprel(L?.gpinit_0)
+        add $r12 = $r12, -8           
+         ;;
+        ldw $r16 = @gotoff(_start)[$r14]
+        call $r63 = foo                 ## foo
+         ;;
+        ldw $r63 = 16[$r12]             ## (sv:$r63)gra_spill_temp_0
+         ;;
+        ldw $r14 = 20[$r12]             ## (sv:$r14)gra_spill_temp_1
+        add $r12 = $r12, 8            
+         ;;
+foo:	return $r63                   
+         ;;
+	.data
+	.long	_start
+	.section "__libc_subfreeres", "aw", @progbits
+	.long	_start
+	.section "__libc_atexit", "aw", @progbits
+	.long	_start
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/dynbss-1.d binutils/ld/testsuite/ld-lx/dynbss-1.d
--- binutils-2.21.51/ld/testsuite/ld-lx/dynbss-1.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/dynbss-1.d	2011-07-11 16:09:11.378539000 +0100
@@ -0,0 +1,33 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: dynbss-1.s
+#as: -EL
+#ld: -EL -e 0x1000 -L. -laashared
+#objdump: -RT
+#name: Shared library symbol allocated in .bss, copy reloc. created
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+DYNAMIC SYMBOL TABLE:
+08000008 g    D  \*ABS\*	00000000 __etext
+08000008 g    D  \.text	00000000 _etext
+08000000 g    D  \.text	00000000 __text_start
+00000008 g    D  \*ABS\*	00000000 _rodata_align
+08000284 g    D  \.bss	00000000 _bss_start
+08000288 g    D  \.bss	00000000 _ebss
+080001f0 g    D  \.data	00000000 _data_start
+08000008 g    D  .*	00000000 __srodata
+08000008 g    D  \*ABS\*	00000000 __erodata
+00000001 g    D  \*ABS\*	00000000 _text_align
+08000000 g    D  \.text	00000000 __stext
+08000284 g    DO \.bss	00000004 foo
+080001fc g    D  \.data	00000000 _edata
+08000288 g    D  \.bss	00000000 _end
+
+
+DYNAMIC RELOCATION RECORDS
+OFFSET   TYPE              VALUE 
+08000284 R_LX_COPY         foo
+
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/dynbss-1.s binutils/ld/testsuite/ld-lx/dynbss-1.s
--- binutils-2.21.51/ld/testsuite/ld-lx/dynbss-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/dynbss-1.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,8 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# An absolute reference from the text of the main program to a symbol
+# in a shared library causes a duplicate of the symbol to be created in
+# the .dynbss section.
+	.text
+	ldw $r3 = foo[$r0]
+	;;
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/dynbss-2.d binutils/ld/testsuite/ld-lx/dynbss-2.d
--- binutils-2.21.51/ld/testsuite/ld-lx/dynbss-2.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/dynbss-2.d	2011-07-11 16:09:11.378539000 +0100
@@ -0,0 +1,48 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: dynbss-2.s
+#as: -EL
+#ld: -EL -e 0x1000 -L. -laashared
+#objdump: -t
+#name: Shared library symbol allocated in .bss, aliases also overridden
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+SYMBOL TABLE:
+08000000 l    d  \.text	00000000 \.text
+08000010 l    d  \.interp	00000000 \.interp
+08000024 l    d  \.hash	00000000 \.hash
+0800007c l    d  \.dynsym	00000000 \.dynsym
+0800018c l    d  \.dynstr	00000000 \.dynstr
+08000220 l    d  \.rela\.dyn	00000000 \.rela\.dyn
+08000238 l    d  \.data	00000000 \.data
+08000244 l    d  \.dynamic	00000000 \.dynamic
+080002cc l    d  \.bss	00000000 \.bss
+08000244 l     O \.dynamic	00000000 _DYNAMIC
+08000238 l     O \.data	00000000 _GLOBAL_OFFSET_TABLE_
+00001000 g       .*	00000000 _eboot
+08000010 g       \*ABS\*	00000000 __etext
+08000010 g       \.text	00000000 _etext
+08000000 g       \.text	00000000 __text_start
+00000008 g       \*ABS\*	00000000 _rodata_align
+080002cc g       \.bss	00000000 _bss_start
+080002cc  w    O \.bss	00000004 _environ
+080002cc g     O \.bss	00000004 __environ
+080002d4 g       \.bss	00000000 _ebss
+00000000 g       .*	00000000 _eboot_reset
+08000238 g       \.data	00000000 _data_start
+08000010 g       .*	00000000 __srodata
+08000010 g       \*ABS\*	00000000 __erodata
+08000010 g       .*	00000000 _post_text_reserve
+00000001 g       \*ABS\*	00000000 _text_align
+08000000 g       \.text	00000000 __stext
+080002d0 g     O \.bss	00000004 foo
+08000244 g       \.data	00000000 _edata
+080002d4 g       \.bss	00000000 _end
+08000010 g       .*	00000000 _post_rodata_reserve
+00001000 g       \*ABS\*	00000000 BOOT_ADDRESS
+00000000 g       \*ABS\*	00000000 RESET_ADDRESS
+08000000 g       \*ABS\*	00000000 TEXT_BASE
+
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/dynbss-2.s binutils/ld/testsuite/ld-lx/dynbss-2.s
--- binutils-2.21.51/ld/testsuite/ld-lx/dynbss-2.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/dynbss-2.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,26 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# An absolute reference to a symbol that is weakly exported and aliased
+# in a shared library, causes the creation of a copy of the symbol
+# in the .dynbss of the main program.  The weakly exported symbol and
+# all of its aliases should be replaced by the symbol in the .dynbss.
+	
+	# In this example we have an absolute reference to _environ
+	# in a shared library, so we create a copy of _environ in the .dynbss.
+	# But in the shared library, _environ is an alias of __environ,
+	# so we must also ensure that __environ is defined in our .dynbss,
+	# at the same address as _environ.
+	# So when looking at the symbol table of the executable, check
+	# that _environ and __environ have the same value.
+	.data
+	.type foo,@object
+	.size foo,4
+	.type _environ,@object
+	.size _environ,4
+	
+	.text
+	ldw $r3 = foo[$r0]
+	;;
+	ldw $r3 = _environ[$r0]
+	;;
+	
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/empty-1.d binutils/ld/testsuite/ld-lx/empty-1.d
--- binutils-2.21.51/ld/testsuite/ld-lx/empty-1.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/empty-1.d	2010-05-25 12:04:31.134734000 +0100
@@ -0,0 +1,14 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2008
+#source: empty-1.s
+#as: -EL --gdwarf2 -mcore=st231
+#ld: -EL -e entry
+#objdump: -h
+#name: empty-1.d An empty text section does not cause a link error.
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Sections:
+Idx Name          Size      VMA       LMA       File off  Algn
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/empty-1.s binutils/ld/testsuite/ld-lx/empty-1.s
--- binutils-2.21.51/ld/testsuite/ld-lx/empty-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/empty-1.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,8 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2008
+	# An empty text section should not cause a link error.
+	.section .text, "ax"
+	.balign 8
+	.global entry
+
+entry:
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/equal-1.s binutils/ld/testsuite/ld-lx/equal-1.s
--- binutils-2.21.51/ld/testsuite/ld-lx/equal-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/equal-1.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,10 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Check that symbol assignment is not treated as an instruction
+	.text
+	nop
+	;; 
+foo:
+	nop
+	;; 
+	bar = foo
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-1a.d binutils/ld/testsuite/ld-lx/far-1a.d
--- binutils-2.21.51/ld/testsuite/ld-lx/far-1a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-1a.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,37 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+#source: far-1.s
+#as: -EL
+#ld: -EL -T far-1.ld
+#objdump: -d
+#name: Stub inserted for far calls (absolute)
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+00000000 \<entry\>:
+   0:	02 00 00 b0 	call \$r63 = 8 \<main\>;;
+   4:	ff ff 3f b0 	call \$r63 = 1000000 \<farfoo\>;;
+
+00000008 \<main\>:
+   8:	00 80 80 15 	
+   c:	c0 0f 00 08 	mov \$r63 = 16777216 \(0x1000000\)
+  10:	c0 9f 00 80 	mov \$r9 = \$r63;;
+  14:	01 00 00 b1 	syncins ;;
+  18:	00 00 80 31 	goto \$r63
+  1c:	40 f2 03 80 	mov \$r63 = \$r9;;
+Disassembly of section fartext:
+
+01000000 \<farfoo\>:
+ 1000000:	00 00 40 b0 	call \$r63 = 0 \<entry\>;;
+ 1000004:	03 00 00 b0 	call \$r63 = 1000010 \<farfoo\+0x10\>;;
+ 1000008:	00 00 80 b1 	goto \$r63;;
+ 100000c:	00 00 00 00 	nop 
+ 1000010:	00 00 80 15 	
+ 1000014:	c0 0f 00 08 	mov \$r63 = 0 \(0x0\)
+ 1000018:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 100001c:	01 00 00 b1 	syncins ;;
+ 1000020:	00 00 80 31 	goto \$r63
+ 1000024:	40 f2 03 80 	mov \$r63 = \$r9;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-1b.d binutils/ld/testsuite/ld-lx/far-1b.d
--- binutils-2.21.51/ld/testsuite/ld-lx/far-1b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-1b.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,41 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2004
+#source: far-1.s
+#as: -EL
+#ld: -shared -EL -T far-1.ld
+#objdump: -d
+#name: Stub inserted for far calls (PIC)
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+00000000 \<entry\>:
+   0:	02 00 00 b0 	call \$r63 = 8 \<main\>;;
+   4:	ff ff 3f b0 	call \$r63 = 1000000 \<farfoo\>;;
+
+00000008 \<main\>:
+   8:	02 00 00 30 	call \$r63 = 10 \<main\+0x8\>
+   c:	c0 9f 00 80 	mov \$r9 = \$r63;;
+  10:	ff 7f 80 15 	
+  14:	ff 0f 1f 88 	add \$r63 = \$r63, 16777200 \(0xfffff0\);;
+  18:	01 00 00 b1 	syncins ;;
+  1c:	00 00 80 31 	goto \$r63
+  20:	40 f2 03 80 	mov \$r63 = \$r9;;
+  24:	00 00 00 80 	nop ;;
+Disassembly of section fartext:
+
+01000000 \<farfoo\>:
+ 1000000:	00 00 40 b0 	call \$r63 = 0 \<entry\>;;
+ 1000004:	03 00 00 b0 	call \$r63 = 1000010 \<farfoo\+0x10\>;;
+ 1000008:	00 00 80 b1 	goto \$r63;;
+ 100000c:	00 00 00 00 	nop 
+ 1000010:	02 00 00 30 	call \$r63 = 1000018 \<farfoo\+0x18\>
+ 1000014:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 1000018:	ff 7f ff 15 	
+ 100001c:	ff 8f 1e 88 	add \$r63 = \$r63, -16777240 \(0xfeffffe8\);;
+ 1000020:	01 00 00 b1 	syncins ;;
+ 1000024:	00 00 80 31 	goto \$r63
+ 1000028:	40 f2 03 80 	mov \$r63 = \$r9;;
+ 100002c:	00 00 00 80 	nop ;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-1c.d binutils/ld/testsuite/ld-lx/far-1c.d
--- binutils-2.21.51/ld/testsuite/ld-lx/far-1c.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-1c.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,37 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2004
+#source: far-1.s
+#as: -EL -mcore=st231
+#ld: -EL -T far-1.ld
+#objdump: -d
+#name: Stub inserted for far calls (absolute), processor has interlocks
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section .text:
+
+00000000 \<entry\>:
+   0:	02 00 00 b0 	call \$r63 = 8 \<main\>;;
+   4:	ff ff 3f b0 	call \$r63 = 1000000 \<farfoo\>;;
+
+00000008 \<main\>:
+   8:	00 80 80 15 	
+   c:	c0 0f 00 08 	mov \$r63 = 16777216 \(0x1000000\)
+  10:	c0 9f 00 80 	mov \$r9 = \$r63;;
+  14:	00 00 80 31 	goto \$r63
+  18:	40 f2 03 80 	mov \$r63 = \$r9;;
+  1c:	00 00 00 80 	nop ;;
+Disassembly of section fartext:
+
+01000000 \<farfoo\>:
+ 1000000:	00 00 40 b0 	call \$r63 = 0 \<entry\>;;
+ 1000004:	03 00 00 b0 	call \$r63 = 1000010 \<farfoo\+0x10\>;;
+ 1000008:	00 00 80 b1 	goto \$r63;;
+ 100000c:	00 00 00 00 	nop 
+ 1000010:	00 00 80 15 	
+ 1000014:	c0 0f 00 08 	mov \$r63 = 0 \(0x0\)
+ 1000018:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 100001c:	00 00 80 31 	goto \$r63
+ 1000020:	40 f2 03 80 	mov \$r63 = \$r9;;
+ 1000024:	00 00 00 80 	nop ;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-1.ld binutils/ld/testsuite/ld-lx/far-1.ld
--- binutils-2.21.51/ld/testsuite/ld-lx/far-1.ld	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-1.ld	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,34 @@
+/*  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2004 */
+OUTPUT_FORMAT("elf32-littlelx", "elf32-lx", "elf32-littlelx")
+OUTPUT_ARCH(lx)
+ENTRY(main)
+
+MEMORY
+{
+ram             : ORIGIN = 0x0000000, LENGTH = 8M
+fram            : ORIGIN = 0x1000000, LENGTH = 8M
+ffram           : ORIGIN = 0x3000000, LENGTH = 8M
+fffram          : ORIGIN = 0x5000000, LENGTH = 8M
+}
+
+PHDRS
+{
+ text PT_LOAD;
+ data PT_LOAD;
+}
+
+SECTIONS
+{
+        .text :  { *(.text) } > ram : text 
+	.plt : { *(.plt) } > ram : text
+	.dynamic : { *(.dynamic) } > ram : data
+	.dynsym : { *(.dynsym) } > ram : data
+	.dynstr : { *(.dynstr) } > ram : data
+	.rela.dyn : { *(.rela.plt) } > ram : data
+	.hash : { *(.hash) } > ram : text
+        .data : { *(.got) *(.got.plt) *(.data) } > ram : data 
+        .bss : { *(.bss)  *(COMMON) *(.dynbss) } > ram : data
+        fartext :  { *(fartext) } > fram : text
+        farfartext :  { *(farfartext) } > ffram : text
+        farfarfartext :  { *(farfarfartext) } > fffram : text
+}
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-1.s binutils/ld/testsuite/ld-lx/far-1.s
--- binutils-2.21.51/ld/testsuite/ld-lx/far-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-1.s	2005-12-23 13:01:37.509789000 +0000
@@ -0,0 +1,25 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	# The linker should insert a long branch stub for a call that
+	# does not reach its destination
+	.text
+entry:
+	.protected entry
+	call  $r63=farfoo # This call does not reach
+	;;
+	call $r63=farfoo  # This call should reach
+	;;
+main:
+	.global main
+	
+	# This section is placed exactly 16MB above .text
+	.section "fartext", "ax"
+	.balign 8
+farfoo:
+	call $r63=entry # This call should reach
+	;; 
+	call $r63=entry # This call does not reach
+	;; 
+	return $r63
+	;;
+	
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-2a.d binutils/ld/testsuite/ld-lx/far-2a.d
--- binutils-2.21.51/ld/testsuite/ld-lx/far-2a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-2a.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,57 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2004
+#source: far-2.s
+#as: -EL -mcore=st231
+#ld: -EL -T far-1.ld
+#objdump: -d
+#name: Multiple stubs, multiple stub sections, processor has interlocks
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+00000000 \<entry\>:
+   0:	04 00 00 b1 	goto 10 \<main\+0x4\>;;
+   4:	09 00 00 b0 	call \$r63 = 28 \<main\+0x1c\>;;
+   8:	02 00 00 b0 	call \$r63 = 10 \<main\+0x4\>;;
+
+0000000c \<main\>:
+   c:	00 00 00 00 	nop 
+  10:	00 80 81 15 	
+  14:	c0 0f 00 08 	mov \$r63 = 50331648 \(0x3000000\)
+  18:	c0 9f 00 80 	mov \$r9 = \$r63;;
+  1c:	00 00 80 31 	goto \$r63
+  20:	40 f2 03 80 	mov \$r63 = \$r9;;
+  24:	00 00 00 80 	nop ;;
+  28:	00 80 82 15 	
+  2c:	c0 0f 00 08 	mov \$r63 = 83886080 \(0x5000000\)
+  30:	c0 9f 00 80 	mov \$r9 = \$r63;;
+  34:	00 00 80 31 	goto \$r63
+  38:	40 f2 03 80 	mov \$r63 = \$r9;;
+  3c:	00 00 00 80 	nop ;;
+Disassembly of section fartext:
+
+01000000 \<farfoo\>:
+ 1000000:	02 00 00 b0 	call \$r63 = 1000008 \<farfoo\+0x8\>;;
+ 1000004:	07 00 00 b0 	call \$r63 = 1000020 \<farfoo\+0x20\>;;
+ 1000008:	00 80 81 15 	
+ 100000c:	c0 0f 00 08 	mov \$r63 = 50331648 \(0x3000000\)
+ 1000010:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 1000014:	00 00 80 31 	goto \$r63
+ 1000018:	40 f2 03 80 	mov \$r63 = \$r9;;
+ 100001c:	00 00 00 80 	nop ;;
+ 1000020:	00 80 82 15 	
+ 1000024:	c0 0f 00 08 	mov \$r63 = 83886080 \(0x5000000\)
+ 1000028:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 100002c:	00 00 80 31 	goto \$r63
+ 1000030:	40 f2 03 80 	mov \$r63 = \$r9;;
+ 1000034:	00 00 00 80 	nop ;;
+Disassembly of section farfartext:
+
+03000000 \<farfarfoo\>:
+ 3000000:	00 00 00 80 	nop ;;
+Disassembly of section farfarfartext:
+
+05000000 \<farfarfarfoo\>:
+ 5000000:	00 00 00 80 	nop ;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-2b.d binutils/ld/testsuite/ld-lx/far-2b.d
--- binutils-2.21.51/ld/testsuite/ld-lx/far-2b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-2b.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,32 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2004
+#source: far-2.s
+#as: -EL -mcore=st231
+#ld: -EL -T far-1.ld --emit-relocs
+#objdump: -r
+#name: far-2b: --emit relocs for multiple stubs, multiple stub sections, processor has interlocks
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_23_PCREL     00000010_14:9\+0
+00000004 R_LX_23_PCREL     00000010_15:a\+0
+00000008 R_LX_23_PCREL     00000010_14:9\+0
+00000010 R_LX_HI23         \*ABS\*\+0x03000000
+00000014 R_LX_LO9          \*ABS\*\+0x03000000
+00000028 R_LX_HI23         \*ABS\*\+0x05000000
+0000002c R_LX_LO9          \*ABS\*\+0x05000000
+
+
+RELOCATION RECORDS FOR \[fartext\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_23_PCREL     00000013_14:9\+0
+00000004 R_LX_23_PCREL     00000013_15:a\+0
+00000008 R_LX_HI23         \*ABS\*\+0x03000000
+0000000c R_LX_LO9          \*ABS\*\+0x03000000
+00000020 R_LX_HI23         \*ABS\*\+0x05000000
+00000024 R_LX_LO9          \*ABS\*\+0x05000000
+
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-2c.d binutils/ld/testsuite/ld-lx/far-2c.d
--- binutils-2.21.51/ld/testsuite/ld-lx/far-2c.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-2c.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,9 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2004
+#source: far-2.s
+#as: -EL -mcore=st231
+#ld: -EL -T far-1.ld --emit-relocs -shared
+#objdump: -r
+#name: far-2c: --emit relocs for multiple stubs, multiple stub sections, processor has interlocks (PIC)
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+#error: .*cannot emit relocations for PIC far call to local symbol
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-2.s binutils/ld/testsuite/ld-lx/far-2.s
--- binutils-2.21.51/ld/testsuite/ld-lx/far-2.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-2.s	2005-12-23 13:01:37.509789000 +0000
@@ -0,0 +1,34 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	# The linker should insert a long branch stub for a call that
+	# does not reach its destination
+	.text
+entry:
+	.protected entry
+	goto farfarfoo       # This call does not reach
+	;;
+	call $r63=farfarfarfoo  # This call does not reach
+	;;
+	call $r63=farfarfoo   # Does not reach, should share stub with goto
+	;; 
+main:
+	.global main
+	
+	# This section is placed exactly 16MB above .text
+	.section "fartext", "ax"
+	.balign 8
+farfoo:
+	call $r63=farfarfoo # This call does not reach
+	;; 
+	call $r63=farfarfarfoo # This call does not reach
+	;; 
+	.section "farfartext", "ax"
+	.balign 8
+farfarfoo:
+	nop
+	;; 
+	.section "farfarfartext", "ax"
+	.balign 8
+farfarfarfoo:
+	nop
+	;; 
+	
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-3.d binutils/ld/testsuite/ld-lx/far-3.d
--- binutils-2.21.51/ld/testsuite/ld-lx/far-3.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-3.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,16 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2008
+#source: far-3.s
+#as: -EL
+#ld: -EL -shared -L. -laashared
+#objdump: -R
+#name: far-3.d Call at address > 16MB to symbol in shared lib
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+DYNAMIC RELOCATION RECORDS
+OFFSET   TYPE              VALUE 
+01e84bac R_LX_JMP_SLOT     foofun
+
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-3.s binutils/ld/testsuite/ld-lx/far-3.s
--- binutils-2.21.51/ld/testsuite/ld-lx/far-3.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-3.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,20 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2008
+	# There is a call that is >16MB from the start of its section.
+	# The call is to a symbol in a shared library, so we should not
+	# insert a long branch stub, instead we should branch to the
+	# PLT.  Note that the PLT is placed after the .text containing the
+	# call, so a branch to the PLT is within range.
+	# The linker had a bug that it attempted to insert a long branch
+	# stub here, and segfaulted because the output section of foofun
+	# is not defined (codex bug #57849).
+	.text
+foo::
+	.text
+	.rept 8000000
+	nop
+	;;
+	.endr
+
+	call  $r63=foofun
+	;;
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-4a.d binutils/ld/testsuite/ld-lx/far-4a.d
--- binutils-2.21.51/ld/testsuite/ld-lx/far-4a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-4a.d	2010-05-25 12:04:31.134734000 +0100
@@ -0,0 +1,58 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+#source: far-4.s
+#source: far-4a.s
+#as: -EL
+#ld: -EL  -L. -laashared
+#objdump: -d
+#name: (far-4a) Call at distance > 16MB from PLT to symbol in shared lib
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section .text:
+
+08000000 \<__start\>:
+ 8000000:	02 00 00 b0 	call \$r63 = 8000008 \<.*\+0x8\>;;
+ 8000004:	80 00 00 80 	mov \$r0 = \$r2;;
+ 8000008:	24 f4 84 15 	
+ 800000c:	c0 0f 0a 08 	mov \$r63 = 166217888 \(0x9e848a0\)
+ 8000010:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 8000014:	01 00 00 b1 	syncins ;;
+ 8000018:	00 00 80 31 	goto \$r63
+ 800001c:	40 f2 03 80 	mov \$r63 = \$r9;;
+	...
+ 9e84820:	00 00 00 80 	nop ;;
+ 9e84824:	1f 00 00 b0 	call \$r63 = 9e848a0 \<_etext\+0x58\>;;
+ 9e84828:	02 00 00 b0 	call \$r63 = 9e84830 <.*\+0x1e84830>;;
+ 9e8482c:	80 00 00 80 	mov \$r0 = \$r2;;
+ 9e84830:	00 00 84 15 	
+ 9e84834:	c0 0f 00 08 	mov \$r63 = 134217728 \(0x8000000\)
+ 9e84838:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 9e8483c:	01 00 00 b1 	syncins ;;
+ 9e84840:	00 00 80 31 	goto \$r63
+ 9e84844:	40 f2 03 80 	mov \$r63 = \$r9;;
+Disassembly of section .plt:
+
+09e84860 \<.plt\>:
+ 9e84860:	25 f4 84 15 	
+ 9e84864:	c0 0f 0b 20 	ldw \$r63 = 166218416 \(0x9e84ab0\)\[\$r0\]
+ 9e84868:	c0 bf 00 80 	mov \$r11 = \$r63;;
+ 9e8486c:	80 c2 0a 20 	ldw \$r10 = 166218412 \(0x9e84aac\)\[\$r0\];;
+ 9e84870:	25 f4 04 95 	
+ 9e84874:	01 00 00 b1 	syncins ;;
+ 9e84878:	00 00 80 31 	goto \$r63
+ 9e8487c:	c0 f2 03 80 	mov \$r63 = \$r11;;
+ 9e84880:	f8 ff 7f 31 	goto 9e84860 \<_etext\+0x18\>
+ 9e84884:	40 02 00 08 	mov \$r9 = 0 \(0x0\);;
+ 9e84888:	00 00 00 95 	
+ 9e8488c:	00 00 00 80 	nop ;;
+	...
+ 9e848a0:	25 f4 84 15 	
+ 9e848a4:	c0 8f 0b 20 	ldw \$r63 = 166218424 \(0x9e84ab8\)\[\$r0\]
+ 9e848a8:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 9e848ac:	01 00 00 b1 	syncins ;;
+ 9e848b0:	00 00 00 80 	nop ;;
+ 9e848b4:	00 00 80 31 	goto \$r63
+ 9e848b8:	40 f2 03 80 	mov \$r63 = \$r9;;
+ 9e848bc:	00 00 00 80 	nop ;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-4a.s binutils/ld/testsuite/ld-lx/far-4a.s
--- binutils-2.21.51/ld/testsuite/ld-lx/far-4a.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-4a.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,21 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+
+	# There is a call to a symbol in a shared library at the end
+	# of a large section. As the PLT is placed after the .text
+	# containing the call, this branch to the PLT is within range,
+	# unlike the other contribution from far-4.s.
+
+	.text
+
+	# Fill with zeroes, to make it simpler to check the output with objdump
+	.rept 8000000
+	.word 0
+	.endr
+	nop
+	;;
+
+	call  $r63=foofun
+	;;
+
+	call  $r63=__start
+	;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-4b.d binutils/ld/testsuite/ld-lx/far-4b.d
--- binutils-2.21.51/ld/testsuite/ld-lx/far-4b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-4b.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,68 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+#source: far-4.s
+#source: far-4a.s
+#as: -EL
+#ld: -EL -shared -L. -laashared -Tshared.ld
+#objdump: -d
+#name: (far-4b) Call at distance > 16MB from PLT to symbol in shared lib (shared lib)
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section .text:
+
+00000074 <__stext>:
+      74:	80 00 00 80 	mov \$r0 = \$r2;;
+
+00000078 \<__start\>:
+      78:	02 00 00 b0 	call \$r63 = 80 \<__start\+0x8\>;;
+      7c:	80 00 00 80 	mov \$r0 = \$r2;;
+      80:	02 00 00 30 	call \$r63 = 88 \<__start\+0x10\>
+      84:	c0 9f 00 80 	mov \$r9 = \$r63;;
+      88:	24 f4 80 15 	
+      8c:	ff 8f 09 88 	add \$r63 = \$r63, 32000152 \(0x1e84898\);;
+      90:	01 00 00 b1 	syncins ;;
+      94:	00 00 80 31 	goto \$r63
+      98:	40 f2 03 80 	mov \$r63 = \$r9;;
+      9c:	00 00 00 80 	nop ;;
+	...
+ 1e848a0:	00 00 00 80 	nop ;;
+ 1e848a4:	1f 00 00 b0 	call \$r63 = 1e84920 <_etext\+0x70>;;
+ 1e848a8:	16 00 00 b0 	call \$r63 = 1e84900 <_etext\+0x50>;;
+ 1e848ac:	80 00 00 80 	mov \$r0 = \$r2;;
+Disassembly of section .plt:
+
+01e848c0 \<.plt\>:
+ 1e848c0:	ce 4f 00 20 	ldw \$r63 = 4 \(0x4\)\[\$r14\]
+ 1e848c4:	c0 bf 00 80 	mov \$r11 = \$r63;;
+ 1e848c8:	8e 02 00 a0 	ldw \$r10 = 0 \(0x0\)\[\$r14\];;
+ 1e848cc:	01 00 00 b1 	syncins ;;
+ 1e848d0:	00 00 80 31 	goto \$r63
+ 1e848d4:	c0 f2 03 80 	mov \$r63 = \$r11;;
+ 1e848d8:	00 00 00 80 	nop ;;
+ 1e848dc:	00 00 00 80 	nop ;;
+ 1e848e0:	f8 ff 7f 31 	goto 1e848c0 \<_etext\+0x10\>
+ 1e848e4:	40 02 00 08 	mov \$r9 = 0 \(0x0\);;
+ 1e848e8:	00 00 00 95 	
+ 1e848ec:	00 00 00 80 	nop ;;
+ 1e848f0:	f4 ff 7f 31 	goto 1e848c0 \<_etext\+0x10\>
+ 1e848f4:	40 c2 00 08 	mov \$r9 = 12 \(0xc\);;
+ 1e848f8:	00 00 00 95 	
+ 1e848fc:	00 00 00 80 	nop ;;
+ 1e84900:	00 00 80 15 	
+ 1e84904:	ce cf 00 20 	ldw \$r63 = 12 \(0xc\)\[\$r14\]
+ 1e84908:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 1e8490c:	01 00 00 b1 	syncins ;;
+ 1e84910:	00 00 00 80 	nop ;;
+ 1e84914:	00 00 80 31 	goto \$r63
+ 1e84918:	40 f2 03 80 	mov \$r63 = \$r9;;
+ 1e8491c:	00 00 00 80 	nop ;;
+ 1e84920:	00 00 80 15 	
+ 1e84924:	ce 0f 01 20 	ldw \$r63 = 16 \(0x10\)\[\$r14\]
+ 1e84928:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 1e8492c:	01 00 00 b1 	syncins ;;
+ 1e84930:	00 00 00 80 	nop ;;
+ 1e84934:	00 00 80 31 	goto \$r63
+ 1e84938:	40 f2 03 80 	mov \$r63 = \$r9;;
+ 1e8493c:	00 00 00 80 	nop ;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-4c.d binutils/ld/testsuite/ld-lx/far-4c.d
--- binutils-2.21.51/ld/testsuite/ld-lx/far-4c.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-4c.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,68 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+#source: far-4.s
+#source: far-4a.s
+#as: -EL
+#ld: -EL -shared -Tshared.ld
+#objdump: -d
+#name: (far-4c) Call at distance > 16MB from PLT to an undefined symbol (shared lib)
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section .text:
+
+00000074 \<__stext\>:
+      74:	80 00 00 80 	mov \$r0 = \$r2;;
+
+00000078 \<__start\>:
+      78:	02 00 00 b0 	call \$r63 = 80 \<__start\+0x8\>;;
+      7c:	80 00 00 80 	mov \$r0 = \$r2;;
+      80:	02 00 00 30 	call \$r63 = 88 \<__start\+0x10\>
+      84:	c0 9f 00 80 	mov \$r9 = \$r63;;
+      88:	24 f4 80 15 	
+      8c:	ff 8f 09 88 	add \$r63 = \$r63, 32000152 \(0x1e84898\);;
+      90:	01 00 00 b1 	syncins ;;
+      94:	00 00 80 31 	goto \$r63
+      98:	40 f2 03 80 	mov \$r63 = \$r9;;
+      9c:	00 00 00 80 	nop ;;
+	...
+ 1e848a0:	00 00 00 80 	nop ;;
+ 1e848a4:	1f 00 00 b0 	call \$r63 = 1e84920 \<_etext\+0x70\>;;
+ 1e848a8:	16 00 00 b0 	call \$r63 = 1e84900 \<_etext\+0x50\>;;
+ 1e848ac:	80 00 00 80 	mov \$r0 = \$r2;;
+Disassembly of section .plt:
+
+01e848c0 \<.plt\>:
+ 1e848c0:	ce 4f 00 20 	ldw \$r63 = 4 \(0x4\)\[\$r14\]
+ 1e848c4:	c0 bf 00 80 	mov \$r11 = \$r63;;
+ 1e848c8:	8e 02 00 a0 	ldw \$r10 = 0 \(0x0\)\[\$r14\];;
+ 1e848cc:	01 00 00 b1 	syncins ;;
+ 1e848d0:	00 00 80 31 	goto \$r63
+ 1e848d4:	c0 f2 03 80 	mov \$r63 = \$r11;;
+ 1e848d8:	00 00 00 80 	nop ;;
+ 1e848dc:	00 00 00 80 	nop ;;
+ 1e848e0:	f8 ff 7f 31 	goto 1e848c0 \<_etext\+0x10\>
+ 1e848e4:	40 02 00 08 	mov \$r9 = 0 \(0x0\);;
+ 1e848e8:	00 00 00 95 	
+ 1e848ec:	00 00 00 80 	nop ;;
+ 1e848f0:	f4 ff 7f 31 	goto 1e848c0 \<_etext\+0x10\>
+ 1e848f4:	40 c2 00 08 	mov \$r9 = 12 \(0xc\);;
+ 1e848f8:	00 00 00 95 	
+ 1e848fc:	00 00 00 80 	nop ;;
+ 1e84900:	00 00 80 15 	
+ 1e84904:	ce cf 00 20 	ldw \$r63 = 12 \(0xc\)\[\$r14\]
+ 1e84908:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 1e8490c:	01 00 00 b1 	syncins ;;
+ 1e84910:	00 00 00 80 	nop ;;
+ 1e84914:	00 00 80 31 	goto \$r63
+ 1e84918:	40 f2 03 80 	mov \$r63 = \$r9;;
+ 1e8491c:	00 00 00 80 	nop ;;
+ 1e84920:	00 00 80 15 	
+ 1e84924:	ce 0f 01 20 	ldw \$r63 = 16 \(0x10\)\[\$r14\]
+ 1e84928:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 1e8492c:	01 00 00 b1 	syncins ;;
+ 1e84930:	00 00 00 80 	nop ;;
+ 1e84934:	00 00 80 31 	goto \$r63
+ 1e84938:	40 f2 03 80 	mov \$r63 = \$r9;;
+ 1e8493c:	00 00 00 80 	nop ;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-4d.d binutils/ld/testsuite/ld-lx/far-4d.d
--- binutils-2.21.51/ld/testsuite/ld-lx/far-4d.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-4d.d	2010-07-01 12:26:47.327589000 +0100
@@ -0,0 +1,67 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+#source: far-4.s
+#source: far-4a.s
+#as: -EL
+#ld: -EL  -L. -laashared --emit-relocs
+#objdump: -dr
+#name: (far-4d) Call at distance > 16MB from PLT to symbol in shared lib (--emit-relocs)
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section .text:
+
+08000000 \<__start\>:
+ 8000000:	02 00 00 b0 	call \$r63 = 8000008 \<00000028_foofun\+0\>;;
+			8000000: R_LX_23_PCREL	00000028_foofun\+0
+ 8000004:	80 00 00 80 	mov \$r0 = \$r2;;
+08000008 <00000028_foofun\+0>:
+ 8000008:	24 f4 84 15 	
+			8000008: R_LX_HI23	foofun
+ 800000c:	c0 0f 0a 08 	mov \$r63 = 166217888 \(0x9e848a0\)
+			800000c: R_LX_LO9	foofun
+ 8000010:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 8000014:	01 00 00 b1 	syncins ;;
+ 8000018:	00 00 80 31 	goto \$r63
+ 800001c:	40 f2 03 80 	mov \$r63 = \$r9;;
+	...
+ 9e84820:	00 00 00 80 	nop ;;
+ 9e84824:	1f 00 00 b0 	call \$r63 = 9e848a0 \<_etext\+0x58\>;;
+			9e84824: R_LX_23_PCREL	foofun
+ 9e84828:	02 00 00 b0 	call \$r63 = 9e84830 <0000002b___start\+0>;;
+			9e84828: R_LX_23_PCREL	0000002b___start\+0
+ 9e8482c:	80 00 00 80 	mov \$r0 = \$r2;;
+09e84830 <0000002b___start\+0>:
+ 9e84830:	00 00 84 15 	
+			9e84830: R_LX_HI23	__start
+ 9e84834:	c0 0f 00 08 	mov \$r63 = 134217728 \(0x8000000\)
+			9e84834: R_LX_LO9	__start
+ 9e84838:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 9e8483c:	01 00 00 b1 	syncins ;;
+ 9e84840:	00 00 80 31 	goto \$r63
+ 9e84844:	40 f2 03 80 	mov \$r63 = \$r9;;
+Disassembly of section .plt:
+
+09e84860 \<.plt\>:
+ 9e84860:	25 f4 84 15 	
+ 9e84864:	c0 0f 0b 20 	ldw \$r63 = 166218416 \(0x9e84ab0\)\[\$r0\]
+ 9e84868:	c0 bf 00 80 	mov \$r11 = \$r63;;
+ 9e8486c:	80 c2 0a 20 	ldw \$r10 = 166218412 \(0x9e84aac\)\[\$r0\];;
+ 9e84870:	25 f4 04 95 	
+ 9e84874:	01 00 00 b1 	syncins ;;
+ 9e84878:	00 00 80 31 	goto \$r63
+ 9e8487c:	c0 f2 03 80 	mov \$r63 = \$r11;;
+ 9e84880:	f8 ff 7f 31 	goto 9e84860 \<.plt\>
+ 9e84884:	40 02 00 08 	mov \$r9 = 0 \(0x0\);;
+ 9e84888:	00 00 00 95 	
+ 9e8488c:	00 00 00 80 	nop ;;
+	...
+ 9e848a0:	25 f4 84 15 	
+ 9e848a4:	c0 8f 0b 20 	ldw \$r63 = 166218424 \(0x9e84ab8\)\[\$r0\]
+ 9e848a8:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ 9e848ac:	01 00 00 b1 	syncins ;;
+ 9e848b0:	00 00 00 80 	nop ;;
+ 9e848b4:	00 00 80 31 	goto \$r63
+ 9e848b8:	40 f2 03 80 	mov \$r63 = \$r9;;
+ 9e848bc:	00 00 00 80 	nop ;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/far-4.s binutils/ld/testsuite/ld-lx/far-4.s
--- binutils-2.21.51/ld/testsuite/ld-lx/far-4.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/far-4.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,12 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+
+	# There is call to a symbol in a shared library at the
+	# beginning of a large section, which will imply inserting long
+	# branch stubs because the PLT is placed after the .text
+	# containing the calls.
+
+	.text
+	.balign 8
+__start::
+	call  $r63=foofun
+	;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/fde-1a.d binutils/ld/testsuite/ld-lx/fde-1a.d
--- binutils-2.21.51/ld/testsuite/ld-lx/fde-1a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/fde-1a.d	2010-07-13 16:02:33.095410000 +0100
@@ -0,0 +1,49 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2008
+#comment: Basic test for the PC-relative transformation of absolute FDE when -shared. 
+#source: fde-1.s
+#as: -EL -mcore=st231
+#ld: -EL -shared -e foo
+#readelf: --debug-dump=frames
+#name: fde-1a test PC-relative transformation of FDE for shared library
+#notarget: *-*-linux*
+Contents of the \.eh_frame section:
+
+00000000 00000018 00000000 CIE
+  Version:               1
+  Augmentation:          "zRPL"
+  Code alignment factor: 1
+  Data alignment factor: -4
+  Return address column: 63
+  Augmentation data:     1b 00 00 00 00 00 1b
+
+  DW_CFA_def_cfa: r12 ofs 16
+
+0000001c 00000020 00000020 FDE cie=00000000 pc=00000420\.\.00000474
+  Augmentation data:     c7 ff ff ff
+
+  DW_CFA_advance_loc4: 4 to 00000424
+  DW_CFA_def_cfa_offset: 40
+  DW_CFA_advance_loc4: 12 to 00000430
+  DW_CFA_offset: r63 at cfa-12
+  DW_CFA_nop
+
+Contents of the \.debug_frame section:
+
+00000000 0000000c ffffffff CIE
+  Version:               1
+  Augmentation:          ""
+  Code alignment factor: 1
+  Data alignment factor: -4
+  Return address column: 63
+
+  DW_CFA_def_cfa: r12 ofs 16
+
+00000010 0000000c ffffffff CIE
+  Version:               1
+  Augmentation:          ""
+  Code alignment factor: 1
+  Data alignment factor: -4
+  Return address column: 63
+
+  DW_CFA_def_cfa: r12 ofs 16
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/fde-1b.d binutils/ld/testsuite/ld-lx/fde-1b.d
--- binutils-2.21.51/ld/testsuite/ld-lx/fde-1b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/fde-1b.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,14 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2008
+#comment: Basic test for --eh-frame-hdr
+#source: fde-1.s
+#as: -EL -mcore=st231
+#ld: -EL -shared -e foo --eh-frame-hdr
+#objdump: --section .eh_frame_hdr -s
+#name: fde-1b test --eh-frame-hdr
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Contents of section \.eh_frame_hdr:
+ 0540 011b033b 1c000000 01000000 18ffffff  .*
+ 0550 3c000000                             .*            
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/fde-1.s binutils/ld/testsuite/ld-lx/fde-1.s
--- binutils-2.21.51/ld/testsuite/ld-lx/fde-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/fde-1.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,245 @@
+	##  /home/afra/users/clarkes/st200/open64/trunk/osprey/targia32_st200/devimage/lib/cmplrs/be::1.0-2-A Unknown (i386-linux-redhat-6.2)
+
+	##-----------------------------------------------------------
+	## Compiling test-cleanup.c (/tmp/ccQZh50D.B)
+	##-----------------------------------------------------------
+
+	##-----------------------------------------------------------
+	## Options:
+	##-----------------------------------------------------------
+	##  Target:st231, ISA:ST231, Pointer Size:32
+	##  -O0	(Optimization level)
+	##  -g0	(Debug level)
+	##  -m1	(Report warnings)
+	##-----------------------------------------------------------
+
+	.assume	st231
+	.nonopinsertion
+
+	.section .text, "ax", @progbits
+	.align	8
+
+	.section .text
+
+	## Program Unit: clean_x
+	.align 8
+	.proc	clean_x
+	.global	clean_x
+clean_x:	## 0x0
+	## lcl_spill_temp_0 = 0
+##	.file	"/home/afra/users/clarkes/temp/test-cleanup.c"
+##	.loc	0	5	0
+##   1  
+##   2  
+##   3  extern int x_cleaned;
+##   4  void clean_x (int *p)
+##   5  {
+L?_BB1_clean_x:	## 0x0
+.LEH_save_ra_clean_x_0:
+	mov 	$r9=$r63                	 ## (sv:$r63)
+	 ;;
+.LEH_post_save_ra_clean_x_0:
+	stw 	0[$r12]=$r9             	 ## lcl_spill_temp_0
+	call 	$r63=L?.gpinit_0       
+	 ;;
+L?.gpinit_0:
+	add 	$r8=$r63, @neggprel(L?.gpinit_0)	 ## L?.gpinit_0
+	stw 	8[$r12]=$r16            	 ## p
+	 ;;
+##	.loc	0	7	0
+##   6    
+##   7    x_cleaned++;
+	.global	x_cleaned
+	ldw 	$r11=@gotoff(x_cleaned)[$r8]	 ## x_cleaned
+	 ;;
+	ldw 	$r11=0[$r11]            
+	 ;;
+	add 	$r11=$r11, 1            
+	ldw 	$r10=@gotoff(x_cleaned)[$r8]	 ## x_cleaned
+	 ;;
+	stw 	0[$r10]=$r11            
+	 ;;
+##	.loc	0	8	0
+##   8  }
+.LEH_restore_ra_clean_x_0:
+	mov 	$r63=$r9                
+	 ;;
+.LEH_post_restore_ra_clean_x_0:
+	return 	$r63                 
+	 ;;
+	.endp	clean_x
+
+	.section .except_table_supp, "a", @progbits
+	.align	4
+
+	.section .except_table, "wa", @progbits
+	.align	4
+
+	.section .text
+
+	## Program Unit: foo
+	.align 8
+	.proc	foo, Handler.1.2
+	.global	foo
+foo:	## 0x0
+	## __Exc_Ptr__ = 20
+	## __Exc_Filter__ = 24
+	## x = 16
+	## lcl_spill_temp_1 = 28
+	## lcl_spill_temp_2 = 32
+##	.loc	0	11	0
+##   9  
+##  10  void foo (void)
+##  11  {
+L?_BB1_foo:	## 0x33
+.LEH_adjust_sp_foo_0:
+	add 	$r12=$r12, -24          
+	 ;;
+.LEH_post_adjust_sp_foo_0:
+	stw 	32[$r12]=$r14           	 ## lcl_spill_temp_2
+	 ;;
+.LEH_save_ra_foo_0:
+	stw 	28[$r12]=$r63           	 ## lcl_spill_temp_1
+	call 	$r63=L?.gpinit_2       
+	 ;;
+L?.gpinit_2:
+.LEH_post_save_ra_foo_0:
+	add 	$r14=$r63, @neggprel(L?.gpinit_2)	 ## L?.gpinit_2
+	 ;;
+L?__1_4:	## 0x51
+##	.loc	0	13	0
+##  12    int x __attribute__ (( cleanup(clean_x) ));
+##  13  }
+	add 	$r16=$r12, 16           	 ## x
+	.type	clean_x, @function
+	call 	$r63=clean_x           	 ## clean_x
+	 ;;
+L?__1_5:	## 0x53
+L?_BB4_foo:	## 0x53
+##	.loc	0	13	0
+##	.body
+##	.label_state 1
+	ldw 	$r14=32[$r12]           	 ## (sv:$r14)lcl_spill_temp_2
+	 ;;
+##	.body
+##	.label_state 1
+.LEH_restore_ra_foo_0:
+.LEH_restore_sp_foo_0:
+	ldw 	$r63=28[$r12]           	 ## (sv:$r63)lcl_spill_temp_1
+	add 	$r12=$r12, 24           
+	 ;;
+.LEH_post_restore_ra_foo_0:
+.LEH_post_restore_sp_foo_0:
+	return 	$r63                 
+	 ;;
+##	.loc	0	13	0
+	## .aproc	Handler.1.2
+Handler.1.2:	## 0x0
+	.type	Handler.1.2, @function
+L?__1_2:	## 0x63
+.LEH_restore_sp_foo_1:
+.LEH_post_restore_sp_foo_1:
+.LEH_restore_ra_foo_1:
+.LEH_post_restore_ra_foo_1:
+	stw 	32[$r12]=$r14           	 ## lcl_spill_temp_2
+	call 	$r63=L?.gpinit_1       
+	 ;;
+L?.gpinit_1:
+	add 	$r14=$r63, @neggprel(L?.gpinit_1)	 ## L?.gpinit_1
+	 ;;
+##	.loc	0	13	0
+	stw 	20[$r12]=$r8            	 ## __Exc_Ptr__
+	 ;;
+	stw 	24[$r12]=$r9            	 ## __Exc_Filter__
+	 ;;
+L?__1_3:	## 0x81
+	ldw 	$r16=20[$r12]           	 ## __Exc_Ptr__
+	.global	_Unwind_Resume
+	.type	_Unwind_Resume, @function
+	call 	$r63=_Unwind_Resume    	 ## _Unwind_Resume
+	 ;;
+	nop                          
+	 ;;
+	.endp	foo
+
+	.section .except_table
+	.type	.range_table.foo.2.17, @object
+.range_table.foo.2.17:	## 0x0
+	## offset 0
+	.byte	255
+	## offset 1
+	.byte	0
+	.uleb128	.LSDATTYPEB1-.LSDATTYPED1
+.LSDATTYPED1:
+	## offset 6
+	.byte	1
+	.uleb128	.LSDACSE1-.LSDACSB1
+.LSDACSB1:
+	.uleb128	L?__1_4-foo
+	.uleb128	L?__1_5-L?__1_4
+	.uleb128	L?__1_2-foo
+	## offset 19
+	.uleb128	0
+.LSDATTYPEB1:
+.LSDACSE1:
+	## end of initialization for .range_table.foo
+	.section .text
+	.align 8
+	.section .except_table_supp
+	.align 4
+	.section .except_table
+	.align 4
+	## .gpvalue 0
+
+	.section .eh_frame, "wa"
+
+.EHCIE:	.align	0
+	.word 0x18
+	.word 0x0
+	.byte	0x01, 0x7a, 0x50, 0x4c, 0x00, 0x01, 0x7c, 0x3f
+	.byte	0x06, 0x00
+	.word	__gcc_personality_v0
+	.byte	0x00, 0x0c, 0x0c, 0x10, 0x00, 0x00
+	.word 0x20
+.FDE1:
+	.word	.FDE1 - .EHCIE
+	.word	L?_BB1_foo
+	.word	L?_BB1_foo - L?_BB1_foo + 0x54
+	.byte	0x04
+	.word	.range_table.foo.2.17
+	.byte	0x04
+	.word	.LEH_post_adjust_sp_foo_0 - L?_BB1_foo
+	.byte	0x0e, 0x28, 0x04
+	.word	.LEH_post_save_ra_foo_0 - .LEH_post_adjust_sp_foo_0
+	.byte	0xbf, 0x03, 0x00
+
+	.section .debug_frame, ""
+	.align	0
+	.byte	0x0c, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff
+	.byte	0x01, 0x00, 0x01, 0x7c, 0x3f, 0x0c, 0x0c, 0x10
+	.byte	0x0c, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff
+	.byte	0x01, 0x00, 0x01, 0x7c, 0x3f, 0x0c, 0x0c, 0x10
+
+
+	.text
+	.proc	_Unwind_Resume
+	.global	_Unwind_Resume
+_Unwind_Resume:
+	return $r63
+	;;
+	.endp
+	
+	.proc	__gcc_personality_v0
+	.global	__gcc_personality_v0
+__gcc_personality_v0:
+	return $r63
+	;; 
+	.endp
+	
+	.data
+
+x_cleaned::
+	.type x_cleaned, @object
+	.word 0
+
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/gc-1.d binutils/ld/testsuite/ld-lx/gc-1.d
--- binutils-2.21.51/ld/testsuite/ld-lx/gc-1.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/gc-1.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,16 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2008
+#source: gc-1.s
+#as: -EL
+#ld: -EL -e _start --gc-sections
+#objdump: -d
+#name: gc-1 test that a section with relocations to non-dynamic symbol can be deleted
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+08000000 \<__start\>:
+ 8000000:	00 00 00 80 	nop ;;
+ 8000004:	80 00 00 80 	mov \$r0 = \$r2;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/gc-1.s binutils/ld/testsuite/ld-lx/gc-1.s
--- binutils-2.21.51/ld/testsuite/ld-lx/gc-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/gc-1.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,12 @@
+	.text
+_start::
+__start::
+	nop
+	;;
+
+	.section .text2, "ax"
+	.balign 8
+foo:
+	mov $r1=foo
+	;;
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/got-1.d binutils/ld/testsuite/ld-lx/got-1.d
--- binutils-2.21.51/ld/testsuite/ld-lx/got-1.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/got-1.d	2011-07-11 16:09:11.378539000 +0100
@@ -0,0 +1,33 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: got-1.s
+#as: -EL
+#ld: -EL -e 0 -L. -laashared
+#objdump: -TR
+#name: Creation of GOT entry
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+DYNAMIC SYMBOL TABLE:
+08000008 g    D  \*ABS\*	00000000 __etext
+08000008 g    D  \.text	00000000 _etext
+08000000 g    D  \.text	00000000 __text_start
+00000008 g    D  \*ABS\*	00000000 _rodata_align
+08000288 g    D  \.bss	00000000 _bss_start
+08000288 g    D  \.bss	00000000 _ebss
+080001f0 g    D  \.data	00000000 _data_start
+08000008 g    D  .*	00000000 __srodata
+08000008 g    D  \*ABS\*	00000000 __erodata
+00000001 g    D  \*ABS\*	00000000 _text_align
+08000000 g    D  \.text	00000000 __stext
+00000000      DO \*UND\*	00000000 foo
+08000200 g    D  \.data	00000000 _edata
+08000288 g    D  \.bss	00000000 _end
+
+
+DYNAMIC RELOCATION RECORDS
+OFFSET   TYPE              VALUE 
+080001fc R_LX_32           foo
+
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/got-1.s binutils/ld/testsuite/ld-lx/got-1.s
--- binutils-2.21.51/ld/testsuite/ld-lx/got-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/got-1.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,5 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Check basic creation of GOT entry
+	.text
+	ldw $r23 = @gotoff(foo)[$r14]
+	;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/lx-rd.exp binutils/ld/testsuite/ld-lx/lx-rd.exp
--- binutils-2.21.51/ld/testsuite/ld-lx/lx-rd.exp	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/lx-rd.exp	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,27 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Expect script for run_dump_test based ld-lx tests.
+#   Copyright 2003 STMicroelectronics Inc.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+
+if [istarget lx-*-*] then {
+    set rd_test_list [lsort [glob -nocomplain $srcdir/$subdir/*.d]]
+    foreach rdtest $rd_test_list {
+	# We need to strip the ".d", but can leave the dirname.
+	verbose [file rootname $rdtest]
+	run_dump_test [file rootname $rdtest]
+    }
+}
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-1a.d binutils/ld/testsuite/ld-lx/plt-1a.d
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-1a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-1a.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,40 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: plt-1.s
+#as: -EL
+#ld: -EL -e 0x1000 -L. -laashared
+#objdump: -d
+#name: plt-1a Creation of PLT entry, little-endian, absolute
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section .text:
+
+.* \<__stext\>:
+.*00:	18 00 00 b0 	call \$r63 = .*60 \<_etext\+0x58\>;;
+.*04:	80 00 00 80 	mov \$r0 = \$r2;;
+Disassembly of section \.plt:
+
+.*20 \<\.plt\>:
+ .*20:	01 00 84 15 	
+ .*24:	c0 0f 07 20 	ldw \$r63 = .* \(0x.*270\)\[\$r0\]
+ .*28:	c0 bf 00 80 	mov \$r11 = \$r63;;
+ .*2c:	80 c2 06 20 	ldw \$r10 = .* \(0x.*26c\)\[\$r0\];;
+ .*30:	01 00 04 95 	
+ .*34:	01 00 00 b1 	syncins ;;
+ .*38:	00 00 80 31 	goto \$r63
+ .*3c:	c0 f2 03 80 	mov \$r63 = \$r11;;
+ .*40:	f8 ff 7f 31 	goto .*20 \<_etext\+0x18\>
+ .*44:	40 02 00 08 	mov \$r9 = 0 \(0x0\);;
+ .*48:	00 00 00 95 	
+ .*4c:	00 00 00 80 	nop ;;
+.*
+ .*60:	01 00 84 15 	
+ .*64:	c0 8f 07 20 	ldw \$r63 = .* \(0x.*278\)\[\$r0\]
+ .*68:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ .*6c:	01 00 00 b1 	syncins ;;
+ .*70:	00 00 00 80 	nop ;;
+ .*74:	00 00 80 31 	goto \$r63
+ .*78:	40 f2 03 80 	mov \$r63 = \$r9;;
+.*
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-1b.d binutils/ld/testsuite/ld-lx/plt-1b.d
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-1b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-1b.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,43 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: plt-1.s
+#as: -EL
+#ld: -EL -e 0x1000 -shared
+#objdump: -d
+#name: plt-1b Creation of PLT entry, little-endian, position-independent
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+0000030c \<__stext\>:
+ 30c:	80 00 00 80 	mov \$r0 = \$r2;;
+
+00000310 \<__text_start\>:
+ 310:	14 00 00 b0 	call \$r63 = .* \<_etext\+0x48\>;;
+ 314:	80 00 00 80 	mov \$r0 = \$r2;;
+Disassembly of section \.plt:
+
+.*20 \<\.plt\>:
+ .*20:	ce 4f 00 20 	ldw \$r63 = 4 \(0x4\)\[\$r14\]
+ .*24:	c0 bf 00 80 	mov \$r11 = \$r63;;
+ .*28:	8e 02 00 a0 	ldw \$r10 = 0 \(0x0\)\[\$r14\];;
+ .*2c:	01 00 00 b1 	syncins ;;
+ .*30:	00 00 80 31 	goto \$r63
+ .*34:	c0 f2 03 80 	mov \$r63 = \$r11;;
+ .*38:	00 00 00 80 	nop ;;
+ .*3c:	00 00 00 80 	nop ;;
+ .*40:	f8 ff 7f 31 	goto .*20 \<_etext\+0x8\>
+ .*44:	40 02 00 08 	mov \$r9 = 0 \(0x0\);;
+ .*48:	00 00 00 95 	
+ .*4c:	00 00 00 80 	nop ;;
+.*
+ .*60:	00 00 80 15 	
+ .*64:	ce cf 00 20 	ldw \$r63 = .* \(0xc\)\[\$r14\]
+ .*68:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ .*6c:	01 00 00 b1 	syncins ;;
+ .*70:	00 00 00 80 	nop ;;
+ .*74:	00 00 80 31 	goto \$r63
+ .*78:	40 f2 03 80 	mov \$r63 = \$r9;;
+ .*7c:	00 00 00 80 	nop ;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-1c.d binutils/ld/testsuite/ld-lx/plt-1c.d
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-1c.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-1c.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,43 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: plt-1.s
+#as: -EB
+#ld: -EB -e 0x1000 -shared
+#objdump: -dR
+#name: plt-1c Creation of PLT entry, big-endian, position-independent
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+0000030c \<__stext\>:
+ 30c:	80 00 00 80 	mov \$r0 = \$r2;;
+
+00000310 \<__text_start\>:
+ 310:	b0 00 00 14 	call \$r63 = 360 \<_etext\+0x48\>;;
+ 314:	80 00 00 80 	mov \$r0 = \$r2;;
+Disassembly of section \.plt:
+
+0.*20 \<\.plt\>:
+ .*20:	20 00 4f ce 	ldw \$r63 = 4 \(0x4\)\[\$r14\]
+ .*24:	80 00 bf c0 	mov \$r11 = \$r63;;
+ .*28:	a0 00 02 8e 	ldw \$r10 = 0 \(0x0\)\[\$r14\];;
+ .*2c:	b1 00 00 01 	syncins ;;
+ .*30:	31 80 00 00 	goto \$r63
+ .*34:	80 03 f2 c0 	mov \$r63 = \$r11;;
+ .*38:	80 00 00 00 	nop ;;
+ .*3c:	80 00 00 00 	nop ;;
+ .*40:	31 7f ff f8 	goto .*20 \<_etext\+0x8\>
+ .*44:	08 00 02 40 	mov \$r9 = 0 \(0x0\);;
+ .*48:	95 00 00 00 	
+ .*4c:	80 00 00 00 	nop ;;
+.*
+ .*60:	15 80 00 00 	
+ .*64:	20 00 cf ce 	ldw \$r63 = 12 \(0xc\)\[\$r14\]
+ .*68:	80 00 9f c0 	mov \$r9 = \$r63;;
+ .*6c:	b1 00 00 01 	syncins ;;
+ .*70:	80 00 00 00 	nop ;;
+ .*74:	31 80 00 00 	goto \$r63
+ .*78:	80 03 f2 40 	mov \$r63 = \$r9;;
+ .*7c:	80 00 00 00 	nop ;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-1d.d binutils/ld/testsuite/ld-lx/plt-1d.d
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-1d.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-1d.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,40 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: plt-1.s
+#as: -EB
+#ld: -EB -e 0x1000 -L. -laasharedbig
+#objdump: -d
+#name: plt-1d Creation of PLT entry, big-endian, absolute
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+0.*000 \<__stext\>:
+ .*000:	b0 00 00 18 	call \$r63 = .*060 \<_etext\+0x58\>;;
+ .*004:	80 00 00 80 	mov \$r0 = \$r2;;
+Disassembly of section \.plt:
+
+0.*020 \<\.plt\>:
+ .*020:	15 84 00 01 	
+ .*024:	20 07 4f c0 	ldw \$r63 = .* \(0x.*274\)\[\$r0\]
+ .*028:	80 00 bf c0 	mov \$r11 = \$r63;;
+ .*02c:	20 07 02 80 	ldw \$r10 = .* \(0x.*270\)\[\$r0\];;
+ .*030:	95 04 00 01 	
+ .*034:	b1 00 00 01 	syncins ;;
+ .*038:	31 80 00 00 	goto \$r63
+ .*03c:	80 03 f2 c0 	mov \$r63 = \$r11;;
+ .*040:	31 7f ff f8 	goto .*020 \<_etext\+0x18\>
+ .*044:	08 00 02 40 	mov \$r9 = 0 \(0x0\);;
+ .*048:	95 00 00 00 	
+ .*04c:	80 00 00 00 	nop ;;
+.*
+ .*060:	15 84 00 01 	
+ .*064:	20 07 cf c0 	ldw \$r63 = .* \(0x.*27c\)\[\$r0\]
+ .*068:	80 00 9f c0 	mov \$r9 = \$r63;;
+ .*06c:	b1 00 00 01 	syncins ;;
+ .*070:	80 00 00 00 	nop ;;
+ .*074:	31 80 00 00 	goto \$r63
+ .*078:	80 03 f2 40 	mov \$r63 = \$r9;;
+.*
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-1.s binutils/ld/testsuite/ld-lx/plt-1.s
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-1.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,8 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Check basic creation of PLT entry
+	.text
+start:
+	.global start
+	call $r63=foofun
+	;;
+	
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-2.d binutils/ld/testsuite/ld-lx/plt-2.d
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-2.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-2.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,20 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: plt-2.s
+#as: -EL
+#ld: -EL -e 0x1000
+#objdump: -d
+#name: plt-2 No PLT entry created for weakly defined symbol in absolute program
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+0.*000 \<__stext\>:
+ .*000:	02 00 00 b0 	call \$r63 = .*008 \<weakfoo\>;;
+ .*004:	00 00 00 80 	nop ;;
+
+0.*008 \<weakfoo\>:
+ .*008:	00 00 00 80 	nop ;;
+ .*00c:	80 00 00 80 	mov \$r0 = \$r2;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-2.s binutils/ld/testsuite/ld-lx/plt-2.s
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-2.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-2.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,11 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	.text
+	call $r63=weakfoo
+	;;
+	nop
+	;;
+weakfoo:
+	.weak weakfoo
+	nop
+	;;
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-3.d binutils/ld/testsuite/ld-lx/plt-3.d
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-3.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-3.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,22 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: plt-3.s
+#as: -EL
+#ld: -EL -e 0x1000 -L. -laashared
+#objdump: -dRT -j.text
+#name: Absolute ref to dynamic fn resolves to address of PLT
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+DYNAMIC SYMBOL TABLE:
+08000008 g    D  \.text	00000000 _etext
+08000000 g    D  \.text	00000000 __text_start
+08000000 g    D  \.text	00000000 __stext
+
+
+Disassembly of section \.text:
+
+08000000 \<__stext\>:
+ 8000000:	00 00 84 15 	
+ 8000004:	c0 05 06 a0 	ldw \$r23 = .* \(0x8000060\)\[\$r0\];;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-3.s binutils/ld/testsuite/ld-lx/plt-3.s
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-3.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-3.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,7 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# An absolute reference in the text of a main program to a function in a
+# shared library, resolves to the plt entry for the function.
+	.text
+	ldw $r23=foofun[$r0]
+	;;
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-4a.s binutils/ld/testsuite/ld-lx/plt-4a.s
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-4a.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-4a.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,9 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+# Check creation of PLT entry with long branch stub
+	.text
+start2:
+	# Make this section artifically big, so that PLT entries are far away
+	.space 0x2000000
+	.global start2
+	call $r63=foofun
+	;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-4b.s binutils/ld/testsuite/ld-lx/plt-4b.s
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-4b.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-4b.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,10 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+# Check creation of PLT entry with long branch stub
+	.text
+start3:
+	# Make this section artifically big, so that PLT entries are far away
+	.space 0x2000000
+	.global start3
+	call $r63=foofun
+	;;
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-4.d binutils/ld/testsuite/ld-lx/plt-4.d
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-4.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-4.d	2010-05-25 12:04:31.134734000 +0100
@@ -0,0 +1,64 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+#source: plt-4.s
+#source: plt-4a.s
+#source: plt-4b.s
+#as: -EL
+#ld: -EL -e 0x1000 -L. -laashared --section-start .foo=0x2000000
+#objdump: -d
+#name: plt-4 Creation of PLT entry with long branch stubs, little-endian, absolute
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section .text:
+
+.* \<__stext\>:
+.*00:	02 00 00 b0 	call \$r63 = .*08 \<.*\+0x8\>;;
+.*04:	80 00 00 80 	mov \$r0 = \$r2;;
+.*08:	00 00 86 15 	
+.*0c:	c0 0f 0a 08 	mov \$r63 = .* \(0x.*a0\)
+.*10:	c0 9f 00 80 	mov \$r9 = \$r63;;
+.*14:	01 00 00 b1 	syncins ;;
+.*18:	00 00 80 31 	goto \$r63
+.*1c:	40 f2 03 80 	mov \$r63 = \$r9;;
+
+.*20 <start2>:
+	...
+.*20:	02 00 00 b0 	call \$r63 = .*28 <start2\+0x2000008>;;
+.*24:	80 00 00 80 	mov \$r0 = \$r2;;
+.*28:	00 00 86 15 	
+.*2c:	c0 0f 0a 08 	mov \$r63 = .* \(0x.*a0\)
+.*30:	c0 9f 00 80 	mov \$r9 = \$r63;;
+.*34:	01 00 00 b1 	syncins ;;
+.*38:	00 00 80 31 	goto \$r63
+.*3c:	40 f2 03 80 	mov \$r63 = \$r9;;
+
+.*40 <start3>:
+	...
+.*40:	18 00 00 b0 	call \$r63 = .* <_etext\+0x58>;;
+.*44:	80 00 00 80 	mov \$r0 = \$r2;;
+Disassembly of section \.plt:
+
+.*60 \<\.plt\>:
+ .*60:	01 00 86 15 	
+ .*64:	c0 0f 0b 20 	ldw \$r63 = .* \(0x.*2b0\)\[\$r0\]
+ .*68:	c0 bf 00 80 	mov \$r11 = \$r63;;
+ .*6c:	80 c2 0a 20 	ldw \$r10 = .* \(0x.*2ac\)\[\$r0\];;
+ .*70:	01 00 06 95 	
+ .*74:	01 00 00 b1 	syncins ;;
+ .*78:	00 00 80 31 	goto \$r63
+ .*7c:	c0 f2 03 80 	mov \$r63 = \$r11;;
+ .*80:	f8 ff 7f 31 	goto .*60 \<_etext\+0x18\>
+ .*84:	40 02 00 08 	mov \$r9 = 0 \(0x0\);;
+ .*88:	00 00 00 95 	
+ .*8c:	00 00 00 80 	nop ;;
+.*
+ .*a0:	01 00 86 15 	
+ .*a4:	c0 8f 0b 20 	ldw \$r63 = .* \(0x.*2b8\)\[\$r0\]
+ .*a8:	c0 9f 00 80 	mov \$r9 = \$r63;;
+ .*ac:	01 00 00 b1 	syncins ;;
+ .*b0:	00 00 00 80 	nop ;;
+ .*b4:	00 00 80 31 	goto \$r63
+ .*b8:	40 f2 03 80 	mov \$r63 = \$r9;;
+.*
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-4.s binutils/ld/testsuite/ld-lx/plt-4.s
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-4.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-4.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,8 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+# Check creation of PLT entry with long branch stub
+	.text
+start:
+	.global start
+	call $r63=foofun
+	;;
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-5.d binutils/ld/testsuite/ld-lx/plt-5.d
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-5.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-5.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,43 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+#source: plt-5.s
+#as: -EL
+#ld: -EL -Tshared.ld -shared
+#objdump: -d
+#name: plt-5 Use PLT entry for a call to a weakly defined symbol from a shared library
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+00000074 \<__stext\>:
+  74:	80 00 00 80 	mov \$r0 = \$r2;;
+
+00000078 \<__text_start\>:
+  78:	12 00 00 b0 	call \$r63 = c0 \<_etext\+0x40\>;;
+  7c:	80 00 00 80 	mov \$r0 = \$r2;;
+Disassembly of section .plt:
+
+00000080 \<.plt\>:
+  80:	ce 4f 00 20 	ldw \$r63 = 4 \(0x4\)\[\$r14\]
+  84:	c0 bf 00 80 	mov \$r11 = \$r63;;
+  88:	8e 02 00 a0 	ldw \$r10 = 0 \(0x0\)\[\$r14\];;
+  8c:	01 00 00 b1 	syncins ;;
+  90:	00 00 80 31 	goto \$r63
+  94:	c0 f2 03 80 	mov \$r63 = \$r11;;
+  98:	00 00 00 80 	nop ;;
+  9c:	00 00 00 80 	nop ;;
+  a0:	f8 ff 7f 31 	goto 80 <_etext>
+  a4:	40 02 00 08 	mov \$r9 = 0 \(0x0\);;
+  a8:	00 00 00 95 	
+  ac:	00 00 00 80 	nop ;;
+	...
+  c0:	00 00 80 15 	
+  c4:	ce cf 00 20 	ldw \$r63 = 12 \(0xc\)\[\$r14\]
+  c8:	c0 9f 00 80 	mov \$r9 = \$r63;;
+  cc:	01 00 00 b1 	syncins ;;
+  d0:	00 00 00 80 	nop ;;
+  d4:	00 00 80 31 	goto \$r63
+  d8:	40 f2 03 80 	mov \$r63 = \$r9;;
+  dc:	00 00 00 80 	nop ;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/plt-5.s binutils/ld/testsuite/ld-lx/plt-5.s
--- binutils-2.21.51/ld/testsuite/ld-lx/plt-5.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/plt-5.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,7 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+
+	.text
+foo::
+	.weak __pthread_once
+	call $r63 = __pthread_once
+	;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-1a.d binutils/ld/testsuite/ld-lx/rel-1a.d
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-1a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-1a.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,21 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: rel-1.s
+#as: --emit-all-relocs -EL
+#ld: -EL -e 0 --defsym const5a5a=0x5a5a
+#objdump: -sr
+#name: All relocation types, emit-all-relocs
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Contents of section \.text:
+ 8000000 0a0000b0 40000320 00000495 40000320  .*
+ 8000010 00000495 40000520 00000495 4e000020  .*
+ 8000020 00000095 80000080                    .*
+Contents of section moretext:
+ 8000028 00000080                             .*
+Contents of section \.data:
+ 8000030 5a5a3000 00083000 00083000 0000eaff  .*
+ 8000040 ffff0000 00000000 00000000 00000000  .*
+ 8000050 30000008  .*
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-1b.d binutils/ld/testsuite/ld-lx/rel-1b.d
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-1b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-1b.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,21 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: rel-1.s
+#as: --emit-all-relocs -EB
+#ld: -EB -e 0 --defsym const5a5a=0x5a5a
+#objdump: -sr
+#name: All relocation types, emit-all-relocs, big-endian
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Contents of section \.text:
+ 8000000 b000000a 20030040 95040000 20030040  .*
+ 8000010 95040000 20050040 95040000 2000004e  .*
+ 8000020 95000000 80000080                    .*
+Contents of section moretext:
+ 8000028 80000000                             .*
+Contents of section \.data:
+ 8000030 5a5a0800 00300800 00300000 0030ffff  .*
+ 8000040 ffea0000 00000000 00000000 00000000  .*
+ 8000050 08000030  .*
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-1c.d binutils/ld/testsuite/ld-lx/rel-1c.d
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-1c.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-1c.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,34 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: rel-1.s
+#as: --emit-all-relocs -EL
+#ld: -EL -e 0 --defsym const5a5a=0x5a5a --emit-relocs
+#objdump: -r
+#name: rel-1c All relocation types, as emit-all-relocs ld --emit-relocs
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_23_PCREL     foo
+00000004 R_LX_LO9          y
+00000008 R_LX_HI23         y
+0000000c R_LX_LO9          y
+00000010 R_LX_HI23         y
+00000014 R_LX_LO9          _GLOBAL_OFFSET_TABLE_\+0x0000000c
+00000018 R_LX_HI23         _GLOBAL_OFFSET_TABLE_\+0x0000000c
+0000001c R_LX_NEG_GPREL_LO9  y
+00000020 R_LX_NEG_GPREL_HI23  y
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_16           const5a5a
+00000002 R_LX_32           y
+00000006 R_LX_LTV32        y
+0000000a R_LX_SEGREL32     y
+0000000e R_LX_32_PCREL     foo
+00000020 R_LX_32           \*ABS\*\+0x08000030
+
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-1d.d binutils/ld/testsuite/ld-lx/rel-1d.d
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-1d.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-1d.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,34 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: rel-1.s
+#as: --emit-all-relocs -EL
+#ld: -EL -e 0 --defsym const5a5a=0x5a5a --emit-relocs --no-transform-to-absolute
+#objdump: -r
+#name: rel-1d All relocation types, as emit-all-relocs ld --emit-relocs
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_23_PCREL     foo
+00000004 R_LX_LO9          y
+00000008 R_LX_HI23         y
+0000000c R_LX_GPREL_LO9    y
+00000010 R_LX_GPREL_HI23   y
+00000014 R_LX_GOTOFF_LO9   y
+00000018 R_LX_GOTOFF_HI23  y
+0000001c R_LX_NEG_GPREL_LO9  y
+00000020 R_LX_NEG_GPREL_HI23  y
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_16           const5a5a
+00000002 R_LX_32           y
+00000006 R_LX_LTV32        y
+0000000a R_LX_SEGREL32     y
+0000000e R_LX_32_PCREL     foo
+00000020 R_LX_32           \*ABS\*\+0x08000030
+
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-1.s binutils/ld/testsuite/ld-lx/rel-1.s
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-1.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,31 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#  Test to generate all the relocation types the linker accepts
+	
+	.text
+start:
+	call $r63=foo		# R_LX_23_PCREL
+	;; 
+	ldw  $r1=y[$r0]		# R_LX_HI23/R_LX_LO9
+	;;
+	ldw $r1=@gprel(y)[$r14] # R_LX_GPREL_HI23/R_LX_GPREL_LO9
+	;;
+	ldw $r1=@gotoff(y)[$r14] # R_LX_GOTOFF_HI23/R_LX_GOTOFF_LO9
+	;;
+	ldw $r1=@neggprel(y)[$r14] # R_LX_NEGGPREL_HI23/R_LX_NEGGPREL_LO9
+	;;
+
+	.data
+y:
+	.data2 const5a5a	# R_LX_16
+	.long y   		# R_LX_32
+	.long @ltv(y)		# R_LX_LTV32
+	.long @segrel(y)	# R_LX_SEGREL32
+	.long foo - .           # R_LX_32_PCREL
+
+#  The following tests relocation types not used by MCDT tools
+	.section moretext, "ax"
+	.align 8
+foo:
+	nop
+	;; 
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-2a.d binutils/ld/testsuite/ld-lx/rel-2a.d
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-2a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-2a.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,17 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: rel-2.s
+#as: -EL
+#ld: -EL --shared
+#objdump: -R
+#name: rel-2a: Dynamic relocation creation for shared library
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+DYNAMIC RELOCATION RECORDS
+OFFSET   TYPE              VALUE 
+0.*2bc R_LX_REL32        \*ABS\*\+0x0.*2c0
+0.*2b8 R_LX_32           foo
+
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-2b.d binutils/ld/testsuite/ld-lx/rel-2b.d
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-2b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-2b.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,16 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: rel-2.s
+#as: -EL
+#ld: -EL -e 0x1000 -L. -laashared
+#objdump: -R
+#name: Dynamic relocation creation for main program
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+DYNAMIC RELOCATION RECORDS
+OFFSET   TYPE              VALUE 
+0.*1e8 R_LX_32           foo
+
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-2.s binutils/ld/testsuite/ld-lx/rel-2.s
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-2.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-2.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,10 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Test the correct dynamic relocations are created for various cases.
+	
+	.data
+	.long foo         # foo is extern, so requires a R_ST200_32
+	.long hidden_foo  # requires a R_ST200_REL32 in relocatable data
+hidden_foo:
+	.hidden hidden_foo
+	.long 0
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-3a.d binutils/ld/testsuite/ld-lx/rel-3a.d
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-3a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-3a.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,6 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: rel-3.s
+#as: -EL --defsym PLTOFF=1
+#ld: -EL -e 0x1000
+#error: contains relocation \(1[78]\) not appropriate for output ABI
+#name: Test message for inappropriate pltoff relocation types
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-3b.d binutils/ld/testsuite/ld-lx/rel-3b.d
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-3b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-3b.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,6 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: rel-3.s
+#as: -EL --defsym GOTOFF_FPTR=1
+#ld: -EL -e 0x1000
+#error: contains relocation \((19|20)\) not appropriate for output ABI
+#name: Test message for inappropriate gotoff_fptr relocation types
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-3c.d binutils/ld/testsuite/ld-lx/rel-3c.d
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-3c.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-3c.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,6 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: rel-3.s
+#as: -EL --defsym FPTR=1
+#ld: -EL -e 0x1000
+#error: contains relocation \(16\) not appropriate for output ABI
+#name: Test message for inappropriate fptr relocation type
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-3d.d binutils/ld/testsuite/ld-lx/rel-3d.d
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-3d.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-3d.d	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,6 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: rel-3.s
+#as: -EL --defsym IPLT=1
+#ld: -EL -e 0x1000
+#error: contains relocation \(21\) not appropriate for output ABI
+#name: Test message for inappropriate pltoff relocation types
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-3.s binutils/ld/testsuite/ld-lx/rel-3.s
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-3.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-3.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,26 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Test for warnings about relocation types that do not match the ABI
+	
+#  The following tests relocation types not used by MCDT tools
+	.text
+	
+	.ifdef PLTOFF
+	ldw $r1=@pltoff(x)[$r14] # R_LX_PLTOFF_HI23/R_LX_PLTOFF_LO9
+	;;
+	.endif
+	
+	.ifdef GOTOFF_FPTR
+	ldw $r1=@gotoff(@fptr(start))[$r14] # R_LX_GOTOFF_FPTR_HI23/LO9
+	;; 
+	.endif
+
+	.ifdef FPTR
+	.long @fptr(start)	# R_LX_FPTR32
+	.endif
+
+	.ifdef IPLT
+	.long @iplt(start)	# R_LX_IPLT
+	.long 0
+	.endif
+	
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-4a.d binutils/ld/testsuite/ld-lx/rel-4a.d
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-4a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-4a.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,21 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 2008
+#source: rel-4.s
+#as: --emit-all-relocs -EL
+#ld: -EL -e start
+#objdump: -sr
+#name: rel-4a: All relocation types, emit-all-relocs
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Contents of section \.text:
+ 8000000 00008015 4d4001a0 00008015 40400188  .*
+ 8000010 00008415 404004a0 00008015 40400088  .*
+ 8000020 00008415 40c004a0                    .*
+Contents of section \.data:
+ 8000028 14000000 01000000 04000000 00000000  .*
+ 8000038 00000000 00000000 00000000 01000000  .*
+ 8000048 00000000 01000000 04000000           .*
+Contents of section \.tdata:
+ 8000054 17000000 00000000                    .*
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-4b.d binutils/ld/testsuite/ld-lx/rel-4b.d
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-4b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-4b.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,39 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 2008
+#source: rel-4.s
+#as: --emit-all-relocs -EL
+#ld: -EL -e start --emit-relocs
+#objdump: -r
+#name: rel-4b: All relocation types, as emit-all-relocs ld --emit-relocs
+#comment: Bare/OS21 script required.
+#comment: transforms GOTOFF_TPREL => TPREL
+#comment: transforms GOTOFF_DTPLDM => absolute
+#comment: transforms GOTOFF_DTPNDX => absolute
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   TYPE              VALUE 
+00000004 R_LX_TPREL_LO9    y
+00000000 R_LX_TPREL_HI23   y
+0000000c R_LX_TPREL_LO9    y
+00000008 R_LX_TPREL_HI23   y
+00000014 R_LX_LO9          _GLOBAL_OFFSET_TABLE_\+0x00000010
+00000010 R_LX_HI23         _GLOBAL_OFFSET_TABLE_\+0x00000010
+0000001c R_LX_DTPREL_LO9   y
+00000018 R_LX_DTPREL_HI23  y
+00000024 R_LX_LO9          _GLOBAL_OFFSET_TABLE_\+0x00000018
+00000020 R_LX_HI23         _GLOBAL_OFFSET_TABLE_\+0x00000018
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_TPREL32      y
+00000004 R_LX_DTPMOD32     y
+00000008 R_LX_DTPREL32     y
+0000001c R_LX_DTPMOD32     y
+00000024 R_LX_DTPMOD32     y
+00000024 R_LX_NONE         \*ABS\*
+00000024 R_LX_NONE         \*ABS\*
+
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-4c.d binutils/ld/testsuite/ld-lx/rel-4c.d
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-4c.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-4c.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,37 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 2008
+#source: rel-4.s
+#as: --emit-all-relocs -EL
+#ld: -EL -e start --emit-relocs --no-transform-to-absolute
+#objdump: -r
+#name: rel-4c: All relocation types, as emit-all-relocs ld --emit-relocs --no-transform-to-absolute
+#comment: Bare/OS21 script required.
+#comment: TLS transformations still performed even with no relax and no transform to absolute
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   TYPE              VALUE 
+00000004 R_LX_TPREL_LO9    y
+00000000 R_LX_TPREL_HI23   y
+0000000c R_LX_TPREL_LO9    y
+00000008 R_LX_TPREL_HI23   y
+00000014 R_LX_GOTOFF_DTPLDM_LO9  y
+00000010 R_LX_GOTOFF_DTPLDM_HI23  y
+0000001c R_LX_DTPREL_LO9   y
+00000018 R_LX_DTPREL_HI23  y
+00000024 R_LX_GOTOFF_DTPNDX_LO9  y
+00000020 R_LX_GOTOFF_DTPNDX_HI23  y
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_TPREL32      y
+00000004 R_LX_DTPMOD32     y
+00000008 R_LX_DTPREL32     y
+0000001c R_LX_DTPMOD32     y
+00000024 R_LX_DTPMOD32     y
+00000024 R_LX_NONE         \*ABS\*
+00000024 R_LX_NONE         \*ABS\*
+
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-4.s binutils/ld/testsuite/ld-lx/rel-4.s
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-4.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-4.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,24 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+# Test for tls relocation types.
+
+	.text
+start::
+	ldw $r1=@tprel(y)[$r13] # R_LX_TPREL_HI23/R_LX_TPREL_LO9
+	;;
+	ldw $r1=@gotoff(@tprel(y))[$r14] # R_LX_GOTOFF_TPREL_HI23/R_LX_GOTOFF_TPREL_LO9
+	;;
+	ldw $r1=@gotoff(@dtpldm(y))[$r14] # R_LX_GOTOFF_DTPLDM_HI23/R_LX_GOTOFF_DTPLDM_LO9
+	;;
+	mov $r1=@dtprel(y)	# R_LX_DTPREL_HI23/R_LX_DTPREL_LO9
+	;;
+	ldw $r1=@gotoff(@dtpndx(y))[$r14] # R_LX_GOTOFF_DTPNDX_HI23/R_LX_GOTOFF_DTPNDX_LO9
+	;; 
+
+	.data
+	.long @tprel(y)		# R_LX_TPREL32
+	.long @dtpmod(y)	# R_LX_DTPMOD
+	.long @dtprel(y)	# R_LX_DTPREL
+
+	.section .tdata,"awT"
+	.long 23
+y::	.long 0
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-5a.d binutils/ld/testsuite/ld-lx/rel-5a.d
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-5a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-5a.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,36 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: rel-5.s
+#as: --emit-all-relocs -EL
+#ld: -EL -e 0 --defsym const5a5a=0x5a5a --emit-relocs --no-transform-to-absolute
+#objdump: -r
+#name: rel-5a All relocation types, global syms, as emit-all-relocs ld --emit-relocs
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   TYPE              VALUE 
+00000004 R_LX_GOTOFF_LO9   y
+00000000 R_LX_GOTOFF_HI23  y
+0000000c R_LX_GOTOFF_LO9   local_y
+00000008 R_LX_GOTOFF_HI23  local_y
+00000014 R_LX_GOTOFF_LO9   foo
+00000010 R_LX_GOTOFF_HI23  foo
+0000001c R_LX_GOTOFF_LO9   local_foo
+00000018 R_LX_GOTOFF_HI23  local_foo
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_16           const5a5a
+00000002 R_LX_32           y
+00000006 R_LX_LTV32        y
+0000000a R_LX_SEGREL32     y
+0000000e R_LX_32_PCREL     foo
+00000020 R_LX_32           y
+0000002c R_LX_32           \*ABS\*\+0x08000028
+00000024 R_LX_32           foo
+00000028 R_LX_32           \*ABS\*\+0x08000020
+
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/rel-5.s binutils/ld/testsuite/ld-lx/rel-5.s
--- binutils-2.21.51/ld/testsuite/ld-lx/rel-5.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/rel-5.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,33 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#  Test to generate GOT static relocations for local and global symbols.
+	
+	.text
+start:
+	ldw $r1=@gotoff(y)[$r14] # R_LX_GOTOFF_HI23/R_LX_GOTOFF_LO9
+	;;
+	ldw $r1=@gotoff(local_y)[$r14] # R_LX_GOTOFF_HI23/R_LX_GOTOFF_LO9
+	;;
+	ldw $r1=@gotoff(foo)[$r14] # R_LX_GOTOFF_HI23/R_LX_GOTOFF_LO9
+	;;
+	ldw $r1=@gotoff(local_foo)[$r14] # R_LX_GOTOFF_HI23/R_LX_GOTOFF_LO9
+	;;
+	
+
+	.data
+y:
+local_y:	
+	.global y
+	.data2 const5a5a	# R_LX_16
+	.long y   		# R_LX_32
+	.long @ltv(y)		# R_LX_LTV32
+	.long @segrel(y)	# R_LX_SEGREL32
+	.long foo - .           # R_LX_32_PCREL
+
+	.section moretext, "ax"
+	.align 8
+foo:
+local_foo:
+	.global foo
+	nop
+	;; 
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/relax-1a.d binutils/ld/testsuite/ld-lx/relax-1a.d
--- binutils-2.21.51/ld/testsuite/ld-lx/relax-1a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/relax-1a.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,23 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: relax-1.s
+#as: -EL -mcore=st240 --defsym st240=1
+#ld: -EL -e 0x1000 -shared -relax
+#objdump: -d
+#name: relax-1a GOT load transformed to GP-relative add, st240 encodings
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+0.*bc <__stext>:
+ .*bc:	80 00 00 80 	mov \$r0 = \$r2;;
+
+.*c0 \<__text_start\>:
+ .*c0:	ff ff ff 15 	
+ .*c4:	ce 80 1f 88 	add \$r3 = \$r14, -8 \(0xfffffff8\);;
+Disassembly of section moretext:
+
+0.*c8 <foo>:
+ .*c8:	00 00 00 80 	nop ;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/relax-1b.d binutils/ld/testsuite/ld-lx/relax-1b.d
--- binutils-2.21.51/ld/testsuite/ld-lx/relax-1b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/relax-1b.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,24 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: relax-1.s
+#as: -EL
+#ld: -EL -e 0x1000 -shared -relax --emit-relocs
+#objdump: -r
+#name: relax-1b: GOT load transformed to GP-relative add --emit-relocs
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   TYPE              VALUE 
+00000008 R_LX_GPREL_LO9    foo
+00000004 R_LX_GPREL_HI23   foo
+00000010 R_LX_GPREL_LO9    foo
+0000000c R_LX_GPREL_HI23   foo
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+0000000c R_LX_NONE         \*ABS\*
+
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/relax-1.d binutils/ld/testsuite/ld-lx/relax-1.d
--- binutils-2.21.51/ld/testsuite/ld-lx/relax-1.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/relax-1.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,25 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: relax-1.s
+#as: -EL
+#ld: -EL -e 0x1000 -shared -relax
+#objdump: -d
+#name: relax-1 GOT load transformed to GP-relative add
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section .text:
+
+000002bc \<__stext\>:
+ 2bc:	80 00 00 80 	mov \$r0 = \$r2;;
+
+000002c0 \<__text_start\>:
+ 2c0:	ff ff ff 15 	
+ 2c4:	ce 80 1f 88 	add \$r3 = \$r14, -8 \(0xfffffff8\);;
+ 2c8:	ff ff ff 15 	
+ 2cc:	ce 80 1f 88 	add \$r3 = \$r14, -8 \(0xfffffff8\);;
+Disassembly of section moretext:
+
+0.*d0 <foo>:
+ .*d0:	00 00 00 80 	nop ;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/relax-1.s binutils/ld/testsuite/ld-lx/relax-1.s
--- binutils-2.21.51/ld/testsuite/ld-lx/relax-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/relax-1.s	2006-09-11 14:24:11.021723000 +0100
@@ -0,0 +1,18 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	# GOT loads can be transformed to GP-relative additions when
+	# linker relaxation is enabled.
+	.text
+	ldw $r3 = @gotoff(foo)[$r14] # base reg. replaced by $r0
+	;;
+	.ifndef st240 
+	ldw.d $r3 = @gotoff(foo)[$r14] # base reg. replaced by $r0
+	;;
+	.endif
+	
+	.section moretext,"ax"
+	.balign 4
+foo:
+	.hidden foo
+	nop
+	;;
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/reloc-rodata.d binutils/ld/testsuite/ld-lx/reloc-rodata.d
--- binutils-2.21.51/ld/testsuite/ld-lx/reloc-rodata.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/reloc-rodata.d	2010-08-06 09:07:18.916178000 +0100
@@ -0,0 +1,21 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+#source: reloc-rodata.s
+#as: -EL
+#ld: -EL -e 0x1000 -shared
+#objdump: -RT
+#name: Codex bug-56839 (Bogus error: dynamic relocation of non-writeable section)
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+DYNAMIC SYMBOL TABLE:
+#...
+.* g    D  \.data	00000000 myvar
+#...
+.* g    D  \.data	00000000 mydata
+#...
+
+DYNAMIC RELOCATION RECORDS
+OFFSET   TYPE              VALUE 
+.* R_LX_32           mydata
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/reloc-rodata.s binutils/ld/testsuite/ld-lx/reloc-rodata.s
--- binutils-2.21.51/ld/testsuite/ld-lx/reloc-rodata.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/reloc-rodata.s	2010-08-06 09:07:18.916178000 +0100
@@ -0,0 +1,10 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+	.section .data.rel.ro, "aw", @progbits
+myvar:
+	.global myvar
+	.long mydata
+
+	.data
+mydata:
+	.global mydata
+	.long 23
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/shared.ld binutils/ld/testsuite/ld-lx/shared.ld
--- binutils-2.21.51/ld/testsuite/ld-lx/shared.ld	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/shared.ld	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,235 @@
+/* Script for ld --shared: link shared library */
+OUTPUT_FORMAT("elf32-littlelx", "elf32-lx", "elf32-littlelx")
+OUTPUT_ARCH(lx)
+ENTRY(__start)
+/* import board mapping definition using search rule -L */
+/* @INCLUDE board.ld@ */
+/* import soc mapping definition using search rule -L */
+/* @INCLUDE soc.ld@ */
+/* import core mapping definition using search rule -L */
+/* @INCLUDE core.ld@ */
+/*
+ * Define the sections
+ */
+SECTIONS
+{
+   . = 0 + SIZEOF_HEADERS;
+  /*==============*/
+  /* text section */
+  /*==============*/
+  /* *** Alignment support *** */
+  /* This will force alignment to a 32 byte boundary
+  if _text_align is defined to be 0x20 */
+  _text_align = (DEFINED(_text_align) ? _text_align : 0x1);
+  /* *** End Alignment support *** */
+  .text ALIGN(_text_align):
+ 	 {
+           __stext = .;
+           /*
+            *  The typical boot code behaviour is to jump to the beginning
+	    *  of the .text section. Be careful that in this case the
+	    *  crt0.o module must be linked in first position.
+	    */
+	  . = ALIGN(8);
+          __text_start = .;
+	  CREATE_OBJECT_SYMBOLS
+	  *(.text)
+	  *(.text.*)
+	  /* .gnu.warning sections are handled specially by elf32.em.  */
+	  *(.gnu.warning)
+	  *(.gnu.linkonce.t.*)
+	  . = ALIGN(8);
+          _etext = .;
+        } /* @> ram@ */ = 0x80000080
+   .plt    :
+        {
+	 *(.plt)
+
+    /* Ensure the end of each text-like section is at least
+    on a word boundary if we are going to
+    have a .post_text_reserve section */
+    . = (DEFINED(_post_text_reserve) ? ALIGN(4) : .);
+	} /* @> ram@ */ = 0
+/*=================================================== */
+/* Dynamic sections. Put into text segment (readonly) */
+/*=================================================== */
+   .hash       : { *(.hash) } /* @> ram@ */
+   .dynsym     : { *(.dynsym) } /* @> ram@ */
+   .dynstr     : { *(.dynstr) } /* @> ram@ */
+   .rel.dyn    :
+        {
+          *(.rel.init)
+          *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)
+          *(.rel.fini)
+          *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)
+          *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)
+          *(.rel.ctors)
+          *(.rel.dtors)
+          *(.rel.got)
+          *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)
+        }  /* @> ram@ */
+   .rela.dyn   :
+        {
+          *(.rela.init)
+          *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)
+          *(.rela.fini)
+          *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)
+          *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)
+          *(.rela.ctors)
+          *(.rela.dtors)
+          *(.rela.got)
+          *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)
+        } /* @> ram@ */
+   .rel.plt    : { *(.rel.plt) } /* @> ram@ */
+   .rela.plt   : { *(.rela.plt) } /* @> ram@ */
+  /*=============*/
+  /* .init section */
+  /*=============*/
+   .init   :
+	{
+	  KEEP (*(.init))
+
+    /* Ensure the end of each text-like section is at least
+    on a word boundary if we are going to
+    have a .post_text_reserve section */
+    . = (DEFINED(_post_text_reserve) ? ALIGN(4) : .);
+        } /* @> ram@ */ = 0x80000080
+  /*=============*/
+  /* .finit section */
+  /*=============*/
+   .fini   :
+	{
+	  KEEP (*(.fini))
+
+    /* Ensure the end of each text-like section is at least
+    on a word boundary if we are going to
+    have a .post_text_reserve section */
+    . = (DEFINED(_post_text_reserve) ? ALIGN(4) : .);
+        } /* @> ram@ */ = 0x80000080
+  __etext = .;
+  /* *** Alignment support *** */
+  /* This will reserve a number of bytes after the text sections in a new
+     section. */
+  .post_text_reserve :
+  {
+    _post_text_res = (DEFINED(_post_text_reserve) ? ABSOLUTE(_post_text_reserve) : 0);
+    . += _post_text_res;
+  } /* @> ram@ */ = 0xDEADADDA
+  /* *** End Alignment support *** */
+  /* *** Alignment support *** */
+  /* This will force alignment to a 32 byte boundary
+  if _rodata_align is defined to be 0x20 */
+  _rodata_align = (DEFINED(_rodata_align) ? _rodata_align : 8);
+  /* *** End Alignment support *** */
+  /*=============*/
+  /* rodata section */
+  /*=============*/
+   .rodata   ALIGN(_rodata_align) :
+       {
+        __srodata = .;
+	*(.rodata)
+	*(.rodata.*)
+	*(.gnu.linkonce.r.*)
+
+    /* Ensure the end of rodata is at least on a word boundary if we are going to
+       have a .post_rodata_reserve section */
+    . = (DEFINED(_post_rodata_reserve) ? ALIGN(4) : .);
+       } /* @> ram@ */ = 0
+  __erodata = .;
+  /* *** Alignment support *** */
+  /* This will reserve a number of bytes after the rodata sections in a new
+     section. */
+  .post_rodata_reserve :
+  {
+    _post_rodata_res = (DEFINED(_post_rodata_reserve) ? ABSOLUTE(_post_rodata_reserve) : 0);
+    . += _post_rodata_res;
+  } /* @> ram@ */ = 0xDEADADDA
+  /* *** End Alignment support *** */
+  /*==============================*/
+  /* exceptions tables */
+  /*==============================*/
+  .except_table   :
+       {
+        *(.except_table)
+       } /* @> ram@ */
+  /DISCARD/  : { *(.except_table_supp); }
+  .eh_frame   :
+       {
+         . = ALIGN(4);
+        KEEP(*(.eh_frame))
+       } /* @> ram@ */
+  /*==============*/
+  /* ctors section */
+  /*==============*/
+   .ctors   :
+       {
+        KEEP (*(.ctors))
+       } /* @> ram@ */
+  /*==============*/
+  /* dtors section */
+  /*==============*/
+   .dtors   :
+       {
+        KEEP (*(.dtors))
+       } /* @> ram@ */
+  /*==============*/
+  /* data section */
+  /*==============*/
+   .data   :
+        {
+          . = ALIGN(4);
+          _data_start = .;
+	  *(.data)
+	  *(.data.*)
+	  *(.gnu.linkonce.d.*)
+          *(.got.plt)
+          *(.got)
+          . = ALIGN(4);
+          _edata = .;
+        } /* @> ram@ */
+   /*==============================*/
+   /* dynamic section (read/write) */
+   /*==============================*/
+   .dynamic : {    *(.dynamic) } /* @> ram@ */
+  /*=============*/
+  /* bss section */
+  /*=============*/
+   .bss   :
+       {
+        . = ALIGN(4);
+	_bss_start = .;
+	*(.bss)
+	*(.bss.*)
+	*(.dynbss)
+	*(COMMON)
+        *(.gnu.linkonce.b.*)
+	. = ALIGN(4);
+	_ebss = .;
+	_end = .;
+       } /* @> ram@ */
+  /* DWARF2 debugging sections */
+  .debug_info       0 : { *(.debug_info) }
+  .debug_line       0 : { *(.debug_line) }
+  .debug_abbrev     0 : { *(.debug_abbrev) }
+  .debug_frame      0 : { *(.debug_frame) }
+  .debug_aranges    0 : { *(.debug_aranges) }
+  .debug_pubnames   0 : { *(.debug_pubnames) }
+  .debug_str        0 : { *(.debug_str) }
+  .debug_funcnames  0 : { *(.debug_funcnames) }
+  .debug_typenames  0 : { *(.debug_typenames) }
+  .debug_varnames   0 : { *(.debug_varnames) }
+  .debug_weaknames  0 : { *(.debug_weaknames) }
+  .debug_macinfo    0 : { *(.debug_macinfo) }
+  .debug_loc        0 : { *(.debug_loc) }
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+  .LX.unwind 0 : { *(.LX.unwind) }
+  .LX.unwind_info 0 : { *(.LX.unwind_info) }
+  /DISCARD/ : {  *(.profile_info); }
+}
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/transform-1b.d binutils/ld/testsuite/ld-lx/transform-1b.d
--- binutils-2.21.51/ld/testsuite/ld-lx/transform-1b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/transform-1b.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,24 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: transform-1.s
+#as: -EL
+#ld: -EL -e 0x1000 --no-transform-to-absolute
+#objdump: -d
+#name: transform-1b GP-relative reference transformed to absolute.
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+08000000 \<__stext\>:
+ 8000000:	00 00 80 15 	
+ 8000004:	ce c0 00 a0 	ldw \$r3 = 12 \(0xc\)\[\$r14\];;
+ 8000008:	ff ff ff 15 	
+ 800000c:	0e 81 1f a0 	ldw \$r4 = -8 \(0xfffffff8\)\[\$r14\];;
+ 8000010:	ff ff ff 15 	
+ 8000014:	4e 81 1f 88 	add \$r5 = \$r14, -8 \(0xfffffff8\);;
+Disassembly of section moretext:
+
+08000018 \<foo\>:
+ 8000018:	00 00 00 80 	nop ;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/transform-1c.d binutils/ld/testsuite/ld-lx/transform-1c.d
--- binutils-2.21.51/ld/testsuite/ld-lx/transform-1c.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/transform-1c.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,25 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 2008
+#source: transform-1.s
+#as: -EL
+#ld: -EL -e 0x1000 --emit-relocs
+#objdump: -r
+#name: transform-1c: emit-relocs for GP-relative reference transformed to absolute.
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   TYPE              VALUE 
+00000004 R_LX_LO9          _GLOBAL_OFFSET_TABLE_\+0x0000000c
+00000000 R_LX_HI23         _GLOBAL_OFFSET_TABLE_\+0x0000000c
+0000000c R_LX_LO9          foo
+00000008 R_LX_HI23         foo
+00000014 R_LX_LO9          foo
+00000010 R_LX_HI23         foo
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+0000000c R_LX_32           foo
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/transform-1.d binutils/ld/testsuite/ld-lx/transform-1.d
--- binutils-2.21.51/ld/testsuite/ld-lx/transform-1.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/transform-1.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,24 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: transform-1.s
+#as: -EL
+#ld: -EL -e 0x1000
+#objdump: -d
+#name: GP-relative reference transformed to absolute.
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+0.*000 \<__stext\>:
+ .*000:	00 00 84 15 	
+ .*004:	c0 c0 02 a0 	ldw \$r3 = [0-9]* \(0x.*02c\)\[\$r0\];;
+ .*008:	00 00 84 15 	
+ .*00c:	00 81 01 a0 	ldw \$r4 = [0-9]* \(0x.*018\)\[\$r0\];;
+ .*010:	00 00 84 15 	
+ .*014:	40 81 01 88 	mov \$r5 = [0-9]* \(0x.*018\);;
+Disassembly of section moretext:
+
+0.*018 \<foo\>:
+ .*018:	00 00 00 80 	nop ;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/transform-1.s binutils/ld/testsuite/ld-lx/transform-1.s
--- binutils-2.21.51/ld/testsuite/ld-lx/transform-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/transform-1.s	2005-12-23 13:01:37.509789000 +0000
@@ -0,0 +1,18 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	# A GP-relative reference is transformed to an absolute reference
+	# when building an absolute main program.
+	.text
+	ldw $r3 = @gotoff(foo)[$r14] # base reg. replaced by $r0
+	;;
+	ldw $r4 = @gprel(foo)[$r14]  # base reg replaced by $r0
+	;; 
+	add $r5 = $r14, @gprel(foo)  # $r14 replaced by $r0, disassembles as mov
+	;;
+
+	.section moretext,"ax"
+	.balign 4
+foo:
+	.global foo
+	nop
+	;;
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/transform-2a.d binutils/ld/testsuite/ld-lx/transform-2a.d
--- binutils-2.21.51/ld/testsuite/ld-lx/transform-2a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/transform-2a.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,20 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: transform-2.s
+#as: -EL
+#ld: -EL -e 0x1000 -L. -laashared
+#objdump: -d
+#name: transform-2a TLS GP-relative reference transformed to absolute.
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+08000000 \<__stext\>:
+ 8000000:	01 00 84 15 	
+ 8000004:	c0 00 04 88 	mov \$r3 = .* \(0x.*240\);;
+ 8000008:	01 00 84 15 	
+ 800000c:	00 81 03 88 	mov \$r4 = .* \(0x.*238\);;
+ 8000010:	01 00 84 15 	
+ 8000014:	40 41 03 a0 	ldw \$r5 = .* \(0x.*234\)\[\$r0\];;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/transform-2b.d binutils/ld/testsuite/ld-lx/transform-2b.d
--- binutils-2.21.51/ld/testsuite/ld-lx/transform-2b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/transform-2b.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,17 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: transform-2.s
+#as: -EL
+#ld: -EL -e 0x1000 -L. -laashared
+#objdump: -R
+#name: transform-2b TLS GP-relative reference transformed to absolute.
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+DYNAMIC RELOCATION RECORDS
+OFFSET   TYPE              VALUE 
+08000234 R_LX_TPREL32      tfoo
+08000238 R_LX_DTPMOD32     tfoo
+08000240 R_LX_DTPMOD32     tfoo
+08000244 R_LX_DTPREL32     tfoo
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/transform-2c.d binutils/ld/testsuite/ld-lx/transform-2c.d
--- binutils-2.21.51/ld/testsuite/ld-lx/transform-2c.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/transform-2c.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,27 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: transform-2.s
+#as: -EL
+#ld: -EL -e 0x1000 -L. -laashared --emit-relocs
+#objdump: -r
+#name: transform-2c: emit-relocs for TLS GP-relative reference transformed to absolute.
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   TYPE              VALUE 
+00000004 R_LX_LO9          _GLOBAL_OFFSET_TABLE_\+0x00000018
+00000000 R_LX_HI23         _GLOBAL_OFFSET_TABLE_\+0x00000018
+0000000c R_LX_LO9          _GLOBAL_OFFSET_TABLE_\+0x00000010
+00000008 R_LX_HI23         _GLOBAL_OFFSET_TABLE_\+0x00000010
+00000014 R_LX_LO9          _GLOBAL_OFFSET_TABLE_\+0x0000000c
+00000010 R_LX_HI23         _GLOBAL_OFFSET_TABLE_\+0x0000000c
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+00000018 R_LX_DTPMOD32     tfoo
+0000001c R_LX_DTPREL32     tfoo
+00000010 R_LX_DTPMOD32     tfoo
+0000000c R_LX_TPREL32      tfoo
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/transform-2.s binutils/ld/testsuite/ld-lx/transform-2.s
--- binutils-2.21.51/ld/testsuite/ld-lx/transform-2.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/transform-2.s	2005-12-23 13:01:37.509789000 +0000
@@ -0,0 +1,11 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	# A GP-relative reference is transformed to an absolute reference
+	# when building an absolute main program.
+	.text
+	add $r3 = $r14, @gotoff(@dtpndx(tfoo)) # $r14 replaced by $r0, disassembles as mov
+	;;
+	add $r4 = $r14, @gotoff(@dtpldm(tfoo)) # $r14 replaced by $r0, disassembles as mov
+	;;
+	ldw $r5 = @gotoff(@tprel(tfoo))[$r14]
+	;;
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/transform-3a.d binutils/ld/testsuite/ld-lx/transform-3a.d
--- binutils-2.21.51/ld/testsuite/ld-lx/transform-3a.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/transform-3a.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,22 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: transform-3.s
+#as: -EL -mcore=st240
+#ld: -EL -e 0x1000 -L. -laasharedst240
+#objdump: -d --section .text
+#name: transform-3a TLS model transformations, st240 encodings
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+08000000 \<__stext\>:
+ 8000000:	00 00 00 00 	nop 
+ 8000004:	0d 44 01 08 	add \$r16 = \$r13, 20 \(0x14\);;
+ 8000008:	00 00 00 95 	
+ 800000c:	00 00 00 00 	nop 
+ 8000010:	00 00 80 15 	
+ 8000014:	0d 04 01 88 	add \$r16 = \$r13, 16 \(0x10\);;
+ 8000018:	00 00 80 15 	
+ 800001c:	40 40 01 88 	mov \$r1 = 20 \(0x14\);;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/transform-3b.d binutils/ld/testsuite/ld-lx/transform-3b.d
--- binutils-2.21.51/ld/testsuite/ld-lx/transform-3b.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/transform-3b.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,29 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: transform-3.s
+#as: -EL
+#ld: -EL -e 0x1000 -L. -laashared --emit-relocs
+#objdump: -r
+#name: transform-3b: emit-relocs for TLS model transformations
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+RELOCATION RECORDS FOR \[\.text\]:
+OFFSET   TYPE              VALUE 
+00000000 R_LX_NONE         \*ABS\*
+00000004 R_LX_TPREL_LO9    tfoo
+00000008 R_LX_TPREL_HI23   tfoo
+0000000c R_LX_NONE         \*ABS\*
+00000014 R_LX_TPREL_LO9    \*ABS\*\+0x080002b0
+00000010 R_LX_TPREL_HI23   \*ABS\*\+0x080002b0
+0000001c R_LX_TPREL_LO9    tfoo
+00000018 R_LX_TPREL_HI23   tfoo
+
+
+RELOCATION RECORDS FOR \[\.data\]:
+OFFSET   TYPE              VALUE 
+00000010 R_LX_NONE         \*ABS\*
+00000010 R_LX_NONE         \*ABS\*
+00000010 R_LX_NONE         \*ABS\*
+00000010 R_LX_NONE         \*ABS\*
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/transform-3c.d binutils/ld/testsuite/ld-lx/transform-3c.d
--- binutils-2.21.51/ld/testsuite/ld-lx/transform-3c.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/transform-3c.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,26 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2008
+#source: transform-3.s
+#as: -EL -mcore=st240
+#ld: -EL -shared -e 0x1000 -L. -laasharedst240
+#objdump: -d --section .text
+#name: transform-3c shared TLS model transformations, st240 encodings
+#comment: -shared should disable TLS model transformations
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+00000394 \<__stext\>:
+ 394:	80 00 00 80 	mov \$r0 = \$r2;;
+
+00000398 \<__text_start\>:
+ 398:	1a 00 00 30 	call \$r63 = 400 \<_etext\+0x48\>
+ 39c:	0e c4 01 08 	add \$r16 = \$r14, 28 \(0x1c\);;
+ 3a0:	00 00 00 95 	
+ 3a4:	17 00 00 30 	call \$r63 = 400 \<_etext\+0x48\>
+ 3a8:	00 00 80 15 	
+ 3ac:	0e 44 01 88 	add \$r16 = \$r14, 20 \(0x14\);;
+ 3b0:	00 00 80 15 	
+ 3b4:	4e 00 01 a1 	ldw \$r1 = 16 \(0x10\)\[\$r14\];;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/transform-3.d binutils/ld/testsuite/ld-lx/transform-3.d
--- binutils-2.21.51/ld/testsuite/ld-lx/transform-3.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/transform-3.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,22 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+#source: transform-3.s
+#as: -EL
+#ld: -EL -e 0x1000 -L. -laashared
+#objdump: -d --section .text
+#name: transform-3 TLS model transformations
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+08000000 \<__stext\>:
+ 8000000:	00 00 00 00 	nop 
+ 8000004:	0d 44 01 08 	add \$r16 = \$r13, 20 \(0x14\);;
+ 8000008:	00 00 00 95 	
+ 800000c:	00 00 00 00 	nop 
+ 8000010:	00 00 80 15 	
+ 8000014:	0d 04 01 88 	add \$r16 = \$r13, 16 \(0x10\);;
+ 8000018:	00 00 80 15 	
+ 800001c:	40 40 01 88 	mov \$r1 = 20 \(0x14\);;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/transform-3d.d binutils/ld/testsuite/ld-lx/transform-3d.d
--- binutils-2.21.51/ld/testsuite/ld-lx/transform-3d.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/transform-3d.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,23 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2008
+#source: transform-3.s
+#as: -EL -mcore=st240
+#ld: -EL -r
+#objdump: -d --section .text
+#name: transform-3d relocatable TLS model transformations, st240 encodings
+#comment: -r should disable TLS model transformations
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+Disassembly of section \.text:
+
+00000000 \<\.text\>:
+   0:	00 00 00 30 	call \$r63 = 0 \<\.text\>
+   4:	0e 04 00 08 	add \$r16 = \$r14, 0 \(0x0\);;
+   8:	00 00 00 95 	
+   c:	00 00 00 30 	call \$r63 = c \<\.text\+0xc\>
+  10:	00 00 80 15 	
+  14:	0e 04 00 88 	add \$r16 = \$r14, 0 \(0x0\);;
+  18:	00 00 80 15 	
+  1c:	4e 00 00 a1 	ldw \$r1 = 0 \(0x0\)\[\$r14\];;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/transform-3.s binutils/ld/testsuite/ld-lx/transform-3.s
--- binutils-2.21.51/ld/testsuite/ld-lx/transform-3.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/transform-3.s	2005-09-26 12:13:28.950705000 +0100
@@ -0,0 +1,29 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+	# Global Dynamic may be transformed to Local Exec.
+	# 
+	.text
+	.global __tls_get_addr
+	.type __tls_get_addr, @function
+	call $r63 = __tls_get_addr   # Rewritten to nop
+	add $r16 = $r14, @gotoff(@dtpndx(tfoo)) # Rewrite base reg as r13 and the offset to be 20 (offset of tfoo within its section + 16 byte TCB size)
+	;;
+
+	# Local Dynamic may be transformed to Local Exec.
+	#	
+	call $r63 = __tls_get_addr  # Rewritten to nop
+	add $r16 = $r14, @gotoff(@dtpldm(tfoo)) # Rewrite base reg as r13 and the offset to be 16 (offset of .tdata from r13)
+	;; 
+
+	# Initial Exec. may be transformed to Local Exec.
+	#
+	ldw $r1 = @gotoff(@tprel(tfoo))[$r14] # Rewrite base reg as r13 and the offset to be 20 (offset of tfoo within its section + 16 byte TCB size)
+	;;
+	
+	.section .tdata,"awT"
+	.align 4
+	.long 0
+tfoo:	.long 23
+	.global tfoo
+	.type tfoo,@object
+	.size tfoo, 4
+	
\ No newline at end of file
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/zdefs-1.d binutils/ld/testsuite/ld-lx/zdefs-1.d
--- binutils-2.21.51/ld/testsuite/ld-lx/zdefs-1.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/zdefs-1.d	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,16 @@
+#comment: THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+#source: zdefs-1.s
+#as: -EL
+#ld: -EL -e 0x1000 -shared -z defs
+#objdump: -R
+#name: zdefs-1.d: bug #60287 Incorrect resolution of reloc to preemptible symbol with -zdefs
+#comment: Bare/OS21 script required.
+#notarget: *-*-linux*
+
+.*:     file format .*lx.*
+
+DYNAMIC RELOCATION RECORDS
+OFFSET   TYPE              VALUE 
+000003ac R_LX_JMP_SLOT     malloc
+
+
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-lx/zdefs-1.s binutils/ld/testsuite/ld-lx/zdefs-1.s
--- binutils-2.21.51/ld/testsuite/ld-lx/zdefs-1.s	1970-01-01 01:00:00.000000000 +0100
+++ binutils/ld/testsuite/ld-lx/zdefs-1.s	2009-08-11 10:14:24.859968000 +0100
@@ -0,0 +1,15 @@
+#  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+	.text
+	nop
+	;; 
+
+malloc:
+	.global malloc
+	nop
+	;;
+
+
+strdup:
+	.global strdup
+	call $r63=malloc
+	;;
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-plugin/plugin-6.d binutils/ld/testsuite/ld-plugin/plugin-6.d
--- binutils-2.21.51/ld/testsuite/ld-plugin/plugin-6.d	2010-12-06 09:23:27.000000000 +0000
+++ binutils/ld/testsuite/ld-plugin/plugin-6.d	2011-07-11 16:09:11.378539000 +0100
@@ -26,6 +26,6 @@
 #...
 hook called: all symbols read.
 tmpdir/main.o: In function `main':
-.*main.c.*: undefined reference to `func'
+.*: undefined reference to `func'
 hook called: cleanup.
 #...
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-plugin/plugin-7.d binutils/ld/testsuite/ld-plugin/plugin-7.d
--- binutils-2.21.51/ld/testsuite/ld-plugin/plugin-7.d	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/testsuite/ld-plugin/plugin-7.d	2011-07-11 16:09:11.378539000 +0100
@@ -26,6 +26,5 @@
 hook called: claim_file tmpdir/text.o \[@0/.* not claimed
 #...
 hook called: all symbols read.
-`_?func' referenced in section `\.text.*' of tmpdir/main.o: defined in discarded section .*
 hook called: cleanup.
 #...
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-plugin/plugin-8.d binutils/ld/testsuite/ld-plugin/plugin-8.d
--- binutils-2.21.51/ld/testsuite/ld-plugin/plugin-8.d	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/testsuite/ld-plugin/plugin-8.d	2011-07-11 16:09:11.378539000 +0100
@@ -30,6 +30,5 @@
 hook called: all symbols read.
 Sym: '_?func' Resolution: LDPR_PREVAILING_DEF
 Sym: '_?func2' Resolution: LDPR_PREVAILING_DEF_IRONLY
-`_?func' referenced in section `\.text.*' of tmpdir/main.o: defined in discarded section .*
 hook called: cleanup.
 #...
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-scripts/phdrs.exp binutils/ld/testsuite/ld-scripts/phdrs.exp
--- binutils-2.21.51/ld/testsuite/ld-scripts/phdrs.exp	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/testsuite/ld-scripts/phdrs.exp	2011-07-06 12:44:26.137253000 +0100
@@ -63,6 +63,11 @@
     if [regexp $phdrs_regexp $exec_output] {
 	pass $testname
     } else {
-	fail $testname
+	# Compare strictly the ST200's PHDRS because they are heavily used by the loader.
+	if { [istarget lx-*-*] && [string compare $exec_output "eflags : 100 - st220 cut0 no-abi bare-machine  user\nProgram Header:\n    PHDR off    0x00000034 vaddr 0x00800038 paddr 0x00800038 align 2**2\n         filesz 0x00000060 memsz 0x00000060 flags r--\n    LOAD off    0x00000000 vaddr 0x00800004 paddr 0x00800004 align 2**3\n         filesz 0x00000098 memsz 0x00000098 flags r-x\n    LOAD off    0x00000098 vaddr 0x0080009c paddr 0x0080009c align 2**2\n         filesz 0x00000004 memsz 0x00000004 flags rw-"] } {
+	     pass $testname
+	 } else {
+	     fail $testname
+	 }
     }
 }
diff -r -N -u binutils-2.21.51/ld/testsuite/ld-srec/srec.exp binutils/ld/testsuite/ld-srec/srec.exp
--- binutils-2.21.51/ld/testsuite/ld-srec/srec.exp	2011-04-13 08:41:36.000000000 +0100
+++ binutils/ld/testsuite/ld-srec/srec.exp	2011-07-06 12:44:26.137253000 +0100
@@ -364,6 +364,9 @@
 # The S-record linker doesn't support Blackfin ELF FDPIC ABI.
 setup_xfail "bfin-*-linux-uclibc"
 
+# The ST200 backend does not support the S-record format.
+setup_xfail "lx-*-*"
+
 run_srec_test $test1 "tmpdir/sr1.o tmpdir/sr2.o"
 
 # Now try linking a C++ program with global constructors and
diff -r -N -u binutils-2.21.51/ld/testsuite/lib/ld-lib.exp binutils/ld/testsuite/lib/ld-lib.exp
--- binutils-2.21.51/ld/testsuite/lib/ld-lib.exp	2011-06-14 09:27:52.000000000 +0100
+++ binutils/ld/testsuite/lib/ld-lib.exp	2011-07-06 12:44:26.137253000 +0100
@@ -502,6 +502,9 @@
 #	both "error" and "warning".  Multiple "warning" directives
 #	append to the expected linker warning message.
 #
+#   comment: COMMENT
+#       Ignored.  This may occur more than once.
+#
 # Each option may occur at most once unless otherwise mentioned.
 #
 # After the option lines come regexp lines.  `run_dump_test' calls
@@ -551,6 +554,7 @@
     set opts(source) {}
     set opts(error) {}
     set opts(warning) {}
+    set opts(comment) {}
     set opts(objcopy_linked_file) {}
     set asflags(${file}.s) {}
 
@@ -567,6 +571,7 @@
 	    xfail {}
 	    target {}
 	    notarget {}
+	    comment {}
 	    warning {}
 	    error {}
 	    source {
diff -r -N -u binutils-2.21.51/libiberty/config/mh-mingw binutils/libiberty/config/mh-mingw
--- binutils-2.21.51/libiberty/config/mh-mingw	1970-01-01 01:00:00.000000000 +0100
+++ binutils/libiberty/config/mh-mingw	2009-11-04 16:32:23.710844000 +0000
@@ -0,0 +1 @@
+EXTRA_OFILES=cygpath.o wrap_file.o
diff -r -N -u binutils-2.21.51/libiberty/configure binutils/libiberty/configure
--- binutils-2.21.51/libiberty/configure	2011-04-13 08:41:36.000000000 +0100
+++ binutils/libiberty/configure	2011-07-06 12:44:26.137253000 +0100
@@ -4834,6 +4834,7 @@
   *-*-freebsd2.2.[012])	frag=mh-fbsd21 ;;
   i370-*-opened*)       frag=mh-openedition ;;
   i[34567]86-*-windows*)	frag=mh-windows ;;
+  *-*-mingw*)		frag=mh-mingw ;;
 esac
 
 if [ -n "${frag}" ]; then
@@ -4867,6 +4868,7 @@
 			esac ;;
     s390*-*-*)		PICFLAG=-fpic ;;
     sh*-*-*)		PICFLAG=-fPIC ;;
+    st2[2-9][0-9]*-*-*)	PICFLAG=-fpic ;;
   esac
 fi
 
diff -r -N -u binutils-2.21.51/libiberty/configure.ac binutils/libiberty/configure.ac
--- binutils-2.21.51/libiberty/configure.ac	2011-04-13 08:41:36.000000000 +0100
+++ binutils/libiberty/configure.ac	2011-07-06 12:44:26.137253000 +0100
@@ -185,6 +185,7 @@
   *-*-freebsd2.2.[[012]])	frag=mh-fbsd21 ;;
   i370-*-opened*)       frag=mh-openedition ;;
   i[[34567]]86-*-windows*)	frag=mh-windows ;;
+  *-*-mingw*)		frag=mh-mingw ;;
 esac
 
 if [[ -n "${frag}" ]]; then
@@ -218,6 +219,7 @@
 			esac ;;
     s390*-*-*)		PICFLAG=-fpic ;;
     sh*-*-*)		PICFLAG=-fPIC ;;
+    st2[2-9][0-9]*-*-*)	PICFLAG=-fpic ;;
   esac
 fi
 AC_SUBST(PICFLAG)
diff -r -N -u binutils-2.21.51/libiberty/cygpath.c binutils/libiberty/cygpath.c
--- binutils-2.21.51/libiberty/cygpath.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils/libiberty/cygpath.c	2011-10-20 09:48:19.463637000 +0100
@@ -0,0 +1,362 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2006
+*/
+/* Basic Cygwin pathname support for MinGW.
+
+   Copyright (C) 2006 STMicroelectronics
+
+   This file is part of the libiberty library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+
+   This file implements a limited amount of support for Cygwin paths.
+   It is intended for use by MinGW programs that must interact with Cygwin.
+
+   It is limited to absolute paths only.  I.e. Those beginning with Cygwin
+   mounts, such as /cygdrive/...  See the comment on cygpath() below.  */
+
+#include "libiberty.h"
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <windows.h>
+
+
+/* These are all the possible settings for the ST_CYGPATH_MODE
+   environment variable.  */
+static enum
+{
+  mode_unset,
+  mode_off,
+  mode_normal,
+  mode_full
+} mode = mode_unset;
+
+
+/* These are the values extracted from the registry.
+   They are extracted the first time cygpath is called.  */
+static const char *cygdrive = NULL;
+static struct mount
+{
+  /* The name of the Cygwin mount point.  E.g. "/usr/bin"  */
+  char *mount;
+
+  /* The actual Windows path that the mount translates to.  */
+  char *actual;
+
+  struct mount *next;
+} *mounts = NULL;
+
+
+/* Read a string from the Windows Registry.
+   KEY should be a valid handle from RegOpenKeyEx().
+   NAME should be the name of the value within the key.
+   The value should be of type REG_SZ.
+   If the value does not exist, is of the wrong typei, or another error
+   occurs, then NULL is returned.
+   Otherwise a malloced string is returned.  */
+static char *
+read_string_from_registry (HKEY key, const char *name)
+{
+  DWORD valuetype = REG_NONE;
+  DWORD valuesize = 0;
+  char *value = NULL;
+
+  if (RegQueryValueEx (key, name, NULL, &valuetype,
+		       NULL, &valuesize) == ERROR_SUCCESS
+      && valuetype == REG_SZ)
+    {
+	value = (char *) xmalloc (valuesize);
+      if (RegQueryValueEx (key, name, NULL, &valuetype, (unsigned char *)value,
+			   &valuesize) != ERROR_SUCCESS)
+	{
+	  free (value);
+	  value = NULL;
+	}
+    }
+
+  return value;
+}
+
+
+/* Fill in the mounts list (mounts is defined statically above).
+   All subkeys (not values) of KEY that contain a REG_SZ value named 'native'
+   are added to the start of the mounts list.  */
+static void
+read_mounts (HKEY key)
+{
+  int mountsize = 15;
+  char *mount = (char *) xmalloc (mountsize);
+  DWORD size = mountsize;
+  int index = 0;
+  int retval = 0;
+
+  /* For each subkey ...  */
+  while ((retval = RegEnumKeyEx (key, index, mount, &size, 0, NULL, 0, NULL))
+	 != ERROR_NO_MORE_ITEMS)
+    {
+      struct mount *newmount;
+      HKEY subkey;
+      char *actual;
+
+      switch (retval) {
+      case ERROR_MORE_DATA:
+	/* The buffer wasn't large enough for this key name.
+	   Unlike RegQueryValueEx, RegEnumKeyEx won't tell us how big it
+	   should be, so just make it bigger and try again.
+	   Note that this code path does NOT increment index.
+       	   Most of the time we will only be dealing with short strings.  */
+	mountsize += 10;
+	mount = (char *) xrealloc (mount, mountsize);
+	break;
+
+      case ERROR_SUCCESS:
+	/* Find the actual windows path.  */
+  	if (RegOpenKeyEx (key, mount, 0, KEY_READ, &subkey) != ERROR_SUCCESS)
+	  {
+	    index++;
+	    break;
+	  }
+	actual = read_string_from_registry (subkey, "native");	
+	RegCloseKey (subkey);
+	if (actual == NULL)
+	  {
+	    index++;
+	    break;
+	  }
+
+	/* Create the new entry in the mount table.  */
+	newmount = (struct mount *) xmalloc (sizeof (struct mount));
+	newmount->mount = xstrdup (mount);
+	newmount->actual = actual;
+	newmount->next = mounts;
+	mounts = newmount;
+	index++;
+	break;
+
+      default:
+	/* Don't infinite loop should any other return value occur.  */
+        index++;
+      }
+
+      /* The last call to RegEnumKeyEx may have clobbered size.
+         Fix it before the next call.  */
+      size = mountsize;
+    }
+
+  free (mount);
+}
+
+
+/* The top level registry reading function.
+   Open the keys, call the above functions to get the right values,
+   and clean up.  */
+static void
+read_registry (void)
+{
+  HKEY hcu_key, hlm_key;
+
+  /* Get key handles for the two places cygwin keeps its registry data.  */
+  if (RegOpenKeyEx (HKEY_CURRENT_USER,
+		    "Software\\Cygnus Solutions\\Cygwin\\mounts v2",
+		    0, KEY_READ, &hcu_key) != ERROR_SUCCESS)
+    hcu_key = NULL;
+
+  if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
+		    "SOFTWARE\\Cygnus Solutions\\Cygwin\\mounts v2",
+		    0, KEY_READ, &hlm_key) != ERROR_SUCCESS)
+    hlm_key = NULL;
+
+  /* Get the virtual mount point used for windows drives.  */
+  if (hcu_key)
+    cygdrive = read_string_from_registry (hcu_key, "cygdrive prefix");
+  if (hlm_key && cygdrive == NULL)
+    cygdrive = read_string_from_registry (hlm_key, "cygdrive prefix");
+
+  /* Read the other mount points.
+     Read hlm before hcu to ensure hcu settings get used by preference
+     by being closer on the mounts stack.  */
+  if (hlm_key)
+    read_mounts (hlm_key);
+  if (hcu_key)
+    read_mounts (hcu_key);
+
+  if (hlm_key)
+    RegCloseKey (hlm_key);
+  if (hcu_key)
+    RegCloseKey (hcu_key);
+}
+
+
+/* Given a path of unknown variety, return the same path with any
+   Cygwin mount points substituted.
+   This function always returns a malloced string which should be
+   freed when the the caller is finished with it.
+
+   The mapping is affected by the ST_CYGPATH_MODE environment variable.
+   See the fprintf messages below for full information.
+
+   It can replace /cygdrive/<letter>/..... style pathnames, even if the
+   user has used 'mount -c' to an alternative string.
+
+   It can replace (if enabled) other Cygwin mount points, such as
+   the usual '/', '/usr/bin', '/usr/lib', as well as any other user defined
+   mount points.
+
+   It does NOT attempt to convert any pathnames that look like native Windows
+   names - such as those starting with '<letter>:' or double slash (UNC).
+
+   It does NOT handle relative pathnames passing through cygwin mounts
+   (e.g. '../cygdrive/c'), or absolute paths with repeated directory
+   separators or relative elements within the mount name
+   (e.g. '/usr/./bin').
+   
+   It does NOT allow backslash \ directory separators within the actual mount
+   path (e.g. '/usr\bin').  Cygwin does not always allow them there either.  */
+char *
+cygpath (const char *path)
+{
+  char *result = NULL;
+
+  if (path == NULL)
+    return NULL;
+
+  /* If this is the first time this function has been called then read the
+     environment and registry.  */
+  if (mode == mode_unset)
+    {
+      char *env = getenv ("ST_CYGPATH_MODE");
+
+      if (env == NULL || strcmp (env, "normal") == 0)
+    	mode = mode_normal;
+      else if (strcmp (env, "full") == 0)
+	mode = mode_full;
+      else if (strcmp (env, "off") == 0)
+	mode = mode_off;
+
+      if (mode != mode_off)
+	read_registry();
+
+      if (mode == mode_unset)
+	{
+	  /* The variable was set, but not to any known value.
+	     Set up a default and print an informational message
+	     for the user.  */
+	  mode = mode_normal;
+	  fprintf (stderr, "ST_CYGPATH_MODE should be one of:\n");
+	  fprintf (stderr, " off    - Disable all path translation.\n");
+	  fprintf (stderr, " normal - Translate %s only.\n", cygdrive);
+	  fprintf (stderr, " full   - Translate all Cygwin mounts.\n");
+	}
+    }
+
+  /* First, test if this can only be a windows (non-cygwin) path.
+     This includes paths that start with a drive letter or UNC double slash.  */
+  if ((isalpha (path[0]) && path[1] == ':')
+      || ((path[0] == '\\' || path[0] == '/')
+	  && (path[1] == '\\' || path[1] == '/')))
+    result = xstrdup (path);
+
+  /* Second, handle /cygdrive/<letter>/ (or whatever) paths.  */
+  if (!result && cygdrive != NULL && (mode == mode_normal || mode == mode_full))
+    {
+      int length = strlen (cygdrive);
+      /* Note that cygwin does not allow '\\' instead of '/' in cygdrive.  */
+      if (strncmp (cygdrive, path, length) == 0
+	  && (path[length] == '/' || path[length] == '\\'
+	      || path[length] == '\0')
+	  && isalpha (path[length+1]))
+        {
+	    result = (char *) xmalloc (strlen (path) - length+1 + 1);
+	  result[0] = path[length+1];
+	  result[1] = ':';
+	  strcpy (result + 2, path + length + 2);
+	}
+    }
+
+  /* Third, handle other types of cygwin path.  */
+  if (!result && mounts != NULL && mode == mode_full)
+    {
+      int matched = 0;
+      struct mount *foundat = NULL;
+      struct mount *mount = mounts;
+      /* Find the longest matching mount point.
+	 This is important. If we just used the first matching mount point
+	 it would probably always match '/' when '/usr/bin' is right.
+	 Use the first of equal length matches - this allows current-user
+	 mounts to override 'local machine' mounts (can this happen?).
+         It is a match only if the matching part is followed by a directory
+         separator or the end of the path, except for the root mount point.  */
+      while (mount != NULL)
+	{
+	  int length = strlen (mount->mount);
+	  if (strncmp (mount->mount, path, length) == 0
+	      && matched < length
+	      && (length == 1 /* Special case for root mount point '/'.  */
+		  || path[length] == '/' || path[length] == '\\'
+		  || path[length] == '\0'))
+	    {
+	      matched = length;
+	      foundat = mount;
+	    }
+	  mount = mount->next;
+	}
+      if (matched)
+	{
+	  /* There was a match so do the substitution.
+	     If matched is 1 then it can only be the root mount point, in
+	     which case we do not want to remove the matched part as it is the 
+	     directory separator.  */
+	  if (matched == 1)
+	    matched = 0;
+	  result = (char *) xmalloc (strlen (foundat->actual) + strlen (path) + 1
+			    - matched);
+	  strcpy (result, foundat->actual);
+	  strcat (result, path + matched);
+	}
+    }
+
+  if (result)
+    {
+      /* Ensure that the return is never just a drive letter.
+	 This is not a valid directory on Windows, but code often
+	 trims trailing slashes.  */
+      int length = strlen(result);
+      if (result[length-1] == ':')
+	{
+	    result = (char *) xrealloc (result, length+2);
+	  result[length] = '/';
+	  result[length+1] = '\0';
+	}
+      return result;
+    }
+
+  /* If we get here then it must have been some other kind of path.  */
+  return xstrdup (path);
+}
+
+
+/* This is just to make inserting the conversion more convenient.
+   The CYGPATH_REPLACE is conditionally compiled so it is harder to
+   add clean up code to go with it without this.  */
+void
+cygpath_replace (char **path)
+{
+  char *result = cygpath (*path);
+  free (*path);
+  *path = result;
+}
diff -r -N -u binutils-2.21.51/libiberty/Makefile.in binutils/libiberty/Makefile.in
--- binutils-2.21.51/libiberty/Makefile.in	2011-04-13 08:41:36.000000000 +0100
+++ binutils/libiberty/Makefile.in	2011-07-06 12:44:26.137253000 +0100
@@ -125,7 +125,7 @@
 CFILES = alloca.c argv.c asprintf.c atexit.c				\
 	basename.c bcmp.c bcopy.c bsearch.c bzero.c			\
 	calloc.c choose-temp.c clock.c concat.c cp-demangle.c		\
-	 cp-demint.c cplus-dem.c crc32.c				\
+	 cp-demint.c cplus-dem.c crc32.c cygpath.c			\
 	dyn-string.c							\
 	fdmatch.c ffs.c fibheap.c filename_cmp.c floatformat.c		\
 	fnmatch.c fopen_unlocked.c					\
@@ -155,7 +155,7 @@
 	tmpnam.c							\
 	unlink-if-ordinary.c						\
 	vasprintf.c vfork.c vfprintf.c vprintf.c vsnprintf.c vsprintf.c	\
-	waitpid.c							\
+	waitpid.c wrap_file.c						\
 	xatexit.c xexit.c xmalloc.c xmemdup.c xstrdup.c xstrerror.c	\
 	 xstrndup.c
 
@@ -196,6 +196,7 @@
 	./basename.$(objext) ./bcmp.$(objext) ./bcopy.$(objext)		\
 	./bsearch.$(objext) ./bzero.$(objext)				\
 	./calloc.$(objext) ./clock.$(objext) ./copysign.$(objext)	\
+	./cygpath.$(objext)						\
 	./_doprnt.$(objext)						\
 	 ./ffs.$(objext)						\
 	./getcwd.$(objext) ./getpagesize.$(objext)			\
@@ -619,6 +620,13 @@
 	else true; fi
 	$(COMPILE.c) $(srcdir)/crc32.c $(OUTPUT_OPTION)
 
+./cygpath.$(objext): $(srcdir)/cygpath.c  config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/cygpath.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/cygpath.c $(OUTPUT_OPTION)
+
 ./dyn-string.$(objext): $(srcdir)/dyn-string.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/dyn-string.h $(INCDIR)/libiberty.h
 	if [ x"$(PICFLAG)" != x ]; then \
@@ -1191,6 +1199,13 @@
 	else true; fi
 	$(COMPILE.c) $(srcdir)/waitpid.c $(OUTPUT_OPTION)
 
+./wrap_file.$(objext): $(srcdir)/wrap_file.c  config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/wrap_file.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/wrap_file.c $(OUTPUT_OPTION)
+
 ./xatexit.$(objext): $(srcdir)/xatexit.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/libiberty.h
 	if [ x"$(PICFLAG)" != x ]; then \
diff -r -N -u binutils-2.21.51/libiberty/wrap_file.c binutils/libiberty/wrap_file.c
--- binutils-2.21.51/libiberty/wrap_file.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils/libiberty/wrap_file.c	2011-10-20 09:48:19.463637000 +0100
@@ -0,0 +1,148 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+*/
+/*
+ * wrap_fopen.c
+ *
+ * This file redefines the standard library functions 
+ * open, create, fopen, fdopen, freopen, remove, rename, unlink, stat for native WIN32 build.
+ * Its purpose is to preprocess argument strings in order to
+ * convert CYGWIN like paths specifiers into native WIN32 paths
+ * It uses the GNU ld -wrap functionality to replace
+ * at link time calls to fopen into calls to __wrap_fopen.
+ *
+ * This file must be linked with any DLL or EXE object
+ * and the linker command line must have the following  option:
+ * -Wl,-wrap,open,-wrap,creat,-wrap,fopen,-wrap,freopen,-wrap,remove,-wrap,rename,-wrap,unlink,-wrap,stat
+ *
+ */
+
+#ifdef __MINGW32__
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <unistd.h>
+
+#include "libiberty.h"
+
+/*
+ * Declare real versions of functions.
+ */
+extern int __real_open (const char *pathname, int flags, mode_t mode);
+extern int __real_creat (const char *pathname, mode_t mode);
+extern FILE *__real_fopen (const char *path, const char *mode);
+extern FILE *__real_freopen (const char *path, const char *mode, FILE *stream);
+extern int __real_unlink (const char *pathname);
+extern int __real_remove (const char *pathname);
+extern int __real_rename (const char *oldpath, const char *newpath);
+extern int __real_stat (const char *file_name, struct stat *buf);
+extern int __real_chdir (const char *path);
+extern int __real_rmdir (const char *pathname); 
+extern DIR *__real_opendir (const char *name);
+extern int __real_access (const char *pathname, int mode);
+
+/*
+ * Following is the implementation of replacement functions.
+ */
+int 
+__wrap_open (const char *pathname, int flags, mode_t mode)
+{
+  int r;
+  pathname = cygpath (pathname);
+  r = __real_open (pathname, flags, mode);
+  return r;
+}
+
+int 
+__wrap_creat (const char *pathname, mode_t mode)
+{
+  int r;
+  pathname = cygpath (pathname);
+  r = __real_creat (pathname, mode);
+  return r;
+}
+
+FILE *
+__wrap_fopen (const char *path, const char *mode)
+{
+  FILE *f;
+  path = cygpath (path);
+  f = __real_fopen (path, mode);
+  return f;
+}
+
+FILE *__wrap_freopen (const char *path, const char *mode, FILE *stream)
+{
+  FILE *f;
+  path = cygpath (path);
+  f = __real_freopen (path, mode, stream);
+  return f;
+}
+
+int __wrap_unlink (const char *pathname) 
+{
+  int r;
+  pathname = cygpath (pathname);
+  r = __real_unlink (pathname);
+  return r;
+}
+
+int __wrap_remove (const char *pathname)
+{
+  int r;
+  pathname = cygpath (pathname);
+  r = __real_remove (pathname);
+  return r;
+}
+
+int __wrap_rename (const char *oldpath, const char *newpath)
+{
+  int r;
+  oldpath = cygpath (oldpath);
+  newpath = cygpath (newpath);
+  r = __real_rename (oldpath, newpath);
+  return r;
+}
+
+int __wrap_stat(const char *file_name, struct stat *buf)
+{
+  int r;
+  file_name = cygpath (file_name);
+  r = __real_stat (file_name, buf);
+  return r;
+}
+
+int __wrap_chdir(const char *path)
+{
+  int r;
+  path = cygpath (path);
+  r = __real_chdir (path);
+  return r;
+}
+
+int __wrap_rmdir(const char *pathname)
+{
+  int r;
+  pathname = cygpath (pathname);
+  r = __real_rmdir (pathname);
+  return r;
+}
+
+DIR *__wrap_opendir(const char *path)
+{
+  DIR *d;
+  path = cygpath (path);
+  d = __real_opendir (path);
+  return d;
+}
+
+int __wrap_access(const char *pathname, int mode)
+{
+  int r; 
+  pathname = cygpath (pathname);
+  r = __real_access (pathname, mode);
+  return r;
+}
+
+#endif /* __MINGW32__ */
diff -r -N -u binutils-2.21.51/Makefile.in binutils/Makefile.in
--- binutils-2.21.51/Makefile.in	2011-06-14 09:27:52.000000000 +0100
+++ binutils/Makefile.in	2011-07-06 12:44:26.137253000 +0100
@@ -186,6 +186,7 @@
 HOST_EXPORTS = \
 	$(BASE_EXPORTS) \
 	CC="$(CC)"; export CC; \
+	SIM="$(SIM)"; export SIM; \
 	ADA_CFLAGS="$(ADA_CFLAGS)"; export ADA_CFLAGS; \
 	CFLAGS="$(CFLAGS)"; export CFLAGS; \
 	CONFIG_SHELL="$(SHELL)"; export CONFIG_SHELL; \
@@ -209,6 +210,8 @@
 	AR_FOR_TARGET="$(AR_FOR_TARGET)"; export AR_FOR_TARGET; \
 	AS_FOR_TARGET="$(AS_FOR_TARGET)"; export AS_FOR_TARGET; \
 	GCC_FOR_TARGET="$(GCC_FOR_TARGET)"; export GCC_FOR_TARGET; \
+	CC_FOR_TARGET="$(CC_FOR_TARGET)"; export CC_FOR_TARGET; \
+	FLAGS_FOR_TARGET="$(FLAGS_FOR_TARGET)"; export FLAGS_FOR_TARGET; \
 	LD_FOR_TARGET="$(LD_FOR_TARGET)"; export LD_FOR_TARGET; \
 	NM_FOR_TARGET="$(NM_FOR_TARGET)"; export NM_FOR_TARGET; \
 	OBJDUMP_FOR_TARGET="$(OBJDUMP_FOR_TARGET)"; export OBJDUMP_FOR_TARGET; \
@@ -385,6 +388,7 @@
 AR = @AR@
 AR_FLAGS = rc
 CC = @CC@
+SIM = @SIM@
 CXX = @CXX@
 DLLTOOL = @DLLTOOL@
 LD = @LD@
diff -r -N -u binutils-2.21.51/Makefile.tpl binutils/Makefile.tpl
--- binutils-2.21.51/Makefile.tpl	2011-06-14 09:27:52.000000000 +0100
+++ binutils/Makefile.tpl	2011-07-06 12:44:26.137253000 +0100
@@ -388,6 +388,7 @@
 AR = @AR@
 AR_FLAGS = rc
 CC = @CC@
+SIM = @SIM@
 CXX = @CXX@
 DLLTOOL = @DLLTOOL@
 LD = @LD@
diff -r -N -u binutils-2.21.51/opcodes/configure binutils/opcodes/configure
--- binutils-2.21.51/opcodes/configure	2011-04-13 08:41:36.000000000 +0100
+++ binutils/opcodes/configure	2011-07-06 12:44:26.137253000 +0100
@@ -12431,6 +12431,7 @@
 	bfd_ip2k_arch)		ta="$ta ip2k-asm.lo ip2k-desc.lo ip2k-dis.lo ip2k-ibld.lo ip2k-opc.lo" using_cgen=yes ;;
         bfd_iq2000_arch)        ta="$ta iq2000-asm.lo iq2000-desc.lo iq2000-dis.lo iq2000-ibld.lo iq2000-opc.lo" using_cgen=yes ;;
 	bfd_lm32_arch)          ta="$ta lm32-asm.lo lm32-desc.lo lm32-dis.lo lm32-ibld.lo lm32-opc.lo lm32-opinst.lo" using_cgen=yes ;;
+	bfd_lx_arch)            ta="$ta lx-opc.lo lx-dis.lo" ;;
 	bfd_m32c_arch)		ta="$ta m32c-asm.lo m32c-desc.lo m32c-dis.lo m32c-ibld.lo m32c-opc.lo" using_cgen=yes ;;
 	bfd_m32r_arch)		ta="$ta m32r-asm.lo m32r-desc.lo m32r-dis.lo m32r-ibld.lo m32r-opc.lo m32r-opinst.lo" using_cgen=yes ;;
 	bfd_m68hc11_arch)	ta="$ta m68hc11-dis.lo m68hc11-opc.lo" ;;
diff -r -N -u binutils-2.21.51/opcodes/configure.in binutils/opcodes/configure.in
--- binutils-2.21.51/opcodes/configure.in	2010-12-06 09:23:27.000000000 +0000
+++ binutils/opcodes/configure.in	2011-07-06 12:44:26.137253000 +0100
@@ -245,6 +245,7 @@
 	bfd_ip2k_arch)		ta="$ta ip2k-asm.lo ip2k-desc.lo ip2k-dis.lo ip2k-ibld.lo ip2k-opc.lo" using_cgen=yes ;;
         bfd_iq2000_arch)        ta="$ta iq2000-asm.lo iq2000-desc.lo iq2000-dis.lo iq2000-ibld.lo iq2000-opc.lo" using_cgen=yes ;;
 	bfd_lm32_arch)          ta="$ta lm32-asm.lo lm32-desc.lo lm32-dis.lo lm32-ibld.lo lm32-opc.lo lm32-opinst.lo" using_cgen=yes ;;
+	bfd_lx_arch)            ta="$ta lx-opc.lo lx-dis.lo" ;;
 	bfd_m32c_arch)		ta="$ta m32c-asm.lo m32c-desc.lo m32c-dis.lo m32c-ibld.lo m32c-opc.lo" using_cgen=yes ;;
 	bfd_m32r_arch)		ta="$ta m32r-asm.lo m32r-desc.lo m32r-dis.lo m32r-ibld.lo m32r-opc.lo m32r-opinst.lo" using_cgen=yes ;;
 	bfd_m68hc11_arch)	ta="$ta m68hc11-dis.lo m68hc11-opc.lo" ;;
diff -r -N -u binutils-2.21.51/opcodes/disassemble.c binutils/opcodes/disassemble.c
--- binutils-2.21.51/opcodes/disassemble.c	2010-12-06 09:23:27.000000000 +0000
+++ binutils/opcodes/disassemble.c	2011-07-06 12:44:26.137253000 +0100
@@ -47,6 +47,7 @@
 #define ARCH_ip2k
 #define ARCH_iq2000
 #define ARCH_lm32
+#define ARCH_lx
 #define ARCH_m32c
 #define ARCH_m32r
 #define ARCH_m68hc11
@@ -231,6 +232,18 @@
       disassemble = print_insn_lm32;
       break;
 #endif
+#ifdef ARCH_lx 
+    case bfd_arch_lx:
+      if (bfd_big_endian (abfd))
+        {
+          disassemble = print_insn_big_lx;
+        }
+      else
+        {
+          disassemble = print_insn_little_lx;
+        }
+      break; 
+#endif
 #ifdef ARCH_m32r
     case bfd_arch_m32r:
       disassemble = print_insn_m32r;
diff -r -N -u binutils-2.21.51/opcodes/lx-dis.c binutils/opcodes/lx-dis.c
--- binutils-2.21.51/opcodes/lx-dis.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils/opcodes/lx-dis.c	2011-08-25 16:05:17.282764000 +0100
@@ -0,0 +1,298 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
+/**
+*** (c) Copyright Hewlett-Packard Company 1999-2003
+***
+*** This program is free software; you can redistribute it and/or
+*** modify it under the terms of the GNU General Public License
+*** as published by the Free Software Foundation; either version
+*** 2 of the License, or (at your option) any later version.
+***
+*** This program is distributed in the hope that it will be useful,
+*** but WITHOUT ANY WARRANTY; without even the implied warranty of
+*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+*** General Public License for more details.
+***
+*** You should have received a copy of the GNU General Public License
+*** along with this program; if not, write to the Free Software
+*** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+**/
+
+/**
+*** static char sccs_id[] = "@(#)lx-dis.c	1.6 12/13/99 09:13:48";
+**/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include "ansidecl.h"
+#include "sysdep.h"
+#include "bfd.h"
+#include "elf-bfd.h"
+#include "dis-asm.h"
+#include "opcode/lx.h"
+#include "elf/lx.h"
+
+/* Things to do 
+ *     -- immext is handled as a bit of a hack
+ *     -- bit extraction and insertion should be handled in
+ *        lx-opc.c
+ *     -- handle bundles, cluster info
+ *
+ */
+
+/* Extra info passed by objdump (DUPLICATED from objdump.c !!!) */
+struct objdump_disasm_info {
+  bfd *abfd;
+  asection *sec;
+  bfd_boolean require_sec;
+};
+
+static int
+print_insn_lx (bfd_vma memaddr, struct disassemble_info *info, int bigendian)
+{
+  lxopc_t *op;         /* operation table index */
+  bfd_byte buffer[4];  /* buffer for code       */
+  unsigned insn;       /* the instruction       */
+  unsigned extension = 0;  /* immediate extension   */
+  int hasextension = 0;/* flag for imm. ext.    */
+  int status;          /* temp                  */
+  int extnstop = 0;
+  int extnclusterstop = 0;
+  static int cluster = 0;
+  char *fmtp;
+  int ch;
+  lxopc_t *opc_table = NULL;
+  struct objdump_disasm_info *aux;
+  flagword elf_private_flags = 0;
+  int lx_core = 0;
+  
+  /* check that tables are initialized */
+
+  /*  lx_init_asm_table(); */
+  /* Get the enconding table to use (st220/st231/...) */
+  aux = (struct objdump_disasm_info *) info->application_data;
+  elf_private_flags = lx_elf_get_private_flags(aux->abfd);
+  lx_core = elf_private_flags & ELF_LX_CORE_MASK;
+  switch (lx_core) {
+  case ELF_LX_CORE_ST220:
+      opc_table = st220_lxoptab;
+      break;
+  case ELF_LX_CORE_ST231:
+      opc_table = st231_lxoptab;
+      break;
+  case ELF_LX_CORE_ST240:
+      opc_table = st240_lxoptab;
+      break;
+  default:
+      /* Core not supported */
+      (*info->fprintf_func)(info->stream, "disassembling not supported for this ST2xx core!");
+      return -1;
+  }
+
+  if (opc_table == NULL) {
+      fprintf(stderr, "error: uninitialized ST2xx opcode table\n");
+      exit(-1);
+  }
+
+  /* read the instruction */
+
+  status = (*info->read_memory_func) (memaddr, buffer, 4, info);
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, memaddr, info);
+      return -1;
+    }
+  if (bigendian)
+    insn = bfd_getb32 (buffer);
+  else
+    insn = bfd_getl32 (buffer);
+
+  if ((LXISIMMEXTL(insn)) || (LXISIMMEXTR(insn)))
+    {
+      (*info->fprintf_func) (info->stream, "");
+      return 4;
+    }
+
+  /* read ahead/back one word if possible   */
+  /* check this for extension syllable */
+
+  if ((memaddr & 4)) /* instruction is odd aligned */
+    {
+
+      /* check for extension to right       */
+      /* iff this is not the end of bundle */
+
+      if (!LXSTOP(insn))
+	{
+	  status = (*info->read_memory_func) (memaddr + 4, buffer, 4, info);
+
+	  if (status == 0)
+	    {
+	      if (bigendian)
+		extension = bfd_getb32 (buffer);
+	      else
+		extension = bfd_getl32 (buffer);
+	      if (LXISIMMEXTL(extension))
+		{
+		  hasextension = 1;
+		  extnstop = LXSTOP(extension);
+		  extnclusterstop = LXCLUSTER(extension);
+		  extension = LXIMMVAL(extension);
+		};
+	    }
+	}
+
+      /* check for extension to left */
+
+      if (!hasextension) 
+	{
+	  status = (*info->read_memory_func) (memaddr - 4, buffer, 4, info);
+	  
+	  if (status == 0)
+	    {
+	      if (bigendian)
+		extension = bfd_getb32 (buffer);
+	      else
+		extension = bfd_getl32 (buffer);
+	      if (!LXSTOP(extension) && LXISIMMEXTR(extension))
+		{
+		  hasextension = 1;
+		  extension = LXIMMVAL(extension);
+		};
+	    }
+	}
+    }
+
+  for (op = opc_table; op->as_op && op->as_op[0] != '\0' ; op++)  
+    {
+      /* find the format of this inst */
+      if ((op->mask & insn) == op->opcode)
+	{
+	  int i;
+
+	  /* print the opcode   */
+
+	  (*info->fprintf_func) (info->stream, "%s ", op->as_op);
+
+	  /* print the operands using the instructions format string. */
+
+	  fmtp = op->fmtstring;
+
+	  for (i = 0; op->format[i]; i++)
+	    {
+	      /* if (op->format[i]) */
+		{
+		  int shift = op->format[i]->shift;
+		  int bits  = op->format[i]->bits;
+		  int type  = op->format[i]->type;
+		  int flags = op->format[i]->flags;
+		  int value;
+		  int ch2;
+
+		  /* Print characters in the format string up to the following
+		     % or nul. */
+		  while((ch2=*fmtp) && ch2 != '%')
+		    {
+		      (*info->fprintf_func)(info->stream, "%c", ch2);
+		      fmtp++;
+		    }
+
+		  /* Skip past %s */
+		  if(ch2 == '%')
+		    {
+		      ch2=*fmtp++;
+		      /* if(ch2 != 's')
+			 give error message */
+		      fmtp++;
+		    }
+		  
+		  value = (insn >> shift) & ~(-1 << bits);
+		  if (flags & lxSIGNED)
+		    {
+		      int signbit = 1 << (bits -1);
+		      value = (value ^ signbit) - signbit;
+		    };
+		  switch (type)
+		    {
+		    case RegClass_st200_general :
+		    case RegClass_st200_nolink :
+		      (*info->fprintf_func)(info->stream,"$r%d", value);
+		      break;
+		    case RegClass_st200_paired :
+		    case RegClass_st200_nzpaired :
+		      (*info->fprintf_func)(info->stream,"$p%d", value);
+		      break;
+		    case RegClass_st200_branch :
+		    case RegClass_st200_predicate :
+		      (*info->fprintf_func)(info->stream,"$b%d", value);
+		      break;
+		    case RegClass_st200_link :
+		      (*info->fprintf_func)(info->stream,"$r63");
+		      break;
+		    case Immediate_st200_brknum:
+		    case Immediate_st200_imm:
+		    case Immediate_st200_isrc2:
+		    case Immediate_st200_sbrknum:
+		    case Immediate_st200_xsrc2:
+		      if (hasextension)
+			value = (value & ~(-1 << bits)) | extension;
+		      (*info->fprintf_func)(info->stream,"%d (0x%x)", value, value);
+		      break;
+		    case Immediate_st200_btarg:
+		      (*info->print_address_func)((value * 4) + memaddr, info);
+		      break;
+		    case RegClass_st200_pairedfirst:
+		    case RegClass_st200_pairedsecond:
+		    default:
+		      fprintf(stderr, "error: unexpected operand type (%d)\n", type);
+		      exit(-1);
+		    };
+		}
+		/*else
+		break;*/
+	    }
+
+	  /* Print trailing characters in the format string, if any */
+	  while((ch=*fmtp))
+	    {
+	      (*info->fprintf_func)(info->stream, "%c", ch);
+	      fmtp++;
+	    }
+
+#if MULTI_CLUSTERS_SUPPORTED
+	  if (LXCLUSTER(insn) || extnclusterstop)
+	    cluster++;
+#else
+	  if (LXCLUSTER(insn) || extnclusterstop)
+	       (*info->fprintf_func)(info->stream, 
+				     "(*** warning: Cluster Bit set!)");
+#endif	  
+	  if (LXSTOP(insn) || extnstop)
+	    {
+	      (*info->fprintf_func)(info->stream, ";;");
+	      cluster = 0;
+	    }
+	  return 4;
+	};
+    }
+  
+  /* couldn't find the opcode, skip this word */
+  
+  (*info->fprintf_func) (info->stream, "*** warning: invalid opcode");
+  return 4;
+}
+
+
+int 
+print_insn_big_lx (bfd_vma memaddr, struct disassemble_info *info)
+{
+  return print_insn_lx (memaddr, info, 1);
+}
+
+int
+print_insn_little_lx (bfd_vma memaddr, struct disassemble_info *info)
+{
+  return print_insn_lx (memaddr, info, 0);
+}
diff -r -N -u binutils-2.21.51/opcodes/lx-opc.c binutils/opcodes/lx-opc.c
--- binutils-2.21.51/opcodes/lx-opc.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils/opcodes/lx-opc.c	2010-06-07 14:41:42.080337000 +0100
@@ -0,0 +1,2014 @@
+/**
+*** (c) Copyright STMicroelectronics, Inc. 1999-2005.
+***
+*** This program is free software; you can redistribute it and/or
+*** modify it under the terms of the GNU General Public License
+*** as published by the Free Software Foundation; either version
+*** 2 of the License, or (at your option) any later version.
+***
+*** This program is distributed in the hope that it will be useful,
+*** but WITHOUT ANY WARRANTY; without even the implied warranty of
+*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+*** General Public License for more details.
+***
+*** You should have received a copy of the GNU General Public License
+*** along with this program; if not, write to the Free Software
+*** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+***
+*** --------------------------------------------------
+***                *** DO NOT EDIT ***
+***  This file was automatically generated by the
+***  Machine Description System (MDS) of STMicroelectronics, Inc.
+*** --------------------------------------------------
+**/
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+*/
+#include "sysdep.h"
+
+#include <stddef.h>
+#include <stdio.h>
+#include "bfd.h"
+#include "elf-bfd.h"
+#include <opcode/lx.h>
+#include <elf/lx.h>
+
+static lxbfield bcond = {"bcond", RegClass_st200_branch, 3, 23, 0};
+static lxbfield bdest = {"bdest", RegClass_st200_branch, 3, 18, 0};
+static lxbfield bdest2 = {"bdest2", RegClass_st200_branch, 3, 12, 0};
+static lxbfield brknum = {"brknum", Immediate_st200_brknum, 12, 0, 0};
+static lxbfield bsrc1 = {"bsrc1", RegClass_st200_branch, 3, 0, 0};
+static lxbfield bsrc2 = {"bsrc2", RegClass_st200_branch, 3, 6, 0};
+static lxbfield btarg = {"btarg", Immediate_st200_btarg, 23, 0, lxSIGNED};
+static lxbfield dest = {"dest", RegClass_st200_general, 6, 12, 0};
+static lxbfield ibdest = {"ibdest", RegClass_st200_branch, 3, 6, 0};
+static lxbfield idest = {"idest", RegClass_st200_general, 6, 6, 0};
+static lxbfield idestp = {"idestp", RegClass_st200_nzpaired, 6, 6, 0};
+static lxbfield imm = {"imm", Immediate_st200_imm, 23, 0, lxSIGNED};
+static lxbfield isrc2 = {"isrc2", Immediate_st200_isrc2, 9, 12, lxSIGNED | lxCANEXTEND};
+static lxbfield nldest = {"nldest", RegClass_st200_nolink, 6, 12, 0};
+static lxbfield nlidest = {"nlidest", RegClass_st200_nolink, 6, 6, 0};
+static lxbfield pcond = {"pcond", RegClass_st200_predicate, 3, 21, 0};
+static lxbfield sbrknum = {"sbrknum", Immediate_st200_sbrknum, 21, 0, 0};
+static lxbfield scond = {"scond", RegClass_st200_branch, 3, 21, 0};
+static lxbfield src1 = {"src1", RegClass_st200_general, 6, 0, 0};
+static lxbfield src2 = {"src2", RegClass_st200_general, 6, 6, 0};
+static lxbfield src2p = {"src2p", RegClass_st200_paired, 6, 6, 0};
+static lxbfield link = {"link", RegClass_st200_link, 0, 0, 0};
+
+#define Bundling_st200_ANY 1
+#define Bundling_st200_ANYX 2
+#define Bundling_st200_FIRST 3
+#define Bundling_st200_EVEN 4
+#define Bundling_st200_MEM 5
+#define Bundling_st200_MEMX 6
+#define Bundling_st200_ODD 7
+#define Bundling_st200_ALONE 8
+#define Bundling_st200_ALONEX 9
+
+BundleType bundle_types[] = {
+#define Bundle_st200_EVEN_ANY_MEM_0_8 0
+  { 3, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_MEM_4_8 1
+  { 3, 4, 8, 1, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_MEM }, { 2, -1 } }, 
+#define Bundle_st200_FIRST_EVEN_MEM_4_8 2
+  { 3, 4, 8, 1, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_MEM }, { 2, -1 } }, 
+#define Bundle_st200_FIRST_MEM_EVEN_0_16 3
+  { 3, 0, 16, 0, { Bundling_st200_FIRST, Bundling_st200_MEM, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_EVEN_ANY_MEM_ANY_0_8 4
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_MEM, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_ANY_MEM_4_8 5
+  { 4, 4, 8, 0, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_EVEN_ODD_MEM_ANY_0_8 6
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_MEM, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_ANY_MEM_4_8 7
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ANY_MEM_4_8 8
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_MEM_EVEN_ANY_0_16 9
+  { 4, 0, 16, 0, { Bundling_st200_FIRST, Bundling_st200_MEM, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ODD_MEM_4_8 10
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_MEM_EVEN_ODD_0_16 11
+  { 4, 0, 16, 0, { Bundling_st200_FIRST, Bundling_st200_MEM, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_MEMX_EVEN_0_16 12
+  { 2, 0, 16, 0, { Bundling_st200_MEMX, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_EVEN_MEMX_4_16 13
+  { 2, 4, 16, 1, { Bundling_st200_EVEN, Bundling_st200_MEMX }, { 0, -1 } }, 
+#define Bundle_st200_EVEN_MEMX_8_16 14
+  { 2, 8, 16, 0, { Bundling_st200_EVEN, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_MEMX_EVEN_12_16 15
+  { 2, 12, 16, 1, { Bundling_st200_MEMX, Bundling_st200_EVEN }, { 1, -1 } }, 
+#define Bundle_st200_MEMX_EVEN_ANY_0_16 16
+  { 3, 0, 16, 0, { Bundling_st200_MEMX, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_MEMX_4_16 17
+  { 3, 4, 16, 0, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_EVEN_MEMX_ANY_8_16 18
+  { 3, 8, 16, 0, { Bundling_st200_EVEN, Bundling_st200_MEMX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_MEMX_ANY_EVEN_12_16 19
+  { 3, 12, 16, 0, { Bundling_st200_MEMX, Bundling_st200_ANY, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_MEMX_EVEN_ODD_0_16 20
+  { 3, 0, 16, 0, { Bundling_st200_MEMX, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_MEMX_4_16 21
+  { 3, 4, 16, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_EVEN_MEMX_ODD_8_16 22
+  { 3, 8, 16, 0, { Bundling_st200_EVEN, Bundling_st200_MEMX, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_MEMX_ODD_EVEN_12_16 23
+  { 3, 12, 16, 0, { Bundling_st200_MEMX, Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANYX_EVEN_MEM_0_16 24
+  { 3, 0, 16, 0, { Bundling_st200_ANYX, Bundling_st200_EVEN, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_MEM_EVEN_ANYX_4_16 25
+  { 3, 4, 16, 0, { Bundling_st200_MEM, Bundling_st200_EVEN, Bundling_st200_ANYX }, { -1 } }, 
+#define Bundle_st200_EVEN_ANYX_MEM_8_16 26
+  { 3, 8, 16, 0, { Bundling_st200_EVEN, Bundling_st200_ANYX, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_MEM_ANYX_EVEN_12_16 27
+  { 3, 12, 16, 0, { Bundling_st200_MEM, Bundling_st200_ANYX, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANY_0_4 28
+  { 1, 0, 4, 0, { Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_0_4 29
+  { 1, 0, 4, 0, { Bundling_st200_FIRST }, { -1 } }, 
+#define Bundle_st200_MEM_0_4 30
+  { 1, 0, 4, 0, { Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ALONE_0_4 31
+  { 1, 0, 4, 0, { Bundling_st200_ALONE }, { -1 } }, 
+#define Bundle_st200_ANY_ANY_0_4 32
+  { 2, 0, 4, 0, { Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_0_4 33
+  { 2, 0, 4, 0, { Bundling_st200_FIRST, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_MEM_0_4 34
+  { 2, 0, 4, 0, { Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_MEM_0_4 35
+  { 2, 0, 4, 0, { Bundling_st200_FIRST, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ANY_ANY_ANY_0_4 36
+  { 3, 0, 4, 0, { Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_ANY_0_4 37
+  { 3, 0, 4, 0, { Bundling_st200_FIRST, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_MEM_ANY_ANY_0_4 38
+  { 3, 0, 4, 0, { Bundling_st200_MEM, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_MEM_ANY_0_4 39
+  { 3, 0, 4, 0, { Bundling_st200_FIRST, Bundling_st200_MEM, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_ANY_ANY_ANY_0_4 40
+  { 4, 0, 4, 0, { Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_ANY_ANY_0_4 41
+  { 4, 0, 4, 0, { Bundling_st200_FIRST, Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_ANY_ANY_MEM_0_4 42
+  { 4, 0, 4, 0, { Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_ANY_MEM_0_4 43
+  { 4, 0, 4, 0, { Bundling_st200_FIRST, Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_EVEN_0_8 44
+  { 1, 0, 8, 0, { Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_EVEN_4_8 45
+  { 1, 4, 8, 1, { Bundling_st200_EVEN }, { 0, -1 } }, 
+#define Bundle_st200_ANY_ODD_0_8 46
+  { 2, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_ANY_4_8 47
+  { 2, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_0_8 48
+  { 2, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_4_8 49
+  { 2, 4, 8, 1, { Bundling_st200_FIRST, Bundling_st200_ODD }, { 1, -1 } }, 
+#define Bundle_st200_EVEN_ODD_0_8 50
+  { 2, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_4_8 51
+  { 2, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_MEM_ODD_0_8 52
+  { 2, 0, 8, 0, { Bundling_st200_MEM, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_MEM_4_8 53
+  { 2, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_EVEN_ANY_0_8 54
+  { 2, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_4_8 55
+  { 2, 4, 8, 0, { Bundling_st200_ANY, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_EVEN_ANY_ANY_0_8 56
+  { 3, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_ANY_4_8 57
+  { 3, 4, 8, 0, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_EVEN_ODD_ANY_0_8 58
+  { 3, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_ANY_4_8 59
+  { 3, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_EVEN_0_8 60
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANY, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ANY_4_8 61
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_EVEN_0_8 62
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ODD_4_8 63
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_EVEN_ANY_EVEN_0_8 64
+  { 3, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_EVEN_4_8 65
+  { 3, 4, 8, 1, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_EVEN }, { 2, -1 } }, 
+#define Bundle_st200_EVEN_ODD_EVEN_0_8 66
+  { 3, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_EVEN_4_8 67
+  { 3, 4, 8, 1, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_EVEN }, { 2, -1 } }, 
+#define Bundle_st200_EVEN_ODD_MEM_0_8 68
+  { 3, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_MEM_4_8 69
+  { 3, 4, 8, 1, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_MEM }, { 2, -1 } }, 
+#define Bundle_st200_ANY_ODD_ANY_0_8 70
+  { 3, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ODD_ANY_ANY_4_8 71
+  { 3, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_ANY_0_8 72
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_ODD_4_8 73
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANY, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ANY_ODD_MEM_0_8 74
+  { 3, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ODD_ANY_MEM_4_8 75
+  { 3, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_MEM_0_8 76
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_MEM_ODD_4_8 77
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_MEM, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ANY_ODD_ANY_ANY_0_8 78
+  { 4, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ODD_ANY_ANY_ANY_4_8 79
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_EVEN_ODD_ANY_ANY_0_8 80
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_ANY_ANY_4_8 81
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_ODD_ANY_ODD_0_8 82
+  { 4, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_ANY_ODD_ANY_4_8 83
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_ODD_EVEN_ODD_0_8 84
+  { 4, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_ODD_ANY_4_8 85
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_ANY_ANY_0_8 86
+  { 4, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_ODD_ANY_4_8 87
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_EVEN_ANY_0_8 88
+  { 4, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ODD_ANY_4_8 89
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_ANY_ODD_0_8 90
+  { 4, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_EVEN_ODD_0_8 91
+  { 4, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_EVEN_ODD_EVEN_ANY_0_8 92
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_ODD_EVEN_4_8 93
+  { 4, 4, 8, 0, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_EVEN_ODD_EVEN_ODD_0_8 94
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_ODD_EVEN_4_8 95
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANY_ODD_ANY_MEM_0_8 96
+  { 4, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ODD_ANY_MEM_ANY_4_8 97
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_MEM, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_ODD_MEM_ODD_0_8 98
+  { 4, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_MEM, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_MEM_ODD_ANY_4_8 99
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_MEM, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_EVEN_ODD_MEM_ODD_0_8 100
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_MEM, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_ODD_MEM_4_8 101
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_EVEN_ANY_ANY_ANY_0_8 102
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_ANY_ANY_4_8 103
+  { 4, 4, 8, 0, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_EVEN_ANY_0_8 104
+  { 4, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ANY_ANY_4_8 105
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_EVEN_ANY_EVEN_ANY_0_8 106
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_ANY_EVEN_4_8 107
+  { 4, 4, 8, 0, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_ANY_MEM_0_8 108
+  { 4, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_MEM_ODD_ANY_4_8 109
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_MEM, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_MEM_ODD_0_8 110
+  { 4, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_MEM, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ANYX_ANY_ANY_0_8 111
+  { 3, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANYX_ANY_ANY_4_8 112
+  { 3, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANYX_ANY_ODD_0_8 113
+  { 3, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANY, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ANYX_ODD_ANY_4_8 114
+  { 3, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_ANY_0_8 115
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_ANY_4_8 116
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_ODD_0_8 117
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ANYX_EVEN_ANY_0_8 118
+  { 3, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANYX_ANY_EVEN_4_8 119
+  { 3, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANY, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANYX_EVEN_ODD_0_8 120
+  { 3, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ANYX_ODD_EVEN_4_8 121
+  { 3, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANYX_ANY_MEM_0_8 122
+  { 3, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ANYX_MEM_ANY_4_8 123
+  { 3, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_MEM, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANYX_MEM_ODD_0_8 124
+  { 3, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_MEM, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ANYX_ODD_MEM_4_8 125
+  { 3, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ODD, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_MEMX_ANY_ANY_0_8 126
+  { 3, 0, 8, 0, { Bundling_st200_MEMX, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_MEMX_ANY_ANY_4_8 127
+  { 3, 4, 8, 0, { Bundling_st200_MEMX, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_MEMX_ANY_ODD_0_8 128
+  { 3, 0, 8, 0, { Bundling_st200_MEMX, Bundling_st200_ANY, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_MEMX_ODD_ANY_4_8 129
+  { 3, 4, 8, 0, { Bundling_st200_MEMX, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_MEMX_ANY_0_8 130
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_MEMX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_MEMX_ANY_4_8 131
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_MEMX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_MEMX_ODD_0_8 132
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_MEMX, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_MEM_0_8 133
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_MEM_4_8 134
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ANYX_ANY_0_8 135
+  { 2, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANYX_ANY_4_8 136
+  { 2, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_0_8 137
+  { 2, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_4_8 138
+  { 2, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX }, { -1 } }, 
+#define Bundle_st200_ANYX_EVEN_0_8 139
+  { 2, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANYX_EVEN_4_8 140
+  { 2, 4, 8, 1, { Bundling_st200_ANYX, Bundling_st200_EVEN }, { 1, -1 } }, 
+#define Bundle_st200_ANYX_MEM_0_8 141
+  { 2, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ANYX_MEM_4_8 142
+  { 2, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_MEMX_ANY_0_8 143
+  { 2, 0, 8, 0, { Bundling_st200_MEMX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_MEMX_ANY_4_8 144
+  { 2, 4, 8, 0, { Bundling_st200_MEMX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_MEMX_0_8 145
+  { 2, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_FIRST_MEMX_4_8 146
+  { 2, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_ANYX_0_8 147
+  { 1, 0, 8, 0, { Bundling_st200_ANYX }, { -1 } }, 
+#define Bundle_st200_ANYX_4_8 148
+  { 1, 4, 8, 0, { Bundling_st200_ANYX }, { -1 } }, 
+#define Bundle_st200_MEMX_0_8 149
+  { 1, 0, 8, 0, { Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_MEMX_4_8 150
+  { 1, 4, 8, 0, { Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_ALONEX_0_8 151
+  { 1, 0, 8, 0, { Bundling_st200_ALONEX }, { -1 } }, 
+#define Bundle_st200_ALONEX_4_8 152
+  { 1, 4, 8, 0, { Bundling_st200_ALONEX }, { -1 } }, 
+#define Bundle_st200_ANYX_ANYX_0_8 153
+  { 2, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANYX }, { -1 } }, 
+#define Bundle_st200_ANYX_ANYX_4_8 154
+  { 2, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANYX }, { -1 } }, 
+#define Bundle_st200_ANYX_MEMX_0_8 155
+  { 2, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_ANYX_MEMX_4_8 156
+  { 2, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_EVEN_MEM_0_8 157
+  { 2, 0, 8, 1, { Bundling_st200_EVEN, Bundling_st200_MEM }, { 1, -1 } }, 
+#define Bundle_st200_EVEN_MEM_4_8 158
+  { 2, 4, 8, 2, { Bundling_st200_EVEN, Bundling_st200_MEM }, { 0, 2, -1 } }, 
+#define Bundle_st200_FIRST_EVEN_MEMX_4_16 159
+  { 3, 4, 16, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_FIRST_MEMX_EVEN_12_16 160
+  { 3, 12, 16, 0, { Bundling_st200_FIRST, Bundling_st200_MEMX, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ODD_0_8 161
+  { 1, 0, 8, 1, { Bundling_st200_ODD }, { 0, -1 } }, 
+#define Bundle_st200_ODD_4_8 162
+  { 1, 4, 8, 0, { Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_0_8 163
+  { 2, 0, 8, 1, { Bundling_st200_FIRST, Bundling_st200_EVEN }, { 1, -1 } }, 
+#define Bundle_st200_FIRST_EVEN_4_8 164
+  { 2, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANY_ODD_ODD_0_8 165
+  { 3, 0, 8, 1, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_ODD }, { 2, -1 } }, 
+#define Bundle_st200_ODD_ANY_ODD_4_8 166
+  { 3, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_EVEN_ODD_ODD_0_8 167
+  { 3, 0, 8, 1, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_ODD }, { 2, -1 } }, 
+#define Bundle_st200_ODD_EVEN_ODD_4_8 168
+  { 3, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_MEM_ODD_0_8 169
+  { 3, 0, 8, 1, { Bundling_st200_ODD, Bundling_st200_MEM, Bundling_st200_ODD }, { 0, -1 } }, 
+#define Bundle_st200_ODD_MEM_ODD_4_8 170
+  { 3, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_MEM, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ANY_EVEN_4_8 171
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ODD_EVEN_4_8 172
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_EVEN_4_8 173
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANYX_ODD_0_8 174
+  { 2, 0, 8, 1, { Bundling_st200_ANYX, Bundling_st200_ODD }, { 1, -1 } }, 
+#define Bundle_st200_ANYX_ODD_4_8 175
+  { 2, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_MEMX_ODD_0_8 176
+  { 2, 0, 8, 1, { Bundling_st200_MEMX, Bundling_st200_ODD }, { 1, -1 } }, 
+#define Bundle_st200_MEMX_ODD_4_8 177
+  { 2, 4, 8, 0, { Bundling_st200_MEMX, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_EVEN_EVEN_0_8 178
+  { 2, 0, 8, 1, { Bundling_st200_EVEN, Bundling_st200_EVEN }, { 1, -1 } }, 
+#define Bundle_st200_EVEN_EVEN_4_8 179
+  { 2, 4, 8, 2, { Bundling_st200_EVEN, Bundling_st200_EVEN }, { 0, 2, -1 } }, 
+#define Bundle_st200_ODD_ODD_0_8 180
+  { 2, 0, 8, 2, { Bundling_st200_ODD, Bundling_st200_ODD }, { 0, 2, -1 } }, 
+#define Bundle_st200_ODD_ODD_4_8 181
+  { 2, 4, 8, 1, { Bundling_st200_ODD, Bundling_st200_ODD }, { 1, -1 } }, 
+#define Bundle_st200_FIRST_ODD_ODD_0_8 182
+  { 3, 0, 8, 1, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_ODD }, { 2, -1 } }, 
+#define Bundle_st200_FIRST_EVEN_EVEN_4_8 183
+  { 3, 4, 8, 1, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_EVEN }, { 2, -1 } }, 
+  { -1, 0, 0, 0, {}, {} }};
+
+short bundlematch_table_size = 3391;
+short bundlematch_table[3391 + 1] = { 
+ /*     0 */    -1,    0,    1,    2,    3,    4,    5,    6,    7,    8,
+ /*    10 */     9,   10,   11,   12,   13,   14,   15,   -1,   -1,   -1,
+ /*    20 */    16,   17,   18,   19,   20,   21,   -1,   -1,   -1,   -1,
+ /*    30 */    -1,   22,   23,   24,   25,   -1,   -1,   -1,   -1,   -1,
+ /*    40 */    26,   27,   28,   29,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*    50 */    -1,   -1,   30,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*    60 */    -1,   31,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*    70 */    32,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*    80 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*    90 */    -1,   33,   34,   35,   36,   37,   38,   39,   -1,   -1,
+ /*   100 */    -1,   -1,   40,   41,   42,   -1,   43,   -1,   -1,   -1,
+ /*   110 */    -1,   -1,   44,   45,   46,   47,   -1,   -1,   -1,   -1,
+ /*   120 */    -1,   48,   49,   50,   51,   -1,   -1,   -1,   -1,   -1,
+ /*   130 */    -1,   -1,   -1,   52,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   140 */    -1,   -1,   53,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   150 */    -1,   54,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   160 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   170 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   180 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   190 */    -1,   -1,   -1,   55,   56,   -1,   57,   -1,   -1,   -1,
+ /*   200 */    -1,   -1,   -1,   58,   -1,   59,   -1,   -1,   -1,   -1,
+ /*   210 */    -1,   -1,   -1,   -1,   60,   -1,   -1,   -1,   -1,   -1,
+ /*   220 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   230 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   240 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   250 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   260 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   270 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   280 */    -1,   -1,   -1,   61,   62,   63,   64,   -1,   -1,   -1,
+ /*   290 */    -1,   -1,   -1,   -1,   -1,   65,   -1,   -1,   -1,   -1,
+ /*   300 */    -1,   -1,   -1,   -1,   66,   -1,   -1,   -1,   -1,   -1,
+ /*   310 */    -1,   -1,   -1,   67,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   320 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   330 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   340 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   350 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   360 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   68,   -1,   -1,
+ /*   370 */    -1,   -1,   -1,   -1,   -1,   -1,   69,   -1,   -1,   -1,
+ /*   380 */    -1,   -1,   -1,   -1,   -1,   70,   -1,   -1,   -1,   -1,
+ /*   390 */    -1,   -1,   -1,   -1,   71,   -1,   -1,   -1,   -1,   -1,
+ /*   400 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   410 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   420 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   430 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   440 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   450 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   460 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   470 */    -1,   -1,   -1,   -1,   -1,   72,   -1,   -1,   -1,   -1,
+ /*   480 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   490 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   500 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   510 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   520 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   530 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   540 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   550 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   560 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   570 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   580 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   590 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   600 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   610 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   620 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   630 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   640 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   650 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   660 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   670 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   680 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   690 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   700 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   710 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   720 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   730 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   740 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   750 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   760 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   770 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   780 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   790 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   800 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   810 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   820 */    73,   -1,   74,   75,   76,   -1,   77,   -1,   -1,   -1,
+ /*   830 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   840 */    -1,   78,   79,   -1,   80,   -1,   -1,   -1,   -1,   -1,
+ /*   850 */    81,   82,   -1,   83,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   860 */    -1,   -1,   84,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   870 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   880 */    85,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   890 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   900 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   910 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   920 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   930 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   940 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   950 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   960 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   970 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   980 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   990 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1000 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1010 */    -1,   -1,   86,   87,   -1,   88,   -1,   -1,   -1,   -1,
+ /*  1020 */    -1,   -1,   -1,   -1,   89,   -1,   -1,   -1,   -1,   -1,
+ /*  1030 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1040 */    -1,   -1,   90,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1050 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1060 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1070 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1080 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1090 */    -1,   -1,   -1,   -1,   -1,   -1,   91,   -1,   -1,   -1,
+ /*  1100 */    -1,   -1,   -1,   -1,   -1,   92,   -1,   -1,   -1,   -1,
+ /*  1110 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1120 */    -1,   -1,   -1,   93,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1130 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1140 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1150 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1160 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1170 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1180 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1190 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1200 */    -1,   -1,   -1,   -1,   94,   -1,   -1,   -1,   -1,   -1,
+ /*  1210 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1220 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1230 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1240 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1250 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1260 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1270 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1280 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1290 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1300 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1310 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1320 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1330 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1340 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1350 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1360 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1370 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1380 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1390 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1400 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1410 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1420 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1430 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1440 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1450 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1460 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1470 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1480 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1490 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1500 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1510 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1520 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1530 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1540 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1550 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1560 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1570 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1580 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1590 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1600 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1610 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1620 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1630 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1640 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1650 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1660 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1670 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1680 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1690 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1700 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1710 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1720 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1730 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1740 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1750 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1760 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1770 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1780 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1790 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1800 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1810 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1820 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1830 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1840 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1850 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1860 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1870 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1880 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1890 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1900 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1910 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1920 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1930 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1940 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1950 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1960 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1970 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1980 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1990 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2000 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2010 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2020 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2030 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2040 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2050 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2060 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2070 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2080 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2090 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2100 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2110 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2120 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2130 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2140 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2150 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2160 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2170 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2180 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2190 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2200 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2210 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2220 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2230 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2240 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2250 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2260 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2270 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2280 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2290 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2300 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2310 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2320 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2330 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2340 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2350 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2360 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2370 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2380 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2390 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2400 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2410 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2420 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2430 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2440 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2450 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2460 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2470 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2480 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2490 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2500 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2510 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2520 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2530 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2540 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2550 */    -1,   -1,   -1,   -1,   95,   -1,   -1,   -1,   -1,   -1,
+ /*  2560 */    -1,   -1,   -1,   96,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2570 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2580 */    -1,   97,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2590 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2600 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2610 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2620 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2630 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2640 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2650 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2660 */    -1,   -1,   98,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2670 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2680 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2690 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2700 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2710 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2720 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2730 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2740 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2750 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2760 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2770 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2780 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2790 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2800 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2810 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2820 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2830 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2840 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2850 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2860 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2870 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2880 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2890 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2900 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2910 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2920 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2930 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2940 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2950 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2960 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2970 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2980 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2990 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3000 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3010 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3020 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3030 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3040 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3050 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3060 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3070 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3080 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3090 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3100 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3110 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3120 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3130 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3140 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3150 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3160 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3170 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3180 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3190 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3200 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3210 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3220 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3230 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3240 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3250 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3260 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3270 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3280 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3290 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3300 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3310 */    99,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3320 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3330 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3340 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3350 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3360 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3370 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3380 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3390 */    -1,  100,};
+
+BundleMatchType canonical_table[101] = {
+  { 1, { Bundle_st200_ANY_0_4 } },
+  { 2, { Bundle_st200_ANYX_0_8, Bundle_st200_ANYX_4_8 } },
+  { 1, { Bundle_st200_FIRST_0_4 } },
+  { 2, { Bundle_st200_EVEN_0_8, Bundle_st200_EVEN_4_8 } },
+  { 1, { Bundle_st200_MEM_0_4 } },
+  { 2, { Bundle_st200_MEMX_0_8, Bundle_st200_MEMX_4_8 } },
+  { 2, { Bundle_st200_ODD_0_8, Bundle_st200_ODD_4_8 } },
+  { 1, { Bundle_st200_ALONE_0_4 } },
+  { 2, { Bundle_st200_ALONEX_0_8, Bundle_st200_ALONEX_4_8 } },
+  { 1, { Bundle_st200_ANY_ANY_0_4 } },
+  { 2, { Bundle_st200_ANYX_ANY_0_8, Bundle_st200_ANYX_ANY_4_8 } },
+  { 1, { Bundle_st200_FIRST_ANY_0_4 } },
+  { 2, { Bundle_st200_EVEN_ANY_0_8, Bundle_st200_ANY_EVEN_4_8 } },
+  { 1, { Bundle_st200_ANY_MEM_0_4 } },
+  { 2, { Bundle_st200_MEMX_ANY_0_8, Bundle_st200_MEMX_ANY_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_0_8, Bundle_st200_ODD_ANY_4_8 } },
+  { 2, { Bundle_st200_ANYX_ANYX_0_8, Bundle_st200_ANYX_ANYX_4_8 } },
+  { 2, { Bundle_st200_FIRST_ANYX_0_8, Bundle_st200_FIRST_ANYX_4_8 } },
+  { 2, { Bundle_st200_ANYX_EVEN_0_8, Bundle_st200_ANYX_EVEN_4_8 } },
+  { 2, { Bundle_st200_ANYX_MEM_0_8, Bundle_st200_ANYX_MEM_4_8 } },
+  { 2, { Bundle_st200_ANYX_MEMX_0_8, Bundle_st200_ANYX_MEMX_4_8 } },
+  { 2, { Bundle_st200_ANYX_ODD_0_8, Bundle_st200_ANYX_ODD_4_8 } },
+  { 2, { Bundle_st200_FIRST_EVEN_0_8, Bundle_st200_FIRST_EVEN_4_8 } },
+  { 1, { Bundle_st200_FIRST_MEM_0_4 } },
+  { 2, { Bundle_st200_FIRST_MEMX_0_8, Bundle_st200_FIRST_MEMX_4_8 } },
+  { 2, { Bundle_st200_FIRST_ODD_0_8, Bundle_st200_FIRST_ODD_4_8 } },
+  { 2, { Bundle_st200_EVEN_EVEN_0_8, Bundle_st200_EVEN_EVEN_4_8 } },
+  { 2, { Bundle_st200_EVEN_MEM_0_8, Bundle_st200_EVEN_MEM_4_8 } },
+  { 4, { Bundle_st200_MEMX_EVEN_0_16, Bundle_st200_EVEN_MEMX_4_16, Bundle_st200_EVEN_MEMX_8_16, Bundle_st200_MEMX_EVEN_12_16 } },
+  { 2, { Bundle_st200_EVEN_ODD_0_8, Bundle_st200_ODD_EVEN_4_8 } },
+  { 2, { Bundle_st200_MEM_ODD_0_8, Bundle_st200_ODD_MEM_4_8 } },
+  { 2, { Bundle_st200_MEMX_ODD_0_8, Bundle_st200_MEMX_ODD_4_8 } },
+  { 2, { Bundle_st200_ODD_ODD_0_8, Bundle_st200_ODD_ODD_4_8 } },
+  { 1, { Bundle_st200_ANY_ANY_ANY_0_4 } },
+  { 2, { Bundle_st200_ANYX_ANY_ANY_0_8, Bundle_st200_ANYX_ANY_ANY_4_8 } },
+  { 1, { Bundle_st200_FIRST_ANY_ANY_0_4 } },
+  { 2, { Bundle_st200_EVEN_ANY_ANY_0_8, Bundle_st200_ANY_EVEN_ANY_4_8 } },
+  { 1, { Bundle_st200_MEM_ANY_ANY_0_4 } },
+  { 2, { Bundle_st200_MEMX_ANY_ANY_0_8, Bundle_st200_MEMX_ANY_ANY_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_ANY_0_8, Bundle_st200_ODD_ANY_ANY_4_8 } },
+  { 2, { Bundle_st200_FIRST_ANYX_ANY_0_8, Bundle_st200_FIRST_ANYX_ANY_4_8 } },
+  { 2, { Bundle_st200_ANYX_EVEN_ANY_0_8, Bundle_st200_ANYX_ANY_EVEN_4_8 } },
+  { 2, { Bundle_st200_ANYX_ANY_MEM_0_8, Bundle_st200_ANYX_MEM_ANY_4_8 } },
+  { 2, { Bundle_st200_ANYX_ANY_ODD_0_8, Bundle_st200_ANYX_ODD_ANY_4_8 } },
+  { 2, { Bundle_st200_FIRST_ANY_EVEN_0_8, Bundle_st200_FIRST_EVEN_ANY_4_8 } },
+  { 1, { Bundle_st200_FIRST_MEM_ANY_0_4 } },
+  { 2, { Bundle_st200_FIRST_MEMX_ANY_0_8, Bundle_st200_FIRST_MEMX_ANY_4_8 } },
+  { 2, { Bundle_st200_FIRST_ODD_ANY_0_8, Bundle_st200_FIRST_ANY_ODD_4_8 } },
+  { 2, { Bundle_st200_EVEN_ANY_EVEN_0_8, Bundle_st200_ANY_EVEN_EVEN_4_8 } },
+  { 2, { Bundle_st200_EVEN_ANY_MEM_0_8, Bundle_st200_ANY_EVEN_MEM_4_8 } },
+  { 4, { Bundle_st200_MEMX_EVEN_ANY_0_16, Bundle_st200_ANY_EVEN_MEMX_4_16, Bundle_st200_EVEN_MEMX_ANY_8_16, Bundle_st200_MEMX_ANY_EVEN_12_16 } },
+  { 2, { Bundle_st200_EVEN_ODD_ANY_0_8, Bundle_st200_ODD_EVEN_ANY_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_MEM_0_8, Bundle_st200_ODD_ANY_MEM_4_8 } },
+  { 2, { Bundle_st200_MEMX_ANY_ODD_0_8, Bundle_st200_MEMX_ODD_ANY_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_ODD_0_8, Bundle_st200_ODD_ANY_ODD_4_8 } },
+  { 1, { Bundle_st200_FIRST_ANYX_EVEN_4_8 } },
+  { 2, { Bundle_st200_FIRST_ANYX_MEM_0_8, Bundle_st200_FIRST_ANYX_MEM_4_8 } },
+  { 1, { Bundle_st200_FIRST_ANYX_ODD_0_8 } },
+  { 4, { Bundle_st200_ANYX_EVEN_MEM_0_16, Bundle_st200_MEM_EVEN_ANYX_4_16, Bundle_st200_EVEN_ANYX_MEM_8_16, Bundle_st200_MEM_ANYX_EVEN_12_16 } },
+  { 2, { Bundle_st200_ANYX_EVEN_ODD_0_8, Bundle_st200_ANYX_ODD_EVEN_4_8 } },
+  { 2, { Bundle_st200_ANYX_MEM_ODD_0_8, Bundle_st200_ANYX_ODD_MEM_4_8 } },
+  { 1, { Bundle_st200_FIRST_EVEN_EVEN_4_8 } },
+  { 2, { Bundle_st200_FIRST_EVEN_MEM_4_8, Bundle_st200_FIRST_MEM_EVEN_0_16 } },
+  { 2, { Bundle_st200_FIRST_EVEN_MEMX_4_16, Bundle_st200_FIRST_MEMX_EVEN_12_16 } },
+  { 2, { Bundle_st200_FIRST_ODD_EVEN_0_8, Bundle_st200_FIRST_EVEN_ODD_4_8 } },
+  { 2, { Bundle_st200_FIRST_ODD_MEM_0_8, Bundle_st200_FIRST_MEM_ODD_4_8 } },
+  { 1, { Bundle_st200_FIRST_MEMX_ODD_0_8 } },
+  { 1, { Bundle_st200_FIRST_ODD_ODD_0_8 } },
+  { 2, { Bundle_st200_EVEN_ODD_EVEN_0_8, Bundle_st200_ODD_EVEN_EVEN_4_8 } },
+  { 2, { Bundle_st200_EVEN_ODD_MEM_0_8, Bundle_st200_ODD_EVEN_MEM_4_8 } },
+  { 4, { Bundle_st200_MEMX_EVEN_ODD_0_16, Bundle_st200_ODD_EVEN_MEMX_4_16, Bundle_st200_EVEN_MEMX_ODD_8_16, Bundle_st200_MEMX_ODD_EVEN_12_16 } },
+  { 2, { Bundle_st200_EVEN_ODD_ODD_0_8, Bundle_st200_ODD_EVEN_ODD_4_8 } },
+  { 2, { Bundle_st200_ODD_MEM_ODD_0_8, Bundle_st200_ODD_MEM_ODD_4_8 } },
+  { 1, { Bundle_st200_ANY_ANY_ANY_ANY_0_4 } },
+  { 1, { Bundle_st200_FIRST_ANY_ANY_ANY_0_4 } },
+  { 2, { Bundle_st200_EVEN_ANY_ANY_ANY_0_8, Bundle_st200_ANY_EVEN_ANY_ANY_4_8 } },
+  { 1, { Bundle_st200_ANY_ANY_ANY_MEM_0_4 } },
+  { 2, { Bundle_st200_ANY_ODD_ANY_ANY_0_8, Bundle_st200_ODD_ANY_ANY_ANY_4_8 } },
+  { 2, { Bundle_st200_FIRST_ANY_EVEN_ANY_0_8, Bundle_st200_FIRST_EVEN_ANY_ANY_4_8 } },
+  { 1, { Bundle_st200_FIRST_ANY_ANY_MEM_0_4 } },
+  { 2, { Bundle_st200_FIRST_ODD_ANY_ANY_0_8, Bundle_st200_FIRST_ANY_ODD_ANY_4_8 } },
+  { 2, { Bundle_st200_EVEN_ANY_EVEN_ANY_0_8, Bundle_st200_ANY_EVEN_ANY_EVEN_4_8 } },
+  { 2, { Bundle_st200_EVEN_ANY_MEM_ANY_0_8, Bundle_st200_ANY_EVEN_ANY_MEM_4_8 } },
+  { 2, { Bundle_st200_EVEN_ODD_ANY_ANY_0_8, Bundle_st200_ODD_EVEN_ANY_ANY_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_ANY_MEM_0_8, Bundle_st200_ODD_ANY_MEM_ANY_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_ANY_ODD_0_8, Bundle_st200_ODD_ANY_ODD_ANY_4_8 } },
+  { 1, { Bundle_st200_FIRST_EVEN_ANY_EVEN_4_8 } },
+  { 2, { Bundle_st200_FIRST_EVEN_ANY_MEM_4_8, Bundle_st200_FIRST_MEM_EVEN_ANY_0_16 } },
+  { 2, { Bundle_st200_FIRST_ODD_EVEN_ANY_0_8, Bundle_st200_FIRST_EVEN_ODD_ANY_4_8 } },
+  { 2, { Bundle_st200_FIRST_ODD_ANY_MEM_0_8, Bundle_st200_FIRST_MEM_ODD_ANY_4_8 } },
+  { 1, { Bundle_st200_FIRST_ODD_ANY_ODD_0_8 } },
+  { 2, { Bundle_st200_EVEN_ODD_EVEN_ANY_0_8, Bundle_st200_ANY_EVEN_ODD_EVEN_4_8 } },
+  { 2, { Bundle_st200_EVEN_ODD_MEM_ANY_0_8, Bundle_st200_ODD_EVEN_ANY_MEM_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_EVEN_ODD_0_8, Bundle_st200_ODD_EVEN_ODD_ANY_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_MEM_ODD_0_8, Bundle_st200_ODD_MEM_ODD_ANY_4_8 } },
+  { 1, { Bundle_st200_FIRST_EVEN_ODD_EVEN_4_8 } },
+  { 2, { Bundle_st200_FIRST_EVEN_ODD_MEM_4_8, Bundle_st200_FIRST_MEM_EVEN_ODD_0_16 } },
+  { 1, { Bundle_st200_FIRST_ODD_EVEN_ODD_0_8 } },
+  { 1, { Bundle_st200_FIRST_ODD_MEM_ODD_0_8 } },
+  { 2, { Bundle_st200_EVEN_ODD_EVEN_ODD_0_8, Bundle_st200_ODD_EVEN_ODD_EVEN_4_8 } },
+  { 2, { Bundle_st200_EVEN_ODD_MEM_ODD_0_8, Bundle_st200_ODD_EVEN_ODD_MEM_4_8 } },
+};
+
+#define Resource_st200_ISSUE 0
+#define Resource_st200_MEM 1
+#define Resource_st200_CTL 2
+#define Resource_st200_ODD 3
+#define Resource_st200_EVEN 4
+#define Resource_st200_LANE0 5
+#define RESOURCE_MAX 6
+const int st200_resource_max = RESOURCE_MAX;
+
+const char *st200_resource_names[RESOURCE_MAX] = {
+  "ISSUE",
+  "MEM",
+  "CTL",
+  "ODD",
+  "EVEN",
+  "LANE0"
+};
+
+const int st220_resources[RESOURCE_MAX] = { 4,1,1,2,2,2};
+const int st231_resources[RESOURCE_MAX] = { 4,1,1,2,2,2};
+const int st240_resources[RESOURCE_MAX] = { 4,1,1,2,2,2};
+
+#define Reservation_st220_ALL 0
+#define Reservation_st220_ALU 1
+#define Reservation_st220_ALUX 2
+#define Reservation_st220_CTL 3
+#define Reservation_st220_ODD 4
+#define Reservation_st220_ODDX 5
+#define Reservation_st220_MEM 6
+#define Reservation_st220_MEMX 7
+#define Reservation_st220_PSW 8
+#define Reservation_st220_EVEN 9
+#define Reservation_st231_ALL 10
+#define Reservation_st231_ALU 11
+#define Reservation_st231_ALUX 12
+#define Reservation_st231_CTL 13
+#define Reservation_st231_ODD 14
+#define Reservation_st231_ODDX 15
+#define Reservation_st231_MEM 16
+#define Reservation_st231_MEMX 17
+#define Reservation_st231_PSW 18
+#define Reservation_st231_EVEN 19
+#define Reservation_st240_ALL 20
+#define Reservation_st240_ALU 21
+#define Reservation_st240_ALUX 22
+#define Reservation_st240_CTL 23
+#define Reservation_st240_ODD 24
+#define Reservation_st240_ODDX 25
+#define Reservation_st240_MEM 26
+#define Reservation_st240_MEMX 27
+#define Reservation_st240_PSW 28
+#define Reservation_st240_EVEN 29
+
+
+#define RESERVATION_TABLE_LINES 1
+const int st200_reservation_table_lines = RESERVATION_TABLE_LINES;
+
+static const int Reservation_st220_ALL_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  4 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st220_ALU_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st220_ALUX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st220_CTL_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  1 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st220_EVEN_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st220_MEM_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st220_MEMX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st220_ODD_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st220_ODDX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st220_PSW_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  1 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_ALL_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  4 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_ALU_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_ALUX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_CTL_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  1 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_EVEN_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_MEM_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_MEMX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_ODD_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_ODDX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_PSW_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  1 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_ALL_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  4 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_ALU_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_ALUX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_CTL_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  1 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_EVEN_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  1 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_MEM_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  1 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_MEMX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  2 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_ODD_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_ODDX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_PSW_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  1 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+const int *st200_reservation_table_table[] = {
+  Reservation_st220_ALL_table,
+  Reservation_st220_ALU_table,
+  Reservation_st220_ALUX_table,
+  Reservation_st220_CTL_table,
+  Reservation_st220_ODD_table,
+  Reservation_st220_ODDX_table,
+  Reservation_st220_MEM_table,
+  Reservation_st220_MEMX_table,
+  Reservation_st220_PSW_table,
+  Reservation_st220_EVEN_table,
+  Reservation_st231_ALL_table,
+  Reservation_st231_ALU_table,
+  Reservation_st231_ALUX_table,
+  Reservation_st231_CTL_table,
+  Reservation_st231_ODD_table,
+  Reservation_st231_ODDX_table,
+  Reservation_st231_MEM_table,
+  Reservation_st231_MEMX_table,
+  Reservation_st231_PSW_table,
+  Reservation_st231_EVEN_table,
+  Reservation_st240_ALL_table,
+  Reservation_st240_ALU_table,
+  Reservation_st240_ALUX_table,
+  Reservation_st240_CTL_table,
+  Reservation_st240_ODD_table,
+  Reservation_st240_ODDX_table,
+  Reservation_st240_MEM_table,
+  Reservation_st240_MEMX_table,
+  Reservation_st240_PSW_table,
+  Reservation_st240_EVEN_table
+};
+
+const Lx_Core_Info st210_core_info = { "st210", 0, 0, ELF_LX_CORE_ST210, FALSE };
+
+lxopc_t st220_lxoptab[] = {
+	{"nop", 0x00000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {0}, "", ""},
+	{"mov", 0x00000000, 0x7ffc003f, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src2, 0}, "", "%s = %s"},
+	{"add", 0x00000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sub", 0x00200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"shl", 0x00400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shr", 0x00600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shru", 0x00800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh1add", 0x00a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh2add", 0x00c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh3add", 0x00e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh4add", 0x01000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"and", 0x01200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andc", 0x01400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"or", 0x01600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"orc", 0x01800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"xor", 0x01a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mullhus", 0x01e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"max", 0x02000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"maxu", 0x02200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"min", 0x02400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"minu", 0x02600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhhs", 0x02800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mull", 0x02a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mullu", 0x02c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulh", 0x02e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhu", 0x03000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulll", 0x03200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulllu", 0x03400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mullh", 0x03600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mullhu", 0x03800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhh", 0x03a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhhu", 0x03c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhs", 0x03e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x04000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x04200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x04400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x04600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x04800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x04a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x04c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x04e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x05000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x05200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x05400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x05600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"orl", 0x05800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x05a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x06000000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x06200000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x06400000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x06600000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x06800000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x06a00000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x06c00000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x06e00000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x07000000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x07200000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x07400000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x07600000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"convib", 0x07800000, 0x7fe3ffc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, 0}, "", "%s = %s"},
+	{"mov", 0x07800000, 0x7fe3ffc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, 0}, "", "%s = %s"},
+	{"mtb", 0x07800000, 0x7fe3ffc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, 0}, "", "%s = %s"},
+	{"orl", 0x07800000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x07a00000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mov", 0x08000000, 0x7fe0003f, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &isrc2, 0}, "", "%s = %s"},
+	{"add", 0x08000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sub", 0x08200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &isrc2, &src1, 0}, "", "%s = %s, %s"},
+	{"shl", 0x08400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shr", 0x08600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shru", 0x08800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh1add", 0x08a00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh2add", 0x08c00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh3add", 0x08e00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh4add", 0x09000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"zxtb", 0x092ff000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"and", 0x09200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"andc", 0x09400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"or", 0x09600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"orc", 0x09800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"xor", 0x09a00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sxtb", 0x09c00000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"sxth", 0x09c01000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"bswap", 0x09c02000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"zxth", 0x09c03000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"clz", 0x09c04000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"mullhus", 0x09e00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"max", 0x0a000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"maxu", 0x0a200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"min", 0x0a400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"minu", 0x0a600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhhs", 0x0a800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mull", 0x0aa00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mullu", 0x0ac00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulh", 0x0ae00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhu", 0x0b000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulll", 0x0b200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulllu", 0x0b400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mullh", 0x0b600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mullhu", 0x0b800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhh", 0x0ba00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhhu", 0x0bc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhs", 0x0be00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x0c000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x0c200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x0c400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x0c600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x0c800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x0ca00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x0cc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x0ce00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x0d000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x0d200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x0d400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x0d600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"orl", 0x0d800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x0da00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x0e000000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x0e200000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x0e400000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x0e600000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x0e800000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x0ea00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x0ec00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x0ee00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x0f000000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x0f200000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x0f400000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x0f600000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"orl", 0x0f800000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x0fa00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"slct", 0x10000000, 0x7f1c0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"slctf", 0x11000000, 0x7f1c0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"addcg", 0x12000000, 0x7f000000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&dest, &bdest, &src1, &src2, &scond, 0}, "", "%s, %s = %s, %s, %s"},
+	{"divs", 0x14000000, 0x7f000000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&dest, &bdest, &src1, &src2, &scond, 0}, "", "%s, %s = %s, %s, %s"},
+	{"imml", 0x15000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st220_EVEN, {&imm, 0}, "", "%s"},
+	{"immr", 0x15800000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st220_EVEN, {&imm, 0}, "", "%s"},
+	{"slct", 0x18000000, 0x7f000000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &scond, &src1, &isrc2, 0}, "", "%s = %s, %s, %s"},
+	{"convbi", 0x19001000, 0x7f1ff03f, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&idest, &scond, 0}, "", "%s = %s"},
+	{"mov", 0x19001000, 0x7f1ff03f, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&idest, &scond, 0}, "", "%s = %s"},
+	{"mfb", 0x19001000, 0x7f1ff03f, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&idest, &scond, 0}, "", "%s = %s"},
+	{"slctf", 0x19000000, 0x7f000000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &scond, &src1, &isrc2, 0}, "", "%s = %s, %s, %s"},
+	{"prgins", 0x1f800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_ALONE, ((int)0 << 8) | (int)Reservation_st220_ALL, {0}, "", ""},
+	{"sbrk", 0x9fa00000, 0xffe00000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&sbrknum, 0}, "", "%s"},
+	{"syscall", 0x1fc00000, 0x7fe00000, ((int)0 << 8) | (int)Bundling_st200_ALONE, ((int)0 << 8) | (int)Reservation_st220_ALL, {&sbrknum, 0}, "", "%s"},
+	{"break", 0x1fe00000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {0}, "", ""},
+	{"ldw", 0x20000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&idest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldw.d", 0x20800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&idest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldh", 0x21000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldh.d", 0x21800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldhu", 0x22000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldhu.d", 0x22800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldb", 0x23000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldb.d", 0x23800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldbu", 0x24000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldbu.d", 0x24800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"stw", 0x25000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"sth", 0x25800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"stb", 0x26000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"pft", 0x26800000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prgadd", 0x27000000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prgset", 0x27800000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st220_MEMX << 8) | (int)Reservation_st220_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"sync", 0x28000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st220_MEM, {0}, "", ""},
+	{"asm_0", 0x2c000000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_1", 0x2c200000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_2", 0x2c400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_3", 0x2c600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_4", 0x2c800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_5", 0x2ca00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_6", 0x2cc00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_7", 0x2ce00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st220_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_8", 0x2d000000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st220_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_9", 0x2d200000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st220_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_10", 0x2d400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st220_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_11", 0x2d600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st220_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_12", 0x2d800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st220_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_13", 0x2da00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st220_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_14", 0x2dc00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st220_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_15", 0x2de00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st220_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_16", 0x2e000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_17", 0x2e200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_18", 0x2e400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_19", 0x2e600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_20", 0x2e800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_21", 0x2ea00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_22", 0x2ec00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_23", 0x2ee00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_24", 0x2f000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_25", 0x2f200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_26", 0x2f400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_27", 0x2f600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st220_ALUX << 8) | (int)Reservation_st220_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_28", 0x2f800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_29", 0x2fa00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_30", 0x2fc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_31", 0x2fe00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st220_ODDX << 8) | (int)Reservation_st220_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"call", 0x30000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st220_CTL, {&link, &btarg, 0}, "", "%s = %s"},
+	{"call", 0x30800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st220_CTL, {&link, &link, 0}, "", "%s = %s"},
+	{"syncins", 0x31000001, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st220_CTL, {0}, "", ""},
+	{"goto", 0x31000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st220_CTL, {&btarg, 0}, "", "%s"},
+	{"goto", 0x31800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st220_CTL, {&link, 0}, "", "%s"},
+	{"return", 0x31800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st220_CTL, {&link, 0}, "", "%s"},
+	{"rfi", 0x32000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st220_CTL, {0}, "", ""},
+	{"br", 0x38000000, 0x7c000000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st220_CTL, {&bcond, &btarg, 0}, "", "%s, %s"},
+	{"brf", 0x3c000000, 0x7c000000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st220_CTL, {&bcond, &btarg, 0}, "", "%s, %s"},
+/* Number of instructions : 203 */
+	{"", 0, 0, 0, 0, {0}, "", ""}};
+
+const Lx_Core_Info st220_core_info = { "st220", st220_lxoptab, st220_resources, ELF_LX_CORE_ST220, TRUE };
+
+lxopc_t st231_lxoptab[] = {
+	{"nop", 0x00000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {0}, "", ""},
+	{"mov", 0x00000000, 0x7ffc003f, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src2, 0}, "", "%s = %s"},
+	{"add", 0x00000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sub", 0x00200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"shl", 0x00400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shr", 0x00600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shru", 0x00800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh1add", 0x00a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh2add", 0x00c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh3add", 0x00e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh4add", 0x01000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"and", 0x01200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andc", 0x01400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"or", 0x01600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"orc", 0x01800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"xor", 0x01a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mullhus", 0x01e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"max", 0x02000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"maxu", 0x02200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"min", 0x02400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"minu", 0x02600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhhs", 0x02800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mull", 0x02a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mullu", 0x02c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulh", 0x02e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhu", 0x03000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulll", 0x03200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulllu", 0x03400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mullh", 0x03600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mullhu", 0x03800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhh", 0x03a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhhu", 0x03c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhs", 0x03e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x04000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x04200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x04400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x04600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x04800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x04a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x04c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x04e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x05000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x05200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x05400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x05600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"orl", 0x05800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x05a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mul32", 0x05c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mul64h", 0x05e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x06000000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x06200000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x06400000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x06600000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x06800000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x06a00000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x06c00000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x06e00000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x07000000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x07200000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x07400000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x07600000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"convib", 0x07800000, 0x7fe3ffc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, 0}, "", "%s = %s"},
+	{"mov", 0x07800000, 0x7fe3ffc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, 0}, "", "%s = %s"},
+	{"mtb", 0x07800000, 0x7fe3ffc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, 0}, "", "%s = %s"},
+	{"orl", 0x07800000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x07a00000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mul64hu", 0x07c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulfrac", 0x07e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mov", 0x08000000, 0x7fe0003f, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &isrc2, 0}, "", "%s = %s"},
+	{"add", 0x08000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sub", 0x08200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &isrc2, &src1, 0}, "", "%s = %s, %s"},
+	{"shl", 0x08400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shr", 0x08600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shru", 0x08800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh1add", 0x08a00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh2add", 0x08c00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh3add", 0x08e00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh4add", 0x09000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"zxtb", 0x092ff000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"and", 0x09200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"andc", 0x09400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"or", 0x09600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"orc", 0x09800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"xor", 0x09a00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sxtb", 0x09c00000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"sxth", 0x09c01000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"bswap", 0x09c02000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"zxth", 0x09c03000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"clz", 0x09c04000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"mullhus", 0x09e00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"max", 0x0a000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"maxu", 0x0a200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"min", 0x0a400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"minu", 0x0a600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhhs", 0x0a800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mull", 0x0aa00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mullu", 0x0ac00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulh", 0x0ae00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhu", 0x0b000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulll", 0x0b200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulllu", 0x0b400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mullh", 0x0b600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mullhu", 0x0b800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhh", 0x0ba00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhhu", 0x0bc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhs", 0x0be00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x0c000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x0c200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x0c400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x0c600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x0c800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x0ca00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x0cc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x0ce00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x0d000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x0d200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x0d400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x0d600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"orl", 0x0d800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x0da00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mul32", 0x0dc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mul64h", 0x0de00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x0e000000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x0e200000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x0e400000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x0e600000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x0e800000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x0ea00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x0ec00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x0ee00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x0f000000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x0f200000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x0f400000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x0f600000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"orl", 0x0f800000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x0fa00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mul64hu", 0x0fc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulfrac", 0x0fe00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"slct", 0x10000000, 0x7f1c0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"slctf", 0x11000000, 0x7f1c0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"addcg", 0x12000000, 0x7f000000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &bdest, &src1, &src2, &scond, 0}, "", "%s, %s = %s, %s, %s"},
+	{"divs", 0x14000000, 0x7f000000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &bdest, &src1, &src2, &scond, 0}, "", "%s, %s = %s, %s, %s"},
+	{"imml", 0x15000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st231_EVEN, {&imm, 0}, "", "%s"},
+	{"immr", 0x15800000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st231_EVEN, {&imm, 0}, "", "%s"},
+	{"slct", 0x18000000, 0x7f000000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &scond, &src1, &isrc2, 0}, "", "%s = %s, %s, %s"},
+	{"convbi", 0x19001000, 0x7f1ff03f, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &scond, 0}, "", "%s = %s"},
+	{"mov", 0x19001000, 0x7f1ff03f, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &scond, 0}, "", "%s = %s"},
+	{"mfb", 0x19001000, 0x7f1ff03f, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &scond, 0}, "", "%s = %s"},
+	{"slctf", 0x19000000, 0x7f000000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &scond, &src1, &isrc2, 0}, "", "%s = %s, %s, %s"},
+	{"prgins", 0x1f800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_ALONE, ((int)0 << 8) | (int)Reservation_st231_ALL, {0}, "", ""},
+	{"sbrk", 0x9fa00000, 0xffe00000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&sbrknum, 0}, "", "%s"},
+	{"syscall", 0x1fc00000, 0x7fe00000, ((int)0 << 8) | (int)Bundling_st200_ALONE, ((int)0 << 8) | (int)Reservation_st231_ALL, {&sbrknum, 0}, "", "%s"},
+	{"break", 0x1fe00000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {0}, "", ""},
+	{"ldw", 0x20000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&idest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldw.d", 0x20800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&idest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldh", 0x21000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldh.d", 0x21800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldhu", 0x22000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldhu.d", 0x22800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldb", 0x23000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldb.d", 0x23800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldbu", 0x24000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldbu.d", 0x24800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"stw", 0x25000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"sth", 0x25800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"stb", 0x26000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"pft", 0x26800000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prgadd", 0x27000000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prgset", 0x27800000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"sync", 0x28000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st231_MEM, {0}, "", ""},
+	{"prginspg", 0x28800000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"syncins", 0x29000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_PSW, {0}, "", ""},
+	{"pswset", 0x29000000, 0x7ffff03f, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_PSW, {&src2, 0}, "", "%s"},
+	{"pswclr", 0x29800000, 0x7ffff03f, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_PSW, {&src2, 0}, "", "%s"},
+	{"asm_31", 0x2be00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_0", 0x2c000000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_1", 0x2c200000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_2", 0x2c400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_3", 0x2c600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_4", 0x2c800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_5", 0x2ca00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_6", 0x2cc00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_7", 0x2ce00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_8", 0x2d000000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st231_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_9", 0x2d200000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st231_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_10", 0x2d400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st231_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_11", 0x2d600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st231_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_12", 0x2d800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st231_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_13", 0x2da00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st231_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_14", 0x2dc00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st231_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_15", 0x2de00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st231_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_16", 0x2e000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_17", 0x2e200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_18", 0x2e400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_19", 0x2e600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_20", 0x2e800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_21", 0x2ea00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_22", 0x2ec00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_23", 0x2ee00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_24", 0x2f000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_25", 0x2f200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_26", 0x2f400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_27", 0x2f600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_28", 0x2f800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_29", 0x2fa00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_30", 0x2fc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"wmb", 0x2fe03000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st231_MEM, {0}, "", ""},
+	{"ldwl", 0x2fe05000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st231_MEM, {&idest, &src1, 0}, "", "%s = [%s]"},
+	{"stwl", 0x2ff00000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st231_MEM, {&bdest2, &src1, &src2, 0}, "", "%s, [%s] = %s"},
+	{"call", 0x30000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {&link, &btarg, 0}, "", "%s = %s"},
+	{"call", 0x30800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {&link, &link, 0}, "", "%s = %s"},
+	{"idle", 0x31000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {0}, "", ""},
+	{"goto", 0x31000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {&btarg, 0}, "", "%s"},
+	{"goto", 0x31800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {&link, 0}, "", "%s"},
+	{"return", 0x31800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {&link, 0}, "", "%s"},
+	{"rfi", 0x32000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_PSW, {0}, "", ""},
+	{"br", 0x38000000, 0x7c000000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {&bcond, &btarg, 0}, "", "%s, %s"},
+	{"brf", 0x3c000000, 0x7c000000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {&bcond, &btarg, 0}, "", "%s, %s"},
+/* Number of instructions : 218 */
+	{"", 0, 0, 0, 0, {0}, "", ""}};
+
+const Lx_Core_Info st231_core_info = { "st231", st231_lxoptab, st231_resources, ELF_LX_CORE_ST231, TRUE };
+
+lxopc_t st240_lxoptab[] = {
+	{"nop", 0x00000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {0}, "", ""},
+	{"mov", 0x00000000, 0x7ffc003f, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src2, 0}, "", "%s = %s"},
+	{"add", 0x00000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sub", 0x00200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"shl", 0x00400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shr", 0x00600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shru", 0x00800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh1add", 0x00a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh2add", 0x00c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh3add", 0x00e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"and", 0x01200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andc", 0x01400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"or", 0x01600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"orc", 0x01800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"xor", 0x01a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mul64h", 0x01e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"max", 0x02000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"addf.n", 0x02080000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"adds", 0x02100000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"maxu", 0x02200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"subf.n", 0x02280000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"subs", 0x02300000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"min", 0x02400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulf.n", 0x02480000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh1adds", 0x02500000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"minu", 0x02600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"convif.n", 0x02680000, 0x7ffc0fc0, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&nldest, &src1, 0}, "", "%s = %s"},
+	{"sh1subs", 0x02700000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"mul64hu", 0x02800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"convfi.n", 0x02880000, 0x7ffc0fc0, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&nldest, &src1, 0}, "", "%s = %s"},
+	{"sats", 0x02900000, 0x7ffc0fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, 0}, "", "%s = %s"},
+	{"mull", 0x02a00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"adds.ph", 0x02b00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mul32", 0x02c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"subs.ph", 0x02d00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"mulh", 0x02e00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"div", 0x03080000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"addso", 0x03100000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulll", 0x03200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"rem", 0x03280000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"subso", 0x03300000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"mulllu", 0x03400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"divu", 0x03480000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh1addso", 0x03500000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"mullh", 0x03600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"remu", 0x03680000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh1subso", 0x03700000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"mullhu", 0x03800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"satso", 0x03900000, 0x7ffc0fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, 0}, "", "%s = %s"},
+	{"mulhh", 0x03a00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhhu", 0x03c00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulfrac", 0x03e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x04000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpeq.pb", 0x04040000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x04200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgef.n", 0x04400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmplef.n", 0x04400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmpgtu.pb", 0x04440000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpeqf.n", 0x04600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgtf.n", 0x04800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpltf.n", 0x04800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x04c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x04c00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x04e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x04e00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x05000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x05000000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmpeq.ph", 0x05040000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x05200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x05200000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmpgt.ph", 0x05240000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x05400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x05600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"orl", 0x05800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x05a00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x06000000, 0x7fff8000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x06008000, 0x7fff8e38, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &bsrc1, &bsrc2, 0}, "", "%s = %s, %s"},
+	{"mov", 0x06010000, 0x7fff8ff8, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &bsrc1, 0}, "", "%s = %s"},
+	{"cmpeq.pb", 0x06040000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x06200000, 0x7fff8000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x06208000, 0x7fff8e38, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &bsrc1, &bsrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu.pb", 0x06240000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgef.n", 0x06400000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmplef.n", 0x06400000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"orl", 0x06408000, 0x7fff8e38, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &bsrc1, &bsrc2, 0}, "", "%s = %s, %s"},
+	{"cmpeqf.n", 0x06600000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x06608000, 0x7fff8e38, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &bsrc1, &bsrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgtf.n", 0x06800000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpltf.n", 0x06800000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x06c00000, 0x7fff8000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x06c00000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x06e00000, 0x7fff8000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x06e00000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x07000000, 0x7fff8000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x07000000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmpeq.ph", 0x07040000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x07200000, 0x7fff8000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x07200000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmpgt.ph", 0x07240000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x07400000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x07600000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"convib", 0x07800000, 0x7fff8fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, 0}, "", "%s = %s"},
+	{"mtb", 0x07800000, 0x7fff8fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, 0}, "", "%s = %s"},
+	{"orl", 0x07800000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x07a00000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mov", 0x07c00000, 0x7fff8fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, 0}, "", "%s = %s"},
+	{"mov", 0x08000000, 0x7fe0003f, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &isrc2, 0}, "", "%s = %s"},
+	{"add", 0x08000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sub", 0x08200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &isrc2, &src1, 0}, "", "%s = %s, %s"},
+	{"shl", 0x08400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shr", 0x08600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shru", 0x08800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh1add", 0x08a00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh2add", 0x08c00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh3add", 0x08e00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"addpc", 0x09000000, 0x7fe0003f, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &isrc2, 0}, "", "%s = %s"},
+	{"zxtb", 0x092ff000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"and", 0x09200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"andc", 0x09400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"or", 0x09600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"xor", 0x09a00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"clz", 0x09c04000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"mul64h", 0x09e00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"max", 0x0a000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"maxu", 0x0a200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"min", 0x0a400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"minu", 0x0a600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mul64hu", 0x0a800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mul32", 0x0ac00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mull", 0x0ac00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulll", 0x0b200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulllu", 0x0b400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulfrac", 0x0be00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x0c000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x0c200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x0c400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x0c600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x0c800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x0ca00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x0cc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x0ce00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x0d000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x0d200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x0e000000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x0e200000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x0e400000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x0e600000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x0e800000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x0ea00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x0ec00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x0ee00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x0f000000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x0f200000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shls", 0x10000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shlso", 0x10200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sxt", 0x10a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"zxt", 0x10c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"rotl", 0x10e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"perm.pb", 0x12000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"unpacku.pbh", 0x12040000, 0x7ffc0fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, 0}, "", "%s = %s"},
+	{"shuff.pbh", 0x12040000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sadu.pb", 0x12080000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"unpacku.pbl", 0x12240000, 0x7ffc0fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, 0}, "", "%s = %s"},
+	{"shuff.pbl", 0x12240000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"absubu.pb", 0x12280000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shuffodd.pb", 0x12440000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"muladdus.pb", 0x12480000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shuffeve.pb", 0x12640000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"pack.pb", 0x12680000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"ext1.pb", 0x12840000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"ext2.pb", 0x12a40000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"ext3.pb", 0x12c40000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"packsu.pb", 0x12e40000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shl.ph", 0x13000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"add.ph", 0x13040000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shuff.phh", 0x13080000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shls.ph", 0x13200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"abss.ph", 0x13240000, 0x7ffc0fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, 0}, "", "%s = %s"},
+	{"shuff.phl", 0x13280000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"pack.ph", 0x13280000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shr.ph", 0x13400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"max.ph", 0x13440000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sub.ph", 0x13480000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"shrrnp.ph", 0x13600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"min.ph", 0x13640000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulfracadds.ph", 0x13680000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shrrne.ph", 0x13800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mul.ph", 0x13840000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"muladd.ph", 0x13a40000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulfracrm.ph", 0x13c40000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"packrnp.phh", 0x13c80000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulfracrne.ph", 0x13e40000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"packs.ph", 0x13e80000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"addcg", 0x14000000, 0x7f000000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &bdest, &src1, &src2, &scond, 0}, "", "%s, %s = %s, %s, %s"},
+	{"imml", 0x15000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&imm, 0}, "", "%s"},
+	{"immr", 0x15800000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&imm, 0}, "", "%s"},
+	{"slct.pb", 0x16000000, 0x7f1c0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"slctf.pb", 0x16000000, 0x7f1c0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &scond, &src2, &src1, 0}, "", "%s = %s, %s, %s"},
+	{"slct", 0x16040000, 0x7f1c0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"slctf", 0x16040000, 0x7f1c0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &scond, &src2, &src1, 0}, "", "%s = %s, %s, %s"},
+	{"mov", 0x17040000, 0x7f1c0fff, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &scond, 0}, "", "%s = %s"},
+	{"extl.pb", 0x17080000, 0x7f1c0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"extr.pb", 0x170c0000, 0x7f1c0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"avgu.pb", 0x17100000, 0x7f1c0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"avg4u.pb", 0x17140000, 0x7f1c0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&nldest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"shls", 0x18000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shlso", 0x18200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shrrnp", 0x18400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"extract", 0x18600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"extractu", 0x18800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sxtb", 0x18a08000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"sxth", 0x18a10000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"sxt", 0x18a00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"zxth", 0x18c10000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"zxt", 0x18c00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"rotl", 0x18e00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"extractl", 0x19600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"extractlu", 0x19800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"bswap", 0x1a01b000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"perm.pb", 0x1a000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shl.ph", 0x1b000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shls.ph", 0x1b200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shr.ph", 0x1b400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shrrnp.ph", 0x1b600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shrrne.ph", 0x1b800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"slct", 0x1c000000, 0x7f000000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &scond, &src1, &isrc2, 0}, "", "%s = %s, %s, %s"},
+	{"convbi", 0x1d001000, 0x7f1ff03f, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &scond, 0}, "", "%s = %s"},
+	{"mfb", 0x1d001000, 0x7f1ff03f, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &scond, 0}, "", "%s = %s"},
+	{"slctf", 0x1d000000, 0x7f000000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &scond, &src1, &isrc2, 0}, "", "%s = %s, %s, %s"},
+	{"slct.pb", 0x1e000000, 0x7f1c0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &scond, &src1, &isrc2, 0}, "", "%s = %s, %s, %s"},
+	{"slctf.pb", 0x1f000000, 0x7f000000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &scond, &src1, &isrc2, 0}, "", "%s = %s, %s, %s"},
+	{"pft", 0x20000000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"pftc", 0x20000000, 0x7f000fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&pcond, &isrc2, &src1, 0}, "", "%s, %s[%s]"},
+	{"ldl", 0x20000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&idestp, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldlc", 0x20000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&idestp, &pcond, &isrc2, &src1, 0}, "", "%s = %s, %s[%s]"},
+	{"ldw", 0x21000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&idest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldwc", 0x21000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&idest, &pcond, &isrc2, &src1, 0}, "", "%s = %s, %s[%s]"},
+	{"ldh", 0x22000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldhc", 0x22000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &pcond, &isrc2, &src1, 0}, "", "%s = %s, %s[%s]"},
+	{"ldhu", 0x23000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldhuc", 0x23000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &pcond, &isrc2, &src1, 0}, "", "%s = %s, %s[%s]"},
+	{"ldb", 0x24000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldbc", 0x24000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &pcond, &isrc2, &src1, 0}, "", "%s = %s, %s[%s]"},
+	{"ldbu", 0x25000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldbuc", 0x25000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &pcond, &isrc2, &src1, 0}, "", "%s = %s, %s[%s]"},
+	{"asm_0", 0x26000000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_1", 0x26200000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_2", 0x26400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_3", 0x26600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_4", 0x26800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_5", 0x26a00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_6", 0x26c00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_7", 0x26e00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_8", 0x27000000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_9", 0x27200000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_10", 0x27400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_11", 0x27600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_12", 0x27800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_13", 0x27a00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_14", 0x27c00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_15", 0x27e00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"stl", 0x28000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &src2p, 0}, "", "%s[%s] = %s"},
+	{"stlc", 0x28000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &pcond, &src2p, 0}, "", "%s[%s] = %s, %s"},
+	{"stw", 0x29000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"stwc", 0x29000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &pcond, &src2, 0}, "", "%s[%s] = %s, %s"},
+	{"sth", 0x2a000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"sthc", 0x2a000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &pcond, &src2, 0}, "", "%s[%s] = %s, %s"},
+	{"asm_16", 0x2b000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_17", 0x2b200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_18", 0x2b400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_19", 0x2b600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_20", 0x2b800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_21", 0x2ba00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_22", 0x2bc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_23", 0x2be00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"stb", 0x2c000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"stbc", 0x2c000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &pcond, &src2, 0}, "", "%s[%s] = %s, %s"},
+	{"asm_24", 0x2d000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_25", 0x2d200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_26", 0x2d400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_27", 0x2d600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_28", 0x2d800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_29", 0x2da00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_30", 0x2dc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_31", 0x2de00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"prgadd", 0x2f000000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prgadd.l1", 0x2f000040, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prgset", 0x2f200000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prgset.l1", 0x2f200040, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prginsadd", 0x2f400000, 0x7fe00fc0, ((int)Bundling_st200_ALONEX << 8) | (int)Bundling_st200_ALONE, ((int)Reservation_st240_ALL << 8) | (int)Reservation_st240_ALL, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prginsadd.l1", 0x2f400040, 0x7fe00fc0, ((int)Bundling_st200_ALONEX << 8) | (int)Bundling_st200_ALONE, ((int)Reservation_st240_ALL << 8) | (int)Reservation_st240_ALL, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prginsset", 0x2f600000, 0x7fe00fc0, ((int)Bundling_st200_ALONEX << 8) | (int)Bundling_st200_ALONE, ((int)Reservation_st240_ALL << 8) | (int)Reservation_st240_ALL, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prginsset.l1", 0x2f600040, 0x7fe00fc0, ((int)Bundling_st200_ALONEX << 8) | (int)Bundling_st200_ALONE, ((int)Reservation_st240_ALL << 8) | (int)Reservation_st240_ALL, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"flushadd", 0x2f800000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"flushadd.l1", 0x2f800040, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"pswmask", 0x2fa00000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"invadd", 0x2fc00000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"invadd.l1", 0x2fc00040, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"syncins", 0x2fe00000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_PSW, {0}, "", ""},
+	{"sync", 0x2fe02000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {0}, "", ""},
+	{"wmb", 0x2fe03000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {0}, "", ""},
+	{"waitl", 0x2fe04000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {0}, "", ""},
+	{"ldwl", 0x2fe05000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {&idest, &src1, 0}, "", "%s = [%s]"},
+	{"dib", 0x2fe06000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {0}, "", ""},
+	{"dbgsbrk", 0xafe08000, 0xfffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&brknum, 0}, "", "%s"},
+	{"sbrk", 0xafe09000, 0xfffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&brknum, 0}, "", "%s"},
+	{"syscall", 0x2fe0a000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ALONE, ((int)0 << 8) | (int)Reservation_st240_ALL, {&brknum, 0}, "", "%s"},
+	{"break", 0x2fe0b000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {0}, "", ""},
+	{"retention", 0xafe0c000, 0xffffffff, ((int)0 << 8) | (int)Bundling_st200_ALONE, ((int)0 << 8) | (int)Reservation_st240_ALL, {0}, "", ""},
+	{"stwl", 0x2ff00000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {&bdest2, &src1, &src2, 0}, "", "%s, [%s] = %s"},
+	{"call", 0x30000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {&link, &btarg, 0}, "", "%s = %s"},
+	{"call", 0x30800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {&link, &link, 0}, "", "%s = %s"},
+	{"idle", 0x31000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {0}, "", ""},
+	{"goto", 0x31000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {&btarg, 0}, "", "%s"},
+	{"goto", 0x31800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {&link, 0}, "", "%s"},
+	{"rfi", 0x32000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_PSW, {0}, "", ""},
+	{"return", 0x33800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {&link, 0}, "", "%s"},
+	{"br", 0x38000000, 0x7c000000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {&bcond, &btarg, 0}, "", "%s, %s"},
+	{"brf", 0x3c000000, 0x7c000000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {&bcond, &btarg, 0}, "", "%s, %s"},
+/* Number of instructions : 319 */
+	{"", 0, 0, 0, 0, {0}, "", ""}};
+
+const Lx_Core_Info st240_core_info = { "st240", st240_lxoptab, st240_resources, ELF_LX_CORE_ST240, TRUE };
+
+const Lx_Core_Info *st200_core_info_table[] = 
+{
+  & st210_core_info,
+  & st220_core_info,
+  & st231_core_info,
+  & st240_core_info
+};
+
diff -r -N -u binutils-2.21.51/opcodes/Makefile.am binutils/opcodes/Makefile.am
--- binutils-2.21.51/opcodes/Makefile.am	2010-12-06 09:23:27.000000000 +0000
+++ binutils/opcodes/Makefile.am	2011-07-06 12:44:26.137253000 +0100
@@ -132,6 +132,8 @@
 	lm32-ibld.c \
 	lm32-opc.c \
 	lm32-opinst.c \
+	lx-dis.c \
+	lx-opc.c \
 	m10200-dis.c \
 	m10200-opc.c \
 	m10300-dis.c \
diff -r -N -u binutils-2.21.51/opcodes/Makefile.in binutils/opcodes/Makefile.in
--- binutils-2.21.51/opcodes/Makefile.in	2010-12-06 09:23:27.000000000 +0000
+++ binutils/opcodes/Makefile.in	2011-07-06 12:44:26.137253000 +0100
@@ -402,6 +402,8 @@
 	lm32-ibld.c \
 	lm32-opc.c \
 	lm32-opinst.c \
+	lx-dis.c \
+	lx-opc.c \
 	m10200-dis.c \
 	m10200-opc.c \
 	m10300-dis.c \
@@ -773,6 +775,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lm32-ibld.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lm32-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lm32-opinst.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lx-dis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lx-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/m10200-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/m10200-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/m10300-dis.Plo@am__quote@
