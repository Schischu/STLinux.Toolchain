 Makefile                                      |    4 +-
 arch/st200/Kconfig                            |  180 ++++
 arch/st200/Makefile                           |   70 ++
 arch/st200/boards/st/mb427/Makefile           |    2 +
 arch/st200/boards/st/mb427/setup.c            |  243 +++++
 arch/st200/boards/st/sim/Makefile             |    2 +
 arch/st200/boards/st/sim/setup.c              |   34 +
 arch/st200/boards/st/stv576_dual_ref/Makefile |    2 +
 arch/st200/boards/st/stv576_dual_ref/setup.c  |   81 ++
 arch/st200/boards/st/stv576_ref/Makefile      |    2 +
 arch/st200/boards/st/stv576_ref/setup.c       |   69 ++
 arch/st200/boot/Makefile                      |   40 +
 arch/st200/boot/compressed/Makefile           |   39 +
 arch/st200/boot/compressed/head.S             |  260 ++++++
 arch/st200/boot/compressed/misc.c             |  233 +++++
 arch/st200/boot/compressed/vmlinux.lds.in     |   46 +
 arch/st200/boot/compressed/vmlinux.scr        |   12 +
 arch/st200/configs/simulator_defconfig        |  842 +++++++++++++++++
 arch/st200/configs/stv576_dual_ref_defconfig  | 1192 +++++++++++++++++++++++++
 arch/st200/configs/stv576_ref_defconfig       | 1191 ++++++++++++++++++++++++
 arch/st200/drivers/Kconfig                    |   29 +
 arch/st200/drivers/Makefile                   |    6 +
 arch/st200/drivers/irq-reflector.c            |  255 ++++++
 arch/st200/drivers/pci/Makefile               |    2 +
 arch/st200/drivers/pci/pci.c                  |  182 ++++
 arch/st200/drivers/pci/v320usc.c              |  326 +++++++
 arch/st200/drivers/pci/v320usc.h              |  455 ++++++++++
 arch/st200/drivers/simcons.c                  |  308 +++++++
 arch/st200/drivers/simeth.c                   |  282 ++++++
 arch/st200/include/asm/Kbuild                 |    1 +
 arch/st200/include/asm/atomic.h               |  312 +++++++
 arch/st200/include/asm/auxvec.h               |    6 +
 arch/st200/include/asm/bitops.h               |  238 +++++
 arch/st200/include/asm/bitsperlong.h          |    1 +
 arch/st200/include/asm/bug.h                  |   14 +
 arch/st200/include/asm/bugs.h                 |   26 +
 arch/st200/include/asm/byteorder.h            |   22 +
 arch/st200/include/asm/cache.h                |   14 +
 arch/st200/include/asm/cacheflush.h           |   73 ++
 arch/st200/include/asm/checksum.h             |    1 +
 arch/st200/include/asm/clock.h                |   53 ++
 arch/st200/include/asm/cputime.h              |    6 +
 arch/st200/include/asm/ctrlregdef-231.h       |  152 ++++
 arch/st200/include/asm/ctrlregdef.h           |  112 +++
 arch/st200/include/asm/current.h              |   23 +
 arch/st200/include/asm/debugregs.h            |   29 +
 arch/st200/include/asm/delay.h                |   22 +
 arch/st200/include/asm/device.h               |    6 +
 arch/st200/include/asm/div64.h                |    6 +
 arch/st200/include/asm/dma-mapping.h          |  170 ++++
 arch/st200/include/asm/dma.h                  |   27 +
 arch/st200/include/asm/elf.h                  |  115 +++
 arch/st200/include/asm/emergency-restart.h    |    6 +
 arch/st200/include/asm/errno.h                |   10 +
 arch/st200/include/asm/fb.h                   |    1 +
 arch/st200/include/asm/fcntl.h                |    6 +
 arch/st200/include/asm/ftrace.h               |    4 +
 arch/st200/include/asm/futex.h                |  140 +++
 arch/st200/include/asm/hardirq.h              |   16 +
 arch/st200/include/asm/hw_irq.h               |    6 +
 arch/st200/include/asm/io.h                   |  223 +++++
 arch/st200/include/asm/ioctl.h                |   64 ++
 arch/st200/include/asm/ioctls.h               |  125 +++
 arch/st200/include/asm/ipcbuf.h               |   31 +
 arch/st200/include/asm/irq-reflector.h        |   78 ++
 arch/st200/include/asm/irq.h                  |   23 +
 arch/st200/include/asm/irq_regs.h             |    1 +
 arch/st200/include/asm/kdebug.h               |    1 +
 arch/st200/include/asm/kmap_types.h           |   24 +
 arch/st200/include/asm/linkage.h              |   11 +
 arch/st200/include/asm/local.h                |    6 +
 arch/st200/include/asm/mman.h                 |   17 +
 arch/st200/include/asm/mmu.h                  |   18 +
 arch/st200/include/asm/mmu_context.h          |  130 +++
 arch/st200/include/asm/module.h               |   14 +
 arch/st200/include/asm/msgbuf.h               |   31 +
 arch/st200/include/asm/mutex.h                |    9 +
 arch/st200/include/asm/namei.h                |   11 +
 arch/st200/include/asm/page.h                 |  121 +++
 arch/st200/include/asm/param.h                |   26 +
 arch/st200/include/asm/pci.h                  |   39 +
 arch/st200/include/asm/percpu.h               |    6 +
 arch/st200/include/asm/pgalloc.h              |   95 ++
 arch/st200/include/asm/pgtable.h              |  532 +++++++++++
 arch/st200/include/asm/poll.h                 |    1 +
 arch/st200/include/asm/posix_types.h          |  140 +++
 arch/st200/include/asm/processor.h            |  116 +++
 arch/st200/include/asm/ptrace.h               |  143 +++
 arch/st200/include/asm/resource.h             |    6 +
 arch/st200/include/asm/scatterlist.h          |   28 +
 arch/st200/include/asm/scu.h                  |   27 +
 arch/st200/include/asm/sections.h             |    7 +
 arch/st200/include/asm/segment.h              |    6 +
 arch/st200/include/asm/sembuf.h               |   25 +
 arch/st200/include/asm/serial.h               |   24 +
 arch/st200/include/asm/setup.h                |  111 +++
 arch/st200/include/asm/shmbuf.h               |   42 +
 arch/st200/include/asm/shmparam.h             |    8 +
 arch/st200/include/asm/sigcontext.h           |   19 +
 arch/st200/include/asm/siginfo.h              |    8 +
 arch/st200/include/asm/signal.h               |    2 +
 arch/st200/include/asm/simtrace.h             |   26 +
 arch/st200/include/asm/socket.h               |    1 +
 arch/st200/include/asm/sockios.h              |   17 +
 arch/st200/include/asm/stat.h                 |   63 ++
 arch/st200/include/asm/statfs.h               |    6 +
 arch/st200/include/asm/string.h               |   18 +
 arch/st200/include/asm/swab.h                 |    6 +
 arch/st200/include/asm/syscallparams.h        |   47 +
 arch/st200/include/asm/system.h               |  176 ++++
 arch/st200/include/asm/termbits.h             |  188 ++++
 arch/st200/include/asm/termios.h              |    1 +
 arch/st200/include/asm/thread_info.h          |  107 +++
 arch/st200/include/asm/timex.h                |   25 +
 arch/st200/include/asm/tlb.h                  |   11 +
 arch/st200/include/asm/tlbflush.h             |   54 ++
 arch/st200/include/asm/topology.h             |    6 +
 arch/st200/include/asm/types.h                |   58 ++
 arch/st200/include/asm/uaccess.h              |  293 ++++++
 arch/st200/include/asm/unaligned.h            |   11 +
 arch/st200/include/asm/unistd.h               |  476 ++++++++++
 arch/st200/include/asm/user.h                 |   60 ++
 arch/st200/include/asm/vdso.h                 |   30 +
 arch/st200/kernel/Makefile                    |   14 +
 arch/st200/kernel/asm-offsets.c               |  134 +++
 arch/st200/kernel/asm_macros.h                |   97 ++
 arch/st200/kernel/debugregs.c                 |   40 +
 arch/st200/kernel/dsu_st200.h                 |   61 ++
 arch/st200/kernel/entry-common.S              |  743 +++++++++++++++
 arch/st200/kernel/entry-st231.S               |  691 ++++++++++++++
 arch/st200/kernel/head.S                      |  201 +++++
 arch/st200/kernel/init_task.c                 |   29 +
 arch/st200/kernel/io.c                        |  167 ++++
 arch/st200/kernel/irq.c                       |  103 +++
 arch/st200/kernel/irq_st200.c                 |   74 ++
 arch/st200/kernel/irq_st200.h                 |   26 +
 arch/st200/kernel/module.c                    |  324 +++++++
 arch/st200/kernel/process.c                   |  230 +++++
 arch/st200/kernel/ptrace.c                    |  392 ++++++++
 arch/st200/kernel/ptrace.h                    |   10 +
 arch/st200/kernel/setup.c                     |  339 +++++++
 arch/st200/kernel/signal.c                    |  348 +++++++
 arch/st200/kernel/st200_ksyms.c               |   43 +
 arch/st200/kernel/stubs.S                     |  540 +++++++++++
 arch/st200/kernel/sys_st200.c                 |   71 ++
 arch/st200/kernel/syscall.S                   |  463 ++++++++++
 arch/st200/kernel/time.c                      |  218 +++++
 arch/st200/kernel/traps.c                     |  734 +++++++++++++++
 arch/st200/kernel/vdso.c                      |  304 +++++++
 arch/st200/kernel/vdso/Makefile               |   53 ++
 arch/st200/kernel/vdso/note.S                 |   25 +
 arch/st200/kernel/vdso/sigtramp.S             |  161 ++++
 arch/st200/kernel/vdso/vdso.lds.S             |  132 +++
 arch/st200/kernel/vdso/vdso_wrapper.S         |   14 +
 arch/st200/kernel/vmlinux.lds.S               |  187 ++++
 arch/st200/lib/Makefile                       |    5 +
 arch/st200/lib/delay.S                        |   27 +
 arch/st200/lib/memcpy.S                       |  491 ++++++++++
 arch/st200/lib/string.S                       |  120 +++
 arch/st200/lib/udelay.c                       |   19 +
 arch/st200/mm/Makefile                        |    6 +
 arch/st200/mm/cache.c                         |   88 ++
 arch/st200/mm/dma-mapping.c                   |  278 ++++++
 arch/st200/mm/fault.c                         |  542 +++++++++++
 arch/st200/mm/init.c                          |  268 ++++++
 arch/st200/mm/ioremap.c                       |  205 +++++
 arch/st200/mm/pgtable.c                       |   88 ++
 arch/st200/mm/scu.c                           |  144 +++
 arch/st200/oprofile/Makefile                  |    9 +
 arch/st200/oprofile/init.c                    |   14 +
 arch/st200/soc/fpga/Makefile                  |    2 +
 arch/st200/soc/fpga/platform.c                |   60 ++
 arch/st200/soc/sim/Makefile                   |    2 +
 arch/st200/soc/sim/platform.c                 |  138 +++
 arch/st200/soc/stv576/Makefile                |    2 +
 arch/st200/soc/stv576/platform.c              |  506 +++++++++++
 drivers/input/keyboard/Kconfig                |    7 +
 drivers/input/keyboard/Makefile               |    1 +
 drivers/input/keyboard/st200simkbd.c          |  219 +++++
 drivers/input/mouse/Kconfig                   |    6 +
 drivers/input/mouse/Makefile                  |    1 +
 drivers/input/mouse/st200simmouse.c           |  179 ++++
 drivers/mtd/nand/Kconfig                      |    7 +
 drivers/mtd/nand/Makefile                     |    1 +
 drivers/mtd/nand/stv576_nand.c                | 1154 ++++++++++++++++++++++++
 drivers/mtd/nand/stv576_nand.h                |  121 +++
 drivers/net/tulip/tulip_core.c                |    4 +-
 drivers/pci/Makefile                          |    1 +
 drivers/serial/Kconfig                        |   15 +
 drivers/serial/Makefile                       |    1 +
 drivers/serial/serial_stv576.c                |  779 ++++++++++++++++
 drivers/serial/serial_stv576.h                |   65 ++
 drivers/usb/Kconfig                           |    4 +
 drivers/usb/host/Kconfig                      |   13 +-
 drivers/usb/host/Makefile                     |    2 +
 drivers/usb/host/ehci-hcd.c                   |    5 +
 drivers/usb/host/ehci-stv576.c                |  159 ++++
 drivers/usb/host/ohci-hcd.c                   |    6 +
 drivers/usb/host/ohci-stv576.c                |  160 ++++
 drivers/usb/host/ohci.h                       |    2 +-
 drivers/usb/host/stv576-common.c              |   98 ++
 drivers/video/Kconfig                         |   33 +
 drivers/video/Makefile                        |    2 +
 drivers/video/st200simfb.c                    |  294 ++++++
 drivers/video/stv576-fb.c                     |  447 +++++++++
 include/linux/elf-em.h                        |    1 +
 include/linux/log2.h                          |    2 +-
 include/linux/math64.h                        |    2 +-
 include/linux/mtd/nand.h                      |    9 +-
 include/linux/serial_core.h                   |    4 +
 include/linux/st_soc.h                        |   81 ++
 kernel/time.c                                 |    4 +-
 lib/Kconfig.debug                             |    3 +-
 net/ipv4/ipconfig.c                           |   15 +
 sound/Kconfig                                 |    5 +
 sound/Makefile                                |    2 +-
 sound/stv576/Kconfig                          |   12 +
 sound/stv576/Makefile                         |    2 +
 sound/stv576/stv576.c                         |  742 +++++++++++++++
 sound/stv576/stv576_audio.h                   |  128 +++
 220 files changed, 26799 insertions(+), 17 deletions(-)

diff --git a/Makefile b/Makefile
index ec932b2..576aa65 100644
--- a/Makefile
+++ b/Makefile
@@ -344,8 +344,8 @@ KBUILD_CPPFLAGS := -D__KERNEL__
 KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
 		   -fno-strict-aliasing -fno-common \
 		   -Werror-implicit-function-declaration \
-		   -Wno-format-security \
-		   -fno-delete-null-pointer-checks
+		   -Wno-format-security
+
 KBUILD_AFLAGS   := -D__ASSEMBLY__
 
 # Read KERNELRELEASE from include/config/kernel.release (if it exists)
diff --git a/arch/st200/Kconfig b/arch/st200/Kconfig
new file mode 100644
index 0000000..b1e448b
--- /dev/null
+++ b/arch/st200/Kconfig
@@ -0,0 +1,180 @@
+#
+# For a description of the syntax of this configuration file,
+# see Documentation/kbuild/kconfig-language.txt.
+#
+
+mainmenu "Linux/ST200 Kernel Configuration"
+
+config ARCH_ST200
+	def_bool y
+	select HAVE_OPROFILE
+	help
+	  The ST200 family of CPUs are VLIW devices, designed for
+	  embedded applications. See the project home page at
+	  <http://www.stlinux.com>.
+
+config MMU
+	def_bool y
+
+config RWSEM_GENERIC_SPINLOCK
+	def_bool y
+
+config RWSEM_XCHGADD_ALGORITHM
+	def_bool n
+
+config GENERIC_HARDIRQS
+	def_bool y
+
+config GENERIC_IRQ_PROBE
+	def_bool n
+
+config GENERIC_CALIBRATE_DELAY
+	def_bool y
+
+config GENERIC_IOMAP
+	def_bool y
+
+config GENERIC_HWEIGHT
+	def_bool y
+
+config GENERIC_FIND_NEXT_BIT
+	def_bool y
+
+config GENERIC_CSUM
+	def_bool y
+
+menu "Processor type and features"
+
+config SOC_SIMULATOR
+	def_bool n
+
+config SOC_STV576
+	def_bool n
+
+config SOC_FPGA
+	def_bool n
+
+choice
+	prompt "ST200 system type"
+	default ST200_SIMULATOR
+
+config ST200_SIMULATOR
+	bool "ST200 Simulator"
+	select SOC_SIMULATOR
+	help
+	  Select this to build a kernel for the ST200 simulator.
+
+config BOARD_MB427
+	bool "MB427 FPGA IP Emulation  board"
+	select SOC_FPGA
+	help
+	  Select this to use the  MB427 IP Emulation board. This board is
+	  mainly used for silicon verification and debugging.
+
+
+config BOARD_STV576_REF
+	bool "ST STV576 Ref board"
+	select SOC_STV576
+	help
+	  Select this to use the STMicro STV576 ref board
+
+config BOARD_STV576_DUAL_REF
+	bool "ST STV576 Dual Ref board"
+	select SOC_STV576
+	help
+	  Select this to use the STMicro Dual STV576 ref board.
+	  This board is very similar to the ref board, except it has
+	  two STV576 on it, but Linux is only supported on one of
+	  them at this time.
+
+endchoice
+
+choice
+	prompt "Processor type"
+	default CPU_SUBTYPE_ST231
+
+config CPU_SUBTYPE_ST231
+	bool "ST231"
+
+endchoice
+
+menu "Timer and clock configuration"
+
+config GENERIC_TIME
+	def_bool y
+
+config GENERIC_CLOCKEVENTS
+	def_bool y
+
+source "kernel/Kconfig.hz"
+source "kernel/time/Kconfig"
+
+endmenu
+
+menu "Memory configuration"
+
+
+# Platform-specific memory start and size definitions
+config MEMORY_START
+	hex "Physical memory start address"
+	default "08000000"
+	---help---
+	  Where RAM starts.
+
+config MEMORY_SIZE
+	hex "Physical memory size"
+	default "01000000"
+	help
+	  This sets the default memory size assumed by the kernel. It can
+	  be overridden as normal by the 'mem=' argument on the kernel command
+	  line.
+
+source "mm/Kconfig"
+
+endmenu
+
+menu "ST200 devices"
+source "arch/st200/drivers/Kconfig"
+endmenu
+
+
+endmenu
+
+menu "Bus Options (PCI)"
+config PCI
+	bool "PCI support"
+	depends on SOC_FPGA
+	help
+	  Enable support for PCI host controller
+
+source "drivers/pci/Kconfig"
+endmenu
+
+
+source "init/Kconfig"
+
+
+menu "Executable file formats"
+
+source "fs/Kconfig.binfmt"
+
+endmenu
+
+source "net/Kconfig"
+
+source "drivers/Kconfig"
+
+source "fs/Kconfig"
+
+menu "Kernel hacking"
+
+source "lib/Kconfig.debug"
+
+endmenu
+
+source "security/Kconfig"
+
+source "crypto/Kconfig"
+
+source "lib/Kconfig"
+
diff --git a/arch/st200/Makefile b/arch/st200/Makefile
new file mode 100644
index 0000000..f61028f
--- /dev/null
+++ b/arch/st200/Makefile
@@ -0,0 +1,70 @@
+#
+# arch/st200/Makefile
+#
+# This file is included by the global makefile so that you can add your own
+# architecture-specific flags and dependencies. Remember to do have actions
+# for "archclean" and "archdep" for cleaning up and making dependencies for
+# this architecture
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (C) 2002 STMicroelectronics Ltd.
+#	Author: Stuart Menefy <stuart.menefy@st.com>
+
+OBJCOPYFLAGS	:= -O binary -R .note -R .note.gnu.build-id  -R .comment -R .stab -R .stabstr -S
+
+KBUILD_CFLAGS += $(cflags-y)
+#ifdef CONFIG_DEBUG_KERNEL
+#CFLAGS += -g -DDEBUG
+#endif
+
+LDFLAGS:= -EL
+#AFLAGS:= -EL
+
+ifdef LOADADDR
+LDFLAGS_vmlinux     += -Ttext $(word 1,$(LOADADDR))
+endif
+
+head-y := arch/st200/kernel/head.o arch/st200/kernel/init_task.o
+
+libs-y				+= arch/st200/lib/ $(shell $(CC) $(CFLAGS) -print-libgcc-file-name)
+core-y				+= arch/st200/kernel/ arch/st200/mm/
+drivers-y			+= arch/st200/drivers/
+
+socdir-$(CONFIG_SOC_SIMULATOR) := sim
+boarddir-$(CONFIG_ST200_SIMULATOR) := st/sim
+
+socdir-$(CONFIG_SOC_STV576) := stv576
+boarddir-$(CONFIG_BOARD_STV576_REF) := st/stv576_ref
+boarddir-$(CONFIG_BOARD_STV576_DUAL_REF) := st/stv576_dual_ref
+
+socdir-$(CONFIG_SOC_FPGA) := fpga
+boarddir-$(CONFIG_BOARD_MB427) := st/mb427
+
+ifneq ($(boarddir-y),)
+core-y += arch/st200/boards/$(boarddir-y)/
+endif
+ifneq ($(socdir-y),)
+core-y += arch/st200/soc/$(socdir-y)/
+endif
+
+core-$(CONFIG_PCI) += arch/st200/drivers/pci/
+
+drivers-$(CONFIG_OPROFILE) 	+= arch/st200/oprofile/
+
+boot := arch/st200/boot
+
+zImage uImage : vmlinux
+	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@
+
+compressed: zImage
+
+archclean:
+	@$(MAKE) -f scripts/Makefile.clean obj=arch/st200/boot
+
+archmrproper:
+
+CLEAN_FILES +=	include/asm-$(ARCH)/asm_offsets.h	\
+		arch/$(ARCH)/kernel/asm-offsets.s
diff --git a/arch/st200/boards/st/mb427/Makefile b/arch/st200/boards/st/mb427/Makefile
new file mode 100644
index 0000000..0999865
--- /dev/null
+++ b/arch/st200/boards/st/mb427/Makefile
@@ -0,0 +1,2 @@
+obj-y 	+= setup.o
+
diff --git a/arch/st200/boards/st/mb427/setup.c b/arch/st200/boards/st/mb427/setup.c
new file mode 100644
index 0000000..16d02c4
--- /dev/null
+++ b/arch/st200/boards/st/mb427/setup.c
@@ -0,0 +1,243 @@
+/*
+ * Copyright (C) 2010 STMicroelectronics Limited
+ * Author: David McKay <david.mckay@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License V2.  See linux/COPYING for more information.
+ *
+ * Support for the MB427 FPGA board
+ */
+
+#include <linux/kernel.h>
+#include <linux/ctype.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+#include <linux/device.h>
+#include <linux/st_soc.h>
+#include <linux/io.h>
+
+int __init board_setup(void)
+{
+	return 0;
+}
+
+#define MB427_SERIAL_PORT(_base, _irq) 					\
+{									\
+	.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_IOREMAP,	\
+	.iotype = UPIO_MEM,						\
+	.irq = (_irq),							\
+	.regshift = 2, /* 32 bit aligned registers */			\
+	.mapbase =  (_base),						\
+	.uartclk = 18432000						\
+}
+
+static struct plat_serial8250_port mb427_serial_data[] = {
+	MB427_SERIAL_PORT(0xfd300000, 6),
+	MB427_SERIAL_PORT(0xfd300040, 5),
+	{}			/* Null flags end list in effect */
+};
+
+static struct platform_device mb427_serial8250_device = {
+	.name = "serial8250",
+	.id = PLAT8250_DEV_PLATFORM,
+	.dev = {
+		.platform_data = mb427_serial_data,
+	},
+};
+
+#ifdef CONFIG_PCI
+
+#include <linux/pci.h>
+
+#define V320_MEMORY_WINDOW_PHYS 0x20000000
+#define V320_MEMORY_WINDOW_SIZE (512 * 1024 * 1024)
+#define V320_IO_WINDOW_PHYS 0x10000000
+
+#define V320_IO_WINDOW_SIZE (16 * 1024 * 1024)
+
+const unsigned long PCIBIOS_MIN_IO = 0x1000;
+const unsigned long PCIBIOS_MIN_MEM = V320_MEMORY_WINDOW_PHYS;
+
+/* Map device to correct idsel line */
+static int mb427_idsel(unsigned char device)
+{
+	static const unsigned char idsel_table[4] = { 14, 15, 16, 21 };
+
+	return (device <= 3) ? 1 << idsel_table[device] : 1 << 19;
+}
+
+static struct plat_v320usc_pci_data mb427_pci_data = {
+	.mem_window_phys = V320_MEMORY_WINDOW_PHYS,
+	.mem_window_size = V320_MEMORY_WINDOW_SIZE,
+	.io_window_phys = V320_IO_WINDOW_PHYS,
+	.idsel = mb427_idsel,
+};
+
+static struct platform_device v320_pci_device = {
+	.name = "v320usc",
+	.id = -1,
+	.num_resources = 1,
+	.resource = (struct resource[]) {
+			[0] = 	{
+				/* Address of V320 regs */
+				.start = 0xfd000000,
+				.end = 0xfd0001ff,
+				.flags = IORESOURCE_MEM,
+			},
+	},
+	.dev = {
+		.platform_data = &mb427_pci_data,
+	}
+};
+
+/* PCI bus0 hardwired peripherals */
+#define MB427_IRQ_ETHER  0
+#define MB427_IRQ_VGA    1
+#define MB427_IRQ_USB_A  4
+#define MB427_IRQ_USB_B  5
+#define MB427_IRQ_USB_C  6
+
+/* PCI bus1 */
+#define MB427_IRQ_PCI_A_0  7
+#define MB427_IRQ_PCI_A_1  8
+#define MB427_IRQ_PCI_A_2 9
+#define MB427_IRQ_PCI_A_3 10
+#define MB427_IRQ_PCI_B   12
+#define MB427_IRQ_PCI_C   13
+#define MB427_IRQ_PCI_D   14
+
+int __init pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int bus_number;
+	int irq;
+	static const int __initdata table[2][6][4] = {
+		{
+			{MB427_IRQ_VGA, 0, 0, 0},
+			{MB427_IRQ_ETHER, 0, 0, 0},
+			{MB427_IRQ_USB_A, MB427_IRQ_USB_B, MB427_IRQ_USB_C, 0},
+			{0, 0, 0, 0},
+			{0, 0, 0, 0},
+			{0, 0, 0, 0}
+		},
+		{
+			{0, 0, 0, 0},
+			{0, 0, 0, 0},
+			{0, 0, 0, 0},
+			{
+			  MB427_IRQ_PCI_A_0,
+			  MB427_IRQ_PCI_B,
+			  MB427_IRQ_PCI_C,
+			  MB427_IRQ_PCI_D
+			},
+			{
+			  MB427_IRQ_PCI_A_1,
+			  MB427_IRQ_PCI_B,
+			  MB427_IRQ_PCI_C,
+			  MB427_IRQ_PCI_D
+			},
+			{ MB427_IRQ_PCI_A_2,
+			  MB427_IRQ_PCI_B,
+			  MB427_IRQ_PCI_C,
+			  MB427_IRQ_PCI_D
+			},
+		}
+	};
+
+	bus_number = dev->bus->number;
+	if (bus_number > 1)
+		return -1;
+
+	/* TODO : make this more robust. */
+	irq = table[bus_number][slot][pin - 1];
+
+	/* Timer interrupts are from 0-2 */
+	irq += 3;
+
+	return irq;
+}
+
+#endif
+
+#define FPGA_REG_BASE 0xfd100000
+#define FPGA_REG_SIZE 10000
+
+static void *fpga_regs;
+static void *alpha_display[2];
+
+void mb427_printk(const char *fmt, ...)
+{
+	char buf[32];
+	int i;
+	va_list args;
+	int end = 0;
+
+	va_start(args, fmt);
+
+	vsnprintf(buf, sizeof(buf), fmt, args);
+
+	for (i = 0; i < 16; i++) {
+		if (buf[i] == '\0')
+			end = 1;
+		if (end || iscntrl(buf[i]))
+			buf[i] = ' ';
+		writel(buf[i], alpha_display[i / 8] + 0xe0 + ((i % 8) * 4));
+	}
+
+	va_end(args);
+}
+
+/* Should this be a platform driver?? */
+static void __init setup_fpga_regs(void)
+{
+	/* We have to switch on the interrupts in the FPGA */
+	fpga_regs = ioremap(FPGA_REG_BASE, FPGA_REG_SIZE);
+
+	if (fpga_regs == NULL)
+		return;
+
+	/* Enable all interrupts from external devices */
+	writel(~0, fpga_regs + 0x80);
+
+	alpha_display[0] = ioremap(0xfd280000, 0xff);
+	alpha_display[1] = ioremap(0xfd200000, 0xff);
+}
+
+static int __init register_soc_devices(void)
+{
+	int ret = 0;
+
+	setup_fpga_regs();
+
+	/* Set up the serial ports */
+	platform_device_register(&mb427_serial8250_device);
+
+	/* And the rest */
+
+	if (soc_data.devices)
+		ret = platform_add_devices(soc_data.devices,
+					 soc_data.num_devices);
+
+#ifdef CONFIG_PCI
+	platform_device_register(&v320_pci_device);
+#endif
+
+	return ret;
+}
+
+arch_initcall(register_soc_devices);
+
+void machine_restart(char *cmd)
+{
+	soc_machine_restart(cmd);
+}
+
+void machine_halt(void)
+{
+	soc_machine_halt();
+}
+
+void machine_power_off(void)
+{
+	soc_machine_power_off();
+}
diff --git a/arch/st200/boards/st/sim/Makefile b/arch/st200/boards/st/sim/Makefile
new file mode 100644
index 0000000..0999865
--- /dev/null
+++ b/arch/st200/boards/st/sim/Makefile
@@ -0,0 +1,2 @@
+obj-y 	+= setup.o
+
diff --git a/arch/st200/boards/st/sim/setup.c b/arch/st200/boards/st/sim/setup.c
new file mode 100644
index 0000000..deb66cf
--- /dev/null
+++ b/arch/st200/boards/st/sim/setup.c
@@ -0,0 +1,34 @@
+#include <linux/platform_device.h>
+#include <linux/st_soc.h>
+
+/* This is the global setup point called from setup_arch. Every board must
+ * have this. Here we initialise all the soc platform devices we need to,
+ * setup the PIO's and SYSCONFIG registers for this particular board.
+ * Note that we have given up trying to get the drivers to know about PIOs,
+ * it is all just too horrible to try to manage in any sensible way.
+ * Therefore, we just initialise everything statically here. Fiddle as needed
+ */
+
+int __init board_setup(void)
+{
+	/* Nothing much to do here */
+
+	return 0;
+}
+
+static int __init register_soc_devices(void)
+{
+	int ret;
+
+	ret = platform_add_devices(soc_data.devices, soc_data.num_devices);
+
+	return ret;
+
+}
+
+arch_initcall(register_soc_devices);
+
+void machine_restart(char *cmd) { soc_machine_restart(cmd); }
+void machine_halt(void) { soc_machine_halt(); }
+void machine_power_off(void) { soc_machine_power_off(); }
+
diff --git a/arch/st200/boards/st/stv576_dual_ref/Makefile b/arch/st200/boards/st/stv576_dual_ref/Makefile
new file mode 100644
index 0000000..0999865
--- /dev/null
+++ b/arch/st200/boards/st/stv576_dual_ref/Makefile
@@ -0,0 +1,2 @@
+obj-y 	+= setup.o
+
diff --git a/arch/st200/boards/st/stv576_dual_ref/setup.c b/arch/st200/boards/st/stv576_dual_ref/setup.c
new file mode 100644
index 0000000..3c80101
--- /dev/null
+++ b/arch/st200/boards/st/stv576_dual_ref/setup.c
@@ -0,0 +1,81 @@
+#include <linux/platform_device.h>
+#include <linux/st_soc.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+
+int __init board_setup(void)
+{
+	/* Nothing much to do here */
+
+	return 0;
+}
+
+static struct mtd_partition nand_partitions[] = {
+	{
+		.name   = "Boot",
+		.offset = 0,
+		.size   = 0x00020000 /* 128 KB */
+	}, {
+		.name   = "Updatable Kernel and support app",
+		.offset = MTDPART_OFS_APPEND,
+		.size   = 0x00a00000 /* 10 MB */
+	}, {
+		.name   = "Root FS",
+		.offset = MTDPART_OFS_APPEND,
+		.size   = 0x03560000 /* ~54 MB */
+	}, {
+		.name   = "Configure",
+		.offset = MTDPART_OFS_APPEND,
+		.size   = 0x02280000 /* 34.50 MB */
+	}, {
+		.name   = "Qtopia FS",
+		.offset = MTDPART_OFS_APPEND,
+		.size   = 0x06e80000 /* 110.50 MB */
+	}, {
+		.name   = "Recovery Root FS",
+		.offset = MTDPART_OFS_APPEND,
+		.size   = 0x02840000 /* 40.25 MB */
+	}, {
+		.name   = "Recovery Kernel and support app",
+		.offset = MTDPART_OFS_APPEND,
+		.size   = MTDPART_SIZ_FULL
+	}
+};
+
+
+static int __init register_soc_devices(void)
+{
+	int i;
+	struct plat_stv576_nand_data *nand_data;
+
+	/* Glue in NAND data */
+	for (i = 0 ; i < soc_data.num_devices; i++) {
+		if (!strcmp("stv576_nand", soc_data.devices[i]->name)) {
+			nand_data = (struct plat_stv576_nand_data *)
+				soc_data.devices[i]->dev.platform_data;
+
+			nand_data->mtd_parts = nand_partitions;
+			nand_data->nr_parts = ARRAY_SIZE(nand_partitions);
+			nand_data->options |= NAND_USE_FLASH_BBT;
+		}
+	}
+
+	return platform_add_devices(soc_data.devices, soc_data.num_devices);
+}
+
+arch_initcall(register_soc_devices);
+
+void machine_restart(char *cmd)
+{
+	soc_machine_restart(cmd);
+}
+
+void machine_halt(void)
+{
+	soc_machine_halt();
+}
+
+void machine_power_off(void)
+{
+	soc_machine_power_off();
+}
diff --git a/arch/st200/boards/st/stv576_ref/Makefile b/arch/st200/boards/st/stv576_ref/Makefile
new file mode 100644
index 0000000..0999865
--- /dev/null
+++ b/arch/st200/boards/st/stv576_ref/Makefile
@@ -0,0 +1,2 @@
+obj-y 	+= setup.o
+
diff --git a/arch/st200/boards/st/stv576_ref/setup.c b/arch/st200/boards/st/stv576_ref/setup.c
new file mode 100644
index 0000000..b5797fc
--- /dev/null
+++ b/arch/st200/boards/st/stv576_ref/setup.c
@@ -0,0 +1,69 @@
+#include <linux/platform_device.h>
+#include <linux/st_soc.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+
+int __init board_setup(void)
+{
+	/* Nothing much to do here */
+
+	return 0;
+}
+
+static struct mtd_partition nand_partitions[] = {
+	{
+		.name	= "Boot",
+		.offset	= 0,
+		.size 	= 0x00040000 /* 256 KB */
+	}, {
+		.name	= "Sirius",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x01000000 /* 16 Megs */
+	}, {
+		.name   = "Kernel",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x00400000 /* 4 Megs */
+	}, {
+		.name 	= "Root FS",
+		.offset = MTDPART_OFS_APPEND,
+		.size 	= MTDPART_SIZ_FULL
+	}
+};
+
+
+static int __init register_soc_devices(void)
+{
+	int i;
+	struct plat_stv576_nand_data *nand_data;
+
+	/* Glue in NAND data */
+	for(i= 0 ;i < soc_data.num_devices; i++ ) {
+		if(!strcmp("stv576_nand", soc_data.devices[i]->name)) {
+			nand_data = (struct plat_stv576_nand_data *)
+				soc_data.devices[i]->dev.platform_data;
+
+			nand_data->mtd_parts = nand_partitions;
+			nand_data->nr_parts = ARRAY_SIZE(nand_partitions);
+			nand_data->options |= NAND_USE_FLASH_BBT;
+		}
+	}
+
+	return platform_add_devices(soc_data.devices, soc_data.num_devices);
+}
+
+arch_initcall(register_soc_devices);
+
+void machine_restart(char *cmd)
+{
+	soc_machine_restart(cmd);
+}
+
+void machine_halt(void)
+{
+	soc_machine_halt();
+}
+
+void machine_power_off(void)
+{
+	soc_machine_power_off();
+}
diff --git a/arch/st200/boot/Makefile b/arch/st200/boot/Makefile
new file mode 100644
index 0000000..c65fb09
--- /dev/null
+++ b/arch/st200/boot/Makefile
@@ -0,0 +1,40 @@
+#
+# arch/st200/boot/Makefile
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (C) 2004 Dave Mckay <david.mckay@st.com>
+#
+
+targets := zImage uImage
+subdir- := compressed
+
+MKIMAGE := $(srctree)/scripts/mkuboot.sh
+ULOADADDR := $(shell printf "0x%8x" $$[$(CONFIG_MEMORY_START)])
+UENTRYADDR := $(shell printf "0x%8x" $$[$(CONFIG_MEMORY_START) + 0x2000])
+
+quiet_cmd_uimage = UIMAGE  $@
+      cmd_uimage = $(CONFIG_SHELL) $(MKIMAGE) -A st200 -O linux -T kernel \
+                   -C gzip -a $(ULOADADDR) -e $(UENTRYADDR) \
+                   -n 'Linux-$(KERNELRELEASE)' -d $< $@
+
+$(obj)/compressed/vmlinux: FORCE
+	$(Q)$(MAKE) $(build)=$(obj)/compressed $@
+
+$(obj)/vmlinux.bin: vmlinux FORCE
+	$(call if_changed,objcopy)
+
+$(obj)/vmlinux.bin.gz: $(obj)/vmlinux.bin FORCE
+	$(call if_changed,gzip)
+
+$(obj)/zImage: $(obj)/compressed/vmlinux FORCE
+	$(call if_changed,objcopy)
+	@echo 'Kernel: $@ is ready'
+
+$(obj)/uImage: $(obj)/vmlinux.bin.gz FORCE
+	@echo obj is $(obj)
+	$(call if_changed,uimage)
+	@echo '  Image $@ is ready'
+
diff --git a/arch/st200/boot/compressed/Makefile b/arch/st200/boot/compressed/Makefile
new file mode 100644
index 0000000..b816430
--- /dev/null
+++ b/arch/st200/boot/compressed/Makefile
@@ -0,0 +1,39 @@
+#
+# linux/arch/sh/boot/compressed/Makefile
+#
+# create a compressed vmlinux image from the original vmlinux
+#
+
+targets		:= vmlinux vmlinux.bin vmlinux.bin.gz head.o misc.o piggy.o
+
+OBJECTS = $(obj)/head.o $(obj)/misc.o
+
+#
+# IMAGE_OFFSET is the load offset of the compression loader
+#
+IMAGE_OFFSET := 0x0
+#IMAGE_OFFSET := $(shell printf "0x%8x" $$[0x80000000+$(CONFIG_MEMORY_START)+0x400000])
+
+ZDATA_ADDR := $(shell printf "0x%8x" $$[0x80000000+$(CONFIG_MEMORY_START)+0x400000])
+
+LDFLAGS_vmlinux := -e startup -Ttext=0x06040000 -Tdata=$(ZDATA_ADDR) -T
+
+CFLAGS_misc.o := -fno-dismissible-load
+
+# The linker script file MUST be first to join onto the -T on the line above. Horrible!!!
+
+$(obj)/vmlinux: $(obj)/vmlinux.lds.in $(OBJECTS) $(obj)/piggy.o FORCE
+	$(call if_changed,ld)
+	@:
+
+$(obj)/vmlinux.bin: vmlinux FORCE
+	$(call if_changed,objcopy)
+
+$(obj)/vmlinux.bin.gz: $(obj)/vmlinux.bin FORCE
+	$(call if_changed,gzip)
+
+LDFLAGS_piggy.o := -r --format binary --oformat elf32-littlelx-linux -T
+OBJCOPYFLAGS += -R .empty_zero_page
+
+$(obj)/piggy.o: $(obj)/vmlinux.scr $(obj)/vmlinux.bin.gz FORCE
+	$(call if_changed,ld)
diff --git a/arch/st200/boot/compressed/head.S b/arch/st200/boot/compressed/head.S
new file mode 100644
index 0000000..880a421
--- /dev/null
+++ b/arch/st200/boot/compressed/head.S
@@ -0,0 +1,260 @@
+/*
+ *  linux/arch/st200/boot/compressed/head.S
+ *
+ *  Copyright (C) 2004 Dave Mckay <david.mckay@st.com>
+ */
+
+#include <linux/linkage.h>
+#include <asm/page.h>
+#include <asm/thread_info.h>
+#include <asm/ctrlregdef.h>
+#include <asm/asm-offsets.h>
+
+/* We need to intialise the mmu so that we can get the cache
+ * going. The initial code is lifted straight from head.S.
+ */
+
+#define PHYS_ADDR(x) ((x) - __PAGE_OFFSET)
+
+ENTRY(startup)
+	mov $r9 = fail
+	;;
+	stw HANDLER_PC[$r0] = $r9
+	;;
+
+	/* Initialise the UTLB */
+	ldw $r9 = TLB_REPLACE[$r0]
+	mov $r8 = $r0
+	;;
+	shru	$r9 = $r9,TLB_REPLACE_LIMIT_SHIFT
+	;;
+1:
+	stw TLB_INDEX[$r0]= $r8
+	add $r8 = $r8,1
+	;;
+	stw TLB_ENTRY0[$r0] = $r0
+	cmpeq	$b0 = $r8, $r9
+	;;
+	stw TLB_ENTRY1[$r0] = $r0
+	;;
+	stw TLB_ENTRY2[$r0] = $r0
+	;;
+	stw TLB_ENTRY3[$r0] = $r0
+	;;
+	brf $b0,1b
+	;;
+
+	/* Flush I&D UTLB */
+	mov	$r8  = TLB_CONTROL_ITLB_FLUSH|TLB_CONTROL_DTLB_FLUSH
+	;;
+	stw	TLB_CONTROL[$r0] = $r8
+	;;
+	/* Set up the kernel UTLB entry */
+	stw	TLB_INDEX[$r0] = $r0
+	mov	$r8 =	TLB_ENTRY0_SHARED		| \
+			TLB_ENTRY0_PROT_SUPER_RWX	| \
+			TLB_ENTRY0_DIRTY		| \
+			TLB_ENTRY0_POLICY_CACHED	| \
+			TLB_ENTRY0_SIZE_256M
+	;;
+	stw	TLB_ENTRY0[$r0] = $r8
+	mov	$r8 = __PAGE_OFFSET >> TLB_ENTRY1_VADDR_SHIFT
+	;;
+	stw	TLB_ENTRY1[$r0] = $r8
+	mov	$r8 = ((CONFIG_MEMORY_START & PAGE_MASK_256M) >> TLB_ENTRY2_PADDR_SHIFT)
+	;;
+	stw	TLB_ENTRY2[$r0] = $r8
+	mov 	$r8 = 1
+	;;
+
+	/* Now set up another TLB entry to cover flash. I'm assuming the flash
+	 * image is less than 256Mb!!!
+	 */
+	stw	TLB_INDEX[$r0] = $r8
+	mov	$r8 =	TLB_ENTRY0_SHARED		| \
+			TLB_ENTRY0_PROT_SUPER_RWX	| \
+			TLB_ENTRY0_DIRTY		| \
+			TLB_ENTRY0_POLICY_CACHED	| \
+			TLB_ENTRY0_SIZE_256M
+	;;
+	stw	TLB_ENTRY0[$r0] = $r8
+	mov	$r8 = 0 >> TLB_ENTRY1_VADDR_SHIFT
+	;;
+	stw	TLB_ENTRY1[$r0] = $r8
+	mov	$r8 = ((0 & PAGE_MASK_256M) >> TLB_ENTRY2_PADDR_SHIFT)
+	;;
+	stw	TLB_ENTRY2[$r0] = $r8
+	mov	$r8 = 2
+	;;
+
+	/* Map the FPGA regs */
+	stw	TLB_INDEX[$r0] = $r8
+	mov	$r8 =	TLB_ENTRY0_SHARED		| \
+			TLB_ENTRY0_PROT_SUPER_RWX	| \
+			TLB_ENTRY0_DIRTY		| \
+			TLB_ENTRY0_POLICY_UNCACHED	| \
+			TLB_ENTRY0_SIZE_256M
+	;;
+	stw	TLB_ENTRY0[$r0] = $r8
+	mov	$r8 = 0x20000000 >> TLB_ENTRY1_VADDR_SHIFT
+	;;
+	stw	TLB_ENTRY1[$r0] = $r8
+	mov	$r8 = ((0x20000000 & PAGE_MASK_256M) >> TLB_ENTRY2_PADDR_SHIFT)
+	;;
+	stw	TLB_ENTRY2[$r0] = $r8
+	mov	$r8 = 3
+	;;
+
+	/* Disable all speculative regions */
+	stw	SCU_BASE0[$r0], $r8
+	;;
+	stw	SCU_BASE1[$r0], $r8
+	;;
+	stw	SCU_BASE2[$r0], $r8
+	;;
+	stw	SCU_BASE3[$r0], $r8
+	;;
+	stw	SCU_LIMIT0[$r0], $r0
+	;;
+	stw	SCU_LIMIT1[$r0], $r0
+	;;
+	stw	SCU_LIMIT2[$r0], $r0
+	;;
+	stw	SCU_LIMIT3[$r0], $r0
+	;;
+	sync
+	;;
+
+	/* Switch on MMU */
+	mov	$r8 = mmu_on		/* This should load the absolute virtual address */
+	;;
+	stw	SAVED_PC[$r0] = $r8
+	mov	$r8 = PSW_TLB_ENABLE
+	;;
+	stw	SAVED_PSW[$r0] = $r8
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	rfi
+	;;
+
+mmu_on:
+	/* MMU is now on */
+
+	/* Zero the bss */
+	mov	$r8 = __bss_start
+	mov	$r9 = __bss_stop
+	;;
+	goto	2f
+	;;
+1:
+	stw	0[$r8] = $r0
+	add	$r8 = $r8, 4
+	;;
+2:	cmpltu	$b0 = $r8, $r9	/* ptr < stop */
+	;;
+	br	$b0, 1b
+	;;
+
+	/* Now shift the data from ROM to RAM */
+	mov $r8 = _sdata
+	mov $r9 = _edata
+	;;
+	mov $r10 = _etext
+	;;
+	goto 2f
+	;;
+1:	ldw  $r11= 0[$r10]
+	add  $r10 = $r10 , 4
+	;;
+	stw  0[$r8] = $r11
+	;;
+	ldw  $r42 = 0[$r8]
+	;;
+	cmpeq	$b0 = $r11,$r42
+	;;
+	brf	$b0,fail
+	;;
+	add  $r8 = $r8, 4
+	;;
+2:	cmpltu $b0 = $r8,$r9
+	;;
+	br	$b0,1b
+	;;
+	/* Set up the stack */
+	ldw $r12 = stack_start[$r0]
+	;;
+	add	$r12 = $r12,-STACK_SCRATCH_AREA /* Allow for scratch area */
+	call	$r63 = decompress_kernel
+	;;
+	/* Ok now drop the icache, and flush the dcache completely */
+	mov	$r8 = $r0
+	;;
+1:
+	prgset	0[$r8]
+	add	$r8 = $r8,32
+	;;
+	cmplt	$b0 = $r8,8*1024
+	;;
+	br	$b0,1b
+	;;
+	prgins
+	;;
+
+	/* Physical address of start_kernel */
+	mov	$r8 = PHYS_ADDR(0x88002000)
+	stw	SAVED_PSW[$r0] = $r0
+	;;
+	stw	SAVED_PC[$r0] = $r8
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	rfi
+	;;
+
+/*
+ * These are useful for debugging this stuff, so
+ * you can do printf's via the simulator back door
+ */
+
+ENTRY(sim_exit)
+	/* Shuffle the arguements */
+	mov	$r17 = $r16
+	mov	$r16 = 0x1
+	goto	__dotsyscall
+	;;
+
+ENTRY(sim_write)
+	/* Shuffle the arguements */
+	mov	$r19 = $r18
+	mov	$r18 = $r17
+	mov	$r17 = $r16
+	mov	$r16 = 0x11
+	;;
+
+ENTRY(__dotsyscall) /* Simulator looks for this */
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	return $r63
+        ;;
+
+
+fail:
+	goto fail
+	;;
diff --git a/arch/st200/boot/compressed/misc.c b/arch/st200/boot/compressed/misc.c
new file mode 100644
index 0000000..ec3bae1
--- /dev/null
+++ b/arch/st200/boot/compressed/misc.c
@@ -0,0 +1,233 @@
+/*
+ * arch/st200/boot/compressed/misc.c
+ *
+ * This is a collection of several routines from gzip-1.0.3
+ * adapted for Linux.
+ *
+ * malloc by Hannu Savolainen 1993 and Matthias Urlichs 1994
+ *
+ * Copied and adopted from SH code by David J. McKay <david.mckay@st.com>
+ *
+ */
+
+#include <asm/uaccess.h>
+
+/*
+ * gzip declarations
+ */
+
+#define OF(args)  args
+#define STATIC static
+
+#undef memset
+#undef memcpy
+#define memzero(s, n)     memset ((s), 0, (n))
+
+typedef unsigned char uch;
+typedef unsigned short ush;
+typedef unsigned long ulg;
+
+#define WSIZE 0x8000		/* Window size must be at least 32k, */
+				/* and a power of two */
+
+static uch *inbuf;		/* input buffer */
+static uch window[WSIZE];	/* Sliding window buffer */
+
+static unsigned insize = 0;	/* valid bytes in inbuf */
+static unsigned inptr = 0;	/* index of next byte to be processed in inbuf */
+static unsigned outcnt = 0;	/* bytes in output buffer */
+
+/* gzip flag byte */
+#define ASCII_FLAG   0x01	/* bit 0 set: file probably ASCII text */
+#define CONTINUATION 0x02	/* bit 1 set: continuation of multi-part gzip file */
+#define EXTRA_FIELD  0x04	/* bit 2 set: extra field present */
+#define ORIG_NAME    0x08	/* bit 3 set: original file name present */
+#define COMMENT      0x10	/* bit 4 set: file comment present */
+#define ENCRYPTED    0x20	/* bit 5 set: file is encrypted */
+#define RESERVED     0xC0	/* bit 6,7:   reserved */
+
+#define get_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf())
+
+/* Diagnostic functions */
+#ifdef DEBUG
+#  define Assert(cond,msg) {if(!(cond)) error(msg);}
+#  define Trace(x) fprintf x
+#  define Tracev(x) {if (verbose) fprintf x ;}
+#  define Tracevv(x) {if (verbose>1) fprintf x ;}
+#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
+#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
+#else
+#  define Assert(cond,msg)
+#  define Trace(x)
+#  define Tracev(x)
+#  define Tracevv(x)
+#  define Tracec(c,x)
+#  define Tracecv(c,x)
+#endif
+
+static int fill_inbuf(void);
+static void flush_window(void);
+static void error(char *m);
+static void gzip_mark(void **);
+static void gzip_release(void **);
+
+extern char input_data[];
+extern int input_len;
+
+static long bytes_out = 0;
+static uch *output_data;
+static unsigned long output_ptr = 0;
+
+static void *malloc(int size);
+static void free(void *where);
+static void error(char *m);
+static void gzip_mark(void **);
+static void gzip_release(void **);
+
+static void puts(const char *);
+
+extern int _text;		/* Defined in vmlinux.lds.S */
+extern int _end;
+static unsigned long free_mem_ptr;
+static unsigned long free_mem_end_ptr;
+
+#define HEAP_SIZE             0x10000
+
+#include "../../../../lib/inflate.c"
+
+static void *malloc(int size)
+{
+	void *p;
+
+	if (size < 0)
+		error("Malloc error");
+	if (free_mem_ptr == 0)
+		error("Memory error");
+
+	free_mem_ptr = (free_mem_ptr + 3) & ~3;	/* Align */
+
+	p = (void *)free_mem_ptr;
+	free_mem_ptr += size;
+
+	if (free_mem_ptr >= free_mem_end_ptr)
+		error("Out of memory");
+
+	return p;
+}
+
+static void free(void *where)
+{				/* Don't care */
+}
+
+static void gzip_mark(void **ptr)
+{
+	*ptr = (void *)free_mem_ptr;
+}
+
+static void gzip_release(void **ptr)
+{
+	free_mem_ptr = (long)*ptr;
+}
+
+static int strlen(const char *s)
+{
+	int i = 0;
+
+	while (*s++)
+		i++;
+	return i;
+}
+
+extern void sim_write(int fd, unsigned long data, int len);
+
+void puts(const char *s)
+{
+	sim_write(2, s, strlen(s));
+}
+
+void *memset(void *s, int c, size_t n)
+{
+	int i;
+	char *ss = (char *)s;
+
+	for (i = 0; i < n; i++)
+		ss[i] = c;
+	return s;
+}
+
+void *memcpy(void *__dest, __const void *__src, size_t __n)
+{
+	int i;
+	char *d = (char *)__dest, *s = (char *)__src;
+
+	for (i = 0; i < __n; i++)
+		d[i] = s[i];
+	return __dest;
+}
+
+/* ===========================================================================
+ * Fill the input buffer. This is called only when the buffer is empty
+ * and at least one byte is really needed.
+ */
+static int fill_inbuf(void)
+{
+	if (insize != 0) {
+		error("ran out of input data");
+	}
+
+	inbuf = input_data;
+	insize = input_len;
+	inptr = 1;
+	return inbuf[0];
+}
+
+/* ===========================================================================
+ * Write the output window window[0..outcnt-1] and update crc and bytes_out.
+ * (Used for the decompressed data only.)
+ */
+static void flush_window(void)
+{
+	ulg c = crc;		/* temporary variable */
+	unsigned n;
+	uch *in, *out, ch;
+
+	in = window;
+	out = &output_data[output_ptr];
+	for (n = 0; n < outcnt; n++) {
+		ch = *out++ = *in++;
+		c = crc_32_tab[((int)c ^ ch) & 0xff] ^ (c >> 8);
+	}
+	crc = c;
+	bytes_out += (ulg) outcnt;
+	output_ptr += (ulg) outcnt;
+	outcnt = 0;
+}
+
+static void error(char *x)
+{
+	puts("\n\n");
+	puts(x);
+	puts("\n\n -- System halted\n");
+
+	sim_exit(1);
+	while (1) ;		/* Halt */
+}
+
+#define STACK_SIZE (4096)
+long user_stack[STACK_SIZE];
+long *stack_start = &user_stack[STACK_SIZE];
+
+void decompress_kernel(void)
+{
+	output_data = 0;
+	/* Kernel start address in virtual memory */
+	output_ptr = (unsigned long)CONFIG_MEMORY_START + 0x80000000 + 0x2000;
+	free_mem_ptr = (unsigned long)&_end;
+	free_mem_end_ptr = free_mem_ptr + HEAP_SIZE;
+
+	makecrc();
+	puts("Uncompressing Linux... ");
+	gunzip();
+	puts("Ok, booting the kernel.\n");
+}
+
diff --git a/arch/st200/boot/compressed/vmlinux.lds.in b/arch/st200/boot/compressed/vmlinux.lds.in
new file mode 100644
index 0000000..2a4b2ee
--- /dev/null
+++ b/arch/st200/boot/compressed/vmlinux.lds.in
@@ -0,0 +1,46 @@
+/*
+ *  linux/arch/st200/boot/compressed/vmlinux.lds.S
+ *
+ *  Copyright (C) 2004 David Mckay <david.mckay@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+OUTPUT_FORMAT("elf32-littlelx-linux", "elf32-littlelx-linux", "elf32-littlelx-linux")
+OUTPUT_ARCH(lx)
+ENTRY(startup)
+
+SECTIONS
+{
+  . = 0				;
+
+  .text : {
+    _stext = .			;
+    *(.text)
+    *(.rodata)
+    *(.rodata.*)
+    *(.piggy_data)
+    . = ALIGN(8)		;
+  }
+  _etext = .			;
+
+  .data	: AT(_etext) {
+    _sdata = .			;
+    *(.data)
+    . = ALIGN(4)		;
+  }
+
+  _edata = .;
+
+  __bss_start	= .		;
+
+  .bss	: {
+	*(.bss)
+   }
+
+   __bss_stop    = .		;
+   _end =  .			;
+}
+
diff --git a/arch/st200/boot/compressed/vmlinux.scr b/arch/st200/boot/compressed/vmlinux.scr
new file mode 100644
index 0000000..943119d
--- /dev/null
+++ b/arch/st200/boot/compressed/vmlinux.scr
@@ -0,0 +1,12 @@
+OUTPUT_FORMAT("elf32-littlelx-linux", "elf32-littlelx-linux", "elf32-littlelx-linux")
+OUTPUT_ARCH(lx)
+
+SECTIONS
+{
+  .piggy_data : {
+	input_len = .;
+	LONG(input_data_end - input_data) input_data = .;
+	*(.data)
+	input_data_end = .;
+	}
+}
diff --git a/arch/st200/configs/simulator_defconfig b/arch/st200/configs/simulator_defconfig
new file mode 100644
index 0000000..ae656b2
--- /dev/null
+++ b/arch/st200/configs/simulator_defconfig
@@ -0,0 +1,842 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32.9
+# Mon Mar  1 18:18:13 2010
+#
+CONFIG_ARCH_ST200=y
+CONFIG_MMU=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_GENERIC_HARDIRQS=y
+# CONFIG_GENERIC_IRQ_PROBE is not set
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_CSUM=y
+
+#
+# Processor type and features
+#
+CONFIG_SOC_SIMULATOR=y
+CONFIG_ST200_SIMULATOR=y
+CONFIG_CPU_SUBTYPE_ST231=y
+
+#
+# Timer and clock configuration
+#
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+# CONFIG_SCHED_HRTICK is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+
+#
+# Memory configuration
+#
+CONFIG_MEMORY_START=0x80000000
+CONFIG_MEMORY_SIZE=0x02000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+
+#
+# ST200 devices
+#
+CONFIG_SIMULATOR_CONSOLE=y
+CONFIG_ST200_SIMULATOR_ETHERNET=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+# CONFIG_MODULES is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPGRE=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+CONFIG_CFG80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=y
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_ETHOC is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_NETDEV_1000=y
+CONFIG_NETDEV_10000=y
+CONFIG_WLAN=y
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+# CONFIG_PPP_ASYNC is not set
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPP_DEFLATE is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_ST200SIM=y
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+CONFIG_MOUSE_ST200_SIM=y
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_ST200_SIMULATOR is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_FB_ST200_SIMFB=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+# CONFIG_HID_PID is not set
+
+#
+# Special HID drivers
+#
+CONFIG_USB_SUPPORT=y
+# CONFIG_USB_ARCH_HAS_HCD is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+
+#
+# Enable Host or Gadget support to see Inventra options
+#
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_NLS is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_SAMPLES is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff --git a/arch/st200/configs/stv576_dual_ref_defconfig b/arch/st200/configs/stv576_dual_ref_defconfig
new file mode 100644
index 0000000..9ad2e75
--- /dev/null
+++ b/arch/st200/configs/stv576_dual_ref_defconfig
@@ -0,0 +1,1192 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32.9
+# Tue Mar  2 14:18:16 2010
+#
+CONFIG_ARCH_ST200=y
+CONFIG_MMU=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_GENERIC_HARDIRQS=y
+# CONFIG_GENERIC_IRQ_PROBE is not set
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_CSUM=y
+
+#
+# Processor type and features
+#
+# CONFIG_SOC_SIMULATOR is not set
+CONFIG_SOC_STV576=y
+# CONFIG_ST200_SIMULATOR is not set
+# CONFIG_BOARD_STV576_REF is not set
+CONFIG_BOARD_STV576_DUAL_REF=y
+CONFIG_CPU_SUBTYPE_ST231=y
+
+#
+# Timer and clock configuration
+#
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+# CONFIG_SCHED_HRTICK is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+
+#
+# Memory configuration
+#
+CONFIG_MEMORY_START=0x20800000
+CONFIG_MEMORY_SIZE=0xf700000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+
+#
+# ST200 devices
+#
+# CONFIG_SIMULATOR_CONSOLE is not set
+# CONFIG_ST200_SIMULATOR_ETHERNET is not set
+CONFIG_STM_IRQ_REFLECTOR=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+# CONFIG_MODULES is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPGRE=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+CONFIG_CFG80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_STV576=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=y
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_ETHOC is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_NETDEV_1000=y
+CONFIG_NETDEV_10000=y
+CONFIG_WLAN=y
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+CONFIG_USB_PEGASUS=y
+CONFIG_USB_RTL8150=y
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_AX8817X=y
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_CDC_EEM is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+# CONFIG_PPP_ASYNC is not set
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPP_DEFLATE is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_ST200SIM=y
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_STV576=y
+CONFIG_SERIAL_STV576_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_STV576=y
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_SEQUENCER=y
+# CONFIG_SND_SEQ_DUMMY is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_SEQUENCER_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_VIRMIDI is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# STV576 ALSA devices
+#
+CONFIG_SND_STV576_AUDIO=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_BIG_ENDIAN_MMIO=y
+CONFIG_USB_EHCI_BIG_ENDIAN_DESC=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_STV576_COMMON=y
+CONFIG_USB_OHCI_BIG_ENDIAN_DESC=y
+CONFIG_USB_OHCI_BIG_ENDIAN_MMIO=y
+# CONFIG_USB_OHCI_LITTLE_ENDIAN is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_CRAMFS is not set
+CONFIG_SQUASHFS=y
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_SAMPLES is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff --git a/arch/st200/configs/stv576_ref_defconfig b/arch/st200/configs/stv576_ref_defconfig
new file mode 100644
index 0000000..f91635d
--- /dev/null
+++ b/arch/st200/configs/stv576_ref_defconfig
@@ -0,0 +1,1191 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32.9
+# Tue Mar  2 13:34:37 2010
+#
+CONFIG_ARCH_ST200=y
+CONFIG_MMU=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_GENERIC_HARDIRQS=y
+# CONFIG_GENERIC_IRQ_PROBE is not set
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_CSUM=y
+
+#
+# Processor type and features
+#
+# CONFIG_SOC_SIMULATOR is not set
+CONFIG_SOC_STV576=y
+# CONFIG_ST200_SIMULATOR is not set
+CONFIG_BOARD_STV576_REF=y
+CONFIG_CPU_SUBTYPE_ST231=y
+
+#
+# Timer and clock configuration
+#
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+# CONFIG_SCHED_HRTICK is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+
+#
+# Memory configuration
+#
+CONFIG_MEMORY_START=0x20800000
+CONFIG_MEMORY_SIZE=0x08000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+
+#
+# ST200 devices
+#
+# CONFIG_SIMULATOR_CONSOLE is not set
+# CONFIG_ST200_SIMULATOR_ETHERNET is not set
+CONFIG_STM_IRQ_REFLECTOR=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+# CONFIG_MODULES is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPGRE=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+CONFIG_CFG80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_STV576=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=y
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_ETHOC is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_NETDEV_1000=y
+CONFIG_NETDEV_10000=y
+CONFIG_WLAN=y
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+CONFIG_USB_PEGASUS=y
+CONFIG_USB_RTL8150=y
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_AX8817X=y
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_CDC_EEM is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+# CONFIG_PPP_ASYNC is not set
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPP_DEFLATE is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_ST200SIM=y
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_STV576=y
+CONFIG_SERIAL_STV576_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_STV576=y
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_SEQUENCER=y
+# CONFIG_SND_SEQ_DUMMY is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_SEQUENCER_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_VIRMIDI is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# STV576 ALSA devices
+#
+CONFIG_SND_STV576_AUDIO=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_BIG_ENDIAN_MMIO=y
+CONFIG_USB_EHCI_BIG_ENDIAN_DESC=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_STV576_COMMON=y
+CONFIG_USB_OHCI_BIG_ENDIAN_DESC=y
+CONFIG_USB_OHCI_BIG_ENDIAN_MMIO=y
+# CONFIG_USB_OHCI_LITTLE_ENDIAN is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_CRAMFS is not set
+CONFIG_SQUASHFS=y
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_SAMPLES is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff --git a/arch/st200/drivers/Kconfig b/arch/st200/drivers/Kconfig
new file mode 100644
index 0000000..540483e
--- /dev/null
+++ b/arch/st200/drivers/Kconfig
@@ -0,0 +1,29 @@
+config SIMULATOR_CONSOLE
+	bool "Console on simulator"
+	help
+	  Simulator console
+
+config ST200_SIMULATOR_ETHERNET
+        bool "Simulator Ethernet device"
+        depends on NET
+        help
+          This option allows the use of a simulated ethernet device.
+          The simulator itself uses the TAP device driver to transfer
+          ethernet frames back and forth. This device driver will only
+          work if the simulator runs under Linux, it is not portable to
+          Solaris or Windows. You will need to configure the TAP device.
+          Read the TAP device documentation, or refer to the networking
+          section of the user mode linux howto at:
+          <http://user-mode-linux.sourceforge.net/UserModeLinux-HOWTO.html>
+
+
+config STM_IRQ_REFLECTOR
+	bool "Interrupt reflector"
+	depends on SOC_STV576
+	help
+	  This is an software interrupt controller that allows
+	  interrupts taken on a companion processor to be reflected
+	  across to the Linux system. This is useful if you want to
+	  drive a peripheral but the interrupts are connected to the
+	  wrong processor.
+
diff --git a/arch/st200/drivers/Makefile b/arch/st200/drivers/Makefile
new file mode 100644
index 0000000..8984afa
--- /dev/null
+++ b/arch/st200/drivers/Makefile
@@ -0,0 +1,6 @@
+obj-$(CONFIG_SIMULATOR_CONSOLE)		+= simcons.o
+
+obj-$(CONFIG_ST200_SIMULATOR_ETHERNET)  += simeth.o
+
+obj-$(CONFIG_STM_IRQ_REFLECTOR)         += irq-reflector.o
+
diff --git a/arch/st200/drivers/irq-reflector.c b/arch/st200/drivers/irq-reflector.c
new file mode 100644
index 0000000..2676a58
--- /dev/null
+++ b/arch/st200/drivers/irq-reflector.c
@@ -0,0 +1,255 @@
+/*
+ * Copyright (C) 2008 STMicroelectronics Limited
+ * Author: David McKay <david.mckay@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License V2.  See linux/COPYING for more information.
+ */
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <asm/irq-reflector.h>
+
+/* Pointer to reflector comms block */
+static struct reflect_block *reflector;
+
+/* Should not be done as a global, but makes things easier for
+ * now
+ */
+static struct plat_irq_reflector_data *irq_reflector_data;
+
+/* We can't be re-entrant on the local cpu either,
+ * as petersons doesn't work with >2
+ */
+static DEFINE_SPINLOCK(reflect_lock);
+
+#define MY_ID (!irq_reflector_data->boot_first)
+
+static inline void claim(void)
+{
+	peterson_spinlock_claim(&reflector->lock, MY_ID);
+}
+
+static inline void release(void)
+{
+	peterson_spinlock_release(&reflector->lock, MY_ID);
+}
+
+static inline u32 reflector_readl(volatile void *addr)
+{
+	return (irq_reflector_data->big_endian) ? readl_be(addr) : readl(addr);
+}
+
+static inline void reflector_writel(u32 val, volatile void *addr)
+{
+	if (irq_reflector_data->big_endian)
+		writel_be(val, addr);
+	else
+		writel(val, addr);
+}
+
+void irq_reflector_dump(void)
+{
+	int read_off, write_off;
+	int len;
+	int i;
+	extern void dump_pie_irqs(void);
+
+	dump_pie_irqs();
+	printk("REFLECTOR BOX STATUS\n");
+	printk("irq_status %08x\n", readl_be(&reflector->irq_status));
+	printk("irq_enable %08x\n", readl_be(&reflector->irq_enable));
+
+	printk("---------------------------------------------\n");
+
+	read_off = reflector_readl(&reflector->read_off);
+	write_off = reflector_readl(&reflector->write_off);
+	while (read_off != write_off) {
+		len = strlen(reflector->msg + read_off) + 1;
+		printk("%s", reflector->msg + read_off);
+		read_off += len;
+		// Check for wrap.
+		if (read_off >= sizeof(reflector->msg) - 40)
+			read_off = 0;
+
+	}
+	reflector_writel(read_off, &reflector->read_off);
+
+	printk("\n\n");
+}
+
+/* Holds the index into the desc array where the reflector
+ * irqs are located
+ */
+static unsigned first_reflect_irq;
+
+/* Map back and forth between linux interrut numbers and
+ * the bits in the reflector block
+ */
+
+static inline int irq_to_bit(unsigned int irq)
+{
+	return irq - first_reflect_irq;
+}
+
+static inline int bit_to_irq(unsigned int bit)
+{
+	return first_reflect_irq + bit;
+}
+
+static void mask_reflector_irq(unsigned int irq)
+{
+	unsigned long flags;
+	int n = irq_to_bit(irq);
+	unsigned enables;
+	int mask = (1 << n);
+
+	spin_lock_irqsave(&reflect_lock, flags);
+
+	claim();
+
+	enables = reflector_readl(&reflector->irq_enable);
+
+	reflector_writel(enables & ~mask, &reflector->irq_enable);
+
+	irq_reflector_data->disable_remote_irq(n, !!(enables & mask));
+
+	release();
+
+	spin_unlock_irqrestore(&reflect_lock, flags);
+}
+
+static void mask_ack_reflector_irq(unsigned int irq)
+{
+	unsigned long flags;
+	int n = irq_to_bit(irq);
+	int mask = ~(1 << n);
+	unsigned status;
+	unsigned enables;
+
+	spin_lock_irqsave(&reflect_lock, flags);
+
+	claim();
+	/* Clear the status, and disable */
+	status = reflector_readl(&reflector->irq_status) & mask;
+	enables = reflector_readl(&reflector->irq_enable) & mask;
+
+	/* This is done here, to avoid re-entering the mux
+	 * interrupt if the other end hasn't dropped the status
+	 * yet.
+	 */
+	reflector_writel(status, &reflector->irq_status);
+	reflector_writel(enables, &reflector->irq_enable);
+
+	if ((status & enables) == 0) {
+		irq_reflector_data->ack_multiplex_irq();
+	}
+
+	/* We don't need to signal the other end here, as we know
+	 * the interrupt has already been disabled at the other end
+	 * by the time we get here and cannot re-enter
+	 */
+
+	release();
+
+	spin_unlock_irqrestore(&reflect_lock, flags);
+}
+
+static void unmask_reflector_irq(unsigned int irq)
+{
+	unsigned long flags;
+	int n = irq_to_bit(irq);
+	unsigned enables;
+	int mask = (1 << n);
+
+	spin_lock_irqsave(&reflect_lock, flags);
+
+	claim();
+
+	enables = reflector_readl(&reflector->irq_enable);
+	reflector_writel(enables | mask, &reflector->irq_enable);
+	irq_reflector_data->enable_remote_irq(n, !!(enables & mask));
+
+	release();
+
+	spin_unlock_irqrestore(&reflect_lock, flags);
+}
+
+static void irq_reflector_demux(unsigned int mux_irq, struct irq_desc *mux_desc)
+{
+	unsigned take;
+	int n;
+	int handled = 0;
+	unsigned irq;
+	struct irq_desc *desc;
+
+	do {
+		/* We don't have to take the lock here as we are only
+		 * reading
+		 */
+		take =
+		    reflector_readl(&reflector->irq_status) &
+		    reflector_readl(&reflector->irq_enable);
+		n = ffs(take);
+		if (n) {
+			irq = bit_to_irq(n - 1);
+			desc = irq_desc + irq;
+			/* These are treated like level */
+			desc->handle_irq(irq, desc);
+			handled = 1;
+		}
+	} while (n);
+
+	if (!handled)
+		printk(KERN_INFO "irq reflector: spurious interrupt demux %d\n",
+		       mux_irq);
+}
+
+static struct irq_chip irq_reflector_chip = {
+	.name = "reflector",
+	.mask = mask_reflector_irq,
+	.mask_ack = mask_ack_reflector_irq,
+	.unmask = unmask_reflector_irq
+};
+
+void __init irq_reflector_early_init(struct platform_device *pdev)
+{
+	struct resource *res;
+	int irq;
+
+	printk("initialising IRQ reflector\n");
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	reflector = ioremap(res->start, res->end - res->start + 1);
+
+	if (reflector == NULL)
+		panic("Unable to map IRQ reflector shared memory area\n");
+
+	/* This is the IRQ number we hook off. This could be a range I guess */
+	irq = platform_get_irq(pdev, 0);
+
+	printk("multiplexing interrupt is %d\n", irq);
+	set_irq_chained_handler(irq, irq_reflector_demux);
+
+	first_reflect_irq = platform_get_irq(pdev, 1);
+
+	for (irq = first_reflect_irq;
+	     irq < (first_reflect_irq + MAX_BOUNCE_IRQS); irq++) {
+		set_irq_chip_and_handler_name(irq, &irq_reflector_chip,
+					      handle_level_irq, "latch");
+	}
+
+	irq_reflector_data = pdev->dev.platform_data;
+
+	/* Who initialises the struct should be passed in as part of the platform_device
+	 * data. In this test case we are running on the SH4, so will boot first. In the STV576
+	 * case, Linux will boot second and so the other end should set it up.
+	 */
+	if (irq_reflector_data->boot_first) {
+		memset(reflector, 0, sizeof(struct reflect_block));
+	}
+}
diff --git a/arch/st200/drivers/pci/Makefile b/arch/st200/drivers/pci/Makefile
new file mode 100644
index 0000000..e2e5e6e
--- /dev/null
+++ b/arch/st200/drivers/pci/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_PCI) += pci.o
+obj-$(CONFIG_SOC_FPGA) += v320usc.o
diff --git a/arch/st200/drivers/pci/pci.c b/arch/st200/drivers/pci/pci.c
new file mode 100644
index 0000000..db4e39a
--- /dev/null
+++ b/arch/st200/drivers/pci/pci.c
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2010 STMicroelectronics Limited
+ * Author: David McKay <david.mckay@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License V2.  See linux/COPYING for more information.
+ *
+ * Generic PCI routines for the ST200, probably still too closely tied to
+ * the FPGA board. Probably a good idea to remodel this code on sh or ARM
+ * infrastructures
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/io.h>
+#include <asm/scu.h>
+
+/* Global pointing at memory mapped IO region,
+ * it is expected that whatever PCI driver you are using
+ * will initialise this
+ */
+void *pcibios_io_region;
+
+/* Ditto for thism, which hols the config operations for
+ * the particular controller
+ */
+struct pci_ops *pcibios_pci_ops;
+
+static void pcibios_enable_bridge(struct pci_dev *dev)
+{
+	struct pci_bus *bus = dev->subordinate;
+	u16 cmd, old_cmd;
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	old_cmd = cmd;
+
+	if (bus->resource[0]->flags & IORESOURCE_IO)
+		cmd |= PCI_COMMAND_IO;
+	if ((bus->resource[1]->flags & IORESOURCE_MEM) ||
+			(bus->resource[2]->flags & IORESOURCE_PREFETCH))
+		cmd |= PCI_COMMAND_MEMORY;
+
+	if (cmd != old_cmd)
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	printk(KERN_INFO "PCI bridge %s, command register -> %04x\n",
+			pci_name(dev), cmd);
+
+}
+
+int pcibios_enable_device(struct pci_dev *dev, int mask)
+{
+	u16 cmd, old_cmd;
+	int idx;
+	struct resource *r;
+
+	if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI)
+		pcibios_enable_bridge(dev);
+
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, L1_CACHE_BYTES);
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	old_cmd = cmd;
+	for (idx = 0; idx < 6; idx++) {
+		/* Only set up the requested stuff */
+		if (!(mask & (1 << idx)))
+			continue;
+
+		r = &dev->resource[idx];
+		if (!r->start && r->end) {
+			printk(KERN_ERR
+			       "PCI: Device %s not available because of "
+			       "resource collisions\n",
+			       pci_name(dev));
+			return -EINVAL;
+		}
+		if (r->flags & IORESOURCE_IO)
+			cmd |= PCI_COMMAND_IO;
+		if (r->flags & IORESOURCE_MEM)
+			cmd |= PCI_COMMAND_MEMORY;
+	}
+	if (dev->resource[PCI_ROM_RESOURCE].start)
+		cmd |= PCI_COMMAND_MEMORY;
+	if (cmd != old_cmd) {
+		printk(KERN_INFO "PCI: Enabling device %s (%04x -> %04x)\n",
+		       pci_name(dev), old_cmd, cmd);
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+	}
+	return 0;
+}
+
+void __init
+pcibios_align_resource(void *data, struct resource *res, resource_size_t size,
+		       resource_size_t align)
+{
+
+}
+
+/*
+ * This function scans the PCI bus looking for graphics cards. If it finds
+ * one, it assumes that any prefetchable region might be a frame buffer. Now
+ * that we no longer support speculative loads from kernel or user, this code
+ * is only a performance enhancement and will not cause code to fail if it
+ * cannot allocate one for some reason. This was not the case before!!
+ */
+
+static void __init pci_look_for_vga(struct pci_dev *d)
+{
+	struct resource *r;
+	int i;
+	u16 class = d->class >> 8;
+
+	if (!(class == PCI_CLASS_DISPLAY_VGA ||
+			class == PCI_CLASS_NOT_DEFINED_VGA))
+		return;
+
+	for (i = 0; i < 6; i++) {
+		r = d->resource + i;
+		if (r->flags & (IORESOURCE_MEM | IORESOURCE_PREFETCH)) {
+			if (request_scu_region(r->start,
+						r->end - r->start + 1))
+				printk(KERN_WARNING "Unable to allocate SCU"
+				"for VGA card - prefetching disabled\n");
+		}
+	}
+}
+
+/* We need to do this after the PCI bus has been probed and set up */
+DECLARE_PCI_FIXUP_ENABLE(PCI_ANY_ID, PCI_ANY_ID, pci_look_for_vga);
+
+void pcibios_update_irq(struct pci_dev *dev, int irq)
+{
+	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
+}
+
+unsigned int pcibios_max_latency = 255;
+
+void pcibios_set_master(struct pci_dev *dev)
+{
+	u8 lat;
+
+	pci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);
+	if (lat < 16)
+		lat = (64 <= pcibios_max_latency) ? 64 : pcibios_max_latency;
+	else if (lat > pcibios_max_latency)
+		lat = pcibios_max_latency;
+	else
+		return;
+	printk(KERN_INFO "PCI: Setting latency timer of device %s to %d\n",
+	       pci_name(dev), lat);
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);
+}
+
+void __devinit pcibios_fixup_bus(struct pci_bus *b)
+{
+	pci_read_bridge_bases(b);
+}
+
+char *__init pcibios_setup(char *str)
+{
+	return str;
+}
+
+static u8 __init no_swizzle(struct pci_dev *dev, u8 * pin)
+{
+	return PCI_SLOT(dev->devfn);
+}
+
+static int __init pcibios_init(void)
+{
+	printk(KERN_INFO "PCI: Probing PCI hardware on host bus 0.\n");
+
+	pci_scan_bus(0, pcibios_pci_ops, NULL);
+
+	pci_assign_unassigned_resources();
+
+	pci_fixup_irqs(no_swizzle, pcibios_map_platform_irq);
+
+	return 0;
+}
+
+subsys_initcall(pcibios_init);
diff --git a/arch/st200/drivers/pci/v320usc.c b/arch/st200/drivers/pci/v320usc.c
new file mode 100644
index 0000000..91f9dd0
--- /dev/null
+++ b/arch/st200/drivers/pci/v320usc.c
@@ -0,0 +1,326 @@
+/*
+ * Copyright (C) 2010 STMicroelectronics Limited
+ * Author: David McKay <david.mckay@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License V2.  See linux/COPYING for more information.
+ *
+ * Support for the V320 PCI controller found on the MB427 FPGA board
+ *
+ * Some code taken from GPL quicklogic which bore the copyright notice
+ *
+ * Copyright (C) 1999,2000,2001 Dan Aizenstros (dan@quicklogic.com)
+ * Copyright (C) 2001 QuickLogic Corporation
+ *
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/st_soc.h>
+#include <asm/scu.h>
+#include "v320usc.h"
+
+/* We are little endian */
+#define LB_PCI_BASEX_IO_SWAP		LB_PCI_BASEX_BYTE_SWAP_NO
+#define LB_PCI_BASEX_CONFIG_SWAP	LB_PCI_BASEX_BYTE_SWAP_NO
+#define LB_PCI_BASEX_MEM_SWAP		LB_PCI_BASEX_BYTE_SWAP_NO
+#define PCI_I2O_MAP_SWAP		PCI_I2O_MAP_BYTE_SWAP_NO
+
+#define HURRICANE_V320USC_BASE 0
+#define HURRICANE_PCI_CONF_BASE  0
+
+/* Pointer to vs320 internal registers */
+static void *v320_regmap;
+/* Pointer to IO region */
+static void *v320_iomap;
+
+/* Pointer to function to compute correct idsel for
+ * given dev. Board specific
+ */
+static int (*get_idsel)(unsigned char dev);
+
+/* Spinlock used when we do config transactions, as
+ * we cannot allow any IO transactions to happen
+ */
+static DEFINE_SPINLOCK(v320lock);
+
+/* 1Meg is enough to address all the IDSEL lines, but 16Meg is smallest size */
+#define V320_IO_SIZE (16*1024*1024)
+
+#define reg(x)	((v320_regmap) + (V320USC_##x))
+
+#define v320usc_inb(addr)		readb(reg(addr))
+#define v320usc_outb(value, addr)	writeb(value, reg(addr))
+#define v320usc_inw(addr)		readw(reg(addr))
+#define v320usc_outw(value, addr)	writew(value, reg(addr))
+#define v320usc_inl(addr)		readl(reg(addr))
+#define v320usc_outl(value, addr)	writel(value, reg(addr))
+
+/* Set the LB_PCI_BASE1 register to allow PCI I/O cycles to be used */
+static void set_io_cycles(void)
+{
+	u32 tempscratch;
+
+	v320usc_outl((v320usc_inl(LB_PCI_BASE1) &
+		      ~(LB_PCI_BASEX_PCI_CMD_MASK | LB_PCI_BASEX_ALOW_MASK |
+			LB_PCI_BASEX_BYTE_SWAP_MASK)) |
+		     LB_PCI_BASEX_IO_SWAP | LB_PCI_BASEX_IO, LB_PCI_BASE1);
+
+	/* do a read of the register to flush the posting buffer */
+	tempscratch = v320usc_inl(LB_PCI_BASE1);
+}
+
+/* Set the LB_PCI_BASE1 register to allow PCI Config cycles to be used */
+static void set_config_cycles(int alow)
+{
+	u32 tempscratch;
+
+	v320usc_outl((v320usc_inl(LB_PCI_BASE1) &
+		      ~(LB_PCI_BASEX_PCI_CMD_MASK | LB_PCI_BASEX_ALOW_MASK |
+			LB_PCI_BASEX_BYTE_SWAP_MASK)) |
+		     LB_PCI_BASEX_CONFIG_SWAP | LB_PCI_BASEX_CONFIG | alow,
+		     LB_PCI_BASE1);
+
+	/* do a read of the register to flush the posting buffer */
+	tempscratch = v320usc_inl(LB_PCI_BASE1);
+}
+
+static int mkaddr(unsigned char bus, unsigned char dev_fn, unsigned char where)
+{
+	unsigned long addr;
+
+	if (bus) {
+		addr = ((bus & 0xff) << 0x10) |
+		    ((dev_fn & 0xff) << 0x08) | (where & 0xff);
+	} else {
+		int device, function;
+		unsigned long idsel;
+
+		device = PCI_SLOT(dev_fn);
+		function = PCI_FUNC(dev_fn);
+
+		/* Board specific function to tell us what idsel line to use
+		 * for this device
+		 */
+		idsel = get_idsel(device);
+
+		addr = idsel | (function << 8) | where;
+	}
+
+	return addr;
+}
+
+static int v320_config_read(struct pci_bus *bus, unsigned int devfn, int where,
+			    int size, u32 *val)
+{
+	int retVal = PCIBIOS_SUCCESSFUL;
+	unsigned long flags;
+	int addr, alow;
+
+	addr = mkaddr((bus) ? bus->number : 0, devfn, where);
+	if (addr == -1)
+		return -1;
+
+	spin_lock_irqsave(&v320lock, flags);
+
+	/* Clear status bits */
+	v320usc_outw(v320usc_inw(PCI_STAT_W), PCI_STAT_W);
+
+	alow = (bus) ? !!bus->number : 0;
+
+	set_config_cycles(alow);
+
+	switch (size) {
+	case 1:
+		*val = readb(v320_iomap + addr);
+		break;
+	case 2:
+		*val = readw(v320_iomap + addr);
+		break;
+	case 4:
+		*val = readl(v320_iomap + addr);
+		break;
+	default:
+		BUG();
+	}
+
+	/* Check for master abort */
+	if (v320usc_inw(PCI_STAT_W) & PCI_STAT_W_M_ABORT)
+		*val = 0xffffffff;
+
+	set_io_cycles();
+
+	spin_unlock_irqrestore(&v320lock, flags);
+
+	return retVal;
+}
+
+static int v320_config_write(struct pci_bus *bus, unsigned int devfn, int where,
+			     int size, u32 val)
+{
+	unsigned long flags;
+	int addr, alow;
+
+	addr = mkaddr((bus) ? bus->number : 0, devfn, where);
+	if (addr == -1)
+		return -1;
+
+	spin_lock_irqsave(&v320lock, flags);
+
+	alow = (bus) ? !!bus->number : 0;
+	set_config_cycles(alow);
+
+	switch (size) {
+	case 1:
+		writeb(val, v320_iomap + addr);
+		break;
+	case 2:
+		writew(val, v320_iomap + addr);
+		break;
+	case 4:
+		writel(val, v320_iomap + addr);
+		break;
+	default:
+		BUG();
+	}
+
+	/* wait for write FIFO to empty */
+	v320usc_inw(PCI_STAT_W);
+
+	set_io_cycles();
+
+	spin_unlock_irqrestore(&v320lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops v320_pci_ops = {
+	v320_config_read,
+	v320_config_write
+};
+
+
+static int __init v320_init_one(u32 mem_window_phys, u32 mem_window_size,
+			       u32 io_window_phys)
+{
+	/* Reset the bus  */
+	v320usc_outb(0, SYSTEM);
+
+	v320usc_outl(0, PCU_SUB0);
+	v320usc_outl(0, PCU_SUB1);
+	v320usc_outl(0, PCU_SUB2);
+
+	v320usc_outw(PCI_CMD_W_MEM_EN |
+		     PCI_CMD_W_MASTER_EN, PCI_CMD_W);
+
+	v320usc_outw(PCI_STAT_W_M_ABORT | PCI_STAT_W_T_ABORT |
+		     PCI_STAT_W_PAR_REP | PCI_STAT_W_PAR_ERR |
+		     PCI_STAT_W_PAR_REP, PCI_STAT_W);
+
+	v320usc_outl(3 << 16, PCI_BUS_CFG);
+
+	v320usc_outl(0xf << 4, PCI_PCU_BASE);
+	v320usc_outl(0, LB_PCU_BASE);
+
+	v320usc_outl(0, LB_ROM_BASE);
+
+	v320usc_outl((CONFIG_MEMORY_START & PCI_MEM_BASE_ADR_BASE_MASK) |
+		     PCI_MEM_BASE_PREFETCH, PCI_MEM_BASE);
+
+	v320usc_outl((CONFIG_MEMORY_START & PCI_MEM_BASE_ADR_BASE_MASK) |
+		     (APERTURE_SIZE(mem_window_size) << 4) | 3, PCI_MEM_MAP);
+
+	v320usc_outl(0, PCI_I2O_MAP);
+	v320usc_outl(0, PCI_I2O_BASE);
+
+	v320usc_outl((mem_window_phys & LB_PCI_BASEX_BASE) |
+		     ((mem_window_phys & LB_PCI_BASEX_BASE) >> 8) |
+		     LB_PCI_BASEX_MEMORY |
+		     LB_PCI_BASEX_SIZE(mem_window_size),
+		     LB_PCI_BASE0);
+
+	/* Base 1  will be the IO and config window. To do config access we
+	 * have to change the IO window to be a config window. So we have to
+	 * disable interrupts. Yuck.  Why didn't they provide a 3rd window, or
+	 * better yet a register pair just for config.
+	 *
+	 * We always set this window to 16Megs, this is the smallest size
+	 *
+	 */
+	v320usc_outl((io_window_phys & LB_PCI_BASEX_BASE) | (0x00 << 16) |
+			LB_PCI_BASEX_IO | LB_PCI_BASEX_SIZE_16MB,
+			LB_PCI_BASE1);
+
+	/* Bring the bus out of reset */
+	v320usc_outb(1 << 7, SYSTEM);
+	mdelay(1000);
+
+	return 0;
+}
+
+
+static int __init v320_pci_probe(struct platform_device *pdev)
+{
+	struct plat_v320usc_pci_data *pci_data = pdev->dev.platform_data;
+	struct resource *res;
+
+	/* First resource is the actual physical address the v320 registers
+	 * can be seen at
+	 */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (res == NULL)
+		return -ENODEV;
+
+	if (!devm_request_mem_region(&pdev->dev, res->start,
+				resource_size(res), "v320 PCI controller"))
+		return -EBUSY;
+
+	v320_regmap = devm_ioremap_nocache(&pdev->dev, res->start,
+					resource_size(res));
+	if (!v320_regmap)
+		return -ENOMEM;
+
+	if (!devm_request_mem_region(&pdev->dev, pci_data->io_window_phys,
+				V320_IO_SIZE, "v320 PCI IO region"))
+		return -EBUSY;
+
+	v320_iomap = devm_ioremap_nocache(&pdev->dev, pci_data->io_window_phys,
+				V320_IO_SIZE);
+	if (!v320_iomap)
+		return -ENOMEM;
+
+	/* Map in the globals */
+	pcibios_io_region = v320_iomap;
+
+	get_idsel = pci_data->idsel;
+
+	pcibios_pci_ops = &v320_pci_ops;
+
+	v320_init_one(pci_data->mem_window_phys, pci_data->mem_window_size,
+			pci_data->io_window_phys);
+
+	return 0;
+}
+
+static struct platform_driver v320_pci_driver = {
+	.probe = v320_pci_probe,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "v320usc",
+	},
+};
+
+static int __init v320_pci_init(void)
+{
+	return platform_driver_register(&v320_pci_driver);
+}
+
+/* We have to bring this up early, before the PCI probing occurs */
+arch_initcall(v320_pci_init);
diff --git a/arch/st200/drivers/pci/v320usc.h b/arch/st200/drivers/pci/v320usc.h
new file mode 100644
index 0000000..84cab39
--- /dev/null
+++ b/arch/st200/drivers/pci/v320usc.h
@@ -0,0 +1,455 @@
+/*
+ * v320usc.h: Register defines for the V320USC family of devices.
+ *
+ * Copyright (C) 1999,2000,2001 Dan Aizenstros (dan@quicklogic.com)
+ * Copyright (C) 2001,2002 QuickLogic Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ */
+
+#ifndef _V320USC_H_
+#define _V320USC_H_
+
+/*
+ * PCI Command Register
+ * - Offset 04h, Size 16 bits
+ */
+#define PCI_CMD_W_IO_EN			0x0001	/* I/O access */
+#define PCI_CMD_W_MEM_EN		0x0002	/* Memory access */
+#define PCI_CMD_W_MASTER_EN		0x0004	/* PCI Master */
+#define PCI_CMD_W_MWI_EN		0x0010	/* Memory Write and */
+						/* Invalidate enable */
+#define PCI_CMD_W_PAR_EN		0x0040	/* Parity error */
+#define PCI_CMD_W_SERR_EN		0x0100	/* System error */
+#define PCI_CMD_W_FBB_EN		0x0200 	/* Fast back to back */
+
+/*
+ * PCI Status Register
+ * - Offset 06h, Size 16 bits
+ */
+#define PCI_STAT_W_NEW_CAP		0x0010	/* New Capabilites          */
+#define PCI_STAT_W_UDF			0x0040	/* User Defined Feature     */
+#define PCI_STAT_W_FAST_BACK		0x0008	/* Fast Back to Back Target */
+#define PCI_STAT_W_PAR_REP		0x0010	/* Data Parity Report */
+#define PCI_STAT_W_DEVSEL_MASK		0x0600	/* 10-9 Bits Device Select */
+#define PCI_STAT_W_DEVSEL_SHIFT		9
+
+#define PCI_STAT_W_T_ABORT		0x1000	/* Target Abort */
+#define PCI_STAT_W_M_ABORT		0x2000	/* Master Abort */
+#define PCI_STAT_W_SYS_ERR		0x4000	/* System Error */
+#define PCI_STAT_W_PAR_ERR		0x8000	/* Parity Error */
+
+/*
+ * PCI Class and Revision Register
+ * - Offset 08h, Size 32 bits
+ */
+
+/*  3-0 Bits Stepping ID
+ *    Rev A = 0,Rev B0 = 1, Rev B1 = 2, Rev B2 = 3
+ */
+#define PCI_CC_REV_VREV_MASK		0x0000000f
+#define PCI_CC_REV_VREV_SHIFT		0
+
+/* 7-4 Bits User Revision ID */
+#define PCI_CC_REV_UREV_MASK		0x000000f0
+#define PCI_CC_REV_UREV_SHIFT		4
+
+/* 15-8 Bits PCI Programming Interface code */
+#define PCI_CC_REV_PROG_IF_MASK		0x0000ff00
+#define PCI_CC_REV_PROG_IF_SHIFT	8
+
+/* 23-16 Bits PCI Sub Class */
+#define PCI_CC_REV_SUB_CLASS_MASK	0x00ff0000
+#define PCI_CC_REV_SUB_CLASS_SHIFT	16
+
+/* 32-24 Bits PCI Base Class */
+#define PCI_CC_REV_BASE_CLASS_MASK	0xff000000
+#define PCI_CC_REV_BASE_CLASS_SHIFT 	24
+
+/*
+ * PCI Access to local memory map access
+ * - Offset 10h, Size 32 bits (I2O mode)
+ */
+#define PCI_I2O_BASE_IO			0x00000001	/* I/O 1 - I/O space */
+							/* 0 - Memory Space  */
+#define PCI_I2O_BASE_TYPE_MASK		0x00000006	/* 2-1 Address range */
+#define PCI_I2O_BASE_TYPE_SHIFT		1
+#define PCI_I2O_BASE_PREFETCH		0x00000008	/* Prefetchable */
+#define PCI_I2O_BASE_ADR_BASE_MASK	0xfff00000	/* Base address */
+#define PCI_I2O_BASE_ADR_BASE_SHIFT	20
+
+/*
+ * PCI Access to local memory map access
+ * - Offset 14h, Size 32 bits
+ */
+#define PCI_MEM_BASE_IO			0x00000001	/* I/O 1 - I/O space */
+							/* 0 - Memory Space  */
+#define PCI_MEM_BASE_TYPE_MASK		0x00000006	/* 2-1 type */
+#define PCI_MEM_BASE_TYPE_SHIFT		1
+#define PCI_MEM_BASE_PREFETCH		0x00000008
+#define PCI_MEM_BASE_ADR_BASE_MASK	0xfff00000
+#define PCI_MEM_BASE_ADR_BASE_SHIFT	20
+
+/*
+ * PCI Bus Parameters Register
+ * - Offset 3ch, Size 32 bits
+ */
+
+/* 7-0 Bits Interrupt Line */
+#define PCI_BPARAM_INT_LINE_MASK	0x000000ff
+#define PCI_BPARAM_INT_LINE_SHIFT	0
+/* 10-8 Bits Interrupt Pin
+ * 0 - disable, 1 - INTA, 2 - INT B
+ * 3 - INT C, 4 - INT C
+ */
+#define PCI_BPARAM_INT_PIN_MASK		0x00000700
+#define PCI_BPARAM_INT_PIN_SHIFT	8
+/* 23-16 Bits Minimum Grant */
+#define PCI_BPARAM_MIN_GRANT_MASK	0x00ff0000
+#define PCI_BPARAM_MIN_GRANT_SHIFT	16
+/* 31-24 Bits Maximum Latency */
+#define PCI_BPARAM_MAX_LAT_MASK		0xff000000
+#define PCI_BPARAM_MAX_LAT_SHIFT	24
+
+/*
+ * PCI I2O Map Register
+ * - Offset 50h, Size 32 bits
+ */
+#define PCI_I2O_MAP_ENABLE		0x00000001  /* Enable aperture */
+#define PCI_I2O_MAP_REG_EN		0x00000002  /* Register enable */
+#define PCI_I2O_MAP_I2O_MODE		0x00000004  /* I2O Mode enable */
+#define PCI_I2O_MAP_RD_POST_INH		0x00000008
+#define PCI_I2O_MAP_SIZE_1MB		0x00000000
+#define PCI_I2O_MAP_SIZE_2MB		0x00000010
+#define PCI_I2O_MAP_SIZE_4MB		0x00000020
+#define PCI_I2O_MAP_SIZE_8MB		0x00000030
+#define PCI_I2O_MAP_SIZE_16MB		0x00000040
+#define PCI_I2O_MAP_SIZE_32MB		0x00000050
+#define PCI_I2O_MAP_SIZE_64MB		0x00000060
+#define PCI_I2O_MAP_SIZE_128MB		0x00000070
+#define PCI_I2O_MAP_SIZE_256MB		0x00000080
+#define PCI_I2O_MAP_SIZE_512MB		0x00000090
+#define PCI_I2O_MAP_SIZE_1GB		0x000000a0
+#define PCI_I2O_MAP_SIZE_MASK		0x000000f0
+#define PCI_I2O_MAP_BYTE_SWAP_NO	0x00000000  /* No swap 32 bits */
+#define PCI_I2O_MAP_BYTE_SWAP_16	0x00000100  /* 16 bits */
+#define PCI_I2O_MAP_BYTE_SWAP_8		0x00000200  /* 8 bits */
+#define PCI_I2O_MAP_BYTE_SWAP_AUTO	0x00000300  /* Auto swap use BE[3:0] */
+#define PCI_I2O_MAP_BYTE_SWAP_MASK	0x00000300
+#define PCI_I2O_MAP_PCI_RD_MB_00	0x00000000
+#define PCI_I2O_MAP_PCI_RD_MB_01	0x00001000
+#define PCI_I2O_MAP_PCI_RD_MB_10	0x00002000
+#define PCI_I2O_MAP_PCI_WR_MB_00	0x00000000
+#define PCI_I2O_MAP_PCI_WR_MB_01	0x00004000
+#define PCI_I2O_MAP_PCI_WR_MB_10	0x00008000
+/* Write prefetch reads */
+#define PCI_I2O_MAP_W_FLUSH		0x00010000
+#define PCI_I2O_MAP_ADR_MASK		0x3ff00000
+#define PCI_I2O_MAP_ADR_SHIFT		20
+
+/*
+ * LB_PCI_BASEx Registers
+ * - Offset 60h, Size 32 bits
+ * - Offset 64h, Size 32 bits
+ */
+
+/* Select value AD1:0 */
+#define LB_PCI_BASEX_ALOW_MASK		0x00000003
+#define LB_PCI_BASEX_ALOW_SHIFT		0x00000000
+#define LB_PCI_BASEX_ERR_EN		0x00000004
+#define LB_PCI_BASEX_PREFETCH		0x00000008  /* Prefetch */
+#define LB_PCI_BASEX_SIZE_DISABLE	0x00000000
+#define LB_PCI_BASEX_SIZE_16MB		0x00000010
+#define LB_PCI_BASEX_SIZE_32MB		0x00000020
+#define LB_PCI_BASEX_SIZE_64MB		0x00000030
+#define LB_PCI_BASEX_SIZE_128MB		0x00000040
+#define LB_PCI_BASEX_SIZE_256MB		0x00000050
+#define LB_PCI_BASEX_SIZE_512MB		0x00000060
+#define LB_PCI_BASEX_SIZE_1GB		0x00000070
+#define LB_PCI_BASEX_SIZE(x)		(0x10 * (ilog2(x) - 23))
+
+#define LB_PCI_BASEX_BYTE_SWAP_NO	0x00000000  /* No swap 32 bits */
+#define LB_PCI_BASEX_BYTE_SWAP_16	0x00000100  /* 16 bits */
+#define LB_PCI_BASEX_BYTE_SWAP_8	0x00000200  /* bits */
+/* Auto swap use BE[3:0] */
+#define LB_PCI_BASEX_BYTE_SWAP_AUTO	0x00000300
+#define LB_PCI_BASEX_BYTE_SWAP_MASK	0x00000300
+/* Burst Write Combine */
+#define LB_PCI_BASEX_COMBINE		0x00000800
+
+#define LB_PCI_BASEX_PCI_CMD_MASK	0x0000e000
+#define LB_PCI_BASEX_PCI_CMD_SHIFT	13
+#define LB_PCI_BASEX_INT_ACK		0x00000000  /* Interrupt Ack */
+#define LB_PCI_BASEX_IO			0x00002000  /* I/O Read/Write */
+#define LB_PCI_BASEX_MEMORY		0x00006000  /* Memory Read/Write */
+#define LB_PCI_BASEX_CONFIG		0x0000a000  /* Config Read/Write */
+#define LB_PCI_BASEX_MULTI_MEMORY	0x0000c000  /* Multiple Memory R/W */
+#define LB_PCI_BASEX_MEMORY_INVALIDATE	0x0000e000  /* MM R/W Invalidate */
+#define LB_PCI_BASEX_MAP_ADR_MASK	0x00ff0000  /* PCI Address map */
+#define LB_PCI_BASEX_MAP_ADR_SHIFT	16
+#define LB_PCI_BASEX_BASE		0xff000000  /* Local Address base */
+#define LB_PCI_BASEX_BASE_ADR_SHIFT	24
+
+/*
+ * SDRAM Local Base Address Register
+ * - Offset 78h, Size 32 bits
+ */
+#define LB_SDRAM_BASE_ENABLE		0x01	/* must be enabled to access */
+#define LB_SDRAM_BASE_SIZE_64M		0x00
+#define LB_SDRAM_BASE_SIZE_128M		0x10
+#define LB_SDRAM_BASE_SIZE_256M		0x20
+#define LB_SDRAM_BASE_SIZE_512M		0x30
+#define LB_SDRAM_BASE_SIZE_1G		0x40
+
+#define LB_SDRAM_BASE_MASK		0xfc000000
+#define LB_SDRAM_BASE_SHIFT		26
+
+/*
+ * SDRAM Block Control Register
+ * - Offset 90h, Size 32 bits
+ * - Offset 94h, Size 32 bits
+ * - Offset 98h, Size 32 bits
+ * - Offset 9ch, Size 32 bits
+ */
+#define SDRAM_BLKX_ENABLE		0x00000001	/* Enable Bank */
+#define SDRAM_BLKX_SIZE_MASK		0x000000f0
+#define SDRAM_BLKX_SIZE_SHIFT		4
+
+/*
+ * Interrupt Configuration Register
+ * - Offset e0h, Size 32 bits
+ * - Offset e4h, Size 32 bits
+ * - Offset e8h, Size 32 bits
+ * - Offset 158h, Size 32 bits
+ */
+#define INT_CFGX_LB_MBI			0x00000001
+#define INT_CFGX_PCI_MBI		0x00000002
+#define INT_CFGX_I2O_OP_NE		0x00000008
+#define INT_CFGX_I2O_IF_NF		0x00000010
+#define INT_CFGX_I2O_IP_NE		0x00000020
+#define INT_CFGX_I2O_OP_NF		0x00000040
+#define INT_CFGX_I2O_OF_NE		0x00000080
+#define INT_CFGX_INT0			0x00000100
+#define INT_CFGX_INT1			0x00000200
+#define INT_CFGX_INT2			0x00000400
+#define INT_CFGX_INT3			0x00000800
+#define INT_CFGX_TIMER0			0x00001000
+#define INT_CFGX_TIMER1			0x00002000
+#define INT_CFGX_ENUM			0x00004000
+#define INT_CFGX_DMA0			0x00010000
+#define INT_CFGX_DMA1			0x00020000
+#define INT_CFGX_PWR_STATE		0x00100000
+#define INT_CFGX_HBI			0x00200000
+#define INT_CFGX_WDI			0x00400000
+#define INT_CFGX_BWI			0x00800000
+#define INT_CFGX_PSLAVE_PI		0x01000000
+#define INT_CFGX_PMASTER_PI		0x02000000
+#define INT_CFGX_PCI_T_ABORT		0x04000000
+#define INT_CFGX_PCI_M_ABORT		0x08000000
+#define INT_CFGX_DRA_PI			0x10000000
+#define INT_CFGX_MODE			0x20000000
+#define INT_CFGX_DI0			0x40000000
+#define INT_CFGX_DI1			0x80000000
+
+/*
+ * Interrupt Status Register
+ * - Offset ECh, Size 32 bits
+ */
+#define INT_STAT_BWI			0x00800000
+#define INT_STAT_WDI			0x00400000
+#define INT_STAT_HBI			0x00200000
+#define INT_STAT_DMA1			0x00020000
+#define INT_STAT_DMA0			0x00010000
+#define INT_STAT_TIMER1			0x00002000
+#define INT_STAT_TIMER0			0x00001000
+#define INT_STAT_INT3			0x00000800
+#define INT_STAT_INT2			0x00000400
+#define INT_STAT_INT1			0x00000200
+#define INT_STAT_INT0			0x00000100
+
+/*
+ * General Purpose Timer Control Register
+ * - Offset 150h, Size 16 bits
+ * - Offset 152h, Size 16 bits
+ */
+#define TIMER_CTLX_W_TI_MODE_0		0x0000	/* Timer input event */
+#define TIMER_CTLX_W_TI_MODE_1		0x0001
+#define TIMER_CTLX_W_TI_MODE_2		0x0002
+#define TIMER_CTLX_W_TI_MODE_3		0x0003
+
+#define TIMER_CTLX_W_CNT_EN_0		0x0000	/* Count enable */
+#define TIMER_CTLX_W_CNT_EN_1		0x0004
+#define TIMER_CTLX_W_CNT_EN_2		0x0008
+#define TIMER_CTLX_W_CNT_EN_3		0x000C
+
+#define TIMER_CTLX_W_TRG_MODE_0		0x0000	/* Trigger mode */
+#define TIMER_CTLX_W_TRG_MODE_1		0x0010
+#define TIMER_CTLX_W_TRG_MODE_2		0x0020
+#define TIMER_CTLX_W_TRG_MODE_3		0x0030
+
+#define TIMER_CTLX_W_TO_MODE_0		0x0000	/* Timer output mode */
+#define TIMER_CTLX_W_TO_MODE_1		0x0100
+#define TIMER_CTLX_W_TO_MODE_2		0x0200
+#define TIMER_CTLX_W_TO_MODE_3		0x0300
+#define TIMER_CTLX_W_TO_MODE_4		0x0400
+#define TIMER_CTLX_W_TO_MODE_5		0x0500
+
+#define TIMER_CTLX_W_DLTCH_0		0x0000	/* Data latch mode */
+#define TIMER_CTLX_W_DLTCH_1		0x0800
+#define TIMER_CTLX_W_DLTCH_2		0x1000
+
+#define TIMER_CTLX_W_ENABLE		0x8000	/* Timer enable */
+
+/*
+ * DMA Delay Register
+ * - Offset 16Ch, Size 8 bits
+ */
+#define DMA_DELAY_MASK			0x000000ff
+#define DMA_DELAY_SHIFT			0
+
+/*
+ * DMA Command / Status Register
+ * - Offset 170h, Size 32 bits
+ * - Offset 174h, Size 32 bits
+ */
+#define DMA_CSR_IPR		0x00000001 /* initiate DMA transfer */
+#define DMA_CSR_HALT		0x00000002 /* pause DMA transfer */
+#define DMA_CSR_DONE		0x00000004 /* DMA transfer complete */
+#define DMA_CSR_DCI		0x00000008 /* DMA control interrupt status */
+#define DMA_CSR_DPE		0x00000010 /* DMA PCI BUS error status */
+#define DMA_CSR_DONE_EN		0x00000400	/* DONE interrupt enable */
+#define DMA_CSR_DCI_EN		0x00000800	/* DCI interrupt enable */
+#define DMA_CSR_DPE_EN		0x00001000	/* DPE interrupt enable */
+#define DMA_CSR_PRIORITY	0x00008000	/* DMA channel priority */
+#define DMA_CSR_PCI_CMD0_MASK	0x000E0000	/* PCI Command Type 0 */
+#define DMA_CSR_PCI_CMD0_SHIFT	17
+#define DMA_CSR_PCI_CMD1_MASK	0x00E00000	/* PCI Command Type 1 */
+#define DMA_CSR_PCI_CMD1_SHIFT	21
+
+/*
+ * DMA Transfer Control Register
+ * - Offset 180h, Size 32 bits
+ * - Offset 190h, Size 32 bits
+ */
+#define DMA_XFER_DMA_CNT_MASK	0x000FFFFF	/* DMA transfer count */
+#define DMA_XFER_DMA_CNT_SHIFT	0
+#define DMA_XFER_DTERM_EN	0x00400000	/* Ext term count enable */
+#define DMA_XFER_BLOCK_FILL	0x00800000	/* Block fill feature enable */
+#define DMA_XFER_DST_BUS	0x01000000	/* DMA destination BUS */
+#define DMA_XFER_SRC_BUS	0x02000000	/* DMA source BUS */
+#define DMA_XFER_PDST_TYPE	0x04000000	/* PCI dest command type */
+#define DMA_XFER_PSRC_TYPE	0x08000000	/* PCI source command type */
+#define DMA_XFER_SWAP_MASK	0x30000000	/* Byte swap control */
+#define DMA_XFER_SWAP_SHIFT	28
+#define DMA_XFER_UPDT_CNT	0x40000000	/* Update count */
+#define DMA_XFER_DREQ_EN	0x80000000	/* External DRQ enable */
+
+/*
+ * DMA Control Block Register
+ * - Offset 180h, Size 32 bits
+ * - Offset 190h, Size 32 bits
+ */
+#define DMA_CTLB_BUS		0x00000001	/* DMA Control addr space */
+#define DMA_CTLB_SA_INC_DIS	0x00000004	/* Source increment disable */
+#define DMA_CTLB_DA_INC_DIS	0x00000008	/* Dest increment disable */
+#define DMA_CTLB_ADDR_MASK	0xFFFFFFF0	/* DMA Control addr mask */
+#define DMA_CTLB_ADDR_SHIFT	4
+
+/*
+ * V320USC registers offsets
+ */
+#define	V320USC_PCI_CMD_W		0x04
+#define	V320USC_PCI_STAT_W		0x06
+#define	V320USC_PCI_CC_REV		0x08
+#define	V320USC_PCI_I2O_BASE		0x10
+#define	V320USC_PCI_MEM_BASE		0x14
+#define V320USC_PCI_PCU_BASE            0x1c
+#define	V320USC_PCI_BPARM		0x3c
+#define	V320USC_PCI_I2O_MAP		0x50
+#define	V320USC_PCI_MEM_MAP		0x54
+#define	V320USC_PCI_BUS_CFG		0x5c
+#define	V320USC_LB_PCI_BASE0		0x60
+#define	V320USC_LB_PCI_BASE1		0x64
+#define	V320USC_LB_PCU_BASE		0x6c
+#define V320USC_SYSTEM                  0x73
+#define V320USC_LB_ROM_BASE             0x74
+#define	V320USC_LB_REG_BASE		0x70
+#define	V320USC_LB_SDRAM_BASE		0x78
+#define	V320USC_LB_BUS_CFG		0x7c
+#define	V320USC_LB_PCI_CTL_W		0x84
+#define V320USC_SDRAM_BLK0		0x90
+#define V320USC_SDRAM_BLK1		0x94
+#define V320USC_SDRAM_BLK2		0x98
+#define V320USC_SDRAM_BLK3		0x9C
+#define V320USC_PCU_SUB0                0xa0
+#define V320USC_PCU_SUB1                0xa4
+#define V320USC_PCU_SUB2                0xa8
+#define	V320USC_INT_CFG0		0xe0
+#define	V320USC_INT_CFG1		0xe4
+#define	V320USC_INT_CFG2		0xe8
+#define	V320USC_INT_STAT		0xec
+#define	V320USC_IOS		        0xf0
+#define	V320USC_WD_HBI_W		0xf4
+#define	V320USC_TIMER_DATA0		0x140
+#define	V320USC_TIMER_DATA1		0x144
+#define	V320USC_TIMER_CTL0_W		0x150
+#define	V320USC_TIMER_CTL1_W		0x152
+#define	V320USC_INT_CFG3		0x158
+#define	V320USC_DMA_DELAY		0x16C
+#define	V320USC_DMA_CSR0		0x170
+#define	V320USC_DMA_CSR1		0x174
+#define	V320USC_DMA_XFER_CTL0		0x180
+#define	V320USC_DMA_SRC_ADR0		0x184
+#define	V320USC_DMA_DST_ADR0		0x188
+#define	V320USC_DMA_CTLB_ADR0		0x18C
+#define	V320USC_DMA_XFER_CTL1		0x190
+#define	V320USC_DMA_SRC_ADR1		0x194
+#define	V320USC_DMA_DST_ADR1		0x198
+#define	V320USC_DMA_CTLB_ADR1		0x19C
+
+/*
+ * Stepping of V3USC320 as read back from V3USC_PCI_CC_REV register
+ */
+#define V3USC_REV_A0 0
+#define V3USC_REV_B0 1
+#define V3USC_REV_B1 2
+
+/*
+ * PCI Bus Parameters Register
+ * - Offset 3ch, Size 32 bits
+ */
+#define INTERRUPT_PIN_DISABLE		0x0	/* Disabled */
+#define INTERRUPT_PIN_INTA		0x1	/* Use INTA */
+#define INTERRUPT_PIN_INTB		0x2	/* Use INTB */
+#define INTERRUPT_PIN_INTC		0x3	/* Use INTC */
+#define INTERRUPT_PIN_INTD		0x4	/* Use INTD */
+
+/*
+ * PCI Base Address for Peripheral Access
+ * - Offset 1ch, Size 32 bits
+ * PCI Intelligent I/O Address Translation Unit Local Bus Address Map Register
+ * - Offset ??h, Size 32 bits
+ */
+#define BYTE_SWAP_NO			0x0	/* No swap 32 bits */
+#define BYTE_SWAP_16			0x1	/* 16 bits */
+#define BYTE_SWAP_8			0x2	/* 8 bits */
+#define BYTE_SWAP_AUTO			0x3	/* Auto swap use BE[3:0]   */
+#define APERTURE_SIZE_1M		0x0	/* Aperture size of 1 MB   */
+#define APERTURE_SIZE_2M		0x1	/* Aperture size of 2 MB   */
+#define APERTURE_SIZE_4M		0x2	/* Aperture size of 4 MB   */
+#define APERTURE_SIZE_8M		0x3	/* Aperture size of 8 MB   */
+#define APERTURE_SIZE_16M		0x4	/* Aperture size of 16 MB  */
+#define APERTURE_SIZE_32M		0x5	/* Aperture size of 32 MB  */
+#define APERTURE_SIZE_64M		0x6	/* Aperture size of 64 MB  */
+#define APERTURE_SIZE_128M		0x7	/* Aperture size of 128 MB */
+#define APERTURE_SIZE_256M		0x8	/* Aperture size of 256 MB */
+#define APERTURE_SIZE_512M		0x9	/* Aperture size of 512 MB */
+#define APERTURE_SIZE_1G		0xa	/* Aperture size of 1 GB   */
+
+/* Calculate the correct aperture size for a given memory size */
+#define APERTURE_SIZE(x)		(ilog2(x) - 20)
+
+#endif /* _V320USC_H_ */
diff --git a/arch/st200/drivers/simcons.c b/arch/st200/drivers/simcons.c
new file mode 100644
index 0000000..e2808de
--- /dev/null
+++ b/arch/st200/drivers/simcons.c
@@ -0,0 +1,308 @@
+/*
+ * linux/drivers/char/simcons.c
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *
+ * ST200 simulator console
+ */
+
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/console.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+static struct tty_driver *simcons_driver;
+
+struct simcons_port {
+	unsigned int count;
+	struct tty_struct *tty;
+#ifdef CONFIG_MAGIC_SYSRQ
+	unsigned long sysrq;
+#endif
+};
+static struct simcons_port simcons_ports[1] = {
+	{
+	 .count = 0,
+#ifdef CONFIG_MAGIC_SYSRQ
+	 .sysrq = 0,
+#endif
+	 }
+};
+
+static DECLARE_MUTEX(simcons_sem);
+
+/* These values corrispond to /dev/ttyFW0 */
+#define SIMCONS_MAJOR 204
+#define SIMCONS_MINOR 12
+
+/* We prefer to use stderr to avoid mixing with trace output */
+#define SIM_WRITE_FD 2
+
+extern void sim_write(int fd, unsigned long data, int len);
+
+static volatile unsigned char *keyreg;
+
+#define KEYBOARD_PHYSICAL 0x1f100000
+
+#define KEYBOARD_KEY_REG 0x0
+#define KEYBOARD_ENABLE_REG 0x4
+
+#define KEYBOARD_IRQ 3
+#define KEYBOARD_RANGE 8	/* Only 2 regs */
+
+/* Macroised to make 'em easy to switch off for RTL simulator */
+//#define NO_KEYBOARD_IO
+
+#ifdef NO_KEYBOARD_IO
+#define KEYBOARD_READ()    0
+#define KEYBOARD_ENABLE()
+#define KEYBOARD_DISABLE()
+#else
+#define KEYBOARD_READ()    readl(keyreg+KEYBOARD_KEY_REG)
+#define KEYBOARD_ENABLE()  writel(1,keyreg+KEYBOARD_ENABLE_REG);
+#define KEYBOARD_DISABLE() writel(0,keyreg+KEYBOARD_ENABLE_REG);
+#endif
+
+extern void st200_flush_dcache_range(unsigned long start, unsigned long size);
+
+static void sim_write_string(char *vaddr, int len)
+{
+	unsigned long flags;
+
+	/* Disable interrupts. Workaround for CMG simulator bug */
+	local_irq_save(flags);
+
+	/* Zap the cache - note we need virtual to do this */
+	st200_flush_dcache_range((unsigned long)vaddr, len);
+
+	/* Translate to physical and write */
+	sim_write(SIM_WRITE_FD, virt_to_phys(vaddr), len);
+
+	local_irq_restore(flags);
+}
+
+/*************************************************************/
+
+static irqreturn_t simcons_rx_irq(int irq, void *ptr)
+{
+	struct simcons_port *port = (struct simcons_port *)ptr;
+	struct tty_struct *tty = port->tty;
+	int count = 1;
+	int i;
+
+	/* If we change the simulator to allow us to report how many chars
+	   are available, this function has all the bits needed to do it
+	 */
+
+	/* If for one reason or another, we can't copy more data, we're done! */
+	if (count == 0)
+		return IRQ_HANDLED;
+
+	for (i = 0; i < count; i++) {
+		unsigned char ch = KEYBOARD_READ();
+
+#ifdef CONFIG_MAGIC_SYSRQ
+		/* We would normally check whether this is a console here */
+		if (ch == 0) {
+			if (port->sysrq == 0) {
+				port->sysrq = jiffies + HZ * 5;
+				continue;
+			} else {
+				port->sysrq = 0;
+			}
+		} else if (port->sysrq) {
+			if (time_before(jiffies, port->sysrq)) {
+				handle_sysrq(ch, regs, NULL);
+				port->sysrq = 0;
+				continue;
+			}
+			port->sysrq = 0;
+		}
+#endif
+
+		tty_insert_flip_char(tty, ch, TTY_NORMAL);
+	}
+
+	tty_schedule_flip(tty);
+
+	return IRQ_HANDLED;
+}
+
+static int simcons_open(struct tty_struct *tty, struct file *filp)
+{
+	struct simcons_port *port;
+	int line = tty->index;
+
+	if (line != 0) {
+		return -ENODEV;
+	}
+	port = &simcons_ports[line];
+	tty->driver_data = port;
+	port->tty = tty;
+
+	if (port->count == 0) {
+		if (request_irq
+		    (KEYBOARD_IRQ, simcons_rx_irq, 0, "simkeyboard", port)) {
+			printk(KERN_ERR "simcons: Cannot allocate irq %d\n",
+			       KEYBOARD_IRQ);
+			return -ENODEV;
+		}
+
+		if (!request_mem_region
+		    (KEYBOARD_PHYSICAL, KEYBOARD_RANGE, "simkeyboard")) {
+			free_irq(KEYBOARD_IRQ, port);
+			printk("simcons: Cannot allocate io region\n");
+			return -ENODEV;
+		}
+
+		keyreg = ioremap(KEYBOARD_PHYSICAL, KEYBOARD_RANGE);
+		if (keyreg == NULL) {
+			free_irq(KEYBOARD_IRQ, port);
+			release_mem_region(KEYBOARD_PHYSICAL, KEYBOARD_RANGE);
+			printk(KERN_ERR
+			       "simcons: Cannot get keyboard IO mem\n");
+			return -ENODEV;
+		}
+
+		/* Now enable the device */
+		KEYBOARD_ENABLE();
+	}
+
+	port->count++;
+	/* Nothing to do */
+	return 0;
+
+}
+
+static void simcons_close(struct tty_struct *tty, struct file *filp)
+{
+	struct simcons_port *port = (struct simcons_port *)tty->driver_data;
+	int line = tty->index;
+
+	if (line != 0)
+		return;
+
+	if (port->count == 0)
+		return;
+
+	if (--port->count == 0) {
+		KEYBOARD_DISABLE();
+		free_irq(KEYBOARD_IRQ, port);
+		release_mem_region(KEYBOARD_PHYSICAL, KEYBOARD_RANGE);
+		iounmap(keyreg);
+	}
+
+}
+
+static int simcons_write(struct tty_struct *tty, const unsigned char *buf,
+			 int count)
+{
+	down(&simcons_sem);
+
+	sim_write_string(buf, count);
+
+	up(&simcons_sem);
+
+	return count;
+}
+
+static int simcons_write_room(struct tty_struct *tty)
+{
+	if (tty->stopped)
+		return 0;
+	return 4096;		/* No limit, really; we're not buffering */
+}
+
+static int simcons_chars_in_buffer(struct tty_struct *tty)
+{
+	return 0;		/* we're not buffering */
+}
+
+static int simcons_ioctl(struct tty_struct *tty, struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	return -ENOIOCTLCMD;
+}
+
+static struct tty_operations simcons_ops = {
+	.open = simcons_open,
+	.close = simcons_close,
+	.write = simcons_write,
+	.write_room = simcons_write_room,
+	.chars_in_buffer = simcons_chars_in_buffer,
+	.ioctl = simcons_ioctl,
+};
+
+static int __init simcons_tty_init(void)
+{
+	int error;
+
+	simcons_driver = alloc_tty_driver(1);
+	if (!simcons_driver)
+		return -ENOMEM;
+
+	simcons_driver->owner = THIS_MODULE;
+	simcons_driver->driver_name = "simcons";
+	simcons_driver->name = "ttyFW";
+	simcons_driver->major = SIMCONS_MAJOR;
+	simcons_driver->minor_start = SIMCONS_MINOR;
+	simcons_driver->type = TTY_DRIVER_TYPE_SERIAL;
+	simcons_driver->subtype = SERIAL_TYPE_NORMAL;
+
+	simcons_driver->init_termios = tty_std_termios;
+	simcons_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_RESET_TERMIOS;
+
+	tty_set_operations(simcons_driver, &simcons_ops);
+
+	if ((error = tty_register_driver(simcons_driver))) {
+		printk(KERN_ERR
+		       "simcons: Couldn't register simcons driver, error = %d\n",
+		       error);
+		put_tty_driver(simcons_driver);
+		return 1;
+	}
+
+	return 0;
+}
+
+__initcall(simcons_tty_init);
+
+/*************************************************************/
+
+static void simconsole_write(struct console *console, const char *string,
+			     unsigned len)
+{
+	sim_write_string(string, len);
+}
+
+static struct tty_driver *simconsole_device(struct console *c, int *index)
+{
+	*index = c->index;
+	return simcons_driver;
+}
+
+static int simcons_registered = 0;
+static struct console simcons = {
+	.name = "ttyFW0",
+	.write = simconsole_write,
+	.device = simconsole_device,
+	.flags = CON_PRINTBUFFER,
+	.index = -1,
+};
+
+int __init simcons_console_init(void)
+{
+	if (!simcons_registered) {
+		simcons_registered = 1;
+		register_console(&simcons);
+	}
+}
+
+console_initcall(simcons_console_init);
diff --git a/arch/st200/drivers/simeth.c b/arch/st200/drivers/simeth.c
new file mode 100644
index 0000000..f97b653
--- /dev/null
+++ b/arch/st200/drivers/simeth.c
@@ -0,0 +1,282 @@
+#include <linux/module.h>
+
+#include <linux/sched.h>
+#include <linux/kernel.h>	/* printk() */
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* size_t */
+#include <linux/interrupt.h>	/* mark_bh */
+
+#include <linux/in.h>
+#include <linux/netdevice.h>	/* struct device, and other headers */
+#include <linux/etherdevice.h>	/* eth_type_trans */
+#include <linux/ip.h>		/* struct iphdr */
+#include <linux/tcp.h>		/* struct tcphdr */
+#include <linux/skbuff.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+
+#include <asm/checksum.h>
+
+/* Needed until we get the sg stuff working */
+extern void st200_flush_dcache_range(unsigned long start, unsigned long size);
+
+struct simeth_private {
+	int count;		/* number of times device opened */
+	void *simeth_base;	/* Address ioremap returns */
+	struct net_device_stats stats;	/* Standard etherner stats */
+};
+
+#define SIMETH_TX_ADDR 0
+#define SIMETH_TX_LEN  0x4
+#define SIMETH_RX_ADDR 0x8
+#define SIMETH_RX_LEN  0xc
+#define SIMETH_ENABLE  0x10
+
+#define CARDNAME "simeth"
+
+#define WRITE_REG(x,value) writel(value,priv->simeth_base+(x))
+#define READ_REG(x) readl(priv->simeth_base+(x))
+
+static irqreturn_t simeth_rx_irq(int irq, void *dev_id)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct simeth_private *priv = netdev_priv(dev);
+	struct sk_buff *skb;
+	int len;
+	unsigned char *p;
+
+	if (!dev)
+		return IRQ_NONE;
+
+	len = READ_REG(SIMETH_RX_LEN);
+
+	skb = dev_alloc_skb(len + 2);
+	if (!skb) {
+		printk("snull rx: low on mem - packet dropped\n");
+		WRITE_REG(SIMETH_RX_ADDR, 0);
+		priv->stats.rx_dropped++;
+		/* writing zero to the address will cause the driver to drop the packet */
+		return IRQ_NONE;
+	}
+	skb_reserve(skb, 2);	/* align IP on 16B boundary */
+
+	/* Ok, make sure none of that data is in the cache. Really should use the
+	 * scatter-gather api, but that doesn't work as yet
+	 */
+
+	p = skb_put(skb, len);
+	st200_flush_dcache_range((unsigned)p, len);
+	/* This will transfer the packet */
+	WRITE_REG(SIMETH_RX_ADDR, virt_to_phys(p));
+
+	skb->dev = dev;
+	skb->protocol = eth_type_trans(skb, dev);
+
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += len;
+
+	netif_rx(skb);
+
+	return IRQ_HANDLED;
+
+}
+
+/*
+ * Transmit a packet (called by the kernel)
+ */
+static int simeth_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	int len;
+	char *data;
+	struct simeth_private *priv = netdev_priv(dev);
+
+	len = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+	data = skb->data;
+	dev->trans_start = jiffies;	/* save the timestamp */
+
+	st200_flush_dcache_range((unsigned)skb->data, len);
+	/* This is about as simple as you are ever going to get
+	 * Instant transmission!!
+	 */
+	WRITE_REG(SIMETH_TX_ADDR, virt_to_phys(skb->data));
+	WRITE_REG(SIMETH_TX_LEN, len);
+
+	dev_kfree_skb_any(skb);
+
+	priv->stats.tx_packets++;
+	priv->stats.tx_bytes += len;
+
+	return 0;		/* Our simple device can not fail */
+}
+
+static int simeth_open(struct net_device *ndev)
+{
+	struct simeth_private *priv = netdev_priv(ndev);
+
+	/* Switch on the device */
+	WRITE_REG(SIMETH_ENABLE, 1);
+
+	netif_start_queue(ndev);
+
+	return 0;
+}
+
+static struct net_device_stats *simeth_stats(struct net_device *dev)
+{
+	struct simeth_private *priv = netdev_priv(dev);
+
+	return &priv->stats;
+}
+
+static int simeth_stop(struct net_device *ndev)
+{
+	struct simeth_private *priv = netdev_priv(ndev);
+
+	netif_stop_queue(ndev);	/* can't transmit any more */
+	unregister_netdev(ndev);
+
+	/* Switch off the device */
+	WRITE_REG(SIMETH_ENABLE, 0);
+
+	return 0;
+
+}
+
+static int simeth_dummy(struct platform_device *dev)
+{
+	return 0;
+}
+
+static int simeth_remove(struct platform_device *pdev)
+{
+//      struct platform_device *pdev = to_platform_device(dev);
+//      struct net_device *ndev = dev_get_drvdata(dev);
+//      struct simeth_private *priv = netdev_priv(ndev);
+
+#if 0
+	if (priv->count == 0)
+		return 0;
+
+	if (--priv->count == 0) {
+		/* Switch off the device */
+		WRITE_REG(SIMETH_ENABLE, 0);
+		netif_stop_queue(dev);	/* can't transmit any more */
+		unregister_netdev(dev);
+		free_irq(dev->irq, dev);
+		release_mem_region(SIMETH_PHYSICAL, SIMETH_RANGE);
+		iounmap(priv->simeth_base);
+		free_netdev(dev);
+		probed = 0;
+	}
+#endif
+
+	return 0;
+}
+
+static const struct net_device_ops simeth_netdev_ops = {
+	.ndo_open = simeth_open,
+	.ndo_stop = simeth_stop,
+	.ndo_start_xmit = simeth_tx,
+	.ndo_get_stats = simeth_stats,
+};
+
+static int simeth_probe(struct platform_device *pdev)
+{
+	struct net_device *ndev;
+	struct resource *res;
+	int reslen;
+	struct simeth_private *priv;
+	void *addr;
+	int ret;
+	int irq;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
+		//      goto out;
+	}
+
+	reslen = res->end - res->start + 1;
+
+	if (!request_mem_region(res->start, reslen, CARDNAME)) {
+		ret = -EBUSY;
+//              goto out;
+	}
+
+	ndev = alloc_etherdev(sizeof(struct simeth_private));
+
+	if (!ndev) {
+		printk("%s: could not allocate device.\n", CARDNAME);
+		ret = -ENOMEM;
+//              goto release_1;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+
+	if (request_irq(irq, simeth_rx_irq, 0, CARDNAME, ndev)) {
+		printk(KERN_ERR "simeth: Cannot allocate irq %d\n", irq);
+		//              ret = -ENODEV;
+	}
+
+	addr = ioremap(res->start, reslen);
+
+	if (!addr) {
+		printk(KERN_ERR "simeth: Cannot get simeth IO mem\n");
+		// Do correct error handling
+//         release_mem_region(SIMETH_PHYSICAL,SIMETH_RANGE);
+//         free_irq(dev->irq,dev);
+		// return -ENODEV;
+	}
+
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+
+	platform_set_drvdata(pdev, ndev);
+
+	priv = netdev_priv(ndev);
+	priv->simeth_base = addr;
+
+	ether_setup(ndev);
+	ndev->dma = (unsigned char)-1;
+	ndev->irq = irq;
+
+	ndev->netdev_ops = &simeth_netdev_ops;
+
+	/*
+	 * Assign the hardware address of the board: use "\0SNULx", where
+	 * x is 0 or 1. The first byte is '\0' to avoid being a multicast
+	 * address (the first byte of multicast addrs is odd).
+	 */
+	memcpy(ndev->dev_addr, "\0SNUL0", ETH_ALEN);
+
+	res = register_netdev(ndev);
+
+	printk("in simeth_prove register_netdev returns %d ndev->name=%s\n",
+	       res, ndev->name);
+
+	return 0;
+}
+
+static struct platform_driver simeth_driver = {
+	.probe = simeth_probe,
+	.remove = simeth_remove,
+	.suspend = simeth_dummy,
+	.resume = simeth_dummy,
+	.driver = {
+		   .name = "STM-" CARDNAME,
+		   }
+};
+
+static int __init simeth_init(void)
+{
+	return platform_driver_register(&simeth_driver);
+}
+
+static void __exit simeth_cleanup(void)
+{
+	platform_driver_unregister(&simeth_driver);
+}
+
+module_init(simeth_init);
+module_exit(simeth_cleanup);
diff --git a/arch/st200/include/asm/Kbuild b/arch/st200/include/asm/Kbuild
new file mode 100644
index 0000000..c68e168
--- /dev/null
+++ b/arch/st200/include/asm/Kbuild
@@ -0,0 +1 @@
+include include/asm-generic/Kbuild.asm
diff --git a/arch/st200/include/asm/atomic.h b/arch/st200/include/asm/atomic.h
new file mode 100644
index 0000000..95a3f90
--- /dev/null
+++ b/arch/st200/include/asm/atomic.h
@@ -0,0 +1,312 @@
+/*
+ *  include/asm-st200/atomic.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *	        Dave Mckay <david.mckay@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_ATOMIC_H
+#define _ASM_ST200_ATOMIC_H
+
+#include <linux/types.h>
+
+/*
+ * Atomic operations that C can't guarantee us.  Useful for
+ * resource counting etc..
+ *
+ */
+
+#define ATOMIC_INIT(i)	{ (i) }
+
+/**
+ * atomic_read - read atomic variable
+ * @v: pointer of type atomic_t
+ *
+ * Atomically reads the value of @v.
+ */
+#define atomic_read(v)		((v)->counter)
+
+/**
+ * atomic_set - set atomic variable
+ * @v: pointer of type atomic_t
+ * @i: required value
+ *
+ * Atomically sets the value of @v to @i.
+ */
+#define atomic_set(v,i)		((v)->counter = (i))
+
+/**
+ * atomic_add - add integer to atomic variable
+ * @i: integer value to add
+ * @v: pointer of type atomic_t
+ *
+ * Atomically adds @i to @v.
+ */
+static inline void atomic_add(int i, atomic_t * v)
+{
+	int tmp;
+
+	asm volatile ("1 : ldw %0   = 0[%1] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    add %0 = %0,%2 \n"
+		      "    ;; \n"
+		      "    stw 0[%1] = %0 \n"
+		      "    and $r12 = $r12,~1\n":"=&r" (tmp)
+		      :"r"(v), "r"(i)
+		      :"r62", "memory");
+}
+
+/**
+ * atomic_sub - subtract the atomic variable
+ * @i: integer value to subtract
+ * @v: pointer of type atomic_t
+ *
+ * Atomically subtracts @i from @v.
+ */
+static inline void atomic_sub(int i, atomic_t * v)
+{
+	int tmp;
+
+	asm volatile ("1 : ldw %0   = 0[%1] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    sub %0 = %0,%2 \n"
+		      "    ;; \n"
+		      "    stw 0[%1] = %0 \n"
+		      "    and $r12 = $r12,~1\n":"=&r" (tmp)
+		      :"r"(v), "r"(i)
+		      :"r62", "memory");
+}
+
+static inline int atomic_add_return(int i, atomic_t * v)
+{
+	int tmp;
+
+	asm volatile ("1 : ldw %0   = 0[%1] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    add %0 = %0,%2 \n"
+		      "    ;; \n"
+		      "    stw 0[%1] = %0 \n"
+		      "    and $r12 = $r12,~1\n":"=&r" (tmp)
+		      :"r"(v), "r"(i)
+		      :"r62", "memory");
+	return tmp;
+}
+
+static inline int atomic_sub_return(int i, atomic_t * v)
+{
+	int tmp;
+
+	asm volatile ("1 : ldw %0   = 0[%1] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    sub %0 = %0,%2 \n"
+		      "    ;; \n"
+		      "    stw 0[%1] = %0 \n"
+		      "    and $r12 = $r12,~1\n":"=&r" (tmp)
+		      :"r"(v), "r"(i)
+		      :"r62", "memory");
+
+	return tmp;
+}
+
+static inline int atomic_inc_return(atomic_t * v)
+{
+	int tmp;
+
+	asm volatile ("1 : ldw %0   = 0[%1] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    add %0 = %0,1 \n"
+		      "    ;; \n"
+		      "    stw 0[%1] = %0 \n"
+		      "    and $r12 = $r12,~1\n":"=&r" (tmp)
+		      :"r"(v)
+		      :"r62", "memory");
+
+	return tmp;
+}
+
+static inline int atomic_dec_return(atomic_t * v)
+{
+	int tmp;
+
+	asm volatile ("1 : ldw %0   = 0[%1] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    add %0 = %0,-1 \n"
+		      "    ;; \n"
+		      "    stw 0[%1] = %0 \n"
+		      "    and $r12 = $r12,~1\n":"=&r" (tmp)
+		      :"r"(v)
+		      :"r62", "memory");
+
+	return tmp;
+}
+
+/**
+ * atomic_sub_and_test - subtract value from variable and test result
+ * @i: integer value to subtract
+ * @v: pointer of type atomic_t
+ *
+ * Atomically subtracts @i from @v and returns
+ * true if the result is zero, or false for all
+ * other cases.
+ */
+
+#define atomic_sub_and_test(i,v) (atomic_sub_return((i), (v)) == 0)
+
+/**
+ * atomic_inc - increment atomic variable
+ * @v: pointer of type atomic_t
+ *
+ * Atomically increments @v by 1
+ */
+
+static inline void atomic_inc(atomic_t * v)
+{
+	int tmp;
+
+	asm volatile ("1 : ldw %0   = 0[%1] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    add %0 = %0,1 \n"
+		      "    ;; \n"
+		      "    stw 0[%1] = %0 \n"
+		      "    and $r12 = $r12,~1":"=&r" (tmp)
+		      :"r"(v)
+		      :"r62", "memory");
+}
+
+/**
+ * atomic_dec - decrement atomic variable
+ * @v: pointer of type atomic_t
+ *
+ * Atomically decrements @v by 1.
+ */
+
+static inline void atomic_dec(atomic_t * v)
+{
+	int tmp;
+
+	asm volatile ("1 : ldw %0   = 0[%1] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    add %0 = %0,-1 \n"
+		      "    ;; \n"
+		      "    stw 0[%1] = %0 \n"
+		      "    and $r12 = $r12,~1":"=&r" (tmp)
+		      :"r"(v)
+		      :"r62", "memory");
+}
+
+/**
+ * atomic_dec_and_test - decrement and test
+ * @v: pointer of type atomic_t
+ *
+ * Atomically decrements @v by 1 and
+ * returns true if the result is 0, or false for all other
+ * cases.
+ */
+
+#define atomic_dec_and_test(v) (atomic_dec_return(v) == 0)
+
+/**
+ * atomic_inc_and_test - increment and test
+ * @v: pointer of type atomic_t
+ *
+ * Atomically increments @v by 1
+ * and returns true if the result is zero, or false for all
+ * other cases.
+ */
+#define atomic_inc_and_test(v) (atomic_inc_return(v) == 0)
+
+/**
+ * atomic_add_negative - add and test if negative
+ * @v: pointer of type atomic_t
+ * @i: integer value to add
+ *
+ * Atomically adds @i to @v and returns true
+ * if the result is negative, or false when
+ * result is greater than or equal to zero.
+ */
+#define atomic_add_negative(i, v) (atomic_add_return(i, (v)) < 0)
+
+#define atomic_cmpxchg(v, old, new) ((int)cmpxchg(&((v)->counter), old, new))
+#define atomic_xchg(v, new) (xchg(&((v)->counter), new))
+
+/**
+ * atomic_add_unless - add unless the number is a given value
+ * @v: pointer of type atomic_t
+ * @a: the amount to add to v...
+ * @u: ...unless v is equal to u.
+ *
+ * Atomically adds @a to @v, so long as it was not @u.
+ * Returns non-zero if @v was not @u, and zero otherwise.
+ */
+static inline int atomic_add_unless(atomic_t * v, int a, int u)
+{
+	int val, res;
+
+	asm volatile ("1 : ldw %0   = 0[%2] \n" "    mov $r62 = 1b \n" "    or  $r12 = $r12,1 \n" "    ;; \n" "    cmpne $b7 = %0,%4 \n" "	  cmpne %1 = %0,%4 \n" "    add %0 = %0,%3 \n" "    ;; \n" "	  brf $b7,2f\n" "    ;; \n" "    stw 0[%2] = %0 \n" "    and $r12 = $r12,~1 \n" "    ;; \n" "2:  and $r12 = $r12,~1 ":"=&r" (val) /* %0 */ , "=&r"(res)	/* %1 */
+		      :"r"(v) /* %2 */ , "r"(a) /* %3 */ , "r"(u)	/* %4 */
+		      :"r62", "memory", "b7");
+
+	return res;
+}
+
+#define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
+
+static inline void atomic_clear_mask(unsigned int mask, atomic_t * v)
+{
+	int tmp;
+
+	asm volatile ("1 : ldw %0   = 0[%1] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    and %0 = %0,%2 \n"
+		      "    ;; \n"
+		      "    stw 0[%1] = %0 \n"
+		      "    and $r12 = $r12,~1":"=&r" (tmp)
+		      :"r"(v), "r"(~mask)
+		      :"r62", "memory");
+}
+
+static inline void atomic_set_mask(unsigned int mask, atomic_t * v)
+{
+	int tmp;
+
+	asm volatile ("1 : ldw %0   = 0[%1] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    or %0 = %0,%2 \n"
+		      "    ;; \n"
+		      "    stw 0[%1] = %0 \n"
+		      "    and $r12 = $r12,~1":"=&r" (tmp)
+		      :"r"(v), "r"(mask)
+		      :"r62", "memory");
+}
+
+/* Atomic operations are already serializing */
+#define smp_mb__before_atomic_dec()	barrier()
+#define smp_mb__after_atomic_dec()	barrier()
+#define smp_mb__before_atomic_inc()	barrier()
+#define smp_mb__after_atomic_inc()	barrier()
+
+#include <asm-generic/atomic-long.h>
+
+#endif /* _ASM_ST200_ATOMIC_H */
diff --git a/arch/st200/include/asm/auxvec.h b/arch/st200/include/asm/auxvec.h
new file mode 100644
index 0000000..5df4ef3
--- /dev/null
+++ b/arch/st200/include/asm/auxvec.h
@@ -0,0 +1,6 @@
+#ifndef _ASM_ST200_AUXVEC_H
+#define _ASM_ST200_AUXVEC_H
+
+#define AT_SYSINFO_EHDR		33
+
+#endif /* _ASM_ST200_AUXVEC_H */
diff --git a/arch/st200/include/asm/bitops.h b/arch/st200/include/asm/bitops.h
new file mode 100644
index 0000000..8458046
--- /dev/null
+++ b/arch/st200/include/asm/bitops.h
@@ -0,0 +1,238 @@
+/*
+ *  include/asm-st200/bitops.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: David McKay <david.mckay@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_BITOPS_H
+#define _ASM_ST200_BITOPS_H
+
+#ifndef _LINUX_BITOPS_H
+#error only <linux/bitops.h> can be included directly
+#endif
+
+#ifdef __KERNEL__
+
+/*
+ * All bit operations return 0 if the bit was cleared before the
+ * operation and != 0 if it was not.
+ *
+ * bit 0 is the LSB of addr; bit 32 is the LSB of (addr+1).
+ */
+
+/**
+ * set_bit - Atomically set a bit in memory
+ * @nr: the bit to set
+ * @addr: the address to start counting from
+ *
+ * This function is atomic and may not be reordered.  See __set_bit()
+ * if you do not require the atomic guarantees.
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ */
+static inline void set_bit(int nr, volatile unsigned long *addr)
+{
+	int mask;
+	volatile unsigned long *a = addr;
+	unsigned long tmp;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+
+	asm volatile ("1 : ldw %0   = 0[%1] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    or %0 = %0,%2 \n"
+		      "    ;; \n"
+		      "    stw 0[%1] = %0 \n"
+		      "    and $r12 = $r12,~1\n":"=&r" (tmp)
+		      :"r"(a), "r"(mask)
+		      :"r62", "memory");
+}
+
+/**
+ * clear_bit - Clears a bit in memory
+ * @nr: Bit to clear
+ * @addr: Address to start counting from
+ *
+ * clear_bit() is atomic and may not be reordered.  However, it does
+ * not contain a memory barrier, so if it is used for locking purposes,
+ * you should call smp_mb__before_clear_bit() and/or smp_mb__after_clear_bit()
+ * in order to ensure changes are visible on other processors.
+ */
+static inline void clear_bit(int nr, volatile unsigned long *addr)
+{
+	int mask;
+	volatile unsigned long *a = addr;
+	unsigned long tmp;
+
+	a += nr >> 5;
+	mask = ~(1 << (nr & 0x1f));
+
+	asm volatile ("1 : ldw %0   = 0[%1] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    and %0 = %0,%2 \n"
+		      "    ;; \n"
+		      "    stw 0[%1] = %0 \n"
+		      "    and $r12 = $r12,~1\n":"=&r" (tmp)
+		      :"r"(a), "r"(mask)
+		      :"r62", "memory");
+}
+
+#define smp_mb__before_clear_bit()	barrier()
+#define smp_mb__after_clear_bit()	barrier()
+
+/**
+ * change_bit - Toggle a bit in memory
+ * @nr: Bit to change
+ * @addr: Address to start counting from
+ *
+ * change_bit() is atomic and may not be reordered.
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ */
+static inline void change_bit(int nr, volatile unsigned long *addr)
+{
+	int mask;
+	volatile unsigned long *a = addr;
+	unsigned long tmp;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	asm volatile ("1 : ldw %0   = 0[%1] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    xor %0 = %0,%2 \n"
+		      "    ;; \n"
+		      "    stw 0[%1] = %0 \n"
+		      "    and $r12 = $r12,~1\n":"=&r" (tmp)
+		      :"r"(a), "r"(mask)
+		      :"r62", "memory");
+
+}
+
+/**
+ * test_and_set_bit - Set a bit and return its old value
+ * @nr: Bit to set
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.
+ * It also implies a memory barrier.
+ */
+static inline int test_and_set_bit(int nr, volatile unsigned long *addr)
+{
+	int mask, retval;
+	volatile unsigned long *a = addr;
+	unsigned long tmp;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+
+	asm volatile ("1 : ldw %0   = 0[%2] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    and %1 = %0,%3\n"
+		      "    or %0 = %0,%3 \n"
+		      "    ;; \n"
+		      "    cmpne %1 = %1,0\n"
+		      "    stw 0[%2] = %0 \n"
+		      "    and $r12 = $r12,~1\n":"=&r" (tmp), "=&r"(retval)
+		      :"r"(a), "r"(mask)
+		      :"r62", "memory");
+
+	return retval;
+}
+
+/**
+ * test_and_clear_bit - Clear a bit and return its old value
+ * @nr: Bit to clear
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.
+ * It also implies a memory barrier.
+ */
+static inline int test_and_clear_bit(int nr, volatile unsigned long *addr)
+{
+	int mask, retval;
+	volatile unsigned long *a = addr;
+	unsigned long tmp;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+
+	asm volatile ("1 : ldw %0   = 0[%2] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    and %1 = %0,%3\n"
+		      "    and %0 = %0,%4 \n"
+		      "    ;; \n"
+		      "    cmpne %1 = %1,0\n"
+		      "    stw 0[%2] = %0 \n"
+		      "    and $r12 = $r12,~1\n":"=&r" (tmp), "=&r"(retval)
+		      :"r"(a), "r"(mask), "r"(~mask)
+		      :"r62", "memory");
+
+	return retval;
+}
+
+/**
+ * test_and_change_bit - Change a bit and return its old value
+ * @nr: Bit to change
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.
+ * It also implies a memory barrier.
+ */
+static __inline__ int test_and_change_bit(int nr, volatile unsigned long *addr)
+{
+	int mask, retval;
+	volatile unsigned long *a = addr;
+	unsigned long tmp;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+
+	asm volatile ("1 : ldw %0   = 0[%2] \n"
+		      "    mov $r62 = 1b \n"
+		      "    or  $r12 = $r12,1 \n"
+		      "    ;; \n"
+		      "    and %1 = %0,%3\n"
+		      "    xor %0 = %0,%3 \n"
+		      "    ;; \n"
+		      "    cmpne %1 = %1,0\n"
+		      "    stw 0[%2] = %0 \n"
+		      "    and $r12 = $r12,~1\n":"=&r" (tmp), "=&r"(retval)
+		      :"r"(a), "r"(mask)
+		      :"r62", "memory");
+
+	return retval;
+}
+
+#include <linux/compiler.h>
+
+#include <asm-generic/bitops/non-atomic.h>
+#include <asm-generic/bitops/find.h>
+#include <asm-generic/bitops/ffz.h>
+#include <asm-generic/bitops/ffs.h>
+#include <asm-generic/bitops/__ffs.h>
+#include <asm-generic/bitops/fls.h>
+#include <asm-generic/bitops/__fls.h>
+#include <asm-generic/bitops/fls64.h>
+#include <asm-generic/bitops/hweight.h>
+#include <asm-generic/bitops/sched.h>
+#include <asm-generic/bitops/ext2-non-atomic.h>
+#include <asm-generic/bitops/ext2-atomic.h>
+#include <asm-generic/bitops/minix.h>
+#include <asm-generic/bitops/lock.h>
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_ST200_BITOPS_H */
diff --git a/arch/st200/include/asm/bitsperlong.h b/arch/st200/include/asm/bitsperlong.h
new file mode 100644
index 0000000..6dc0bb0
--- /dev/null
+++ b/arch/st200/include/asm/bitsperlong.h
@@ -0,0 +1 @@
+#include <asm-generic/bitsperlong.h>
diff --git a/arch/st200/include/asm/bug.h b/arch/st200/include/asm/bug.h
new file mode 100644
index 0000000..3fdb6a6
--- /dev/null
+++ b/arch/st200/include/asm/bug.h
@@ -0,0 +1,14 @@
+/*
+ *  include/asm-st200/io.h
+ *
+ *  Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: David McKay <david.mckay@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_BUG_H
+#define _ASM_ST200_BUG_H
+
+#include <asm-generic/bug.h>
+
+#endif /* _ASM_ST200_BUG_H */
diff --git a/arch/st200/include/asm/bugs.h b/arch/st200/include/asm/bugs.h
new file mode 100644
index 0000000..dc8f80f
--- /dev/null
+++ b/arch/st200/include/asm/bugs.h
@@ -0,0 +1,26 @@
+/*
+ *  include/asm-st200/bugs.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_BUGS_H
+#define _ASM_ST200_BUGS_H
+
+/*
+ * This is included by init/main.c to check for architecture-dependent bugs.
+ *
+ * Needs:
+ *	void check_bugs(void);
+ */
+
+#include <linux/init.h>
+
+static void __init check_bugs(void)
+{
+	printk("CPU: ST200\n");
+}
+
+#endif /* _ASM_ST200_BUGS_H */
diff --git a/arch/st200/include/asm/byteorder.h b/arch/st200/include/asm/byteorder.h
new file mode 100644
index 0000000..c6ce1ac
--- /dev/null
+++ b/arch/st200/include/asm/byteorder.h
@@ -0,0 +1,22 @@
+/*
+ *  include/asm-st200/byteorder.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_BYTEORDER_H
+#define _ASM_ST200_BYTEORDER_H
+
+#include <asm/types.h>
+#include <linux/compiler.h>
+
+#if !defined(__STRICT_ANSI__) || defined(__KERNEL__)
+#  define __BYTEORDER_HAS_U64__
+#  define __SWAB_64_THRU_32__
+#endif
+
+#include <linux/byteorder/little_endian.h>
+
+#endif /* _ASM_ST200_BYTEORDER_H */
diff --git a/arch/st200/include/asm/cache.h b/arch/st200/include/asm/cache.h
new file mode 100644
index 0000000..614075a
--- /dev/null
+++ b/arch/st200/include/asm/cache.h
@@ -0,0 +1,14 @@
+/*
+ * include/asm-st200/cache.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+#ifndef _ASM_ST200_CACHE_H
+#define _ASM_ST200_CACHE_H
+
+#define L1_CACHE_SHIFT	5
+#define L1_CACHE_BYTES	(1 << L1_CACHE_SHIFT)
+
+#endif /* _ASM_ST200_CACHE_H */
diff --git a/arch/st200/include/asm/cacheflush.h b/arch/st200/include/asm/cacheflush.h
new file mode 100644
index 0000000..4c8ea47
--- /dev/null
+++ b/arch/st200/include/asm/cacheflush.h
@@ -0,0 +1,73 @@
+/*
+ * include/asm-st200/cacheflush.h
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_CACHEFLUSH_H
+#define _ASM_ST200_CACHEFLUSH_H
+
+#include <linux/mm.h>
+
+/*
+ * This is called when changing a kernel virtual to physical mapping.
+ * Called from ioremap, vmalloc and vmap.
+ */
+#define flush_cache_all()			do { } while (0)
+
+/*
+ * The next three calls are used when changing a user space virtual
+ * to physical mapping, before the call to flush_tlb_...().
+ * For example:
+ *	flush_cache_mm		called from mmap
+ *	flush_cache_dup_mm      called from fork
+ *	flush_cache_range	called from mmap, mprotect, mremap and msync.
+ *	flush_cache_page	called when copying COW page, swapping pages
+ *				out, while generating core dumps and ptrace.
+ */
+#define flush_cache_mm(mm)			do { } while (0)
+#define flush_cache_dup_mm(mm)			do { } while (0)
+#define flush_cache_range(vma, start, end)	do { } while (0)
+#define flush_cache_page(vma, vmaddr,pfn)	do { } while (0)
+#define flush_cache_vmap(start, end)            do { } while (0)
+#define flush_cache_vunmap(start, end)          do { } while (0)
+
+/*
+ * Called when page is first assigned to a pte.
+ * Called when faulting or swapping in a page.
+ */
+#define flush_icache_page(vma, page)		do { } while (0)
+
+/*
+ * Used to synchronise the user mapping of a page and the page cache
+ * version. Called after the kernel has written to the page OR the
+ * user has potentially written to it and the kernel needs to read it.
+ */
+void flush_dcache_page(struct page *page);
+
+#define flush_dcache_mmap_lock(mapping)         do { } while (0)
+#define flush_dcache_mmap_unlock(mapping)       do { } while (0)
+
+/*
+ * Used when the kernel has modified memory it is going to execute.
+ * Used when loading a kernel module or binfmt_flat files in uCLinux.
+ */
+void flush_icache_range(unsigned long start, unsigned long end);
+
+/*
+ * Used when the kernel has modified a user page via the kernel mapping.
+ * Currently only used by ptrace.
+ */
+void flush_icache_user_range(struct vm_area_struct *vma,
+			     struct page *page, unsigned long addr, int len);
+
+#define copy_to_user_page(vma, page, vaddr, dst, src, len) \
+do { memcpy(dst, src, len); \
+     flush_icache_user_range(vma, page, vaddr, len); \
+} while (0)
+#define copy_from_user_page(vma, page, vaddr, dst, src, len) \
+        memcpy(dst, src, len)
+
+#endif /* _ASM_ST200_CACHEFLUSH_H */
diff --git a/arch/st200/include/asm/checksum.h b/arch/st200/include/asm/checksum.h
new file mode 100644
index 0000000..adbb5e6
--- /dev/null
+++ b/arch/st200/include/asm/checksum.h
@@ -0,0 +1 @@
+#include <asm-generic/checksum.h>
diff --git a/arch/st200/include/asm/clock.h b/arch/st200/include/asm/clock.h
new file mode 100644
index 0000000..02be94e
--- /dev/null
+++ b/arch/st200/include/asm/clock.h
@@ -0,0 +1,53 @@
+
+#ifndef __ASM_ST200_CLOCK_H
+#define __ASM_ST200_CLOCK_H
+
+#include <linux/kref.h>
+#include <linux/list.h>
+#include <linux/seq_file.h>
+#include <linux/clk.h>
+
+struct clk;
+
+struct clk_ops {
+	void (*init) (struct clk * clk);
+	void (*enable) (struct clk * clk);
+	void (*disable) (struct clk * clk);
+	void (*recalc) (struct clk * clk);
+	int (*set_rate) (struct clk * clk, unsigned long rate, int algo_id);
+	long (*round_rate) (struct clk * clk, unsigned long rate);
+};
+
+struct clk {
+	struct list_head node;
+	const char *name;
+	int id;
+	struct module *owner;
+
+	struct clk *parent;
+	struct clk_ops *ops;
+
+	struct kref kref;
+
+	unsigned long rate;
+	unsigned long flags;
+};
+
+#define CLK_ALWAYS_ENABLED	(1 << 0)
+#define CLK_RATE_PROPAGATES	(1 << 1)
+
+/* Should be defined by processor-specific code */
+void arch_init_clk_ops(struct clk_ops **, int type);
+
+/* arch/sh/kernel/cpu/clock.c */
+int clk_init(void);
+
+int __clk_enable(struct clk *);
+void __clk_disable(struct clk *);
+
+void clk_recalc_rate(struct clk *);
+
+int clk_register(struct clk *);
+void clk_unregister(struct clk *);
+
+#endif /* __ASM_ST200_CLOCK_H */
diff --git a/arch/st200/include/asm/cputime.h b/arch/st200/include/asm/cputime.h
new file mode 100644
index 0000000..c40dbba
--- /dev/null
+++ b/arch/st200/include/asm/cputime.h
@@ -0,0 +1,6 @@
+#ifndef __ST200_CPUTIME_H
+#define __ST200_CPUTIME_H
+
+#include <asm-generic/cputime.h>
+
+#endif /* __ST200_CPUTIME_H */
diff --git a/arch/st200/include/asm/ctrlregdef-231.h b/arch/st200/include/asm/ctrlregdef-231.h
new file mode 100644
index 0000000..a63ec32
--- /dev/null
+++ b/arch/st200/include/asm/ctrlregdef-231.h
@@ -0,0 +1,152 @@
+/*
+ * include/asm-st200/ctrlregdef-230.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * Control register defintions for ST230
+ */
+
+#ifndef _ASM_ST200_CTRLREGDEFS_230_H
+#define _ASM_ST200_CTRLREGDEFS_230_H
+
+/* Exception cause as an integer, indicating the cause of the last trap. */
+#define EXCAUSENO	CTRL_ADDR(0xff88)
+
+/* TLB related control registers */
+#define TLB_INDEX	CTRL_ADDR(0xff80)	/* Index of the TLB entry pointed to by TLB_ENTRYx */
+#define TLB_ENTRY0	CTRL_ADDR(0xff78)	/* TLB entry bits  [31:00] */
+#define TLB_ENTRY1	CTRL_ADDR(0xff70)	/* TLB entry bits  [63:32] */
+#define TLB_ENTRY2	CTRL_ADDR(0xff68)	/* TLB entry bits  [95:64] */
+#define TLB_ENTRY3	CTRL_ADDR(0xff60)	/* TLB entry bits [127:96] */
+#define TLB_EXCAUSE	CTRL_ADDR(0xff58)	/* Cause of the TLB related exception */
+#define TLB_CONTROL	CTRL_ADDR(0xff50)	/* Control bits for TLB */
+#define TLB_REPLACE	CTRL_ADDR(0xff48)	/* Replacement pointer */
+#define TLB_ASID	CTRL_ADDR(0xff40)	/* Current address space ID */
+
+#define SCU_BASE0	CTRL_ADDR(0xd000)	/* SCU base 0. */
+#define SCU_LIMIT0	CTRL_ADDR(0xd008)	/* SCU limit 0. */
+#define SCU_BASE1	CTRL_ADDR(0xd010)	/* SCU base 1. */
+#define SCU_LIMIT1	CTRL_ADDR(0xd018)	/* SCU limit 1. */
+#define SCU_BASE2	CTRL_ADDR(0xd020)	/* SCU base 2. */
+#define SCU_LIMIT2	CTRL_ADDR(0xd028)	/* SCU limit 2. */
+#define SCU_BASE3	CTRL_ADDR(0xd030)	/* SCU base 3. */
+#define SCU_LIMIT3	CTRL_ADDR(0xd038)	/* SCU limit 3. */
+#define SCU_BASE(n)     CTRL_ADDR(0xd000+(0x10*(n)))	/* SCU base n */
+#define SCU_LIMIT(n)    CTRL_ADDR(0xd008+(0x10*(n)))	/* SCU limit n */
+#define SCU_NUM_ENTRIES 4
+
+#define SCU_SHIFT	13
+
+/************ PSW bit definitions ************/
+#define PSW_USER_MODE			(1<< 0)	/* When 1 the core is in user mode, otherwise supervisor mode. */
+#define PSW_INT_ENABLE			(1<< 1)	/* When 1 external interrupts are enabled. */
+#define PSW_TLB_ENABLE			(1<< 2)	/* When 1 address translation is enabled. */
+#define PSW_TLB_DYNAMIC			(1<< 3)	/* When 1 purges and speculative loads which miss the TLB cause TLB_NO_MAPPING exceptions. */
+#define PSW_SPECLOAD_MALIGNTRAP_EN	(1<< 4)	/* When 1 enables exceptions on speculative load misalignment errors. */
+#define PSW_DBREAK_ENABLE		(1<< 8)	/* When 1 data breakpoints are enabled. */
+#define PSW_IBREAK_ENABLE		(1<< 9)	/* When 1 instruction breakpoints are enabled. */
+#define PSW_DEBUG_MODE			(1<<12)	/* When 1 the core is in debug mode. */
+
+/* These are the default things we always stick in the PSW, separated out for
+ * user and kernel. Done like this for uclinux, which doesn't appreciate
+ * having the TLB turned on!
+ */
+#define PSW_KERNEL_NOSPEC	(PSW_TLB_ENABLE|PSW_SPECLOAD_MALIGNTRAP_EN)
+#define PSW_KERNEL_DEFAULT	(PSW_TLB_ENABLE|PSW_SPECLOAD_MALIGNTRAP_EN|PSW_TLB_DYNAMIC)
+#define PSW_USER_DEFAULT	(PSW_TLB_ENABLE|PSW_TLB_DYNAMIC|PSW_USER_MODE)
+
+/* TLB bit definitions */
+#define TLB_ENTRY0_ASID_MASK		0xff
+#define TLB_ENTRY0_SHARED		(1<< 8)	/* Page shared by multiple processes (ASID ignored). */
+#define TLB_ENTRY0_PROT_SUPER_X		(1<< 9)
+#define TLB_ENTRY0_PROT_SUPER_R		(2<< 9)
+#define TLB_ENTRY0_PROT_SUPER_W		(4<< 9)
+#define TLB_ENTRY0_PROT_SUPER_RWX	\
+	(TLB_ENTRY0_PROT_SUPER_X | TLB_ENTRY0_PROT_SUPER_R | TLB_ENTRY0_PROT_SUPER_W)
+#define TLB_ENTRY0_PROT_USER_X		(1<<12)
+#define TLB_ENTRY0_PROT_USER_R		(2<<12)
+#define TLB_ENTRY0_PROT_USER_W		(4<<12)
+#define TLB_ENTRY0_PROT_USER_RWX	\
+	(TLB_ENTRY0_PROT_USER_X | TLB_ENTRY0_PROT_USER_R | TLB_ENTRY0_PROT_USER_W)
+#define TLB_ENTRY0_DIRTY		(1<<15)	/* Page is dirty. When this bit is 0 write accesses to this page (when write permission is allowed) cause a TLB_WRITE_TO_CLEAN exception. When this bit is 1 writes to this page (when write permission is allowed) are permitted. */
+#define TLB_ENTRY0_POLICY_MASK		(15<<16)
+#define TLB_ENTRY0_POLICY_UNCACHED	(0<<16)	/* Non cached */
+#define TLB_ENTRY0_POLICY_CACHED	(1<<16)	/* Cached */
+#define TLB_ENTRY0_POLICY_WCUNCACHED	(2<<16)	/* Write combining */
+#define TLB_ENTRY0_SIZE_MASK		(7<<20)
+#define TLB_ENTRY0_SIZE_DISABLED	(0<<20)	/* Disabled */
+#define TLB_ENTRY0_SIZE_8K		(1<<20)	/* 8Kb */
+#define TLB_ENTRY0_SIZE_4M		(2<<20)	/* 4MB */
+#define TLB_ENTRY0_SIZE_256M		(3<<20)	/* 256MB */
+
+#define TLB_ENTRY1_VADDR_MASK		0x0007ffff	/* For 8K pages */
+#define TLB_ENTRY1_VADDR_SHIFT		13
+
+#define TLB_ENTRY2_PADDR_MASK		0x0007ffff	/* For 8K pages */
+#define TLB_ENTRY2_PADDR_SHIFT		13
+
+/* TLB_REPLACE masks */
+#define TLB_REPLACE_LFSR_MASK		0xffff
+#define TLB_REPLACE_LIMIT_SHIFT		16
+
+/* TLB_CONTROL masks */
+#define TLB_CONTROL_ITLB_FLUSH		(1<<0)
+#define TLB_CONTROL_DTLB_FLUSH		(1<<1)
+
+/* TLB_ASID masks */
+#define TLB_ASID_ASID_MASK		0xff
+
+/* TLB_EXCAUSE bit defintions */
+#define TLB_EXCAUSE_INDEX_MASK		0x3f
+#define TLB_EXCAUSE_CAUSE_MASK			(3<<16)
+#define TLB_EXCAUSE_CAUSE_NO_MAPPING		(0<<16)
+#define TLB_EXCAUSE_CAUSE_PROT_VIOLATION	(1<<16)
+#define TLB_EXCAUSE_CAUSE_WRITE_TO_CLEAN	(2<<16)
+#define TLB_EXCAUSE_CAUSE_MULTI_MAPPING		(3<<16)
+#define TLB_EXCAUSE_SPEC	(1<<18)
+#define TLB_EXCAUSE_WRITE	(1<<19)
+#define TLB_EXCAUSE_IN_UTLB	(1<<20)
+
+/* EXCAUSENO definitions */
+#define EXCAUSENO_STBUS_IC_ERROR	 0	/* The Instruction Cache caused a bus error. */
+#define EXCAUSENO_STBUS_DC_ERROR	 1	/* The Data Cache caused a bus error. */
+#define EXCAUSENO_EXTERN_INT		 2	/* There was an external interrupt. */
+#define EXCAUSENO_IBREAK		 3	/* An instruction address breakpoint has occured. */
+#define EXCAUSENO_ITLB			 4	/* Instruction side TLB exception */
+#define EXCAUSENO_SBREAK		 5	/* A software breakpoint was found. */
+#define EXCAUSENO_ILL_INST		 6	/* The bundle could not be decoded into legal sequence of operations or a privileged operation is being issued in user mode. */
+#define EXCAUSENO_SYSCALL		 7	/* A syscall instruction was found */
+#define EXCAUSENO_DBREAK		 8	/* The DPU has triggered a breakpoint on a data address. */
+#define EXCAUSENO_MISALIGNED_TRAP	 9	/* The address is misaligned and misaligned accesses are not supported. */
+#define EXCAUSENO_CREG_NO_MAPPING	10	/* The load or store address was in control register space, but no control register exists at that exact address. */
+#define EXCAUSENO_CREG_ACCESS_VIOLATION	11	/* A store to a control register was attempted whilst in user mode. */
+#define EXCAUSENO_DTLB			12	/* Data side TLB exception */
+#define EXCAUSENO_SDI_TIMEOUT		14	/* One of the SDI interfaces timed out while being accessed. */
+
+/* EXCAUSE bit definitions */
+#define EXCAUSE_STBUS_IC_ERROR		(1<<EXCAUSENO_STBUS_IC_ERROR)
+#define EXCAUSE_STBUS_DC_ERROR		(1<<EXCAUSENO_STBUS_DC_ERROR)
+#define EXCAUSE_EXTERN_INT		(1<<EXCAUSENO_EXTERN_INT)
+#define EXCAUSE_IBREAK			(1<<EXCAUSENO_IBREAK)
+#define EXCAUSE_ITLB			(1<<EXCAUSENO_ITLB)
+#define EXCAUSE_SBREAK			(1<<EXCAUSENO_SBREAK)
+#define EXCAUSE_ILL_INST		(1<<EXCAUSENO_ILL_INST)
+#define EXCAUSE_SYSCALL			(1<<EXCAUSENO_SYSCALL)
+#define EXCAUSE_DBREAK			(1<<EXCAUSENO_DBREAK)
+#define EXCAUSE_MISALIGNED_TRAP		(1<<EXCAUSENO_MISALIGNED_TRAP)
+#define EXCAUSE_CREG_NO_MAPPING		(1<<EXCAUSENO_CREG_NO_MAPPING)
+#define EXCAUSE_CREG_ACCESS_VIOLATION	(1<<EXCAUSENO_CREG_ACCESS_VIOLATION)
+#define EXCAUSE_DTLB			(1<<EXCAUSENO_DTLB)
+#define EXCAUSE_SDI_TIMEOUT		(1<<EXCAUSENO_SDI_TIMEOUT)
+
+/* Additional performance monitoring events */
+#define PM_EVENT_LONGIMM		21	/* Number of long immediates in completed bundles. */
+#define PM_EVENT_ITLBMISS		22	/* The number of instruction cache fills that missed the ITLB. */
+#define PM_EVENT_DTLBMISS		23	/* The number of load/store operations that missed the DTLB when the TLB is enabled. */
+#define PM_EVENT_UTLBHIT		24	/* The number of accesses to the UTLB which were hits. */
+#define PM_EVENT_ITLBWAITCYCLES		25	/* Number of cycles the instruction cache spends waiting for the ITLB to fill. */
+#define PM_EVENT_DTLBWAITCYCLES		26	/* Number of cycles the data cache spends waiting for the ITLB to fill. */
+#define PM_EVENT_UTLBARBITRATIONCYCLES	27	/* Number of cycles where the ITLB or DTLB was waiting for access to the UTLB because the UTLB was busy servicing a request. */
+
+#endif /* _ASM_ST200_CTRLREGDEFS_230_H */
diff --git a/arch/st200/include/asm/ctrlregdef.h b/arch/st200/include/asm/ctrlregdef.h
new file mode 100644
index 0000000..6080b8b
--- /dev/null
+++ b/arch/st200/include/asm/ctrlregdef.h
@@ -0,0 +1,112 @@
+/*
+ * include/asm-st200/ctrlregdef.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * Control register defintions for generic ST200
+ */
+
+#ifndef _ASM_ST200_CTRLREGDEFS_H
+#define _ASM_ST200_CTRLREGDEFS_H
+
+#if defined(CONFIG_CPU_SUBTYPE_ST231)
+#include "ctrlregdef-231.h"
+#else
+#error Unrecognised CPU subtype
+#endif
+
+#define CTRL_REG_BASE 0xffff0000
+
+#define CTRL_ADDR(offset) (CTRL_REG_BASE+(offset))
+
+/* Saved Program Counter, written by hardware on exception. */
+#define SAVED_PC	CTRL_ADDR(0xffe8)
+
+/* Saved PSW, written by hardware on exception. */
+#define SAVED_PSW	CTRL_ADDR(0xfff0)
+
+/* The Program Status Word. */
+#define PSW		CTRL_ADDR(0xfff8)
+
+/* Exception handler defines */
+
+/* The address of the exception handler code. */
+#define HANDLER_PC CTRL_ADDR(0xffe0)
+
+/* A one hot vector of trap (exception/interrupt) types
+   indicating the cause of the last trap. Written by the hardware on a trap. */
+#define EXCAUSE CTRL_ADDR(0xffd8)
+
+/* This will be the data effective address in the case of
+    either a DPU, CREG, DBREAK, or MISALIGNED_TRAP exception.
+    For other exception types this register will be zero. */
+#define EXADDRESS CTRL_ADDR(0xffd0)
+
+#define SAVED_SAVED_PSW	CTRL_ADDR(0xffc0)	/* PSW saved by debug unit interrupt. */
+#define SAVED_SAVED_PC	CTRL_ADDR(0xffb8)	/* PC saved by debug unit interrupt. */
+
+/* The version number of the core. */
+#define CORE_VERSION		CTRL_ADDR(0xffc8)
+
+/* Base address of the peripherial registers. The top 12 bits of this register
+   are wired to the peripherial base input pins. */
+#define PERIPHERAL_BASE	CTRL_ADDR(0xffb0)
+
+#define SCRATCH1 CTRL_ADDR(0xffa8)
+#define SCRATCH2 CTRL_ADDR(0xffa0)
+
+/* Performance register defintions */
+
+#define PM_EVENT_DHIT		0	/* The number of load and stores that hit the cache. This includes uncached accesses that hit the cache. */
+#define PM_EVENT_DMISS		1	/* The number of load and stores that miss the cache. This includes stores that miss the cache and are send to the write buffer. Uncached accesses are not included in this count. */
+#define PM_EVENT_DMISSCYCLES	2	/* The number of cycles the core is stalled due to the data cache being busy. */
+#define PM_EVENT_PFTISSUED	3	/* The number of prefetches */
+#define PM_EVENT_PFTHITS	4	/* The number of cached loads that hit the prefetch buffer. */
+#define PM_EVENT_WBHITS		5	/* The number of cached writes that hit the write buffer. */
+#define PM_EVENT_IHIT		6	/* The number of accesses the instruction buffer made that hit the instruction cache. */
+#define PM_EVENT_IMISS		7	/* The number of accesses the instruction buffer made that missed the instruction cache. */
+#define PM_EVENT_IMISSCYCLES	8	/* The number of cycles the instruction cache was stalled for. */
+#define PM_EVENT_IBUFINVALID	9	/* Duration where IBuffer is not able to issue bundles to the pipeline. */
+#define PM_EVENT_BUNDLES	10	/* Bundles executed. */
+#define PM_EVENT_LDST		11	/* Load/Store instructions executed. */
+#define PM_EVENT_TAKENBR	12	/* Number of taken branches (br and brf), rfis,goto sandcall s.  */
+#define PM_EVENT_NOTTAKENBR	13	/* Number of not taken branches (br and brf). */
+#define PM_EVENT_EXCEPTIONS	14	/* Number of exceptions and Debug interrupts. */
+#define PM_EVENT_INTERRUPTS	15	/* Number of interrupts. */
+#define PM_EVENT_BUSREADS	16	/* Number of architectural read transactions issued to the bus. This is the number of uncached reads, I & D cache refills and prefetches issued to the bus. */
+#define PM_EVENT_BUSWRITES	17	/* Number of architectural write transactions issued to the bus. This is the number of write buffer lines evicted and the number of uncached writes issued to the bus. */
+#define PM_EVENT_OPERATIONS	18	/* Number of completed operations. Includes nops in the instruction stream but not those added dynamically. This counter excludes long immediates. */
+#define PM_EVENT_WBMISSES	19	/* Number of cached writes that missed the cache and misses the write buffer. This excludes cache line evictions. */
+#define PM_EVENT_NOPBUNDLES	20	/* Number of completed bundles that were empty or contained only nops. This includes nop bundles generated by instruction buffer stalls and interlocking stalls. It excludes pipeline stalls due to load/stores and control register/sdi accesses. */
+
+#define PM_CR		CTRL_ADDR(0xf800)	/* Performance monitoring control. */
+#define PM_CNT0		CTRL_ADDR(0xf808)	/* Performance monitor counter 0 value. */
+#define PM_CNT1		CTRL_ADDR(0xf810)	/* Performance monitor counter 1 value. */
+#define PM_CNT2		CTRL_ADDR(0xf818)	/* Performance monitor counter 2 value. */
+#define PM_CNT3		CTRL_ADDR(0xf820)	/* Performance monitor counter 3 value. */
+#define PM_PCLK		CTRL_ADDR(0xf828)	/* Performance monitor core cycle counter. */
+
+#define PM_CR_ENB	0	/* When 1, counting is enabled. When 0 counting is disabled. */
+#define PM_CR_RST	1	/* When a 1 is written all the counters (PM_CNT0-3 and PM_PCLK) are set to zero. If a 0 is written it is ignored. This field does not retain its value and so always reads as 0. */
+#define PM_CR_EVENT0	12	/* 5-bit field specifying the event being monitored for this counter. */
+#define PM_CR_EVENT1	17	/* 5-bit field specifying the event being monitored for this counter. */
+#define PM_CR_EVENT2	22	/* 5-bit field specifying the event being monitored for this counter. */
+#define PM_CR_EVENT3	27	/* 5-bit field specifying the event being monitored for this counter. */
+
+/* Debug related registers */
+
+#define DBREAK_LOWER	CTRL_ADDR(0xfe80)	/* Data breakpoint lower address. */
+#define DBREAK_UPPER	CTRL_ADDR(0xfe78)	/* Data breakpoint upper address. */
+#define DBREAK_CONTROL	CTRL_ADDR(0xfe70)	/* Data breakpoint control. */
+
+#define IBREAK_LOWER	CTRL_ADDR(0xfdd0)	/* Instruction breakpoint lower address. */
+#define IBREAK_UPPER	CTRL_ADDR(0xfdc8)	/* Instruction breakpoint upper address. */
+#define IBREAK_CONTROL	CTRL_ADDR(0xfdc0)	/* Instruction breakpoint control. */
+
+#define BREAK_CONTROL_BRK_IN_RANGE	(1<<0)	/* Break if address >= lower && address <=upper. */
+#define BREAK_CONTROL_BRK_OUT_RANGE	(1<<1)	/* Break if address < lower || address > upper. */
+#define BREAK_CONTROL_BRK_EITHER	(1<<2)	/* Break if address == lower || address == upper. */
+#define BREAK_CONTROL_BRK_MASKED	(1<<3)	/* Break if address & upper == lower. */
+
+#endif /* _ASM_ST200_CTRLREGDEFS_H */
diff --git a/arch/st200/include/asm/current.h b/arch/st200/include/asm/current.h
new file mode 100644
index 0000000..50d0ad3
--- /dev/null
+++ b/arch/st200/include/asm/current.h
@@ -0,0 +1,23 @@
+/*
+ *  include/asm-st200/current.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_CURRENT_H
+#define _ASM_ST200_CURRENT_H
+
+#include <linux/thread_info.h>
+
+struct task_struct;
+
+static inline struct task_struct *get_current(void)
+{
+	return current_thread_info()->task;
+}
+
+#define current get_current()
+
+#endif /* _ASM_ST200_CURRENT_H */
diff --git a/arch/st200/include/asm/debugregs.h b/arch/st200/include/asm/debugregs.h
new file mode 100644
index 0000000..92e2620
--- /dev/null
+++ b/arch/st200/include/asm/debugregs.h
@@ -0,0 +1,29 @@
+/*
+ * include/asm-st200/debugregs.h
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ */
+
+/* Arguments to PT_DEBUG to get the offset of registers into struct user */
+
+#ifndef _ASM_ST200_DEBUGREGS_H
+#define _ASM_ST200_DEBUGREGS_H
+
+#define DR_DBREAK_CONTROL	0
+#define DR_DBREAK_LOWER		1
+#define DR_DBREAK_UPPER		2
+#define DR_IBREAK_CONTROL	3
+#define DR_IBREAK_LOWER		4
+#define DR_IBREAK_UPPER		5
+
+#define DR_TRACE		6
+
+/* Values for DR_[DI]BREAK_CONTROL */
+
+#define DR_BRK_IN_RANGE		(1<<0)
+#define DR_BRK_OUT_RANGE	(1<<1)
+#define DR_BRK_EITHER		(1<<2)
+#define DR_BRK_MASKED		(1<<3)
+
+#endif /* _ASM_ST200_DEBUGREGS_H */
diff --git a/arch/st200/include/asm/delay.h b/arch/st200/include/asm/delay.h
new file mode 100644
index 0000000..02a762d
--- /dev/null
+++ b/arch/st200/include/asm/delay.h
@@ -0,0 +1,22 @@
+/*
+ *  include/asm-st200/delay.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_DELAY_H
+#define _ASM_ST200_DELAY_H
+
+extern void __bad_udelay(void);
+
+extern void __udelay(unsigned long usecs);
+extern void __const_udelay(unsigned long usecs);
+extern void __delay(unsigned long loops);
+
+#define udelay(n) (__builtin_constant_p(n) ? \
+	((n) > 20000 ? __bad_udelay() : __const_udelay((n) * 0x10c6ul)) : \
+	__udelay(n))
+
+#endif /* _ASM_ST200_DELAY_H */
diff --git a/arch/st200/include/asm/device.h b/arch/st200/include/asm/device.h
new file mode 100644
index 0000000..06746c5
--- /dev/null
+++ b/arch/st200/include/asm/device.h
@@ -0,0 +1,6 @@
+/*
+ * Arch specific extensions to struct device
+ *
+ * This file is released under the GPLv2
+ */
+#include <asm-generic/device.h>
diff --git a/arch/st200/include/asm/div64.h b/arch/st200/include/asm/div64.h
new file mode 100644
index 0000000..169c2ad
--- /dev/null
+++ b/arch/st200/include/asm/div64.h
@@ -0,0 +1,6 @@
+#ifndef _ASM_ST200_DIV64_H
+#define _ASM_ST200_DIV64_H
+
+#include <asm-generic/div64.h>
+
+#endif /*_ASM_ST200_DIV64_H */
diff --git a/arch/st200/include/asm/dma-mapping.h b/arch/st200/include/asm/dma-mapping.h
new file mode 100644
index 0000000..0dbac09
--- /dev/null
+++ b/arch/st200/include/asm/dma-mapping.h
@@ -0,0 +1,170 @@
+#ifndef _ASM_ST200_DMA_MAPPING_H
+#define _ASM_ST200_DMA_MAPPING_H
+
+#include <linux/mm.h>
+#include <linux/scatterlist.h>
+#include <asm/cache.h>
+#include <asm/io.h>
+
+/* These should really allocate some cached memory */
+#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
+#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
+
+void *dma_alloc_coherent(struct device *dev, size_t size,
+			 dma_addr_t *dma_handle, gfp_t flag);
+
+void dma_free_coherent(struct device *dev, size_t size,
+		       void *vaddr, dma_addr_t dma_handle);
+
+extern void st200_flush_dcache_range(unsigned long addr, unsigned long size);
+
+/* Nobody should put anything here on an ST200 system */
+#define DMA_ERROR_CODE          (~(dma_addr_t)0x0)
+
+static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
+{
+	return (dma_addr == DMA_ERROR_CODE);
+}
+
+static inline void
+dma_cache_sync(struct device *dev, void *vaddr, size_t size,
+	       enum dma_data_direction direction)
+{
+	/* For ST240 we can optimise this, as we now have invalidate */
+	st200_flush_dcache_range((unsigned long)vaddr, (unsigned long)size);
+}
+
+static inline dma_addr_t
+dma_map_single(struct device *dev, void *ptr, size_t size,
+	       enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+
+	dma_cache_sync(dev, ptr, size, direction);
+	return virt_to_phys(ptr);
+}
+
+static inline void
+dma_unmap_single(struct device *dev, dma_addr_t dma_addr, size_t size,
+		 enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+}
+
+static inline int
+dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
+	   enum dma_data_direction direction)
+{
+	int i;
+	void set_watchpoint(void);
+
+	BUG_ON(direction == DMA_NONE);
+
+	for (i = 0; i < nents; i++) {
+		dma_cache_sync(dev, sg_virt(sg + i), sg[i].length, direction);
+		sg[i].dma_address = sg_phys(sg + i);
+	}
+
+	return nents;
+}
+
+static inline dma_addr_t
+dma_map_page(struct device *dev, struct page *page, unsigned long offset,
+	     size_t size, enum dma_data_direction direction)
+{
+	return dma_map_single(dev, page_address(page) + offset, size,
+			      direction);
+}
+
+static inline void
+dma_unmap_page(struct device *dev, dma_addr_t dma_handle, size_t size,
+	       enum dma_data_direction direction)
+{
+	dma_unmap_single(dev, dma_handle, size, direction);
+}
+
+static inline void
+dma_unmap_sg(struct device *dev, struct scatterlist *sg, int nhwentries,
+	     enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+}
+
+static inline void
+dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle, size_t size,
+			enum dma_data_direction direction)
+{
+	dma_cache_sync(dev, (void *)(phys_to_virt(dma_handle)), size,
+		       direction);
+}
+
+static inline void
+dma_sync_single_for_device(struct device *dev, dma_addr_t dma_handle,
+			   size_t size, enum dma_data_direction direction)
+{
+	dma_cache_sync(dev, (void *)(phys_to_virt(dma_handle)), size,
+		       direction);
+}
+
+static inline void
+dma_sync_single_range_for_cpu(struct device *dev, dma_addr_t dma_handle,
+			      unsigned long offset, size_t size,
+			      enum dma_data_direction direction)
+{
+	dma_sync_single_for_cpu(dev, dma_handle + offset, size, direction);
+}
+
+static inline void
+dma_sync_single_range_for_device(struct device *dev, dma_addr_t dma_handle,
+				 unsigned long offset, size_t size,
+				 enum dma_data_direction direction)
+{
+	dma_sync_single_for_device(dev, dma_handle + offset, size, direction);
+}
+
+static inline void
+dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg, int nelems,
+		    enum dma_data_direction direction)
+{
+	int i;
+
+	for (i = 0; i < nelems; i++) {
+		dma_cache_sync(dev, sg_virt(sg + i), sg[i].length, direction);
+	}
+}
+
+static inline void
+dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg, int nelems,
+		       enum dma_data_direction direction)
+{
+	dma_sync_sg_for_cpu(dev, sg, nelems, direction);
+}
+
+static inline int dma_supported(struct device *dev, u64 mask)
+{
+	return 1;
+}
+
+static inline int dma_set_mask(struct device *dev, u64 mask)
+{
+	if (!dev->dma_mask || !dma_supported(dev, mask))
+		return -EIO;
+
+	*dev->dma_mask = mask;
+
+	return 0;
+}
+
+static inline int dma_get_cache_alignment(void)
+{
+	/* Return the maximum possible, to be safe */
+	return L1_CACHE_BYTES;
+}
+
+/* This is wrong, but the API is crap, you really need the virtual address to figure out
+ * if the particular area you have been given is coherent or not. There is no easy way to
+ * figure it out given just the physical address.
+ */
+#define dma_is_consistent(d,h)	(0)
+
+#endif /*_ASM_ST200_DMA_MAPPING_H */
diff --git a/arch/st200/include/asm/dma.h b/arch/st200/include/asm/dma.h
new file mode 100644
index 0000000..a6e9446
--- /dev/null
+++ b/arch/st200/include/asm/dma.h
@@ -0,0 +1,27 @@
+/*
+ *  include/asm-st200/dma.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_DMA_H
+#define _ASM_ST200_DMA_H
+
+#include <asm/io.h>
+
+/* The maximum address that we can perform a DMA transfer to on this platform */
+#define MAX_DMA_ADDRESS      (0xFFFFFFFF)
+
+/* These are in kernel/dma.c: */
+extern int request_dma(unsigned int dmanr, const char *device_id);	/* reserve a DMA channel */
+extern void free_dma(unsigned int dmanr);	/* release it again */
+
+#ifdef CONFIG_PCI
+extern int isa_dma_bridge_buggy;
+#else
+#define isa_dma_bridge_buggy 	(0)
+#endif
+
+#endif /* _ASM_ST200_DMA_H */
diff --git a/arch/st200/include/asm/elf.h b/arch/st200/include/asm/elf.h
new file mode 100644
index 0000000..1d07a63
--- /dev/null
+++ b/arch/st200/include/asm/elf.h
@@ -0,0 +1,115 @@
+#ifndef __ASM_ST200_ELF_H
+#define __ASM_ST200_ELF_H
+
+/*
+ * st200 ELF relocation types
+ */
+#define R_LX_32			2	/* Simple 32 bit relocation -- for data */
+#define R_LX_23_PCREL		4	/* A PC Relative 24-bit relocation, shifted by 2 right container */
+#define R_LX_HI23		5	/* A HI part of a 32 bit absolute relocation */
+#define R_LX_LO9		6	/* low part of a 32 immediate */
+
+/*
+ * ELF register definitions..
+ */
+
+#include <asm/ptrace.h>
+#include <asm/user.h>
+#include <linux/utsname.h>
+
+typedef unsigned long elf_greg_t;
+
+#define ELF_NGREG	(sizeof(struct user_regs_struct) / sizeof(elf_greg_t))
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+typedef struct {
+} elf_fpregset_t;
+
+/*
+ * This is used to ensure we don't load something for the wrong architecture.
+ */
+#define elf_check_arch(x) ((x)->e_machine == EM_ST200)
+
+/*
+ * These are used to set parameters in the core dumps.
+ */
+#define ELF_CLASS	ELFCLASS32
+#define ELF_DATA	ELFDATA2LSB
+#define ELF_ARCH	EM_ST200
+
+/* $r0.1 is set by ld.so to a pointer to a function which might be
+   registered using atexit.  This provides a mean for the dynamic
+   linker to call DT_FINI functions for shared libraries that have
+   been loaded before the code runs.
+
+   So that we can use the same startup file with static executables,
+   we start programs with a value of 0 to indicate that there is no
+   such function.  */
+#define ELF_PLAT_INIT(_r, load_addr) do	\
+	_r->r16 = 0;			\
+while (0)
+
+#define USE_ELF_CORE_DUMP
+#define ELF_EXEC_PAGESIZE	8192
+
+/* This is the location that an ET_DYN program is loaded if exec'ed.  Typical
+   use of this is to invoke "./ld.so someprog" to test out a new version of
+   the loader.  We need to make sure that it is out of the way of the program
+   that it will "exec", and that there is sufficient room for the brk.  */
+
+#define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
+
+/* The registers are layed out in pt_regs for efficient syscalling.
+   Re-order them for the linear elf_gregset_t. */
+
+struct pt_regs;			/* forward declaration... */
+extern void st200_elf_core_copy_regs(struct pt_regs *regs, elf_gregset_t dst);
+#define ELF_CORE_COPY_REGS(dst, regs) \
+	st200_elf_core_copy_regs(regs, dst);
+
+/* Similar, but for a thread other than current.  */
+
+extern int
+st200_elf_core_copy_task_regs(struct task_struct *task, elf_gregset_t dst);
+#define ELF_CORE_COPY_TASK_REGS(task, dst) \
+        st200_elf_core_copy_task_regs(task, *(dst))
+
+/* This yields a mask that user programs can use to figure out what
+   instruction set this CPU supports.  This could be done in user space,
+   but it's not easy, and we've already done it here.  */
+
+#define ELF_HWCAP	0
+
+/* This yields a string that ld.so will use to load implementation
+   specific libraries for optimization.  This is more specific in
+   intent than poking at uname or /proc/cpuinfo.
+
+   For the moment, we have only optimizations for the Intel generations,
+   but that could change... */
+
+#define ELF_PLATFORM  (utsname()->machine)
+
+#ifdef __KERNEL__
+#define SET_PERSONALITY(ex) set_personality(PER_LINUX)
+#define ELF_CORE_COPY_FPREGS(t, fpu) (0)
+
+/* vDSO has arch_setup_additional_pages */
+#define ARCH_HAS_SETUP_ADDITIONAL_PAGES
+struct linux_binprm;
+extern int arch_setup_additional_pages(struct linux_binprm *bprm,
+				       int uses_interp);
+#define VDSO_AUX_ENT(a, b) NEW_AUX_ENT(a, b);
+
+#define ARCH_DLINFO							\
+do {									\
+	VDSO_AUX_ENT(AT_SYSINFO_EHDR, current->mm->context.vdso)	\
+} while (0)
+
+#ifdef CONFIG_SMP
+extern void dump_smp_unlazy_fpu(void);
+#define ELF_CORE_SYNC dump_smp_unlazy_fpu
+#endif
+
+#endif
+
+#endif /* _ASM_ST200_ELF_H */
diff --git a/arch/st200/include/asm/emergency-restart.h b/arch/st200/include/asm/emergency-restart.h
new file mode 100644
index 0000000..108d8c4
--- /dev/null
+++ b/arch/st200/include/asm/emergency-restart.h
@@ -0,0 +1,6 @@
+#ifndef _ASM_EMERGENCY_RESTART_H
+#define _ASM_EMERGENCY_RESTART_H
+
+#include <asm-generic/emergency-restart.h>
+
+#endif /* _ASM_EMERGENCY_RESTART_H */
diff --git a/arch/st200/include/asm/errno.h b/arch/st200/include/asm/errno.h
new file mode 100644
index 0000000..7032034
--- /dev/null
+++ b/arch/st200/include/asm/errno.h
@@ -0,0 +1,10 @@
+/*
+ *  include/asm-st200/errno.h
+ */
+
+#ifndef _ASM_ST200_ERRNO_H
+#define _ASM_ST200_ERRNO_H
+
+#include <asm-generic/errno.h>
+
+#endif /* _ASM_ST200_ERRNO_H */
diff --git a/arch/st200/include/asm/fb.h b/arch/st200/include/asm/fb.h
new file mode 100644
index 0000000..3a4988e
--- /dev/null
+++ b/arch/st200/include/asm/fb.h
@@ -0,0 +1 @@
+#include <asm-generic/fb.h>
diff --git a/arch/st200/include/asm/fcntl.h b/arch/st200/include/asm/fcntl.h
new file mode 100644
index 0000000..89b37f6
--- /dev/null
+++ b/arch/st200/include/asm/fcntl.h
@@ -0,0 +1,6 @@
+#ifndef _ASM_ST200_FCNTL_H
+#define _ASM_ST200_FCNTL_H
+
+#include <asm-generic/fcntl.h>
+
+#endif /* _ASM_ST200_FCNTL_H */
diff --git a/arch/st200/include/asm/ftrace.h b/arch/st200/include/asm/ftrace.h
new file mode 100644
index 0000000..a7358c1
--- /dev/null
+++ b/arch/st200/include/asm/ftrace.h
@@ -0,0 +1,4 @@
+#ifndef _ASM_ST200_FTRACE_H
+#define _ASM_ST200_FTRACE_H
+
+#endif /* _ASM_ST200_FTRACE_H */
diff --git a/arch/st200/include/asm/futex.h b/arch/st200/include/asm/futex.h
new file mode 100644
index 0000000..7b6463a
--- /dev/null
+++ b/arch/st200/include/asm/futex.h
@@ -0,0 +1,140 @@
+#ifndef _ASM_ST200_FUTEX_H
+#define _ASM_ST200_FUTEX_H
+
+#ifdef __KERNEL__
+
+#include <linux/futex.h>
+#include <linux/uaccess.h>
+#include <asm/errno.h>
+
+/* We only need one fixup, because if we fault on the stw, the fault handler
+ * will see this as a fault on the ldw, as the PC will be rolled back to
+ * the ldw. We do not have to worry about unaligned, as this will be caught 
+ * by the fixup handler.
+ */
+
+#define __futex_atomic_op(insn, ret, oldval, uaddr, oparg)	\
+	__asm__ __volatile__(					\
+	"1:	ldw	%0 = 0[%2]		\n"		\
+	"	mov 	$r62 = 1b		\n"		\
+	"	or	$r12 = $r12, 1		\n"		\
+	"	;; 				\n"		\
+	insn							\
+	"	;;				\n"		\
+	"	stw	0[%2] = %1 		\n"		\
+	"	and	$r12 = $r12, ~1		\n"		\
+	"	mov	%1 = 0			\n"		\
+	"	;;				\n"		\
+	"2:					\n"		\
+	"	.section .fixup, \"ax\"		\n"		\
+	"	.align 4			\n"		\
+	"3:	mov	%1 = -"__stringify(EFAULT)"\n"		\
+	"	goto 	2b			\n"		\
+	"	;;				\n"		\
+	"	.previous			\n"		\
+	"	.section __ex_table,\"a\"	\n"		\
+	"	.align 4			\n"		\
+	"	.long	1b, 3b			\n"		\
+	"	.previous			\n"		\
+	:	"=&r" (oldval) /* %0 */, "=&r"(ret) /* %1 */	\
+	:	"r" (uaddr) /* %2 */ , "r"(oparg) /* %3 */	\
+	:	"r62", "memory")
+
+static inline int futex_atomic_op_inuser (int encoded_op, int __user *uaddr)
+{
+	int op = (encoded_op >> 28) & 7;
+	int cmp = (encoded_op >> 24) & 15;
+	int oparg = (encoded_op << 8) >> 20;
+	int cmparg = (encoded_op << 20) >> 20;
+	int oldval = 0, ret;
+
+	if (encoded_op & (FUTEX_OP_OPARG_SHIFT << 28))
+		oparg = 1 << oparg;
+
+	if (!access_ok(VERIFY_WRITE, uaddr, sizeof(int)))
+		return -EFAULT;
+
+	pagefault_disable();
+
+	switch (op) {
+	case FUTEX_OP_SET:
+		__futex_atomic_op("mov %1 = %3\n", ret, oldval, uaddr, oparg);
+		break;
+	case FUTEX_OP_ADD:
+		__futex_atomic_op("add %1 = %3, %0\n", ret, oldval, uaddr, oparg);
+		break;
+	case FUTEX_OP_OR:
+		__futex_atomic_op("or %1 = %3, %0\n", ret, oldval, uaddr, oparg);
+		break;
+	case FUTEX_OP_ANDN:
+		__futex_atomic_op("andc %1 = %3, %0\n", ret, oldval, uaddr, oparg);
+		break;
+	case FUTEX_OP_XOR:
+		__futex_atomic_op("xor %1 = %3, %0\n", ret, oldval, uaddr, oparg);
+		break;
+	default:
+		ret = -ENOSYS;
+	}
+
+	pagefault_enable();
+
+	if (!ret) {
+		switch (cmp) {
+		case FUTEX_OP_CMP_EQ: ret = (oldval == cmparg); break;
+		case FUTEX_OP_CMP_NE: ret = (oldval != cmparg); break;
+		case FUTEX_OP_CMP_LT: ret = (oldval < cmparg); break;
+		case FUTEX_OP_CMP_GE: ret = (oldval >= cmparg); break;
+		case FUTEX_OP_CMP_LE: ret = (oldval <= cmparg); break;
+		case FUTEX_OP_CMP_GT: ret = (oldval > cmparg); break;
+		default: ret = -ENOSYS;
+		}
+	}
+	return ret;
+}
+
+static inline int
+futex_atomic_cmpxchg_inatomic(int __user *uaddr, int oldval, int newval)
+{
+	int prev, tmp;
+
+	if (!access_ok(VERIFY_WRITE, uaddr, sizeof(int)))
+		return -EFAULT;
+
+	/* We store the new value if oldval == prev, note we always do the
+	 * store, even if this is not the case We simply store the value we
+	 * have just read. Same argument as above for why we only need one
+	 * exception block
+	 */
+
+	__asm__ __volatile__ (
+	"1:	ldw	%0 = 0[%2]		\n"
+	"	mov	$r62 = 1b		\n"
+	"	or	$r12 = $r12, 1		\n"
+	"	;;				\n"
+	"	cmpeq	$b7 = %0, %3		\n"
+	"	;;				\n"
+	"	slct	%1 = $b7, %4, %0	\n"
+	"	;;				\n"
+	"	stw	0[%2] = %1		\n"
+	"	and	$r12 = $r12, ~1		\n"
+	"	;;				\n"
+	"2:					\n"		
+	"	.section .fixup, \"ax\"		\n"
+	"	.align 4			\n"
+	"3:	mov	%0 = -"__stringify(EFAULT)"\n"
+	"	goto 	2b			\n"
+	"	;;				\n"
+	"	.previous			\n"
+	"	.section __ex_table,\"a\"	\n"
+	"	.align 4			\n"
+	"	.long	1b, 3b			\n"
+	"	.previous			\n"
+	:	"=&r"(prev) /* %0 */, "=&r" (tmp) /* %1 */
+	:	"r"(uaddr) /* %2 */, "r"(oldval) /* %3 */, "r"(newval) /* %4 */
+	:	"b7", "r62", "memory");
+
+	return prev;
+}
+
+#endif /* __KERNEL__ */
+#endif /* _ASM_ST200_FUTEX_H */
diff --git a/arch/st200/include/asm/hardirq.h b/arch/st200/include/asm/hardirq.h
new file mode 100644
index 0000000..de89837
--- /dev/null
+++ b/arch/st200/include/asm/hardirq.h
@@ -0,0 +1,16 @@
+#ifndef _ST200_HARDIRQ_H
+#define _ST200_HARDIRQ_H
+
+#include <linux/threads.h>
+#include <linux/cache.h>
+#include <asm/irq.h>
+
+typedef struct {
+	unsigned long __softirq_pending;
+} ____cacheline_aligned irq_cpustat_t;
+
+#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
+
+extern void ack_bad_irq(unsigned int irq);
+
+#endif /* _ST200_HARDIRQ_H */
diff --git a/arch/st200/include/asm/hw_irq.h b/arch/st200/include/asm/hw_irq.h
new file mode 100644
index 0000000..cfea251
--- /dev/null
+++ b/arch/st200/include/asm/hw_irq.h
@@ -0,0 +1,6 @@
+#ifndef __ASM_ST200_HW_IRQ_H
+#define __ASM_ST200_HW_IRQ_H
+
+#include <asm-generic/hw_irq.h>
+
+#endif /* __ASM_ST200_HW_IRQ_H */
diff --git a/arch/st200/include/asm/io.h b/arch/st200/include/asm/io.h
new file mode 100644
index 0000000..459f89f
--- /dev/null
+++ b/arch/st200/include/asm/io.h
@@ -0,0 +1,223 @@
+/*
+ * include/asm-st200/io.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_IO_H
+#define _ASM_ST200_IO_H
+
+#include <asm-generic/iomap.h>
+#include <asm/byteorder.h>
+
+/*
+ * This file contains the definitions for the x86 IO instructions
+ * inb/inw/inl/outb/outw/outl and the "string versions" of the same
+ * (insb/insw/insl/outsb/outsw/outsl). You can also use "pausing"
+ * versions of the single-IO instructions (inb_p/inw_p/..).
+ */
+
+#ifdef __KERNEL__
+
+#include <asm/pgtable.h>
+
+#define IO_SPACE_LIMIT 0xffff
+
+/**
+ *	virt_to_phys	-	map virtual addresses to physical
+ *	@address: address to remap
+ *
+ *	The returned physical address is the physical (CPU) mapping for
+ *	the memory address given. It is only valid to use this function on
+ *	addresses directly mapped or allocated via kmalloc.
+ *
+ *	This function does not give bus mappings for DMA transfers. In
+ *	almost all conceivable cases a device driver should not be using
+ *	this function
+ */
+static inline unsigned long virt_to_phys(volatile void *address)
+{
+	return __pa(address);
+}
+
+/**
+ *	phys_to_virt	-	map physical address to virtual
+ *	@address: address to remap
+ *
+ *	The returned virtual address is a current CPU mapping for
+ *	the memory address given. It is only valid to use this function on
+ *	addresses that have a kernel mapping
+ * page_to_phys
+ *	This function does not handle bus mappings for DMA transfers. In
+ *	almost all conceivable cases a device driver should not be using
+ *	this function
+ */
+static inline void *phys_to_virt(unsigned long address)
+{
+	return __va(address);
+}
+
+/*
+ * Change "struct page" to physical address.
+ */
+#ifndef CONFIG_DISCONTIGMEM
+#define page_to_phys(page) ((dma_addr_t)page_to_pfn(page) << PAGE_SHIFT)
+#endif
+
+extern void *__ioremap(unsigned long offset, unsigned long size, pgprot_t prot);
+extern void iounmap(void *addr);
+
+/**
+ * ioremap     -   map bus memory into CPU space
+ * @offset:    bus address of the memory
+ * @size:      size of the resource to map
+ *
+ * ioremap performs a platform specific sequence of operations to
+ * make bus memory CPU accessible via the readb/readw/readl/writeb/
+ * writew/writel functions and the other mmio helpers. The returned
+ * address is not guaranteed to be usable directly as a virtual
+ * address.
+ */
+
+static inline void *ioremap(unsigned long offset, unsigned long size)
+{
+	return __ioremap(offset, size, PAGE_KERNEL_NC);
+}
+
+/**
+ * ioremap_...     -   map bus memory into CPU space
+ * @offset:    bus address of the memory
+ * @size:      size of the resource to map
+ *
+ * These functions behave in the same way as ioremap, but with specified
+ * cache attributes.
+ *
+ * Must be freed with iounmap.
+ */
+static inline void *ioremap_nocache(unsigned long offset, unsigned long size)
+{
+	return __ioremap(offset, size, PAGE_KERNEL_NC);
+}
+
+static inline void *ioremap_writecombine(unsigned long offset,
+					 unsigned long size)
+{
+	return __ioremap(offset, size, PAGE_KERNEL_NCWC);
+}
+
+static inline void *ioremap_cache(unsigned long offset, unsigned long size)
+{
+	return __ioremap(offset, size, PAGE_KERNEL);
+}
+
+/*
+ * readX/writeX() are used to access memory mapped devices. On some
+ * architectures the memory mapped IO stuff needs to be accessed
+ * differently. On the ST200 architecture, we just read/write the
+ * memory location directly.
+ */
+#define readb(addr) (*(volatile unsigned char *)(addr))
+#define readw(addr) (*(volatile unsigned short *)(addr))
+#define readl(addr) (*(volatile unsigned int *)(addr))
+#define readsl(addr,data,len)  __raw_readsl(addr,data,len)
+#define __raw_readb readb
+#define __raw_readw readw
+#define __raw_readl readl
+
+/* Big endian versions for seriously wierd hardware like the STV576 */
+
+#define readw_be(addr) be16_to_cpu(readw(addr))
+#define readl_be(addr) be32_to_cpu(readl(addr))
+
+#define writeb(b,addr) (*(volatile unsigned char *)(addr) = (b))
+#define writew(b,addr) (*(volatile unsigned short *)(addr) = (b))
+#define writel(b,addr) (*(volatile unsigned int *)(addr) = (b))
+#define writesl(addr,data,len)  __raw_writesl(addr,data,len)
+#define __raw_writeb writeb
+#define __raw_writew writew
+#define __raw_writel writel
+
+#define writew_be(b,addr) writew(cpu_to_be16(b),addr)
+#define writel_be(b,addr) writel(cpu_to_be32(b),addr)
+
+#if 0
+#define memset_io(a,b,c)	memset((a),(b),(c))
+#define memcpy_fromio(a,b,c)	memcpy((a),(b),(c))
+#define memcpy_toio(a,b,c)	memcpy((a),(b),(c))
+#else
+/* We need to do word accesses in memcpy_fromio() in order
+ * to get the 64 bit wide flash to work
+ */
+void memcpy_fromio(void *a, unsigned long addr, int len);
+void memcpy_toio(unsigned long addr, void *a, int len);
+void memset_io(unsigned long addr, int c, int len);
+
+#endif
+
+/*
+ * inX/outX() are used to access IO ports. As there are no IO
+ * instructions on the ST200, this is simply a special memory region.
+ *
+ */
+
+#ifdef CONFIG_PCI
+/* Global pointer to io region */
+extern void *pcibios_io_region;
+#define PORT_TO_ADDR(x) ((x) + pcibios_io_region)
+#else
+/* Nothing to IO to, will blow up if you try! */
+#define PORT_TO_ADDR(x) 0
+#endif
+
+#define inb(port) (*(volatile unsigned char*)PORT_TO_ADDR(port))
+#define inw(port) (*(volatile unsigned short*)PORT_TO_ADDR(port))
+#define inl(port) (*(volatile unsigned int*)PORT_TO_ADDR(port))
+
+#define outb(b, port) (*(volatile unsigned char*)PORT_TO_ADDR(port) = (b))
+#define outw(b, port) (*(volatile unsigned short*)PORT_TO_ADDR(port) = (b))
+#define outl(b, port) (*(volatile unsigned int*)PORT_TO_ADDR(port) = (b))
+
+#define inb_p inb
+#define outb_p outb
+#define inw_p inw
+#define outw_p outw
+#define inl_p inl
+#define outl_p outl
+
+extern void outsb(unsigned long addr, const void *src, unsigned long count);
+extern void outsw(unsigned long addr, const void *src, unsigned long count);
+extern void outsl(unsigned long addr, const void *src, unsigned long count);
+extern void insb(unsigned long addr, void *dst, unsigned long count);
+extern void insw(unsigned long addr, void *dst, unsigned long count);
+extern void insl(unsigned long addr, void *dst, unsigned long count);
+
+/*
+ * Convert a physical pointer to a virtual kernel pointer for /dev/mem
+ * access
+ */
+#define xlate_dev_mem_ptr(p)    __va(p)
+
+/*
+ * Convert a virtual cached pointer to an uncached pointer
+ */
+#define xlate_dev_kmem_ptr(p)   p
+
+/* ST200 caches are not DMA coherent */
+extern void dma_cache_wback_inv(unsigned long start, unsigned long size);
+extern void dma_cache_wback(unsigned long start, unsigned long size);
+extern void dma_cache_inv(unsigned long start, unsigned long size);
+
+/* The ctrl_inl() etc macros are used to acccess the control
+ * registers of the ST200. These are mapped to the top 64K of
+ * addess space. They are *not* translated, so we pull them out
+ * here in case we have to do wierd things with readl() and writel()
+ * later on.
+ */
+#define ctrl_inl(addr) (*(volatile unsigned long *)(addr))
+#define ctrl_outl(b,addr) (*(volatile unsigned long *)(addr) = (b))
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_ST200_IO_H */
diff --git a/arch/st200/include/asm/ioctl.h b/arch/st200/include/asm/ioctl.h
new file mode 100644
index 0000000..7cb7862
--- /dev/null
+++ b/arch/st200/include/asm/ioctl.h
@@ -0,0 +1,64 @@
+/*
+ *  include/asm-st200/ioctl.h
+ *
+ *  copied from include/asm-alpha/ioctl.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ */
+
+#ifndef _ASM_ST200_IOCTL_H
+#define _ASM_ST200_IOCTL_H
+
+#define _IOC_NRBITS	8
+#define _IOC_TYPEBITS	8
+#define _IOC_SIZEBITS	13
+#define _IOC_DIRBITS	3
+
+#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
+#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
+#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
+#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
+
+#define _IOC_NRSHIFT	0
+#define _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)
+#define _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)
+#define _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)
+
+/*
+ * Direction bits _IOC_NONE could be 0, but OSF/1 gives it a bit.
+ * And this turns out useful to catch old ioctl numbers in header
+ * files for us.
+ */
+#define _IOC_NONE	1U
+#define _IOC_READ	2U
+#define _IOC_WRITE	4U
+
+#define _IOC(dir,type,nr,size)			\
+	((unsigned int)				\
+	 (((dir)  << _IOC_DIRSHIFT) |		\
+	  ((type) << _IOC_TYPESHIFT) |		\
+	  ((nr)	  << _IOC_NRSHIFT) |		\
+	  ((size) << _IOC_SIZESHIFT)))
+
+/* used to create ioctl numbers */
+#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
+#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))
+#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))
+#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
+
+/* used to decode ioctl numbers.. */
+#define _IOC_DIR(nr)		(((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
+#define _IOC_TYPE(nr)		(((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
+#define _IOC_NR(nr)		(((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
+#define _IOC_SIZE(nr)		(((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)
+
+/* ...and for the drivers/sound files... */
+
+#define IOC_IN		(_IOC_WRITE << _IOC_DIRSHIFT)
+#define IOC_OUT		(_IOC_READ << _IOC_DIRSHIFT)
+#define IOC_INOUT	((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)
+#define IOCSIZE_MASK	(_IOC_SIZEMASK << _IOC_SIZESHIFT)
+#define IOCSIZE_SHIFT	(_IOC_SIZESHIFT)
+
+#endif /* _ASM_ST200_IOCTL_H */
diff --git a/arch/st200/include/asm/ioctls.h b/arch/st200/include/asm/ioctls.h
new file mode 100644
index 0000000..c6de0fa
--- /dev/null
+++ b/arch/st200/include/asm/ioctls.h
@@ -0,0 +1,125 @@
+/*
+ * include/asm-st200/cacheflush.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_IOCTLS_H
+#define _ASM_ST200_IOCTLS_H
+
+#include <asm/ioctl.h>
+
+#define FIOCLEX		_IO('f', 1)
+#define FIONCLEX	_IO('f', 2)
+#define FIOASYNC	_IOW('f', 125, int)
+#define FIONBIO		_IOW('f', 126, int)
+#define FIONREAD	_IOR('f', 127, int)
+#define TIOCINQ		FIONREAD
+#define FIOQSIZE	_IOR('f', 128, loff_t)
+
+#if 0				/* depricated */
+#define TIOCGETP	_IOR('t', 8, struct sgttyb)
+#define TIOCSETP	_IOW('t', 9, struct sgttyb)
+#define TIOCSETN	_IOW('t', 10, struct sgttyb)	/* TIOCSETP wo flush */
+#define TIOCSETC	_IOW('t', 17, struct tchars)
+#define TIOCGETC	_IOR('t', 18, struct tchars)
+#endif
+
+#define TCGETS		_IOR('t', 19, struct termios)
+#define TCSETS		_IOW('t', 20, struct termios)
+#define TCSETSW		_IOW('t', 21, struct termios)
+#define TCSETSF		_IOW('t', 22, struct termios)
+
+#define TCGETA		_IOR('t', 23, struct termio)
+#define TCSETA		_IOW('t', 24, struct termio)
+#define TCSETAW		_IOW('t', 25, struct termio)
+#define TCSETAF		_IOW('t', 28, struct termio)
+
+#define TCSBRK		_IO('t', 29)
+#define TCXONC		_IO('t', 30)
+#define TCFLSH		_IO('t', 31)
+
+#define TIOCSWINSZ	_IOW('t', 103, struct winsize)
+#define TIOCGWINSZ	_IOR('t', 104, struct winsize)
+#define	TIOCSTART	_IO('t', 110)	/* start output, like ^Q */
+#define	TIOCSTOP	_IO('t', 111)	/* stop output, like ^S */
+#define TIOCOUTQ        _IOR('t', 115, int)	/* output queue size */
+
+#if 0				/* depricated */
+#define TIOCGLTC	_IOR('t', 116, struct ltchars)
+#define TIOCSLTC	_IOW('t', 117, struct ltchars)
+#endif
+#define TIOCSPGRP	_IOW('t', 118, int)
+#define TIOCGPGRP	_IOR('t', 119, int)
+
+#define TIOCEXCL	_IO('T', 12)
+#define TIOCNXCL	_IO('T', 13)
+#define TIOCSCTTY	_IO('T', 14)
+
+#define TIOCSTI		_IOW('T', 18, char)
+#define TIOCMGET	_IOR('T', 21, int)
+#define TIOCMBIS	_IOW('T', 22, int)
+#define TIOCMBIC	_IOW('T', 23, int)
+#define TIOCMSET	_IOW('T', 24, int)
+# define TIOCM_LE	0x001
+# define TIOCM_DTR	0x002
+# define TIOCM_RTS	0x004
+# define TIOCM_ST	0x008
+# define TIOCM_SR	0x010
+# define TIOCM_CTS	0x020
+# define TIOCM_CAR	0x040
+# define TIOCM_RNG	0x080
+# define TIOCM_DSR	0x100
+# define TIOCM_CD	TIOCM_CAR
+# define TIOCM_RI	TIOCM_RNG
+# define TIOCM_OUT1	0x2000
+# define TIOCM_OUT2	0x4000
+# define TIOCM_LOOP	0x8000
+
+#define TIOCGSOFTCAR	_IOR('T', 25, int)
+#define TIOCSSOFTCAR	_IOW('T', 26, int)
+#define TIOCLINUX	_IOWR('T', 28, char)
+#define TIOCCONS	_IO('T', 29)
+#define TIOCGSERIAL	_IOR('T', 30, struct serial_struct)
+#define TIOCSSERIAL	_IOW('T', 31, struct serial_struct)
+#define TIOCPKT		_IOW('T', 32, int)
+# define TIOCPKT_DATA		 0
+# define TIOCPKT_FLUSHREAD	 1
+# define TIOCPKT_FLUSHWRITE	 2
+# define TIOCPKT_STOP		 4
+# define TIOCPKT_START		 8
+# define TIOCPKT_NOSTOP		16
+# define TIOCPKT_DOSTOP		32
+
+#define TIOCNOTTY	_IO('T', 34)
+#define TIOCSETD	_IOW('T', 35, int)
+#define TIOCGETD	_IOR('T', 36, int)
+#define TCSBRKP		_IOW('T', 37, int)	/* Needed for POSIX tcsendbreak() */
+#define TIOCTTYGSTRUCT	_IOR('T', 38, struct tty_struct)	/* For debugging only */
+#define TIOCSBRK	_IO('T', 39)	/* BSD compatibility */
+#define TIOCCBRK	_IO('T', 40)	/* BSD compatibility */
+#define TIOCGSID	_IOR('T', 41, pid_t)	/* Return the session ID of FD */
+#define TIOCGPTN	_IOR('T', 48, unsigned int)	/* Get Pty Number (of pty-mux device) */
+#define TIOCSPTLCK	_IOW('T', 49, int)	/* Lock/unlock Pty */
+
+#define TIOCSERCONFIG	_IO('T', 83)
+#define TIOCSERGWILD	_IOR('T', 84,  int)
+#define TIOCSERSWILD	_IOW('T', 85,  int)
+#define TIOCGLCKTRMIOS	_IOR('T', 86, struct termios)
+#define TIOCSLCKTRMIOS	_IOW('T', 86, struct termios)
+#define TIOCSERGSTRUCT	_IOR('T', 88, struct async_struct)	/* For debugging only */
+#define TIOCSERGETLSR	_IOR('T', 89, unsigned int)	/* Get line status register */
+  /* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
+# define TIOCSER_TEMT    0x01	/* Transmitter physically empty */
+
+#define TIOCSERGETMULTI	_IOR('T', 90, struct serial_multiport_struct)	/* Get multiport config  */
+#define TIOCSERSETMULTI	_IOW('T', 91, struct serial_multiport_struct)	/* Set multiport config */
+
+#define TIOCMIWAIT	_IO('T', 92)	/* wait for a change on serial input line(s) */
+#define TIOCGICOUNT	_IOR('T', 93, struct async_icount)	/* read serial port inline interrupt counts */
+#define TIOCGHAYESESP	_IOR('T', 94, struct hayes_esp_config)	/* Get Hayes ESP configuration */
+#define TIOCSHAYESESP	_IOW('T', 94, struct hayes_esp_config)	/* Set Hayes ESP configuration */
+
+#endif /* _ASM_ST200_IOCTLS_H */
diff --git a/arch/st200/include/asm/ipcbuf.h b/arch/st200/include/asm/ipcbuf.h
new file mode 100644
index 0000000..f339c72
--- /dev/null
+++ b/arch/st200/include/asm/ipcbuf.h
@@ -0,0 +1,31 @@
+/*
+ * include/asm-st200/ipcbuf.h
+ */
+
+#ifndef _ASM_ST200_IPCBUF_H
+#define _ASM_ST200_IPCBUF_H
+
+/*
+ * The ipc64_perm structure for ST200 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 32-bit seq
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct ipc64_perm {
+	__kernel_key_t key;
+	__kernel_uid32_t uid;
+	__kernel_gid32_t gid;
+	__kernel_uid32_t cuid;
+	__kernel_gid32_t cgid;
+	__kernel_mode_t mode;
+	unsigned short seq;
+	unsigned short __pad1;
+	unsigned long __unused1;
+	unsigned long __unused2;
+};
+
+#endif /* _ASM_ST200_IPCBUF_H */
diff --git a/arch/st200/include/asm/irq-reflector.h b/arch/st200/include/asm/irq-reflector.h
new file mode 100644
index 0000000..7cb2f71
--- /dev/null
+++ b/arch/st200/include/asm/irq-reflector.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2008 STMicroelectronics Limited
+ * Author: David McKay <david.mckay@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License V2.  See linux/COPYING for more information.
+ */
+
+#ifndef __ASM_ST200_IRQ_REFLECTOR_H__
+#define __ASM_ST200_IRQ_REFLECTOR_H__
+
+#include <linux/platform_device.h>
+
+/* Must be marked as volatile. Must be mapped uncached.
+ * char is used to avoid endian swap between big endian/
+ * little endian machines
+ */
+struct peterson_spinlock {
+	volatile unsigned char flag[2];
+	volatile unsigned char turn;
+	unsigned char pad;
+};
+
+static inline void peterson_spinlock_claim(struct peterson_spinlock *p,
+					   int self)
+{
+	int other = !self;
+
+	p->flag[self] = 1;
+	/* Read back for write posting. Paranoia */
+	p->flag[self];
+
+	p->turn = other;
+	/* Spin until the other is done */
+	while (p->flag[other] && p->turn == other) ;
+}
+
+static inline void peterson_spinlock_release(struct peterson_spinlock *p,
+					     int self)
+{
+	p->flag[self] = 0;
+	/* Read back for write posting, and flush out above write */
+	p->flag[self];
+}
+
+#define MAX_BOUNCE_IRQS 32
+
+struct reflect_block {
+	/* Controls access to the structure,
+	 * and also the interrupt itself
+	 */
+	struct peterson_spinlock lock;
+	volatile unsigned irq_status;	/* 1 if interrupt is set */
+	volatile unsigned irq_enable;	/* 1 if interrupt enabled */
+	char msg[65536];	// * printf HACK for debug.
+	int read_off;
+	int write_off;
+};
+
+struct plat_irq_reflector_data {
+	unsigned boot_first:1;	//  True if you have to initialise everything
+	unsigned big_endian:1;	// True if the above structure is big endian
+
+	void (*ack_multiplex_irq) (void);	// drop the interrupt you were signalled on.
+	/* The use of this depends on what hardware you have got. If you can
+	 * disable and enable interrupts by writing to registers on the
+	 * companions interrupt controller directly, then you can implement
+	 * that here. If you can't, and all you can do is raise a remote
+	 * interrupt on it then you can do that here. The prev_enabled field
+	 * is if the software thinks it is off or not.
+	 */
+	void (*enable_remote_irq) (int n, int prev_enabled);
+	void (*disable_remote_irq) (int n, int prev_enabled);
+};
+
+void __init irq_reflector_early_init(struct platform_device *pdev);
+
+#endif
diff --git a/arch/st200/include/asm/irq.h b/arch/st200/include/asm/irq.h
new file mode 100644
index 0000000..8cc350e
--- /dev/null
+++ b/arch/st200/include/asm/irq.h
@@ -0,0 +1,23 @@
+/*
+ * include/asm-st200/irq.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_IRQ_H
+#define _ASM_ST200_IRQ_H
+
+#define NR_IRQS 128
+
+static __inline__ int irq_canonicalize(int irq)
+{
+	return irq;
+}
+
+extern void disable_irq(unsigned int);
+extern void disable_irq_nosync(unsigned int);
+extern void enable_irq(unsigned int);
+
+#endif /* _ASM_ST200_IRQ_H */
diff --git a/arch/st200/include/asm/irq_regs.h b/arch/st200/include/asm/irq_regs.h
new file mode 100644
index 0000000..3dd9c0b
--- /dev/null
+++ b/arch/st200/include/asm/irq_regs.h
@@ -0,0 +1 @@
+#include <asm-generic/irq_regs.h>
diff --git a/arch/st200/include/asm/kdebug.h b/arch/st200/include/asm/kdebug.h
new file mode 100644
index 0000000..6ece1b0
--- /dev/null
+++ b/arch/st200/include/asm/kdebug.h
@@ -0,0 +1 @@
+#include <asm-generic/kdebug.h>
diff --git a/arch/st200/include/asm/kmap_types.h b/arch/st200/include/asm/kmap_types.h
new file mode 100644
index 0000000..fbd7ecc
--- /dev/null
+++ b/arch/st200/include/asm/kmap_types.h
@@ -0,0 +1,24 @@
+#ifndef _ASM_ST200_KMAP_TYPES_H
+#define _ASM_ST200_KMAP_TYPES_H
+
+/*
+ * This is the "bare minimum".  AIO seems to require this.
+ */
+enum km_type {
+	KM_BOUNCE_READ,
+	KM_SKB_SUNRPC_DATA,
+	KM_SKB_DATA_SOFTIRQ,
+	KM_USER0,
+	KM_USER1,
+	KM_BIO_SRC_IRQ,
+	KM_BIO_DST_IRQ,
+	KM_PTE0,
+	KM_PTE1,
+	KM_IRQ0,
+	KM_IRQ1,
+	KM_SOFTIRQ0,
+	KM_SOFTIRQ1,
+	KM_TYPE_NR
+};
+
+#endif /* _ASM_ST200_KMAP_TYPES_H */
diff --git a/arch/st200/include/asm/linkage.h b/arch/st200/include/asm/linkage.h
new file mode 100644
index 0000000..a9e0728
--- /dev/null
+++ b/arch/st200/include/asm/linkage.h
@@ -0,0 +1,11 @@
+#ifndef __ASM_LINKAGE_H
+#define __ASM_LINKAGE_H
+
+#define __ALIGN .balign 4
+#define __ALIGN_STR ".balign 4"
+
+#define ENDPROC(name) \
+  .type name, %function; \
+  END(name)
+
+#endif
diff --git a/arch/st200/include/asm/local.h b/arch/st200/include/asm/local.h
new file mode 100644
index 0000000..1a3cd6a
--- /dev/null
+++ b/arch/st200/include/asm/local.h
@@ -0,0 +1,6 @@
+#ifndef _ASM_ST200_LOCAL_H
+#define _ASM_ST200_LOCAL_H
+
+#include <asm-generic/local.h>
+
+#endif /* _ASM_ST200_LOCAL_H */
diff --git a/arch/st200/include/asm/mman.h b/arch/st200/include/asm/mman.h
new file mode 100644
index 0000000..b477994
--- /dev/null
+++ b/arch/st200/include/asm/mman.h
@@ -0,0 +1,17 @@
+#ifndef _ASM_ST200_MMAN_H
+#define _ASM_ST200_MMAN_H
+
+#include <asm-generic/mman.h>
+
+#define MAP_GROWSDOWN	0x0100	/* stack-like segment */
+#define MAP_DENYWRITE	0x0800	/* ETXTBSY */
+#define MAP_EXECUTABLE	0x1000	/* mark it as an executable */
+#define MAP_LOCKED	0x2000	/* pages are locked */
+#define MAP_NORESERVE	0x4000	/* don't check for reservations */
+#define MAP_POPULATE	0x8000	/* populate (prefault) page tables */
+#define MAP_NONBLOCK	0x10000	/* do not block on IO */
+
+#define MCL_CURRENT	1	/* lock all current mappings */
+#define MCL_FUTURE	2	/* lock all future mappings */
+
+#endif /* _ASM_ST200_MMAN_H */
diff --git a/arch/st200/include/asm/mmu.h b/arch/st200/include/asm/mmu.h
new file mode 100644
index 0000000..59ad5ce
--- /dev/null
+++ b/arch/st200/include/asm/mmu.h
@@ -0,0 +1,18 @@
+/*
+ * include/asm-st200/mmu.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *      Author: David McKay <david.mckay@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_MMU_H
+#define _ASM_ST200_MMU_H
+
+/* Default "unsigned long" context */
+typedef struct {
+  unsigned long  id;
+  unsigned long  vdso;
+} mm_context_t;
+
+#endif
diff --git a/arch/st200/include/asm/mmu_context.h b/arch/st200/include/asm/mmu_context.h
new file mode 100644
index 0000000..f317c64
--- /dev/null
+++ b/arch/st200/include/asm/mmu_context.h
@@ -0,0 +1,130 @@
+/*
+ * include/asm-st200/mmu_context.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * Derived from include/asm-mips/mmu_context.h which is:
+ *	Copyright (C) 1996, 1997, 1998, 1999 by Ralf Baechle
+ *	Copyright (C) 1999 Silicon Graphics, Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ */
+#ifndef _ASM_ST200_MMU_CONTEXT_MMU_H
+#define _ASM_ST200_MMU_CONTEXT_MMU_H
+
+#include <linux/slab.h>
+#include <asm/pgalloc.h>
+#include <asm/system.h>
+#include <asm/ctrlregdef.h>
+#include <asm/io.h>
+#include <asm-generic/mm_hooks.h>
+
+extern unsigned long asid_cache;
+extern pgd_t *current_pgd[];
+
+#define ASID_INC	0x1
+#define ASID_MASK	0xff
+
+extern inline void set_asid(unsigned long asid)
+{
+	ctrl_outl(asid & ASID_MASK, TLB_ASID);
+}
+
+static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
+{
+}
+
+/*
+ *  All unused by hardware upper bits will be considered
+ *  as a software asid extension.
+ */
+#define ASID_VERSION_MASK  ((unsigned long)~ASID_MASK)
+#define ASID_FIRST_VERSION ((unsigned long)(~ASID_VERSION_MASK) + 1)
+
+extern inline void get_new_mmu_context(struct mm_struct *mm, unsigned long asid)
+{
+	/* gross hack to avoid having to include tlbflush.h */
+	extern void flush_tlb_all(void);
+
+	if (!((asid += ASID_INC) & ASID_MASK)) {
+		flush_tlb_all();	/* start new asid cycle */
+		if (!asid)	/* fix version if needed */
+			asid = ASID_FIRST_VERSION;
+	}
+	mm->context.id = asid_cache = asid;
+}
+
+/*
+ * Initialize the context related info for a new mm_struct
+ * instance.
+ */
+extern inline int
+init_new_context(struct task_struct *tsk, struct mm_struct *mm)
+{
+#ifndef CONFIG_SMP
+	mm->context.id = 0;
+#else
+	mm->context.id = (unsigned long)kmalloc(smp_num_cpus *
+						sizeof(unsigned long),
+						GFP_KERNEL);
+	/*
+	 * Init the "context" values so that a tlbpid allocation
+	 * happens on the first switch.
+	 */
+	if (mm->context.id == 0)
+		return -ENOMEM;
+	memset((void *)mm->context.id, 0, smp_num_cpus * sizeof(unsigned long));
+#endif
+	return 0;
+}
+
+/*
+ * Check that the specified context is part of the current cycle.
+ */
+extern inline int context_valid(unsigned long context)
+{
+	return !((context ^ asid_cache) & ASID_VERSION_MASK);
+}
+
+extern inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
+			     struct task_struct *tsk)
+{
+	unsigned long asid = asid_cache;
+
+	/* Check if our ASID is of an older version and thus invalid */
+	if ((next->context.id ^ asid) & ASID_VERSION_MASK)
+		get_new_mmu_context(next, asid);
+
+	current_pgd[smp_processor_id()] = next->pgd;
+	set_asid(next->context.id);
+}
+
+/*
+ * Destroy context related info for an mm_struct that is about
+ * to be put to rest.
+ */
+extern inline void destroy_context(struct mm_struct *mm)
+{
+	/* Nothing to do.  */
+}
+
+/*
+ * After we have set current->mm to a new value, this activates
+ * the context for the new mm so we see the new mappings.
+ */
+extern inline void activate_mm(struct mm_struct *prev, struct mm_struct *next)
+{
+	/* Unconditionally get a new ASID.  */
+	get_new_mmu_context(next, asid_cache);
+
+	current_pgd[smp_processor_id()] = next->pgd;
+	set_asid(next->context.id);
+}
+
+#define deactivate_mm(tsk,mm)	do { } while (0)
+
+#endif /* _ASM_ST200_MMU_CONTEXT_MMU_H */
diff --git a/arch/st200/include/asm/module.h b/arch/st200/include/asm/module.h
new file mode 100644
index 0000000..86044f0
--- /dev/null
+++ b/arch/st200/include/asm/module.h
@@ -0,0 +1,14 @@
+#ifndef _ASM_ST200_MODULE_H
+#define _ASM_ST200_MODULE_H
+
+/* ST200 is simple */
+struct mod_arch_specific {
+	unsigned long stub_offset, stub_count, stub_max;
+	unsigned long init_stub_offset, init_stub_count, init_stub_max;
+};
+
+#define Elf_Shdr Elf32_Shdr
+#define Elf_Sym Elf32_Sym
+#define Elf_Ehdr Elf32_Ehdr
+
+#endif /* _ASM_ST200_MODULE_H */
diff --git a/arch/st200/include/asm/msgbuf.h b/arch/st200/include/asm/msgbuf.h
new file mode 100644
index 0000000..d296ec9
--- /dev/null
+++ b/arch/st200/include/asm/msgbuf.h
@@ -0,0 +1,31 @@
+#ifndef _ASM_ST200_MSGBUF_H
+#define _ASM_ST200_MSGBUF_H
+
+/*
+ * The msqid64_ds structure for ST200 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct msqid64_ds {
+	struct ipc64_perm msg_perm;
+	__kernel_time_t msg_stime;	/* last msgsnd time */
+	unsigned long __unused1;
+	__kernel_time_t msg_rtime;	/* last msgrcv time */
+	unsigned long __unused2;
+	__kernel_time_t msg_ctime;	/* last change time */
+	unsigned long __unused3;
+	unsigned long msg_cbytes;	/* current number of bytes on queue */
+	unsigned long msg_qnum;	/* number of messages in queue */
+	unsigned long msg_qbytes;	/* max number of bytes on queue */
+	__kernel_pid_t msg_lspid;	/* pid of last msgsnd */
+	__kernel_pid_t msg_lrpid;	/* last receive pid */
+	unsigned long __unused4;
+	unsigned long __unused5;
+};
+
+#endif /* _ASM_ST200_MSGBUF_H */
diff --git a/arch/st200/include/asm/mutex.h b/arch/st200/include/asm/mutex.h
new file mode 100644
index 0000000..458c1f7
--- /dev/null
+++ b/arch/st200/include/asm/mutex.h
@@ -0,0 +1,9 @@
+/*
+ * Pull in the generic implementation for the mutex fastpath.
+ *
+ * TODO: implement optimized primitives instead, or leave the generic
+ * implementation in place, or pick the atomic_xchg() based generic
+ * implementation. (see asm-generic/mutex-xchg.h for details)
+ */
+
+#include <asm-generic/mutex-dec.h>
diff --git a/arch/st200/include/asm/namei.h b/arch/st200/include/asm/namei.h
new file mode 100644
index 0000000..1bc5c08
--- /dev/null
+++ b/arch/st200/include/asm/namei.h
@@ -0,0 +1,11 @@
+#ifndef _ASM_ST200_NAMEI_H
+#define _ASM_ST200_NAMEI_H
+
+/* This dummy routine maybe changed to something useful
+ * for /usr/gnemul/ emulation stuff.
+ * Look at asm-sparc/namei.h for details.
+ */
+
+#define __emul_prefix() NULL
+
+#endif /* _ASM_ST200_NAMEI_H */
diff --git a/arch/st200/include/asm/page.h b/arch/st200/include/asm/page.h
new file mode 100644
index 0000000..162fe7d
--- /dev/null
+++ b/arch/st200/include/asm/page.h
@@ -0,0 +1,121 @@
+/*
+ *  include/asm-st200/io.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_PAGE_H
+#define _ASM_ST200_PAGE_H
+
+/* PAGE_SHIFT determines the page size */
+#define PAGE_SHIFT	13
+#define PAGE_SIZE	(1 << PAGE_SHIFT)
+#define PAGE_MASK	(~(PAGE_SIZE-1))
+
+#define PAGE_SHIFT_256M		28
+#define PAGE_SIZE_256M		(1<<PAGE_SHIFT_256M)
+#define PAGE_MASK_256M		(~(PAGE_SIZE_256M-1))
+
+/* We do define AT_SYSINFO_EHDR but don't use the gate mechanism */
+#define __HAVE_ARCH_GATE_AREA		1
+
+#ifdef __KERNEL__
+#ifndef __ASSEMBLY__
+
+#define clear_page(page)	memset((void *)(page), 0, PAGE_SIZE)
+#define copy_page(to,from)	memcpy((void *)(to), (void *)(from), PAGE_SIZE)
+
+#define clear_user_page(to, vaddr, page)	\
+do {						\
+	clear_page(to);				\
+	flush_dcache_page(page);		\
+} while (0)
+#define copy_user_page(to, from, vaddr, page)	\
+do {						\
+	copy_page(to, from);			\
+	flush_dcache_page(page);		\
+} while (0)
+
+/*
+ * These are used to make use of C type-checking..
+ */
+typedef struct {
+	unsigned long pte;
+} pte_t;
+typedef struct {
+	unsigned long pmd;
+} pmd_t;
+typedef struct {
+	unsigned long pgd;
+} pgd_t;
+typedef struct {
+	unsigned long pgprot;
+} pgprot_t;
+typedef struct page *pgtable_t;
+
+#define pte_val(x)	((x).pte)
+#define pmd_val(x)	((x).pmd)
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+
+#define __pte(x) ((pte_t) { (x) } )
+#define __pmd(x) ((pmd_t) { (x) } )
+#define __pgd(x) ((pgd_t) { (x) } )
+#define __pgprot(x)	((pgprot_t) { (x) } )
+
+#endif /* !__ASSEMBLY__ */
+
+/* Start of kernel address space */
+#define __PAGE_OFFSET		(0x80000000)
+
+#define CONTROL_START		(0xffff0000)
+
+#define BIG_PAGE_SIZE           (256*1024*1024)
+#define _MEMORY_START		CONFIG_MEMORY_START
+#define _MEMORY_SIZE		CONFIG_MEMORY_SIZE
+
+#define _MEMORY_OFFSET          (CONFIG_MEMORY_START%BIG_PAGE_SIZE)
+#define _MEMORY_PAGES           ((CONFIG_MEMORY_START/BIG_PAGE_SIZE)*BIG_PAGE_SIZE)
+
+/*
+ * PFNs start at physical 0, while pages start at _MEMORY_START
+ */
+#define ARCH_PFN_OFFSET		(_MEMORY_START >> PAGE_SHIFT)
+
+#ifndef __ASSEMBLY__
+
+extern unsigned long last_user_utlb_entry;
+#define UTLB_USER_START		0
+#define UTLB_USER_LAST		last_user_utlb_entry
+#define UTLB_USER_ENTRIES	(UTLB_USER_LAST - UTLB_USER_START + 1)
+#define UTLB_KERNEL_ENTRY	(UTLB_USER_LAST + 1)
+
+#define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
+
+#define __pa(x)			(((unsigned long)(x)-PAGE_OFFSET)+_MEMORY_PAGES)
+#define __va(x)                 ((void *)(((unsigned long)(x)-_MEMORY_PAGES)+ PAGE_OFFSET))
+
+#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
+#define pfn_valid(pfn)		(((pfn) - ARCH_PFN_OFFSET) < max_mapnr)
+#define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
+
+/*
+ * Default vma flags for stack and anonymous pages
+ * Note we do not have execute permission.
+ */
+#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | \
+				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+
+/* Is this physical address RAM or not? */
+int phys_is_ram(unsigned long physaddr);
+
+#endif /* __ASSEMBLY__ */
+
+#include <asm-generic/memory_model.h>
+#include <asm-generic/getorder.h>
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_ST200_PAGE_H */
diff --git a/arch/st200/include/asm/param.h b/arch/st200/include/asm/param.h
new file mode 100644
index 0000000..d59451e
--- /dev/null
+++ b/arch/st200/include/asm/param.h
@@ -0,0 +1,26 @@
+/*
+ * include/asm-st200/param.h
+ */
+
+#ifndef _ASM_ST200_PARAM_H
+#define _ASM_ST200_PARAM_H
+
+#ifdef __KERNEL__
+# define HZ		100	/* Internal kernel timer frequency */
+# define USER_HZ	100	/* .. some user interfaces are in "ticks" */
+# define CLOCKS_PER_SEC	(USER_HZ)	/* like times() */
+#endif
+
+#ifndef HZ
+#define HZ 100
+#endif
+
+#define EXEC_PAGESIZE	8192
+
+#ifndef NOGROUP
+#define NOGROUP		(-1)
+#endif
+
+#define MAXHOSTNAMELEN	64	/* max length of hostname */
+
+#endif /* _ASM_ST200_PARAM_H */
diff --git a/arch/st200/include/asm/pci.h b/arch/st200/include/asm/pci.h
new file mode 100644
index 0000000..a7aaa4b
--- /dev/null
+++ b/arch/st200/include/asm/pci.h
@@ -0,0 +1,39 @@
+#ifndef _ASM_ST200_PCI_H
+#define _ASM_ST200_PCI_H
+
+#ifdef __KERNEL__
+
+#include <linux/mm.h>
+#include <asm/scatterlist.h>
+
+#define pcibios_assign_all_busses()     1
+
+/* Defined in board or soc layer */
+extern const unsigned long PCIBIOS_MIN_IO, PCIBIOS_MIN_MEM;
+
+/* Global pointer to base of memory mapped IO region */
+extern void *pcibios_io_region;
+
+/* We only support one pci controller at the moment */
+extern struct pci_ops *pcibios_pci_ops;
+
+/* The PCI address space does equal the physical memory
+ * address space.  The networking and block device layers use
+ * this boolean for bounce buffer decisions.
+ */
+#define PCI_DMA_BUS_IS_PHYS     (1)
+
+void pcibios_set_master(struct pci_dev *dev);
+
+/* Gives us the slot to irq number mapping */
+int pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin);
+
+#endif /* __KERNEL__ */
+
+/* implement the pci_ DMA API in terms of the generic device dma_ one */
+#include <asm-generic/pci-dma-compat.h>
+
+/* generic pci stuff */
+#include <asm-generic/pci.h>
+
+#endif /* _ASM_ST200_PCI_H */
diff --git a/arch/st200/include/asm/percpu.h b/arch/st200/include/asm/percpu.h
new file mode 100644
index 0000000..450d896
--- /dev/null
+++ b/arch/st200/include/asm/percpu.h
@@ -0,0 +1,6 @@
+#ifndef _ASM_ST200_PERCPU_H
+#define _ASM_ST200_PERCPU_H
+
+#include <asm-generic/percpu.h>
+
+#endif /* _ASM_ST200_PERCPU_H */
diff --git a/arch/st200/include/asm/pgalloc.h b/arch/st200/include/asm/pgalloc.h
new file mode 100644
index 0000000..794ecdd
--- /dev/null
+++ b/arch/st200/include/asm/pgalloc.h
@@ -0,0 +1,95 @@
+#ifndef _ASM_ST200_PGALLOC_MMU_H
+#define _ASM_ST200_PGALLOC_MMU_H
+
+#include <linux/mm.h>
+
+/*
+ * Allocate and free page tables. The xxx_kernel() versions are
+ * used to allocate a kernel page table.
+ */
+
+static inline void
+pmd_populate(struct mm_struct *mm, pmd_t * pmd, struct page *page)
+{
+	set_pmd(pmd,
+		__pmd((unsigned long)__va(page_to_pfn(page) << PAGE_SHIFT)));
+}
+
+static inline void
+pmd_populate_kernel(struct mm_struct *mm, pmd_t * pmd, pte_t * pte)
+{
+	set_pmd(pmd, __pmd((unsigned long)pte));
+}
+
+static inline void pgd_populate(struct mm_struct *mm, pgd_t * pgd, pmd_t * pmd)
+{
+	BUG();
+}
+
+static inline pgd_t *pgd_alloc(struct mm_struct *mm)
+{
+	//unsigned int pgd_size = (PTRS_PER_PGD * sizeof(pgd_t));
+	pgd_t *pgd = (pgd_t *) __get_free_page(GFP_KERNEL);
+
+	if (pgd) {
+		memset(pgd, 0, USER_PTRS_PER_PGD * sizeof(pgd_t));
+		memcpy(pgd + USER_PTRS_PER_PGD,
+		       swapper_pg_dir + USER_PTRS_PER_PGD,
+		       (PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
+	}
+
+	return pgd;
+}
+
+static inline void pgd_free(struct mm_struct *mm, pgd_t * pgd)
+{
+	free_page((unsigned long)pgd);
+}
+
+#define __pmd_free_tlb(tlb,x, address ) do { } while (0)
+
+static inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long address)
+{
+	BUG();
+	return (pmd_t *) 1;
+}
+
+static inline void pmd_free(struct mm_struct *mm, pmd_t * pmd)
+{
+}
+
+extern pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long addr);
+
+static inline void pte_free_kernel(struct mm_struct *mm, pte_t * pte)
+{
+	free_page((unsigned long)pte);
+}
+
+static inline pgtable_t pte_alloc_one(struct mm_struct *mm, unsigned long addr)
+{
+	pte_t *pte = pte_alloc_one_kernel(mm, addr);
+	struct page *page;
+
+	if (!pte)
+		return NULL;
+
+	page = virt_to_page(pte);
+	pgtable_page_ctor(page);
+	return page;
+}
+
+static inline void pte_free(struct mm_struct *mm, pgtable_t ptepage)
+{
+	pgtable_page_dtor(ptepage);
+	__free_page(ptepage);
+}
+
+#define __pte_free_tlb(tlb, pte, address ) 	\
+	do {					\
+		pgtable_page_dtor(pte);		\
+		tlb_remove_page((tlb),(pte));	\
+	} while (0)
+
+#define check_pgt_cache()	do { } while (0)
+
+#endif /* _ASM_ST200_PGALLOC_H */
diff --git a/arch/st200/include/asm/pgtable.h b/arch/st200/include/asm/pgtable.h
new file mode 100644
index 0000000..2dc425c
--- /dev/null
+++ b/arch/st200/include/asm/pgtable.h
@@ -0,0 +1,532 @@
+/*
+ * include/asm-st200/pgtable-mmu.h
+ *
+ * Copyright (C) 2002-3 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_PGTABLE_MMU_H
+#define _ASM_ST200_PGTABLE_MMU_H
+
+#include <asm-generic/4level-fixup.h>
+
+#include <asm/page.h>
+
+
+#ifndef __ASSEMBLY__
+struct mm_struct;
+struct vm_area_struct;
+#endif
+
+/*
+ * The Linux memory management assumes a three-level page table setup. On
+ * the ST200, we use that, but "fold" the mid level into the top-level page
+ * table.
+ *
+ * Given a virtual address:
+ * - the lowest PAGE_SHIFT bits determine offset into the page
+ * - the next higher PAGE_SHIFT-2 bits determine the pte# in the pagetable
+ *   directory (the -2 is from the 4 byte ptes, and each page table is a
+ *   single page long).
+ * - the remaining bits determine pgd#.
+ *
+ * Pictorially (assuming an 8K page):
+ *
+ *        pgd#                  pte#                page offset
+ * +----------------+----------------------+--------------------------+
+ * |31            24|23                  13|12                       0|
+ * +----------------+----------------------+--------------------------+
+ */
+
+/* PMD_SHIFT determines the size of the area a second-level page table can map */
+#define PMD_SHIFT       (PAGE_SHIFT + (PAGE_SHIFT-2))
+#define PMD_SIZE        (1UL << PMD_SHIFT)
+#define PMD_MASK        (~(PMD_SIZE-1))
+
+/* PGDIR_SHIFT determines what a third-level page table entry can map */
+#define PGDIR_SHIFT	PMD_SHIFT
+#define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
+#define PGDIR_MASK	(~(PGDIR_SIZE-1))
+
+/* Entries per page directory level: we use two-level, so
+ * we don't really have any PMD directory physically.
+ */
+#define PTRS_PER_PTE    (PAGE_SIZE >> 2)
+#define PTRS_PER_PMD    1
+#define PTRS_PER_PGD    (1<<(32 - PGDIR_SHIFT))
+
+#define USER_PTRS_PER_PGD       (TASK_SIZE/PGDIR_SIZE)
+#define FIRST_USER_ADDRESS      0
+
+#ifdef UNKNOWN
+#define USER_PGD_PTRS (PAGE_OFFSET >> PGDIR_SHIFT)
+#define KERNEL_PGD_PTRS (PTRS_PER_PGD-USER_PGD_PTRS)
+#endif
+
+#define pte_ERROR(e) \
+	printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, pte_val(e))
+#define pmd_ERROR(e) \
+	printk("%s:%d: bad pmd %08lx.\n", __FILE__, __LINE__, pmd_val(e))
+#define pgd_ERROR(e) \
+	printk("%s:%d: bad pgd %08lx.\n", __FILE__, __LINE__, pgd_val(e))
+
+/*
+ * Align vmalloc and boot time mappings on a 16M boundary, to try and make
+ * best use of pte directories.
+ * We also leave a gap between physical memory, vmalloc, boot mappings
+ * and control registers to try and catch any out-of-bounds memory accesses.
+ * The allocation routines leave a page sized hole between each allocated
+ * area for the same reason. ;)
+ */
+#define VMALLOC_OFFSET	(16*1024*1024)
+#define VMALLOC_START	(0xc0000000 & ~(VMALLOC_OFFSET - 1))
+#define VMALLOC_END	((CONTROL_START - (3 * VMALLOC_OFFSET)) \
+				& ~(VMALLOC_OFFSET - 1))
+
+/* Area of virtual memory reserved for dma_coherent allocations */
+#define CONSISTENT_START	((CONTROL_START - (2 * VMALLOC_OFFSET)) \
+					& ~(VMALLOC_OFFSET - 1))
+#define CONSISTENT_END		((CONTROL_START - VMALLOC_OFFSET) \
+					& ~(VMALLOC_OFFSET - 1))
+
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+
+/* TLB_ENTRY2 */
+#define _PAGE_PADDR_MASK	0x0007ffff
+
+/* TLB_ENTRY0 */
+#define _PAGE_BIT_SHARED	19
+
+#define _PAGE_SHARED		(1 << _PAGE_BIT_SHARED)
+
+/* Software flags */
+#define _PAGE_BIT_ACCESSED	20
+#define _PAGE_BIT_SOFT_USER_X	21
+
+#define _PAGE_ACCESSED		(1 << _PAGE_BIT_ACCESSED)
+#define _PAGE_SOFT_USER_X	(1 << _PAGE_BIT_SOFT_USER_X)
+
+/* TLB_ENTRY0 */
+#define _PAGE_BIT_PROT_SUPER_W	22
+#define _PAGE_BIT_PROT_USER_X	23
+#define _PAGE_BIT_PROT_USER_R	24
+#define _PAGE_BIT_PROT_USER_W	25
+#define _PAGE_BIT_DIRTY		26
+#define _PAGE_BIT_POLICY0	27
+#define _PAGE_BIT_POLICY1	28
+#define _PAGE_BIT_UNUSED	29	/* when pte_present */
+#define _PAGE_BIT_FILE		29	/* when !pte_present */
+#define _PAGE_BIT_SIZE0		30
+#define _PAGE_BIT_SIZE1		31
+
+#define _PAGE_PROT_SUPER_W	(1 << _PAGE_BIT_PROT_SUPER_W)
+#define _PAGE_PROT_USER_X	(1 << _PAGE_BIT_PROT_USER_X)
+#define _PAGE_PROT_USER_R	(1 << _PAGE_BIT_PROT_USER_R)
+#define _PAGE_PROT_USER_W	(1 << _PAGE_BIT_PROT_USER_W)
+#define _PAGE_PROT_ALL_W        ( _PAGE_PROT_SUPER_W |  _PAGE_PROT_USER_W )
+#define _PAGE_DIRTY		(1 << _PAGE_BIT_DIRTY)
+#define _PAGE_POLICY_NC		(0 << _PAGE_BIT_POLICY0)
+#define _PAGE_POLICY_C		(1 << _PAGE_BIT_POLICY0)
+#define _PAGE_POLICY_NCWC	(2 << _PAGE_BIT_POLICY0)
+#define _PAGE_POLICY_MASK	(3 << _PAGE_BIT_POLICY0)
+#define _PAGE_FILE		(1 << _PAGE_BIT_FILE)
+#define _PAGE_SIZE_DISABLED	(0 << _PAGE_BIT_SIZE0)
+#define _PAGE_SIZE_8K		(1 << _PAGE_BIT_SIZE0)
+#define _PAGE_SIZE_4M		(2 << _PAGE_BIT_SIZE0)
+#define _PAGE_SIZE_256M		(3 << _PAGE_BIT_SIZE0)
+#define _PAGE_SIZE_MASK		(3 << _PAGE_BIT_SIZE0)
+
+/* Masks and shifts to convert pte's to TLB entries */
+#define _PAGE_TLB_ENTRY2_MASK		_PAGE_PADDR_MASK
+#define _PAGE_TLB_ENTRY0_0_MASK		0x1Fc80000
+#define _PAGE_TLB_ENTRY0_0_SHIFT	11
+#define _PAGE_TLB_ENTRY0_1_MASK		0xc0000000
+#define _PAGE_TLB_ENTRY0_1_SHIFT	10
+
+/* Extra bits which need to be ORed into TLB_ENTRY0 */
+#define TLB_ENTRY0_EXTRABITS	( TLB_ENTRY0_PROT_SUPER_X |  TLB_ENTRY0_PROT_SUPER_R )
+
+/* Bits which are not modified when changing a pte's permissions */
+#define _PAGE_CHG_MASK	(_PAGE_PADDR_MASK | _PAGE_ACCESSED | _PAGE_DIRTY)
+
+/* Bits which are set for a 'normal' page */
+#define _PAGE_NORMAL		(_PAGE_SIZE_8K | _PAGE_ACCESSED | _PAGE_POLICY_C)
+#define _PAGE_NORMAL_NC		((_PAGE_NORMAL & ~_PAGE_POLICY_MASK) | _PAGE_POLICY_NC)
+#define _PAGE_NORMAL_NCWC	((_PAGE_NORMAL & ~_PAGE_POLICY_MASK) | _PAGE_POLICY_NCWC)
+
+#ifndef __ASSEMBLY__
+
+/*
+ * All the normal masks have the "page accessed" bits on, as any time
+ * they are used, the page is accessed. They are cleared only by the
+ * page-out routines.
+ *
+ * PAGE_COPY is used for the stack, so usually has the execute bit set.
+ * However we are trying to avoid this, so don't for now, and see
+ * what breaks.
+ *
+ * Note we use _PAGE_SIZE_DISABLED to mark pages which are not present,
+ * so we set _PAGE_SIZE_8K even for PAGE_NONE.
+ */
+#define PAGE_NONE	__pgprot(_PAGE_NORMAL)
+#define PAGE_SHARED	__pgprot(_PAGE_NORMAL | _PAGE_PROT_USER_R | _PAGE_PROT_ALL_W)
+#define PAGE_COPY	__pgprot(_PAGE_NORMAL | _PAGE_PROT_USER_R)
+#define PAGE_READONLY	__pgprot(_PAGE_NORMAL | _PAGE_PROT_USER_R)
+#define PAGE_KERNEL	__pgprot(_PAGE_NORMAL | _PAGE_SHARED | _PAGE_DIRTY | _PAGE_PROT_SUPER_W)
+#define PAGE_KERNEL_NC	__pgprot(_PAGE_NORMAL_NC | _PAGE_SHARED | _PAGE_DIRTY | _PAGE_PROT_SUPER_W)
+#define PAGE_KERNEL_NCWC	__pgprot(_PAGE_NORMAL_NCWC | _PAGE_SHARED | _PAGE_DIRTY | _PAGE_PROT_SUPER_W)
+
+#define _PAGE_P(x) __pgprot(_PAGE_NORMAL | ((x) & (~_PAGE_PROT_ALL_W)))
+#define _PAGE_S(x) __pgprot(_PAGE_NORMAL | (x))
+
+	/* xwr */
+#define __P000	_PAGE_P(0)
+#define __P001	_PAGE_P(_PAGE_PROT_USER_R)
+#define __P010	_PAGE_P(_PAGE_PROT_USER_W)
+#define __P011	_PAGE_P(_PAGE_PROT_USER_W | _PAGE_PROT_USER_R)
+#define __P100	_PAGE_P(_PAGE_SOFT_USER_X)
+#define __P101	_PAGE_P(_PAGE_SOFT_USER_X | _PAGE_PROT_USER_R)
+#define __P110	_PAGE_P(_PAGE_SOFT_USER_X | _PAGE_PROT_ALL_W)
+#define __P111	_PAGE_P(_PAGE_SOFT_USER_X | _PAGE_PROT_ALL_W | _PAGE_PROT_USER_R)
+
+#define __S000	_PAGE_S(0)
+#define __S001	_PAGE_S(_PAGE_PROT_USER_R)
+#define __S010	_PAGE_S(_PAGE_PROT_USER_W)
+#define __S011	_PAGE_S(_PAGE_PROT_USER_W | _PAGE_PROT_USER_R)
+#define __S100	_PAGE_S(_PAGE_SOFT_USER_X)
+#define __S101	_PAGE_S(_PAGE_SOFT_USER_X | _PAGE_PROT_USER_R)
+#define __S110	_PAGE_S(_PAGE_SOFT_USER_X | _PAGE_PROT_ALL_W)
+#define __S111	_PAGE_S(_PAGE_SOFT_USER_X | _PAGE_PROT_ALL_W | _PAGE_PROT_USER_R)
+
+/*
+ * Certain architectures need to do special things when PTEs
+ * within a page table are directly modified.  Thus, the following
+ * hook is made available.
+ *
+ * pmds are folded into pgds so set_pmd doesnt get actually called,
+ * but the define is needed for a generic inline function.
+ */
+void set_pte(pte_t * ptep, pte_t pte);
+
+#define set_pte_at(mm,addr,ptep,pteval) set_pte(ptep,pteval)
+
+#define set_pmd(pmdptr, pmdval) (*(pmdptr) = pmdval)
+#define set_pgd(pgdptr, pgdval) (*(pgdptr) = pgdval)
+
+static inline unsigned long pte_pfn(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_PADDR_MASK;
+}
+
+static inline pte_t pfn_pte(unsigned long pfn, pgprot_t prot)
+{
+	return __pte(pfn | pgprot_val(prot));
+}
+
+static inline unsigned long pmd_pfn(pmd_t pmd)
+{
+	return __pa(pmd_val(pmd)) >> PAGE_SHIFT;
+}
+
+/* returns the "struct page *" corresponding to the pte/pmd */
+#define pte_page(pte)		pfn_to_page(pte_pfn(pte))
+#define pmd_page(pmd)		pfn_to_page(pmd_pfn(pmd))
+#define pmd_pgtable(pmd) 	pmd_page(pmd)
+
+#define mk_pte(page, pgprot)	pfn_pte(page_to_pfn(page), (pgprot))
+
+/*
+ * Remember pte_none() and pte_present() must work without checking
+ * the other first. We use _PAGE_SIZE_DISABLED to mark pages not
+ * present (and keep these bits free in swp_entry_t). pte_none will
+ * always fail for present pages (because the _PAGE_SIZE bits will be
+ * set), and for not present pages, because the offset cannot be zero.
+ */
+extern inline int pte_none(pte_t pte)
+{
+	return !pte_val(pte);
+}
+
+extern inline int pte_present(pte_t pte)
+{
+	return (pte_val(pte) & _PAGE_SIZE_MASK) != _PAGE_SIZE_DISABLED;
+}
+
+extern inline void pte_clear(struct mm_struct *mm, unsigned long addr,
+			     pte_t * ptep)
+{
+	set_pte_at(mm, addr, ptep, __pte(0));
+}
+
+extern inline int pmd_none(pmd_t pmd)
+{
+	return !pmd_val(pmd);
+}
+
+extern void *high_memory;
+extern inline int pmd_bad(pmd_t pmd)
+{
+	return (pmd_val(pmd) > (unsigned long)high_memory) ||
+	    (pmd_val(pmd) < (PAGE_OFFSET + _MEMORY_OFFSET));
+}
+
+extern inline int pmd_present(pmd_t pmd)
+{
+	return pmd_val(pmd);
+}
+
+extern inline void pmd_clear(pmd_t * pmdp)
+{
+	set_pmd(pmdp, __pmd(0));
+}
+
+/*
+ * The "pgd_xxx()" functions here are trivial for a folded two-level
+ * setup: the pgd is never bad, and a pmd always exists (as it's folded
+ * into the pgd entry)
+ */
+extern inline int pgd_none(pgd_t pgd)
+{
+	return 0;
+}
+
+extern inline int pgd_bad(pgd_t pgd)
+{
+	return 0;
+}
+
+extern inline int pgd_present(pgd_t pgd)
+{
+	return 1;
+}
+
+extern inline void pgd_clear(pgd_t * pgdp)
+{
+}
+
+#define pages_to_mb(x) ((x) >> (20-PAGE_SHIFT))
+
+/*
+ * The following only work if pte_present() is true.
+ * Undefined behaviour if not..
+ */
+static inline int pte_read(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_PROT_USER_R;
+}
+
+static inline int pte_exec(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_SOFT_USER_X;
+}
+
+static inline int pte_dirty(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_DIRTY;
+}
+
+static inline int pte_young(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_ACCESSED;
+}
+
+static inline int pte_write(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_PROT_USER_W;
+}
+
+#define pte_special(pte) (0)
+
+static inline pte_t pte_rdprotect(pte_t pte)
+{
+	pte_val(pte) &= ~_PAGE_PROT_USER_R;
+	return pte;
+}
+
+static inline pte_t pte_exprotect(pte_t pte)
+{
+	pte_val(pte) &= ~(_PAGE_SOFT_USER_X | _PAGE_PROT_USER_X);
+	return pte;
+}
+
+static inline pte_t pte_mkclean(pte_t pte)
+{
+	pte_val(pte) &= ~_PAGE_DIRTY;
+	return pte;
+}
+
+static inline pte_t pte_mkold(pte_t pte)
+{
+	pte_val(pte) &= ~_PAGE_ACCESSED;
+	return pte;
+}
+
+static inline pte_t pte_wrprotect(pte_t pte)
+{
+	pte_val(pte) &= ~_PAGE_PROT_ALL_W;
+	return pte;
+}
+
+static inline pte_t pte_mkread(pte_t pte)
+{
+	pte_val(pte) |= _PAGE_PROT_USER_R;
+	return pte;
+}
+
+static inline pte_t pte_mkexec(pte_t pte)
+{
+	pte_val(pte) |= _PAGE_SOFT_USER_X;
+	return pte;
+}
+
+static inline pte_t pte_mkdirty(pte_t pte)
+{
+	pte_val(pte) |= _PAGE_DIRTY;
+	return pte;
+}
+
+static inline pte_t pte_mkyoung(pte_t pte)
+{
+	pte_val(pte) |= _PAGE_ACCESSED;
+	return pte;
+}
+
+static inline pte_t pte_mkwrite(pte_t pte)
+{
+	pte_val(pte) |= _PAGE_PROT_ALL_W;
+	return pte;
+}
+
+static inline pte_t pte_mkspecial(pte_t pte)
+{
+	return pte;
+}
+
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+{
+	return __pte((pte_val(pte) & _PAGE_CHG_MASK) | pgprot_val(newprot));
+}
+
+/* to find an entry in a page-table-directory. */
+#define pgd_index(address) (( address >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
+#define pgd_offset(mm, address) ((mm)->pgd+pgd_index(address))
+
+/* to find an entry in a kernel page-table-directory */
+#define pgd_offset_k(address) pgd_offset(&init_mm, address)
+
+/* Find an entry in the second-level page table.. */
+/* Trivial for the folded page table */
+extern inline pmd_t *pmd_offset(pgd_t * dir, unsigned long address)
+{
+	return (pmd_t *) dir;
+}
+
+/* Find an entry in the third-level page table.. */
+extern inline pte_t *pte_offset_kernel(pmd_t * pmdp, unsigned long address)
+{
+	return (pte_t *) pmd_val(*pmdp) +
+	    ((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1));
+}
+
+#define pte_offset_map		pte_offset_kernel
+#define pte_offset_map_nested	pte_offset_kernel
+#define pte_unmap(pte)		do { } while (0)
+#define pte_unmap_nested(pte)	do { } while (0)
+
+typedef pte_t *pte_addr_t;
+
+extern void update_mmu_cache(struct vm_area_struct *vma,
+			     unsigned long address, pte_t pte);
+
+/* Handling of pte entries which represent not_present() pages. */
+/* We use _PAGE_SIZE_DISABLED (which is fortunatly zero) to flag pages
+ * which are not present, so:
+ *  bits 31-30	present flag (0)
+ *  bit     29  file
+ *  bits 28- 8	offset
+ *  bits  7- 0	type
+ */
+
+/* Encode and de-code a swap entry */
+#define __swp_type(x)			((x).val & 0xff)
+#define __swp_offset(x)			(((x).val & 0x1fffffff) >> 8)
+#define __swp_entry(type, offset)	((swp_entry_t) { ((type) | ((offset) << 8)) & 0x1fffffff })
+#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)		((pte_t) { (x).val })
+
+/* File offset in PTE support. */
+#define pte_file(pte)		(pte_val(pte) & _PAGE_FILE)
+#define pte_to_pgoff(pte)	(pte_val(pte) & 0x1fffffff)
+#define pgoff_to_pte(off)	(__pte((off) | _PAGE_FILE))
+#define PTE_FILE_MAX_BITS	(29UL)	/* We reserve 3 bits in total */
+
+#endif /* !__ASSEMBLY__ */
+
+#ifndef __ASSEMBLY__
+
+extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
+extern void paging_init(void);
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero: used
+ * for zero-mapped memory areas etc..
+ */
+extern unsigned long empty_zero_page[PAGE_SIZE / sizeof(unsigned long)];
+#define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
+
+#endif /* !__ASSEMBLY__ */
+
+#ifndef CONFIG_DISCONTIGMEM
+/*
+ * kern_addr_valid(ADDR) tests if ADDR is pointing to valid kernel
+ * memory.  For the return value to be meaningful, ADDR must be >=
+ * PAGE_OFFSET.  This operation can be relatively expensive (e.g.,
+ * require a hash-, or multi-level tree-lookup or something of that
+ * sort) but it guarantees to return TRUE only if accessing the page
+ * at that address does not cause an error.  Note that there may be
+ * addresses for which kern_addr_valid() returns FALSE even though an
+ * access would not cause an error (e.g., this is typically true for
+ * memory mapped I/O regions.
+ *
+ * XXX Need to implement this for ST200.
+ */
+#define kern_addr_valid(addr)	(1)
+#endif /* !CONFIG_DISCONTIGMEM */
+
+#ifndef __ASSEMBLY__
+
+/*
+ * remap a physical address `phys' of size `size' with page protection `prot'
+ * into virtual address `from'
+ */
+#define io_remap_page_range(vma,from,phys,size,prot) \
+		remap_pfn_range(vma, from, (phys) >> PAGE_SHIFT, size, prot)
+
+/*
+ * Change the page cache policy.
+ */
+#define pgprot_noncached(prot)		\
+	__pgprot((pgprot_val(prot) & ~_PAGE_POLICY_MASK) | _PAGE_POLICY_NC)
+#define pgprot_writecombine(prot)	\
+	__pgprot((pgprot_val(prot) & ~_PAGE_POLICY_MASK) | _PAGE_POLICY_NCWC)
+
+#define pgprot_cached(prot)	\
+	__pgprot((pgprot_val(prot) & ~_PAGE_POLICY_MASK) | _PAGE_POLICY_C)
+#include <asm-generic/pgtable.h>
+
+/*
+ * remap a physical page `pfn' of size `size' with page protection `prot'
+ * into virtual address `from'
+ */
+#define io_remap_pfn_range(vma,from,pfn,size,prot) \
+                remap_pfn_range(vma, from, pfn, size, prot)
+
+/*
+ * No page table caches to initialise
+ */
+#define pgtable_cache_init() do { } while (0)
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _ASM_ST200_PGTABLE_MMU_H */
diff --git a/arch/st200/include/asm/poll.h b/arch/st200/include/asm/poll.h
new file mode 100644
index 0000000..c98509d
--- /dev/null
+++ b/arch/st200/include/asm/poll.h
@@ -0,0 +1 @@
+#include <asm-generic/poll.h>
diff --git a/arch/st200/include/asm/posix_types.h b/arch/st200/include/asm/posix_types.h
new file mode 100644
index 0000000..0430890
--- /dev/null
+++ b/arch/st200/include/asm/posix_types.h
@@ -0,0 +1,140 @@
+/*
+ * include/asm-st200/posix_types.h
+ */
+
+#ifndef _ASM_ST200_POSIX_TYPES_H
+#define _ASM_ST200_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long __kernel_ino_t;
+typedef unsigned int __kernel_mode_t;
+typedef unsigned int __kernel_nlink_t;
+typedef long __kernel_off_t;
+typedef int __kernel_pid_t;
+typedef unsigned int __kernel_ipc_pid_t;
+typedef unsigned int __kernel_uid_t;
+typedef unsigned int __kernel_gid_t;
+typedef unsigned int __kernel_size_t;
+typedef int __kernel_ssize_t;
+typedef int __kernel_ptrdiff_t;
+typedef long __kernel_time_t;
+typedef long __kernel_suseconds_t;
+typedef long __kernel_clock_t;
+typedef int __kernel_timer_t;
+typedef int __kernel_clockid_t;
+typedef int __kernel_daddr_t;
+typedef char *__kernel_caddr_t;
+
+typedef unsigned short __kernel_uid16_t;
+typedef unsigned short __kernel_gid16_t;
+typedef unsigned int __kernel_uid32_t;
+typedef unsigned int __kernel_gid32_t;
+
+typedef unsigned short __kernel_old_uid_t;
+typedef unsigned short __kernel_old_gid_t;
+typedef unsigned short __kernel_old_dev_t;
+
+#ifdef __GNUC__
+typedef long long __kernel_loff_t;
+#endif
+
+typedef struct {
+#if defined(__KERNEL__) || defined(__USE_ALL)
+	int val[2];
+#else				/* !defined(__KERNEL__) && !defined(__USE_ALL) */
+	int __val[2];
+#endif				/* !defined(__KERNEL__) && !defined(__USE_ALL) */
+} __kernel_fsid_t;
+
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+
+#undef __FD_SET
+static __inline__ void __FD_SET(unsigned long fd, __kernel_fd_set * fdsetp)
+{
+	unsigned long _tmp = fd / __NFDBITS;
+	unsigned long _rem = fd % __NFDBITS;
+	fdsetp->fds_bits[_tmp] |= (1UL << _rem);
+}
+
+#undef __FD_CLR
+static __inline__ void __FD_CLR(unsigned long fd, __kernel_fd_set * fdsetp)
+{
+	unsigned long _tmp = fd / __NFDBITS;
+	unsigned long _rem = fd % __NFDBITS;
+	fdsetp->fds_bits[_tmp] &= ~(1UL << _rem);
+}
+
+#undef __FD_ISSET
+static __inline__ int __FD_ISSET(unsigned long fd, const __kernel_fd_set * p)
+{
+	unsigned long _tmp = fd / __NFDBITS;
+	unsigned long _rem = fd % __NFDBITS;
+	return (p->fds_bits[_tmp] & (1UL << _rem)) != 0;
+}
+
+/*
+ * This will unroll the loop for the normal constant case (8 ints,
+ * for a 256-bit fd_set)
+ */
+#undef __FD_ZERO
+static __inline__ void __FD_ZERO(__kernel_fd_set * p)
+{
+	unsigned long *tmp = p->fds_bits;
+	int i;
+
+	if (__builtin_constant_p(__FDSET_LONGS)) {
+		switch (__FDSET_LONGS) {
+		case 16:
+			tmp[0] = 0;
+			tmp[1] = 0;
+			tmp[2] = 0;
+			tmp[3] = 0;
+			tmp[4] = 0;
+			tmp[5] = 0;
+			tmp[6] = 0;
+			tmp[7] = 0;
+			tmp[8] = 0;
+			tmp[9] = 0;
+			tmp[10] = 0;
+			tmp[11] = 0;
+			tmp[12] = 0;
+			tmp[13] = 0;
+			tmp[14] = 0;
+			tmp[15] = 0;
+			return;
+
+		case 8:
+			tmp[0] = 0;
+			tmp[1] = 0;
+			tmp[2] = 0;
+			tmp[3] = 0;
+			tmp[4] = 0;
+			tmp[5] = 0;
+			tmp[6] = 0;
+			tmp[7] = 0;
+			return;
+
+		case 4:
+			tmp[0] = 0;
+			tmp[1] = 0;
+			tmp[2] = 0;
+			tmp[3] = 0;
+			return;
+		}
+	}
+	i = __FDSET_LONGS;
+	while (i) {
+		i--;
+		*tmp = 0;
+		tmp++;
+	}
+}
+
+#endif /* defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2) */
+
+#endif /* _ASM_ST200_POSIX_TYPES_H */
diff --git a/arch/st200/include/asm/processor.h b/arch/st200/include/asm/processor.h
new file mode 100644
index 0000000..f5a768a
--- /dev/null
+++ b/arch/st200/include/asm/processor.h
@@ -0,0 +1,116 @@
+/*
+ * include/asm-st200/processor.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_PROCESSOR_H
+#define _ASM_ST200_PROCESSOR_H
+
+#include <asm/ptrace.h>
+#include <asm/page.h>
+
+/*
+ * Default implementation of macro that returns current
+ * instruction pointer ("program counter").
+ */
+#define current_text_addr() ({ __label__ _l; _l: &&_l;})
+
+struct cpuinfo_st200 {
+
+};
+
+/*
+ * capabilities of CPUs
+ */
+
+extern struct cpuinfo_st200 boot_cpu_data;
+
+#define cpu_data (&boot_cpu_data)
+#define current_cpu_data boot_cpu_data
+
+/*
+ * User space process size.
+ */
+
+#define TASK_SIZE	        (PAGE_OFFSET)
+
+#define STACK_TOP	TASK_SIZE
+#define STACK_TOP_MAX	STACK_TOP
+
+/* This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+#define TASK_UNMAPPED_BASE	(PAGE_ALIGN(TASK_SIZE / 3))
+
+typedef struct {
+	unsigned long seg;
+} mm_segment_t;
+
+/* Flags for struct thread_struct flags field */
+#define ST200_THREAD_DEBUG_VALID	(1<<0)
+#define ST200_THREAD_TRACE_VALID	(1<<1)
+
+/* Offsets into this struct are used in __switchto */
+struct thread_struct {
+	unsigned long sp;
+	unsigned long pc;
+
+	unsigned long flags;
+
+	/* Debug registers */
+	struct {
+		unsigned long dbreak_control;
+		unsigned long dbreak_lower;
+		unsigned long dbreak_upper;
+		unsigned long ibreak_control;
+		unsigned long ibreak_lower;
+		unsigned long ibreak_upper;
+	} debug;
+
+	/* Trace registers */
+	struct {
+		unsigned long trace;
+	} trace;
+};
+
+#define KSTK_EIP(tsk)  ((tsk)->thread.pc)
+#define KSTK_ESP(tsk)  ((tsk)->thread.sp)
+
+#define INIT_THREAD  { .flags = 0 }
+
+/* Forward declaration, a strange C thing */
+struct task_struct;
+struct mm_struct;
+
+/* Do necessary setup to start up a newly executed thread.  */
+extern void start_thread(struct pt_regs *, unsigned long, unsigned long);
+
+/* Free all resources held by a thread. */
+extern void release_thread(struct task_struct *);
+
+/* Prepare to copy thread state - unlazy all lazy status */
+#define prepare_to_copy(tsk)	do { } while (0)
+
+/* create a kernel thread without removing it from tasklists */
+extern int kernel_thread(int (*fn) (void *), void *arg, unsigned long flags);
+
+/* Return saved PC of a blocked thread.  */
+/* This is probably not 100% correct */
+
+static inline unsigned long thread_saved_pc(struct thread_struct *t)
+{
+	return t->pc;
+}
+
+unsigned long get_wchan(struct task_struct *p);
+
+#define cpu_relax()	barrier()
+
+/* Give a symbolic backtrace (best effort) */
+void st200_show_stack_trace(unsigned long *sp);
+
+
+#endif /* _ASM_ST200_PROCESSOR_H */
diff --git a/arch/st200/include/asm/ptrace.h b/arch/st200/include/asm/ptrace.h
new file mode 100644
index 0000000..666ba47
--- /dev/null
+++ b/arch/st200/include/asm/ptrace.h
@@ -0,0 +1,143 @@
+/*
+ * include/asm-st200/ptrace.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_PTRACE_H
+#define _ASM_ST200_PTRACE_H
+
+/*
+ * This struct defines the way the registers are stored on the
+ * kernel stack during a system call or other kernel entry
+ *
+ * To improve performance, this only contains the scratch registers,
+ * including the system call parameters (in case we need to restart
+ * the system call), and a few other fundamental registers.
+ *
+ * All preserved registers will be naturally preserved or saved in
+ * switch_stack.
+ *
+ * Note that in the case of a system call, only the argument registers
+ * may be present.
+ *
+ * A few system calls (notably fork and friends) and signal handling
+ * require the full register state. This is handled in special stubs,
+ * which push a struct switch_stack immediatly below the struct pt_regs.
+ *
+ * To keep stack alignment simple, both structs should be multiples of 32
+ * bytes.
+ */
+
+struct pt_regs {
+	unsigned long psw;
+	unsigned long pc;
+	unsigned long br;
+	unsigned long lr;	/* Link */
+
+	unsigned long r8;	/* scratch */
+	unsigned long r9;	/* scratch */
+	unsigned long r10;	/* scratch */
+	unsigned long r11;	/* scratch */
+	unsigned long r12;	/* SP */
+	unsigned long r15;	/* scratch/syscall no */
+	unsigned long r16;	/* arg0 */
+	unsigned long r17;	/* arg1 */
+	unsigned long r18;	/* arg2 */
+	unsigned long r19;	/* arg3 */
+	unsigned long r20;	/* arg4 */
+	unsigned long r21;	/* arg5 */
+	unsigned long r22;	/* arg6 */
+	unsigned long r23;	/* arg7 */
+	unsigned long r24;	/* scratch */
+	unsigned long r25;	/* scratch */
+	unsigned long r26;	/* scratch */
+	unsigned long r27;	/* scratch */
+	unsigned long r28;	/* scratch */
+	unsigned long r29;	/* scratch */
+	unsigned long r30;	/* scratch */
+	unsigned long r31;	/* scratch */
+	unsigned long r32;	/* scratch */
+	unsigned long r33;	/* scratch */
+	unsigned long r34;	/* scratch */
+	unsigned long r35;	/* scratch */
+	unsigned long r36;	/* scratch */
+	unsigned long r37;	/* scratch */
+	unsigned long r38;	/* scratch */
+	unsigned long r39;	/* scratch */
+	unsigned long r40;	/* scratch */
+	unsigned long r41;	/* scratch */
+	unsigned long r42;	/* scratch */
+	unsigned long r43;	/* scratch */
+	unsigned long r44;	/* scratch */
+	unsigned long r45;	/* scratch */
+	unsigned long r46;	/* scratch */
+	unsigned long r47;	/* scratch */
+	unsigned long r48;	/* scratch */
+	unsigned long r49;	/* scratch */
+	unsigned long r50;	/* scratch */
+	unsigned long r51;	/* scratch */
+	unsigned long r52;	/* scratch */
+	unsigned long r53;	/* scratch */
+	unsigned long r54;	/* scratch */
+	unsigned long r55;	/* scratch */
+	unsigned long r56;	/* scratch */
+	unsigned long r57;	/* scratch */
+	unsigned long r58;	/* scratch */
+	unsigned long r59;	/* scratch */
+	unsigned long r60;	/* scratch */
+	unsigned long r61;	/* scratch */
+	unsigned long r62;	/* scratch */
+	unsigned long pad[1];	/* Align to 8 bytes */
+};
+
+/*
+ * This is the extended stack used by signal handlers and the context
+ * switcher: it's pushed after the normal "struct pt_regs".
+ */
+struct switch_stack {
+	unsigned long r1;
+	unsigned long r2;
+	unsigned long r3;
+	unsigned long r4;
+	unsigned long r5;
+	unsigned long r6;
+	unsigned long r7;
+	unsigned long r13;	/* Reserved for TLS (thread local storage) */
+	unsigned long r14;	/* GOT pointer */
+	unsigned long pad[1];	/* To align to 8 byte boundary */
+};
+
+#ifdef __KERNEL__
+#define _PSW_USER 1
+#define user_mode(regs) ((regs)->psw & _PSW_USER)
+#define instruction_pointer(regs) ((regs)->pc)
+#define profile_pc(regs) instruction_pointer(regs)
+
+#define force_successful_syscall_return() (st200_task_regs(current_thread_info())->r15 = 0)
+
+/* Dump register state. Pass NULL if ss not available */
+void st200_show_regs(struct pt_regs *regs, struct switch_stack *ss);
+
+#endif
+
+/* Register numbers in the ptrace system call interface */
+
+#define PT_PC		0
+#define PT_PSW	      	1
+#define PT_R0		2
+#define PT_R(x)		((x)+PT_R0)
+#define PT_B(x)		((x)+PT_R(63)+1)
+#define PT_GP_NREGS     74
+#define PT_DEBUG(x)	((x)+PT_GP_NREGS)
+#define PT_TRACE	80
+
+#ifdef __KERNEL__
+/* Allows entire register state to be updated in one go*/
+#define PTRACE_GETREGS            12
+#define PTRACE_SETREGS            13
+#endif
+
+#endif /* _ASM_ST200_PTRACE_H */
diff --git a/arch/st200/include/asm/resource.h b/arch/st200/include/asm/resource.h
new file mode 100644
index 0000000..14ee829
--- /dev/null
+++ b/arch/st200/include/asm/resource.h
@@ -0,0 +1,6 @@
+#ifndef __ASM_ST200_RESOURCE_H
+#define __ASM_ST200_RESOURCE_H
+
+#include <asm-generic/resource.h>
+
+#endif /* __ASM_ST200_RESOURCE_H */
diff --git a/arch/st200/include/asm/scatterlist.h b/arch/st200/include/asm/scatterlist.h
new file mode 100644
index 0000000..d6c5a75
--- /dev/null
+++ b/arch/st200/include/asm/scatterlist.h
@@ -0,0 +1,28 @@
+#ifndef _ASM_ST200_SCATTERLIST_H
+#define _ASM_ST200_SCATTERLIST_H
+
+#include <asm/types.h>
+
+struct scatterlist {
+#ifdef CONFIG_DEBUG_SG
+	unsigned long sg_magic;
+#endif
+	unsigned long page_link;
+	unsigned int offset;
+	dma_addr_t dma_address;
+	unsigned int length;
+};
+
+/*
+ * These macros should be used after a pci_map_sg call has been done
+ * to get bus addresses of each of the SG entries and their lengths.
+ * You should only work with the number of sg entries pci_map_sg
+ * returns, or alternatively stop on the first sg_dma_len(sg) which
+ * is 0.
+ */
+#define sg_dma_address(sg)      ((sg)->dma_address)
+#define sg_dma_len(sg)          ((sg)->length)
+
+#define ISA_DMA_THRESHOLD (~0UL)
+
+#endif /* _ASM_ST200_SCATTERLIST_H */
diff --git a/arch/st200/include/asm/scu.h b/arch/st200/include/asm/scu.h
new file mode 100644
index 0000000..7cb4b71
--- /dev/null
+++ b/arch/st200/include/asm/scu.h
@@ -0,0 +1,27 @@
+#ifndef _ASM_ST200_SCU__H
+#define _ASM_ST200_SCU_H_
+
+/*
+ * These routines manage allocation of slots in the SCU. Although speculative loads
+ * are not supported in either user or kernel mode, we still support prefetching. For
+ * the prefetch to complete you must have an SCU region allocated, otherwise it will do
+ * nothing. For this reason, these routines are still used.
+ * We do not have all the dreadful problems with prefetch that we had with speculation,
+ * because prefetch is a no-op if it misses the TLB, and of course it is only a performance
+ * issue rather than a correctness one. We could disable all the SCU regions and the program
+ * would still function correctly.
+ */
+
+/* Request a physical address range for valid speculation. start and  size
+ * must be page aligned and a multiple of page size. If the region requested
+ * is wholly contained in another existing region, then the reference count
+ * for that region is incremented.
+ *
+ *  Returns 0 on success, - on failure
+ */
+int request_scu_region(unsigned long region_start, unsigned region_size);
+
+/* Release a region from the scu */
+void release_scu_region(unsigned long region_start, unsigned region_size);
+
+#endif /* _ASM_ST200_SCU_H_ */
diff --git a/arch/st200/include/asm/sections.h b/arch/st200/include/asm/sections.h
new file mode 100644
index 0000000..0d201a9
--- /dev/null
+++ b/arch/st200/include/asm/sections.h
@@ -0,0 +1,7 @@
+#ifndef _ASM_ST200_SECTIONS_H
+#define _ASM_ST200_SECTIONS_H
+
+/* nothing to see, move along */
+#include <asm-generic/sections.h>
+
+#endif
diff --git a/arch/st200/include/asm/segment.h b/arch/st200/include/asm/segment.h
new file mode 100644
index 0000000..3492471
--- /dev/null
+++ b/arch/st200/include/asm/segment.h
@@ -0,0 +1,6 @@
+#ifndef _ASM_ST200_SEGMENT_H
+#define _ASM_ST200_SEGMENT_H
+
+/* Only here because we have some old header files that expect it.. */
+
+#endif /* _ASM_ST200_SEGMENT_H */
diff --git a/arch/st200/include/asm/sembuf.h b/arch/st200/include/asm/sembuf.h
new file mode 100644
index 0000000..f581cb0
--- /dev/null
+++ b/arch/st200/include/asm/sembuf.h
@@ -0,0 +1,25 @@
+#ifndef _ASM_ST200_SEMBUF_H
+#define _ASM_ST200_SEMBUF_H
+
+/*
+ * The semid64_ds structure for ST200 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct semid64_ds {
+	struct ipc64_perm sem_perm;	/* permissions .. see ipc.h */
+	__kernel_time_t sem_otime;	/* last semop time */
+	unsigned long __unused1;
+	__kernel_time_t sem_ctime;	/* last change time */
+	unsigned long __unused2;
+	unsigned long sem_nsems;	/* no. of semaphores in array */
+	unsigned long __unused3;
+	unsigned long __unused4;
+};
+
+#endif /* _ASM_ST200_SEMBUF_H */
diff --git a/arch/st200/include/asm/serial.h b/arch/st200/include/asm/serial.h
new file mode 100644
index 0000000..5b6eb69
--- /dev/null
+++ b/arch/st200/include/asm/serial.h
@@ -0,0 +1,24 @@
+/*
+ * include/asm-sh/serial.h
+ *
+ * Configuration details for 8250, 16450, 16550, etc. serial ports
+ */
+
+#ifndef _ASM_SERIAL_H
+#define _ASM_SERIAL_H
+
+#include <linux/kernel.h>
+
+/*
+ * This assumes you have a 1.8432 MHz clock for your UART.
+ *
+ */
+#define BASE_BAUD ( 18432000 / 16 )
+
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+
+#define STD_SERIAL_PORT_DEFNS
+
+#define SERIAL_PORT_DFNS STD_SERIAL_PORT_DEFNS
+
+#endif /* _ASM_SERIAL_H */
diff --git a/arch/st200/include/asm/setup.h b/arch/st200/include/asm/setup.h
new file mode 100644
index 0000000..94fb153
--- /dev/null
+++ b/arch/st200/include/asm/setup.h
@@ -0,0 +1,111 @@
+/*
+ *  linux/include/asm-st200/setup.h
+ *
+ * Shamelessly stolen from the ARM for the ST200 by David McKay
+ *
+ *  Copyright (C) 1997-1999 Russell King
+ *  Copyright (C) 2004 Dave McKay <david.mckay@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Structure passed to kernel to tell it about the
+ *  hardware it's running on.  See Documentation/st200/Setup
+ *  for more info.
+ */
+
+#ifndef __ASM_ST200_SETUP_H
+#define __ASM_ST200_SETUP_H
+
+/* The list ends with an ATAG_NONE node. */
+#define ATAG_NONE	0x00000000
+
+struct tag_header {
+	u32 size;		/* Size IN WORDS */
+	u32 tag;
+};
+
+#define ATAG_MKTAG(x) ((0x5441<<16)|(x))
+
+/* The list must start with an ATAG_CORE node */
+#define ATAG_CORE	ATAG_MKTAG(1)
+#define ATAG_CORE_MAGIC 0xabcd1234
+struct tag_core {
+	u32 magic;
+	u32 flags;		/* bit 0 = read-only root filesystem */
+	u32 rootdev;
+};
+
+/* On the ST200 we can only have one of these.
+ * We cannot cope with discontiguous memory at the moment,
+ * and the kernel image is not relocatable, so  the start
+ * is a bit of a waste of time.
+ */
+#define ATAG_MEM	ATAG_MKTAG(2)
+
+struct tag_mem32 {
+	u32 start;		/* physical start address */
+	u32 size;
+};
+
+/* describes where the compressed ramdisk image lives (physical address) */
+#define ATAG_INITRD	ATAG_MKTAG(5)
+
+struct tag_initrd {
+	u32 start;		/* physical start address */
+	u32 size;		/* size of compressed ramdisk image in bytes */
+};
+
+#define COMMAND_LINE_SIZE	1024
+
+/* command line: \0 terminated string */
+#define ATAG_CMDLINE	ATAG_MKTAG(9)
+
+struct tag_cmdline {
+	char cmdline[1];	/* this is the minimum size */
+};
+
+struct tag {
+	struct tag_header hdr;
+	union {
+		struct tag_core core;
+		struct tag_mem32 mem;
+		struct tag_initrd initrd;
+		struct tag_cmdline cmdline;
+	};
+};
+
+struct tagtable {
+	u32 tag;
+	int (*parse) (const struct tag *);
+};
+
+#define __tag __used __attribute__((__section__(".taglist")))
+
+#define __tagtable(tag, fn) \
+static struct tagtable __tagtable_##fn __tag = { tag, fn }
+
+#define tag_member_present(tag,member)				\
+	((unsigned long)(&((struct tag *)0L)->member + 1)	\
+		<= (tag)->hdr.size * 4)
+
+#define tag_next(t)	((struct tag *)((u32 *)(t) + (t)->hdr.size))
+#define tag_size(type)	((sizeof(struct tag_header) + sizeof(struct type)) >> 2)
+
+#define for_each_tag(t,base)		\
+	for (t = base; t->hdr.size; t = tag_next(t))
+
+/*
+ * Early command line parameters.
+ */
+struct early_params {
+	const char *arg;
+	void (*fn) (char **p);
+};
+
+#define __early_param(name,fn)					\
+static struct early_params __early_##fn __attribute_used__	\
+__attribute__((__section__("__early_param"))) = { name, fn }
+
+#endif /*  __ASM_ST200_SETUP_H */
diff --git a/arch/st200/include/asm/shmbuf.h b/arch/st200/include/asm/shmbuf.h
new file mode 100644
index 0000000..87de615
--- /dev/null
+++ b/arch/st200/include/asm/shmbuf.h
@@ -0,0 +1,42 @@
+#ifndef _ASM_ST200_SHMBUF_H
+#define _ASM_ST200_SHMBUF_H
+
+/*
+ * The shmid64_ds structure for the ST200 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct shmid64_ds {
+	struct ipc64_perm shm_perm;	/* operation perms */
+	size_t shm_segsz;	/* size of segment (bytes) */
+	__kernel_time_t shm_atime;	/* last attach time */
+	unsigned long __unused1;
+	__kernel_time_t shm_dtime;	/* last detach time */
+	unsigned long __unused2;
+	__kernel_time_t shm_ctime;	/* last change time */
+	unsigned long __unused3;
+	__kernel_pid_t shm_cpid;	/* pid of creator */
+	__kernel_pid_t shm_lpid;	/* pid of last operator */
+	unsigned long shm_nattch;	/* no. of current attaches */
+	unsigned long __unused4;
+	unsigned long __unused5;
+};
+
+struct shminfo64 {
+	unsigned long shmmax;
+	unsigned long shmmin;
+	unsigned long shmmni;
+	unsigned long shmseg;
+	unsigned long shmall;
+	unsigned long __unused1;
+	unsigned long __unused2;
+	unsigned long __unused3;
+	unsigned long __unused4;
+};
+
+#endif /* _ASM_ST200_SHMBUF_H */
diff --git a/arch/st200/include/asm/shmparam.h b/arch/st200/include/asm/shmparam.h
new file mode 100644
index 0000000..c8b279a
--- /dev/null
+++ b/arch/st200/include/asm/shmparam.h
@@ -0,0 +1,8 @@
+#ifndef _ASM_ST200_SHMPARAM_H
+#define _ASM_ST200_SHMPARAM_H
+
+/* We have no problems with D cache aliasing on the ST200 */
+
+#define	SHMLBA PAGE_SIZE
+
+#endif /* _ASM_ST200_SHMPARAM_H */
diff --git a/arch/st200/include/asm/sigcontext.h b/arch/st200/include/asm/sigcontext.h
new file mode 100644
index 0000000..14c8932
--- /dev/null
+++ b/arch/st200/include/asm/sigcontext.h
@@ -0,0 +1,19 @@
+#ifndef _ASM_ST200_SIGCONTEXT_H
+#define _ASM_ST200_SIGCONTEXT_H
+
+#include <asm/ptrace.h>
+
+struct sigcontext {
+	unsigned long sc_flags;
+	struct pt_regs sc_regs;	/* registers to restore */
+	struct switch_stack sc_ss;	/* registers to restore */
+	stack_t sc_stack;	/* previously active stack */
+	unsigned long sc_reserved[8];
+	/*
+	 * The mask must come last so we can increase _NSIG_WORDS
+	 * without breaking binary compatibility.
+	 */
+	sigset_t sc_mask;	/* signal mask to restore after handler returns */
+};
+
+#endif /* _ASM_ST200_SIGCONTEXT_H */
diff --git a/arch/st200/include/asm/siginfo.h b/arch/st200/include/asm/siginfo.h
new file mode 100644
index 0000000..553ed2f
--- /dev/null
+++ b/arch/st200/include/asm/siginfo.h
@@ -0,0 +1,8 @@
+#ifndef _ASM_ST200_SIGINFO_H
+#define _ASM_ST200_SIGINFO_H
+
+#define __ARCH_SI_TRAPNO
+
+#include <asm-generic/siginfo.h>
+
+#endif
diff --git a/arch/st200/include/asm/signal.h b/arch/st200/include/asm/signal.h
new file mode 100644
index 0000000..222b01b
--- /dev/null
+++ b/arch/st200/include/asm/signal.h
@@ -0,0 +1,2 @@
+#include <asm/bitsperlong.h>
+#include <asm-generic/signal.h>
diff --git a/arch/st200/include/asm/simtrace.h b/arch/st200/include/asm/simtrace.h
new file mode 100644
index 0000000..6aba848
--- /dev/null
+++ b/arch/st200/include/asm/simtrace.h
@@ -0,0 +1,26 @@
+/*
+ * include/asm-st200/simtrace.h
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ */
+
+/* Simulator trace plug-in interface */
+
+#ifndef _ASM_ST200_SIMTRACE_H
+#define _ASM_ST200_SIMTRACE_H
+
+#ifdef CONFIG_SIMULATOR_TRACE_DEVICE
+void sim_trace_on(int mode);
+void sim_trace_off(void);
+#else
+static __inline__ void sim_trace_on(int mode)
+{
+}
+
+static __inline__ void sim_trace_off(void)
+{
+}
+#endif
+
+#endif /* _ASM_ST200_SIMTRACE_H */
diff --git a/arch/st200/include/asm/socket.h b/arch/st200/include/asm/socket.h
new file mode 100644
index 0000000..6b71384
--- /dev/null
+++ b/arch/st200/include/asm/socket.h
@@ -0,0 +1 @@
+#include <asm-generic/socket.h>
diff --git a/arch/st200/include/asm/sockios.h b/arch/st200/include/asm/sockios.h
new file mode 100644
index 0000000..2444f03
--- /dev/null
+++ b/arch/st200/include/asm/sockios.h
@@ -0,0 +1,17 @@
+#ifndef __ASM_ST200_SOCKIOS_H
+#define __ASM_ST200_SOCKIOS_H
+
+#include <asm/ioctl.h>
+
+/* Socket-level I/O control calls. */
+#define FIOGETOWN	_IOR('f', 123, int)
+#define FIOSETOWN 	_IOW('f', 124, int)
+
+#define SIOCATMARK	_IOR('s', 7, int)
+#define SIOCSPGRP	_IOW('s', 8, pid_t)
+#define SIOCGPGRP	_IOR('s', 9, pid_t)
+
+#define SIOCGSTAMP	_IOR('s', 100, struct timeval)	/* Get stamp (timeval) */
+#define SIOCGSTAMPNS	_IOR('s', 101, struct timespec)	/* Get stamp (timespec) */
+
+#endif /* __ASM_ST200_SOCKIOS_H */
diff --git a/arch/st200/include/asm/stat.h b/arch/st200/include/asm/stat.h
new file mode 100644
index 0000000..29736a8
--- /dev/null
+++ b/arch/st200/include/asm/stat.h
@@ -0,0 +1,63 @@
+#ifndef _ASM_ST200_STAT_H
+#define _ASM_ST200_STAT_H
+
+struct stat {
+	unsigned long st_dev;
+	unsigned long st_ino;
+	unsigned long st_nlink;
+	unsigned int st_mode;
+	unsigned int st_uid;
+	unsigned int st_gid;
+	unsigned int __pad0;
+	unsigned long st_rdev;
+	unsigned long st_size;
+	unsigned long st_atime;
+	unsigned long st_atime_nsec;
+	unsigned long st_mtime;
+	unsigned long st_mtime_nsec;
+	unsigned long st_ctime;
+	unsigned long st_ctime_nsec;
+	unsigned long st_blksize;
+	long st_blocks;
+	unsigned long __unused[3];
+};
+
+#define STAT_HAVE_NSEC 1
+
+/* This matches struct stat64 in glibc2.1, hence the absolutely
+ * insane amounts of padding around dev_t's.
+ */
+struct stat64 {
+	unsigned short st_dev;
+	unsigned char __pad0[10];
+
+#define STAT64_HAS_BROKEN_ST_INO	1
+	unsigned long __st_ino;
+
+	unsigned int st_mode;
+	unsigned int st_nlink;
+
+	unsigned long st_uid;
+	unsigned long st_gid;
+
+	unsigned short st_rdev;
+	unsigned char __pad3[10];
+
+	long long st_size;
+	unsigned long st_blksize;
+
+	long long st_blocks;	/* Number 512-byte blocks allocated. */
+
+	unsigned long st_atime;
+	unsigned long st_atime_nsec;
+
+	unsigned long st_mtime;
+	unsigned int st_mtime_nsec;
+
+	unsigned long st_ctime;
+	unsigned long st_ctime_nsec;
+
+	unsigned long long st_ino;
+};
+
+#endif /* _ASM_ST200_STAT_H */
diff --git a/arch/st200/include/asm/statfs.h b/arch/st200/include/asm/statfs.h
new file mode 100644
index 0000000..c3d7d8b
--- /dev/null
+++ b/arch/st200/include/asm/statfs.h
@@ -0,0 +1,6 @@
+#ifndef __ASM_ST200_STATFS_H
+#define __ASM_ST200_STATFS_H
+
+#include <asm-generic/statfs.h>
+
+#endif /* __ASM_SH_STATFS_H */
diff --git a/arch/st200/include/asm/string.h b/arch/st200/include/asm/string.h
new file mode 100644
index 0000000..d0f5858
--- /dev/null
+++ b/arch/st200/include/asm/string.h
@@ -0,0 +1,18 @@
+/*
+ * include/asm-st200/string.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: David McKay <david.mckay@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_STRING_H
+#define _ASM_ST200_STRING_H
+
+#define __HAVE_ARCH_MEMCPY
+extern void *memcpy(void *__to, __const__ void *__from, size_t __n);
+
+#define __HAVE_ARCH_MEMSET
+extern void *memset(void *s, int c, size_t count);
+
+#endif /* _ASM_ST200_STRING_H */
diff --git a/arch/st200/include/asm/swab.h b/arch/st200/include/asm/swab.h
new file mode 100644
index 0000000..fadc3cc
--- /dev/null
+++ b/arch/st200/include/asm/swab.h
@@ -0,0 +1,6 @@
+#ifndef _ASM_SCORE_SWAB_H
+#define _ASM_SCORE_SWAB_H
+
+#include <asm-generic/swab.h>
+
+#endif /* _ASM_SCORE_SWAB_H */
diff --git a/arch/st200/include/asm/syscallparams.h b/arch/st200/include/asm/syscallparams.h
new file mode 100644
index 0000000..445ae6a
--- /dev/null
+++ b/arch/st200/include/asm/syscallparams.h
@@ -0,0 +1,47 @@
+/*
+ *  include/asm-st200/syscallparams.h
+ *
+ *  Copyright (C) 2003 STMicroelectronics Limited
+ *      Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_SYSCALLPARAM_H
+#define _ASM_ST200_SYSCALLPARAM_H
+
+/*
+ * The LX ABI specifies that the first eight parameters to a function are
+ * passed in registers, the remaining parameters are passed on the stack.
+ * This allows us to 'pass' the registers pushed onto the stack by the
+ * system call entry code to the C code. However there are some restrictions
+ * on the alignment of these parameters, there is the 16 byte scratch area
+ * which every function has, and some additional padding needed to align
+ * the stack on a 32 byte boundary. So by defining these structures,
+ * and passing them as the 9th parameter, we can make use of this facility,
+ * and avoid the above problems.
+ */
+
+struct syscallparams {
+	unsigned int pad[4];
+	struct pt_regs regs;
+};
+
+struct syscallparams_ss {
+	unsigned int pad[4];
+	struct switch_stack ss;
+	struct pt_regs regs;
+};
+
+/*
+ * This demonstrates how it is possible to return two results from a
+ * system call.
+ */
+union syscallresult {
+	unsigned long result1;
+	struct {
+		unsigned long r16;
+		unsigned long r17;
+	} result2;
+};
+
+#endif /* _ASM_ST200_SYSCALLPARAM_H */
diff --git a/arch/st200/include/asm/system.h b/arch/st200/include/asm/system.h
new file mode 100644
index 0000000..89b9ef9
--- /dev/null
+++ b/arch/st200/include/asm/system.h
@@ -0,0 +1,176 @@
+#ifndef __ASM_ST200_SYSTEM_H
+#define __ASM_ST200_SYSTEM_H
+
+#include <asm/segment.h>
+#include <asm/ptrace.h>
+#include <asm/ctrlregdef.h>
+
+#ifdef __KERNEL__
+
+#define SWITCH_DEBUG_FLAGS (ST200_THREAD_DEBUG_VALID | ST200_THREAD_TRACE_VALID)
+#define switch_to(prev, next, last) do {			\
+	extern struct task_struct* __switch_to(struct thread_struct* prev_ts,	\
+		struct thread_struct* next_ts, unsigned long ssp,	\
+		struct task_struct * prev);				\
+	extern void clear_debugregs(struct task_struct*);		\
+	extern void set_debugregs(struct task_struct*);			\
+	if (prev->thread.flags & SWITCH_DEBUG_FLAGS)			\
+		clear_debugregs(prev);					\
+	if (next->thread.flags & SWITCH_DEBUG_FLAGS)			\
+		set_debugregs(next);					\
+	last = __switch_to(&prev->thread, &next->thread,		\
+			(unsigned long)(next->stack) + THREAD_SIZE, prev);	\
+} while (0)
+
+#endif /* __KERNEL__ */
+
+/*
+ * Force strict CPU ordering.
+ * And yes, this is required on UP too when we're talking
+ * to devices.
+ *
+ */
+
+/* ST200FIXME: Using the intrinsics would be better here */
+/* Actually, I do NOT think the sync is needed, will remove later */
+#define mb()		__asm__ volatile ("sync \n":::"memory")
+#define rmb()		mb()
+#define wmb()		mb()
+#define smp_mb()	mb()
+#define smp_rmb()	mb()
+#define smp_wmb()	mb()
+#define smp_read_barrier_depends()	do { } while(0)
+#define read_barrier_depends()		do { } while(0)
+
+#define set_mb(var, value)		do { var = value; mb(); } while (0)
+#define set_wmb(var, value)		do { var = value; wmb(); } while (0)
+
+/* interrupt control.. */
+#define local_irq_disable() __asm__ volatile ("pswclr %0\n"         \
+                                              : /* No output */     \
+					      : "r" (PSW_INT_ENABLE)\
+                                              : "memory"         \
+                                             );
+
+#define local_irq_enable() __asm__ volatile ("pswset %0\n"         \
+                                              : /* No output */     \
+					      : "r" (PSW_INT_ENABLE)\
+                                              : "memory"         \
+                                             );
+
+#define local_save_flags(x) do { typecheck(unsigned long,x);            \
+                                 __asm__ volatile ("ldw %0 = %1[$r0]\n" \
+                                                   :"=r" (x)            \
+                                                   :"i" (PSW)           \
+					          ); } while(0)
+
+#define local_irq_restore(x) do { typecheck(unsigned long,x);        \
+                                  __asm__ volatile ("pswset %0 \n"   \
+                                                    ";;\n"           \
+                                                    "pswclr %1 \n"   \
+                                                   : /* No output */ \
+                                                   :"r" (x & (PSW_INT_ENABLE)), "r" ( (~(x)) & (PSW_INT_ENABLE)) \
+                                                   : "memory"        \
+					          ); } while(0)
+
+#define irqs_disabled()			\
+({					\
+	unsigned long flags;		\
+	local_save_flags(flags);	\
+	!(flags & PSW_INT_ENABLE);	\
+})
+
+/* For spinlocks etc */
+#define local_irq_save(x)  do { local_save_flags(x); local_irq_disable(); } while (0)
+
+#define xchg(ptr,v) ((__typeof__(*(ptr)))__xchg((unsigned long)(v),(ptr),sizeof(*(ptr))))
+
+extern void __xchg_called_with_bad_pointer(void);
+
+static __inline__ unsigned long __xchg(unsigned long x, volatile void *ptr,
+				       int size)
+{
+	unsigned long retval;
+
+	switch (size) {
+	case 4:
+		asm volatile ("1: ldw %0    = 0[%1]\n"
+			      "   mov $r62  = 1b\n"
+			      "   or  $r12  = $r12,1\n"
+			      "   ;;\n"
+			      "   stw 0[%1] = %2\n"
+			      "   and $r12  = $r12,~1\n":"=&r" (retval)
+			      :"r"(ptr), "r"(x)
+			      :"memory", "r62");
+		break;
+	case 2:
+		asm volatile ("1: ldhu %0    = 0[%1]\n"
+			      "   mov $r62  = 1b\n"
+			      "   or  $r12  = $r12,1\n"
+			      "   ;;\n"
+			      "   sth 0[%1] = %2\n"
+			      "   and $r12  = $r12,~1\n":"=&r" (retval)
+			      :"r"(ptr), "r"(x)
+			      :"memory", "r62");
+		break;
+	case 1:
+		asm volatile ("1: ldbu %0    = 0[%1]\n"
+			      "   mov $r62  = 1b\n"
+			      "   or  $r12  = $r12,1\n"
+			      "   ;;\n"
+			      "   stb 0[%1] = %2\n"
+			      "   and $r12  = $r12,~1\n":"=&r" (retval)
+			      :"r"(ptr), "r"(x)
+			      :"memory", "r62");
+		break;
+	default:
+		__xchg_called_with_bad_pointer();
+		break;
+	}
+
+	return retval;
+}
+
+#define __HAVE_ARCH_CMPXCHG 1
+#define cmpxchg(ptr,o,n)\
+        ((__typeof__(*(ptr)))__cmpxchg((ptr),(unsigned long)(o),\
+                                        (unsigned long)(n),sizeof(*(ptr))))
+
+extern void __cmpxchg_called_with_bad_pointer(void);
+
+static __inline__ unsigned long __cmpxchg(volatile void *ptr, unsigned long old,
+					  unsigned long new, int size)
+{
+	unsigned long prev;
+
+	switch (size) {
+	case 1:
+		asm volatile ("1 : ldbu %0  = 0[%1] \n" "    mov $r62 = 1b \n" "    or  $r12 = $r12,1 \n" "    ;; \n" "    cmpeq $b7 = %0,%2 \n" "    ;; \n" "	  brf $b7,2f\n" "    ;; \n" "    stb 0[%1] = %3 \n" "    and $r12 = $r12,~1 \n" "    ;; \n" "2:  and $r12 = $r12,~1 ":"=&r" (prev)	/* %0 */
+			      :"r"(ptr) /* %1 */ , "r"(old) /* %2 */ , "r"(new)	/* %3 */
+			      :"r62", "memory", "b7");
+		return prev;
+	case 2:
+		asm volatile ("1 : ldhu %0  = 0[%1] \n" "    mov $r62 = 1b \n" "    or  $r12 = $r12,1 \n" "    ;; \n" "    cmpeq $b7 = %0,%2 \n" "    ;; \n" "	  brf $b7,2f\n" "    ;; \n" "    sth 0[%1] = %3 \n" "    and $r12 = $r12,~1 \n" "    ;; \n" "2:  and $r12 = $r12,~1 ":"=&r" (prev)	/* %0 */
+			      :"r"(ptr) /* %1 */ , "r"(old) /* %2 */ , "r"(new)	/* %3 */
+			      :"r62", "memory", "b7");
+		return prev;
+	case 4:
+		asm volatile ("1 : ldw %0  = 0[%1] \n" "    mov $r62 = 1b \n" "    or  $r12 = $r12,1 \n" "    ;; \n" "    cmpeq $b7 = %0,%2 \n" "    ;; \n" "	  brf $b7,2f\n" "    ;; \n" "    stw 0[%1] = %3 \n" "    and $r12 = $r12,~1 \n" "    ;; \n" "2:  and $r12 = $r12,~1 ":"=&r" (prev)	/* %0 */
+			      :"r"(ptr) /* %1 */ , "r"(old) /* %2 */ , "r"(new)	/* %3 */
+			      :"r62", "memory", "b7");
+		return prev;
+	default:
+		__cmpxchg_called_with_bad_pointer();
+		break;
+	}
+
+	return prev;
+}
+
+#define arch_align_stack(x) (x)
+
+extern void die(const char *str, struct pt_regs *regs)
+    __attribute__ ((noreturn));
+extern void die_if_kernel(const char *str, struct pt_regs *regs);
+
+#endif /* __ASM_ST200_SYSTEM_H */
diff --git a/arch/st200/include/asm/termbits.h b/arch/st200/include/asm/termbits.h
new file mode 100644
index 0000000..6348da0
--- /dev/null
+++ b/arch/st200/include/asm/termbits.h
@@ -0,0 +1,188 @@
+#ifndef _ASM_ST200_TERMBITS_H
+#define _ASM_ST200_TERMBITS_H
+
+#include <linux/posix_types.h>
+
+typedef unsigned char cc_t;
+typedef unsigned int speed_t;
+typedef unsigned int tcflag_t;
+
+#define NCCS 19
+struct termios {
+	tcflag_t c_iflag;	/* input mode flags */
+	tcflag_t c_oflag;	/* output mode flags */
+	tcflag_t c_cflag;	/* control mode flags */
+	tcflag_t c_lflag;	/* local mode flags */
+	cc_t c_line;		/* line discipline */
+	cc_t c_cc[NCCS];	/* control characters */
+	speed_t c_ispeed;	/* input speed */
+	speed_t c_ospeed;	/* output speed */
+};
+
+/* ST200 followed the alpha and has matching termios and ktermios */
+
+struct ktermios {
+	tcflag_t c_iflag;	/* input mode flags */
+	tcflag_t c_oflag;	/* output mode flags */
+	tcflag_t c_cflag;	/* control mode flags */
+	tcflag_t c_lflag;	/* local mode flags */
+	cc_t c_line;		/* line discipline (== c_cc[19]) */
+	cc_t c_cc[NCCS];	/* control characters */
+	speed_t c_ispeed;	/* input speed */
+	speed_t c_ospeed;	/* output speed */
+};
+
+/* c_cc characters */
+#define VINTR 0
+#define VQUIT 1
+#define VERASE 2
+#define VKILL 3
+#define VEOF 4
+#define VTIME 5
+#define VMIN 6
+#define VSWTC 7
+#define VSTART 8
+#define VSTOP 9
+#define VSUSP 10
+#define VEOL 11
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE 14
+#define VLNEXT 15
+#define VEOL2 16
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IUCLC	0001000
+#define IXON	0002000
+#define IXANY	0004000
+#define IXOFF	0010000
+#define IMAXBEL	0020000
+#define IUTF8   0040000
+
+/* c_oflag bits */
+#define OPOST	0000001
+#define OLCUC	0000002
+#define ONLCR	0000004
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+#define OFILL	0000100
+#define OFDEL	0000200
+#define NLDLY	0000400
+#define   NL0	0000000
+#define   NL1	0000400
+#define CRDLY	0003000
+#define   CR0	0000000
+#define   CR1	0001000
+#define   CR2	0002000
+#define   CR3	0003000
+#define TABDLY	0014000
+#define   TAB0	0000000
+#define   TAB1	0004000
+#define   TAB2	0010000
+#define   TAB3	0014000
+#define   XTABS	0014000
+#define BSDLY	0020000
+#define   BS0	0000000
+#define   BS1	0020000
+#define VTDLY	0040000
+#define   VT0	0000000
+#define   VT1	0040000
+#define FFDLY	0100000
+#define   FF0	0000000
+#define   FF1	0100000
+
+/* c_cflag bit meaning */
+#define CBAUD	0010017
+#define  B0	0000000		/* hang up */
+#define  B50	0000001
+#define  B75	0000002
+#define  B110	0000003
+#define  B134	0000004
+#define  B150	0000005
+#define  B200	0000006
+#define  B300	0000007
+#define  B600	0000010
+#define  B1200	0000011
+#define  B1800	0000012
+#define  B2400	0000013
+#define  B4800	0000014
+#define  B9600	0000015
+#define  B19200	0000016
+#define  B38400	0000017
+#define EXTA B19200
+#define EXTB B38400
+#define CSIZE	0000060
+#define   CS5	0000000
+#define   CS6	0000020
+#define   CS7	0000040
+#define   CS8	0000060
+#define CSTOPB	0000100
+#define CREAD	0000200
+#define PARENB	0000400
+#define PARODD	0001000
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define CBAUDEX 0010000
+#define    B57600 0010001
+#define   B115200 0010002
+#define   B230400 0010003
+#define   B460800 0010004
+#define   B500000 0010005
+#define   B576000 0010006
+#define   B921600 0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define CIBAUD	  002003600000	/* input baud rate (not used) */
+#define CMSPAR	  010000000000	/* mark or space (stick) parity */
+#define CRTSCTS	  020000000000	/* flow control */
+
+/* c_lflag bits */
+#define ISIG	0000001
+#define ICANON	0000002
+#define XCASE	0000004
+#define ECHO	0000010
+#define ECHOE	0000020
+#define ECHOK	0000040
+#define ECHONL	0000100
+#define NOFLSH	0000200
+#define TOSTOP	0000400
+#define ECHOCTL	0001000
+#define ECHOPRT	0002000
+#define ECHOKE	0004000
+#define FLUSHO	0010000
+#define PENDIN	0040000
+#define IEXTEN	0100000
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0
+#define	TCOON		1
+#define	TCIOFF		2
+#define	TCION		3
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0
+#define	TCOFLUSH	1
+#define	TCIOFLUSH	2
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+
+#endif
diff --git a/arch/st200/include/asm/termios.h b/arch/st200/include/asm/termios.h
new file mode 100644
index 0000000..280d78a
--- /dev/null
+++ b/arch/st200/include/asm/termios.h
@@ -0,0 +1 @@
+#include <asm-generic/termios.h>
diff --git a/arch/st200/include/asm/thread_info.h b/arch/st200/include/asm/thread_info.h
new file mode 100644
index 0000000..74cc232
--- /dev/null
+++ b/arch/st200/include/asm/thread_info.h
@@ -0,0 +1,107 @@
+/*
+ *  include/asm-st200/current.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_THREAD_INFO_H
+#define _ASM_ST200_THREAD_INFO_H
+
+#ifdef __KERNEL__
+
+#ifndef __ASSEMBLY__
+
+#include <asm/processor.h>
+#include <asm/ptrace.h>
+
+/*
+ * low level task data that entry.S needs immediate access to
+ * this struct appears at the bottom of the supervisor stack pages
+ */
+struct thread_info {
+	struct task_struct *task;	/* main task structure */
+	struct exec_domain *exec_domain;	/* execution domain */
+	unsigned long flags;	/* low level flags */
+	__u32 cpu;		/* current CPU */
+	__s32 preempt_count;	/* 0 => preemptable, <0 => BUG */
+	mm_segment_t addr_limit;	/* thread address space */
+
+	struct restart_block restart_block;
+};
+
+#define PREEMPT_ACTIVE		0x10000000
+
+/*
+ * macros/functions for gaining access to the thread information structure
+ *
+ * preempt_count needs to be 1 initially, until the scheduler is functional.
+ */
+#define INIT_THREAD_INFO(tsk)			\
+{						\
+	.task		= &tsk,			\
+	.exec_domain	= &default_exec_domain,	\
+	.flags		= 0,			\
+	.cpu		= 0,			\
+	.preempt_count	= 1,			\
+	.addr_limit	= KERNEL_DS,		\
+        .restart_block = {                      \
+                .fn = do_no_restart_syscall,    \
+        },                                      \
+}
+
+#define init_thread_info	(init_thread_union.thread_info)
+#define init_stack		(init_thread_union.stack)
+
+#endif /* __ASSEMBLY__ */
+
+/* thread information allocation */
+#define THREAD_SIZE_ORDER	1
+#define THREAD_SIZE	(PAGE_SIZE << THREAD_SIZE_ORDER)
+
+/*
+ * thread information flags
+ * - these are process state flags that various assembly files may need to access
+ * - pending work-to-be-done flags are in lower bits (faster to access)
+ * - other flags in higher bits
+ */
+#define TIF_SYSCALL_TRACE	0	/* syscall trace active */
+#define TIF_NOTIFY_RESUME	1	/* resumption notification requested */
+#define TIF_SIGPENDING		2	/* signal pending */
+#define TIF_NEED_RESCHED	3	/* rescheduling necessary */
+#define TIF_POLLING_NRFLAG	16	/* true if poll_idle() is polling TIF_NEED_RESCHED */
+#define TIF_MEMDIE              17
+
+#define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
+#define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
+#define _TIF_SIGPENDING		(1<<TIF_SIGPENDING)
+#define _TIF_NEED_RESCHED	(1<<TIF_NEED_RESCHED)
+#define _TIF_POLLING_NRFLAG	(1<<TIF_POLLING_NRFLAG)
+
+#define _TIF_WORK_MASK		0x0000FFFE	/* work to do on interrupt/exception return */
+#define _TIF_ALLWORK_MASK	0x0000FFFF	/* work to do on any return to u-space */
+
+#ifndef __ASSEMBLY__
+
+static inline struct pt_regs *st200_task_regs(struct thread_info *t)
+{
+	return (struct pt_regs *)((char *)(t) + THREAD_SIZE) - 1;
+}
+
+/* how to get the thread information struct from C */
+static inline struct thread_info *current_thread_info(void)
+{
+	struct thread_info *ti;
+	register long sp __asm__("r12");
+
+	ti = (struct thread_info *) (sp & (~(THREAD_SIZE - 1)));
+
+	return ti;
+}
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_ST200_THREAD_INFO_H */
diff --git a/arch/st200/include/asm/timex.h b/arch/st200/include/asm/timex.h
new file mode 100644
index 0000000..6c0968b
--- /dev/null
+++ b/arch/st200/include/asm/timex.h
@@ -0,0 +1,25 @@
+/*
+ *  include/asm-st200/timex.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: David McKay <david.mckay@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_TIMEX_H
+#define _ASM_ST200_TIMEX_H
+
+/* FIXME: Will need updating */
+//#define CLOCK_TICK_RATE 1193180 /* Underlying HZ */
+#define CLOCK_TICK_RATE 1000000	/* Underlying HZ */
+
+/* FIXME: This can be a long long on the ST240 */
+typedef unsigned long cycles_t;
+
+/* FIXME: ST200 does have a cycle counter */
+static inline cycles_t get_cycles(void)
+{
+	return 0;
+}
+
+#endif
diff --git a/arch/st200/include/asm/tlb.h b/arch/st200/include/asm/tlb.h
new file mode 100644
index 0000000..c2b8b71
--- /dev/null
+++ b/arch/st200/include/asm/tlb.h
@@ -0,0 +1,11 @@
+#ifndef _ASM_ST200_TLB_H
+#define _ASM_ST200_TLB_H
+
+#define tlb_start_vma(tlb, vma) do { } while (0)
+#define tlb_end_vma(tlb, vma) do { } while (0)
+#define __tlb_remove_tlb_entry(tlb, ptep, address) do { } while (0)
+#define tlb_flush(tlb) flush_tlb_mm((tlb)->mm)
+
+#include <asm-generic/tlb.h>
+
+#endif /* _ASM_ST200_TLB_H */
diff --git a/arch/st200/include/asm/tlbflush.h b/arch/st200/include/asm/tlbflush.h
new file mode 100644
index 0000000..ff08422
--- /dev/null
+++ b/arch/st200/include/asm/tlbflush.h
@@ -0,0 +1,54 @@
+#ifndef _ASM_ST200_TLBFLUSH_H
+#define _ASM_ST200_TLBFLUSH_H
+
+#include <linux/mm.h>
+
+#include <asm/processor.h>
+#include <asm/mmu_context.h>
+
+
+/*
+ * TLB flushing:
+ *
+ *  - flush_tlb() flushes the current mm struct TLBs
+ *  - flush_tlb_all() flushes all processes TLBs
+ *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
+ *  - flush_tlb_page(vma, vmaddr) flushes one page
+ *  - flush_tlb_range(vma, start, end) flushes a range of pages
+ *  - flush_tlb_kernel_range(start, end) flushes a range of kernel pages
+ *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
+ *
+ */
+
+extern void flush_tlb(void);
+extern void flush_tlb_all(void);
+extern void __flush_tlb_mm(unsigned long context);
+static inline void flush_tlb_mm(struct mm_struct *mm)
+{
+	if (context_valid(mm->context.id))
+		__flush_tlb_mm(mm->context.id & ASID_MASK);
+}
+
+extern void __flush_tlb_page(unsigned long context, unsigned long addr);
+static inline void flush_tlb_page(struct vm_area_struct *vma,
+				  unsigned long addr)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	if (context_valid(mm->context.id))
+		__flush_tlb_page(mm->context.id & ASID_MASK, addr & PAGE_MASK);
+}
+
+extern void __flush_tlb_range(unsigned long context,
+			      unsigned long start, unsigned long end);
+static inline void flush_tlb_range(struct vm_area_struct *vma,
+				   unsigned long start, unsigned long end)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	if (context_valid(mm->context.id))
+		__flush_tlb_range(mm->context.id & ASID_MASK,
+				  start & PAGE_MASK, end & PAGE_MASK);
+}
+
+#define flush_tlb_kernel_range(start, end) flush_tlb_all()
+
+#endif /* _ASM_ST200_TLBFLUSH_H */
diff --git a/arch/st200/include/asm/topology.h b/arch/st200/include/asm/topology.h
new file mode 100644
index 0000000..a914ded
--- /dev/null
+++ b/arch/st200/include/asm/topology.h
@@ -0,0 +1,6 @@
+#ifndef _ASM_ST200_TOPOLOGY_H
+#define _ASM_ST200_TOPOLOGY_H
+
+#include <asm-generic/topology.h>
+
+#endif /* _ASM_ST200_TOPOLOGY_H */
diff --git a/arch/st200/include/asm/types.h b/arch/st200/include/asm/types.h
new file mode 100644
index 0000000..e27e61f
--- /dev/null
+++ b/arch/st200/include/asm/types.h
@@ -0,0 +1,58 @@
+#ifndef _ASM_ST200_TYPES_H
+#define _ASM_ST200_TYPES_H
+
+#ifndef __ASSEMBLY__
+
+typedef unsigned short umode_t;
+
+/*
+ * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
+ * header files exported to user space
+ */
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+#if defined(__GNUC__)
+__extension__ typedef __signed__ long long __s64;
+__extension__ typedef unsigned long long __u64;
+#endif
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+#ifdef __KERNEL__
+
+#define BITS_PER_LONG 32
+
+#ifndef __ASSEMBLY__
+
+typedef signed char s8;
+typedef unsigned char u8;
+
+typedef signed short s16;
+typedef unsigned short u16;
+
+typedef signed int s32;
+typedef unsigned int u32;
+
+typedef signed long long s64;
+typedef unsigned long long u64;
+
+/* DMA addresses are 32 bits wide */
+typedef u32 dma_addr_t;
+typedef u64 dma64_addr_t;
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+
+#endif
diff --git a/arch/st200/include/asm/uaccess.h b/arch/st200/include/asm/uaccess.h
new file mode 100644
index 0000000..7d925f7
--- /dev/null
+++ b/arch/st200/include/asm/uaccess.h
@@ -0,0 +1,293 @@
+/*
+ * include/asm-st200/uaccess.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_UACCESS_H
+#define _ASM_ST200_UACCESS_H
+
+/*
+ * User space memory access functions
+ */
+#include <linux/sched.h>
+#include <asm/errno.h>
+
+#define VERIFY_READ 0
+#define VERIFY_WRITE 1
+
+/*
+ * The exception table consists of pairs of addresses: the first is the
+ * address of an instruction that is allowed to fault, and the second is
+ * the address at which the program should continue.  No registers are
+ * modified, so it is entirely up to the continuation code to figure out
+ * what to do.
+ *
+ * All the routines below use bits of fixup code that are out of line
+ * with the main instruction path.  This means when everything is well,
+ * we don't even have to jump over them.  Further, they do not intrude
+ * on our cache or tlb entries.
+ */
+
+struct exception_table_entry {
+	unsigned long insn, fixup;
+};
+
+/* Returns 0 if exception not found and fixup otherwise.  */
+extern unsigned long search_exception_table(unsigned long);
+
+/*
+ * The fs value determines whether argument validity checking should be
+ * performed or not.  If get_fs() == USER_DS, checking is performed, with
+ * get_fs() == KERNEL_DS, checking is bypassed.
+ *
+ * For historical reasons (Data Segment Register?), these macros are misnamed.
+ */
+
+#define get_ds()	(KERNEL_DS)
+#define get_fs()	(current_thread_info()->addr_limit)
+#define set_fs(x)	(current_thread_info()->addr_limit = (x))
+
+#define segment_eq(a,b)	((a).seg == (b).seg)
+
+#define MAKE_MM_SEG(s)  ((mm_segment_t) { (s) })
+
+/* addr_limit is the maximum accessible address for the task. we misuse
+ * the KERNEL_DS and USER_DS values to both assign and compare the
+ * addr_limit values through the equally misnamed get/set_fs macros.
+ * (see above)
+ */
+
+#define KERNEL_DS	MAKE_MM_SEG(0xffffffff)
+#define USER_DS		MAKE_MM_SEG(PAGE_OFFSET)
+
+/*
+ * Ideally we should be doing this using assembler:
+ *   This needs 33-bit arithmetic. We have a carry..
+ *
+ *   sum := addr + size;  carry? --> result = false;
+ *   if (sum >= addr_limit) result = false;
+ *   otherwise result = true
+ *
+ * but we don't have inline asm, so hack it using long longs.
+ */
+static inline int access_ok(int type, const void *addr, unsigned long size)
+{
+	return ((unsigned long long)(unsigned long)addr +
+		(unsigned long long)size) <=
+	    (unsigned long long)current_thread_info()->addr_limit.seg;
+}
+
+static inline int verify_area(int type, const void *addr, unsigned long size)
+{
+	return access_ok(type, addr, size) ? 0 : -EFAULT;
+}
+
+/*
+ * These are the main single-value transfer routines.  They automatically
+ * use the right size if we just have the right pointer type.
+ *
+ * As the ST200 uses the same address space for kernel and user
+ * data, we can just do these as direct assignments.  (Of course, the
+ * exception handling means that it's no longer "just"...)
+ *
+ * Careful to not
+ * (a) re-use the arguments for side effects (sizeof/typeof is ok)
+ * (b) require any knowledge of processes at this stage
+ *
+ * These functions return 0 on success and -EFAULT on error.
+ */
+#define put_user(x,ptr) \
+  __put_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+#define get_user(x,ptr) \
+  __get_user_check((x),(ptr),sizeof(*(ptr)))
+
+/*
+ * The "__xxx" versions do not do address space checking, useful when
+ * doing multiple accesses to the same area (the programmer has to do the
+ * checks by hand with "access_ok()")
+ */
+#define __put_user(x,ptr) \
+  __put_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+#define __get_user(x,ptr) \
+  __get_user_nocheck((x),(ptr),sizeof(*(ptr)))
+
+extern long __get_user_asm_byte(const void *ptr, long *retval);
+extern long __get_user_asm_half(const void *ptr, long *retval);
+extern long __get_user_asm_word(const void *ptr, long *retval);
+extern long long __get_user_asm_double(const void *ptr, long *retval);
+extern long __get_user_bad(void);
+
+extern void __put_user_asm_byte(long x, void *ptr, long *retval);
+extern void __put_user_asm_half(long x, void *ptr, long *retval);
+extern void __put_user_asm_word(long x, void *ptr, long *retval);
+extern void __put_user_asm_double(long long x, void *ptr, long *retval);
+extern void __put_user_bad(void);
+
+#define __get_user_check(x,ptr,size)					\
+({									\
+	long __gu_err = -EFAULT;					\
+	unsigned long __gu_val = 0;					\
+	const __typeof__(*(ptr)) *__gu_addr = (ptr);			\
+	if (access_ok(VERIFY_READ,__gu_addr,size)) {			\
+		__gu_err = 0;						\
+		__get_user_size(__gu_val,__gu_addr,(size),__gu_err);	\
+	}								\
+	(x) = (__typeof__(*(ptr)))__gu_val;				\
+	__gu_err;							\
+})
+
+#define __get_user_nocheck(x,ptr,size)					\
+({									\
+	long __gu_err = 0;						\
+	unsigned long __gu_val;						\
+	__get_user_size(__gu_val,(ptr),(size),__gu_err);		\
+	(x) = (__typeof__(*(ptr)))__gu_val;				\
+	__gu_err;							\
+})
+
+#define __put_user_check(x,ptr,size)					\
+({									\
+	long __pu_err = -EFAULT;					\
+	__typeof__(*(ptr)) *__pu_addr = (ptr);				\
+	if (access_ok(VERIFY_WRITE,__pu_addr,size)) {			\
+		__pu_err = 0;						\
+		__put_user_size((x),__pu_addr,(size),__pu_err);		\
+	}								\
+	__pu_err;							\
+})
+
+#define __put_user_nocheck(x,ptr,size)					\
+({									\
+	long __pu_err = 0;						\
+	__typeof__(*(ptr)) *__pu_addr = (ptr);				\
+	__put_user_size((x),__pu_addr,(size),__pu_err);			\
+	__pu_err;							\
+})
+
+#define __get_user_size(x,ptr,size,retval)				\
+do {									\
+	switch (size) {							\
+	case 1:	(x) = __get_user_asm_byte(ptr,&retval);	break;		\
+	case 2:	(x) = __get_user_asm_half(ptr,&retval);	break;		\
+	case 4:	(x) = __get_user_asm_word(ptr,&retval);	break;		\
+	case 8:	(x) = __get_user_asm_double(ptr,&retval); break;	\
+	default: (x) = __get_user_bad();				\
+	}								\
+} while (0)
+
+#define __put_user_size(x,ptr,size,retval)				\
+do {									\
+	switch (size) {							\
+	case 1: __put_user_asm_byte(x,ptr,&retval);	break;	\
+	case 2: __put_user_asm_half(x,ptr,&retval);	break;	\
+	case 4: __put_user_asm_word(x,ptr,&retval);	break;	\
+	case 8: __put_user_asm_double(x,ptr,&retval);	break;	\
+	default: __put_user_bad();					\
+	}								\
+} while (0)
+
+unsigned long __do_copy_user(void *to, const void *from, unsigned long n);
+unsigned long __do_clear_user(void *to, unsigned long n);
+long __do_strncpy_from_user(char *dst, const char *src, long count);
+long __do_strnlen_user(const char *s, long n);
+
+/*
+ * All the {__,}copy_{to,from}_user and {__,}clear_user functions
+ * return the number of bytes NOT copied.
+ */
+static __inline__ unsigned long copy_from_user(void *to, const void *from,
+					       unsigned long n)
+{
+	if (access_ok(VERIFY_READ, from, n))
+		n = __do_copy_user(to, from, n);
+	else			/* security hole - plug it */
+		memset(to, 0, n);
+	return n;
+}
+
+static __inline__ unsigned long __copy_from_user_inatomic(void *to,
+							  const void *from,
+							  unsigned long n)
+{
+	return __do_copy_user(to, from, n);
+}
+
+static inline unsigned long __copy_from_user(void *to, const void __user * from,
+					     unsigned long n)
+{
+	might_sleep();
+	return __copy_from_user_inatomic(to, from, n);
+}
+
+static __inline__ unsigned long copy_to_user(void *to, const void *from,
+					     unsigned long n)
+{
+	if (access_ok(VERIFY_WRITE, to, n))
+		n = __do_copy_user(to, from, n);
+	return n;
+}
+
+static __inline__ unsigned long __copy_to_user_inatomic(void *to,
+							const void *from,
+							unsigned long n)
+{
+	return __do_copy_user(to, from, n);
+}
+
+static inline unsigned long __copy_to_user(void __user * to, const void *from,
+					   unsigned long n)
+{
+	might_sleep();
+	return __copy_to_user_inatomic(to, from, n);
+}
+
+static __inline__ unsigned long clear_user(void *to, unsigned long n)
+{
+	if (access_ok(VERIFY_WRITE, to, n))
+		n = __do_clear_user(to, n);
+	return n;
+}
+
+static __inline__ unsigned long __clear_user(void *to, unsigned long n)
+{
+	return __do_clear_user(to, n);
+}
+
+/*
+ * {__,}strcpy_from_user returns -EFAULT if exception, count if the entire
+ * buffer filled, else strlen (without trailing nul).
+ */
+static __inline__ long strncpy_from_user(char *dst, const char *src, long count)
+{
+	long res = -EFAULT;
+	if (access_ok(VERIFY_READ, src, 1))
+		res = __do_strncpy_from_user(dst, src, count);
+	return res;
+}
+
+static __inline__ long __strncpy_from_user(char *dst, const char *src,
+					   long count)
+{
+	return __do_strncpy_from_user(dst, src, count);
+}
+
+/*
+ * strnlen_user returns 0 if exception before NUL or reaching the
+ * supplied limit (N), a value greater than N if the limit would be
+ * exceeded, else strlen (including trailing nul).
+ */
+static inline long strnlen_user(const char *s, long n)
+{
+	unsigned long res = 0;
+
+	if (access_ok(VERIFY_READ, s, 0))
+		res = __do_strnlen_user(s, n);
+	return res;
+}
+
+#define strlen_user(s)	strnlen_user(s, ~0UL >> 1)
+
+#endif /* _ASM_ST200_UACCESS_H */
diff --git a/arch/st200/include/asm/unaligned.h b/arch/st200/include/asm/unaligned.h
new file mode 100644
index 0000000..bd8ae3c
--- /dev/null
+++ b/arch/st200/include/asm/unaligned.h
@@ -0,0 +1,11 @@
+#ifndef _ASM_ST200_UNALIGNED_H
+#define _ASM_ST200_UNALIGNED_H
+
+#include <linux/unaligned/le_struct.h>
+#include <linux/unaligned/be_byteshift.h>
+#include <linux/unaligned/generic.h>
+
+#define get_unaligned  __get_unaligned_le
+#define put_unaligned  __put_unaligned_le
+
+#endif /* _ASM_ST200_UNALIGNED_H */
diff --git a/arch/st200/include/asm/unistd.h b/arch/st200/include/asm/unistd.h
new file mode 100644
index 0000000..2434114
--- /dev/null
+++ b/arch/st200/include/asm/unistd.h
@@ -0,0 +1,476 @@
+/*
+ *  include/asm-st200/unistd.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: David McKay <david.mckay@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_UNISTD_H
+#define _ASM_ST200_UNISTD_H
+
+/*
+ * This file contains the system call numbers.
+ */
+
+#define __NR_syscall                0
+#define __NR_exit                   1
+#define __NR_read                   2
+#define __NR_write                  3
+#define __NR_open                   4
+#define __NR_close                  5
+#define __NR_link                   6
+#define __NR_unlink                 7
+#define __NR_execve                 8
+#define __NR_chdir                  9
+#define __NR_mknod                 10
+#define __NR_chmod                 11
+#define __NR_lchown                12
+#define __NR_socket                13
+#define __NR_stat                  14
+#define __NR_lseek                 15
+#define __NR_getpid                16
+#define __NR_mount                 17
+#define __NR_bind                  18
+#define __NR_setuid                19
+#define __NR_getuid                20
+#define __NR_ptrace                21
+#define __NR_fstat                 22
+#define __NR_utimes                23
+#define __NR_connect               24
+#define __NR_listen                25
+#define __NR_access                26
+#define __NR_accept                27
+#define __NR_sync                  28
+#define __NR_kill                  29
+#define __NR_rename                30
+#define __NR_mkdir                 31
+#define __NR_rmdir                 32
+#define __NR_dup                   33
+#define __NR_pipe                  34
+#define __NR_times                 35
+#define __NR_getsockname           36
+#define __NR_brk                   37
+#define __NR_setgid                38
+#define __NR_getgid                39
+#define __NR_geteuid               40
+#define __NR_getegid               41
+#define __NR_acct                  42
+#define __NR_umount2               43
+#define __NR_getpeername           44
+#define __NR_ioctl                 45
+#define __NR_fcntl                 46
+#define __NR_socketpair            47
+#define __NR_setpgid               48
+#define __NR_send                  49
+#define __NR_uname                 50
+#define __NR_umask                 51
+#define __NR_chroot                52
+#define __NR_ustat                 53
+#define __NR_dup2                  54
+#define __NR_getppid               55
+#define __NR_setsid                56
+#define __NR_pivot_root            57
+#define __NR_setreuid              58
+#define __NR_setregid              59
+#define __NR_mincore               60
+#define __NR_sethostname           61
+#define __NR_setrlimit             62
+#define __NR_getrlimit             63
+#define __NR_getrusage             64
+#define __NR_gettimeofday          65
+#define __NR_settimeofday          66
+#define __NR_getgroups             67
+#define __NR_setgroups             68
+#define __NR_sendto                69
+#define __NR_symlink               70
+#define __NR_lstat                 71
+#define __NR_readlink              72
+#define __NR_uselib                73
+#define __NR_swapon                74
+#define __NR_reboot                75
+#define __NR_mmap2                 76
+#define __NR_munmap                77
+#define __NR_truncate              78
+#define __NR_ftruncate             79
+#define __NR_fchmod                80
+#define __NR_fchown                81
+#define __NR_getpriority           82
+#define __NR_setpriority           83
+#define __NR_recv                  84
+#define __NR_statfs                85
+#define __NR_fstatfs               86
+#define __NR_stat64                87
+#define __NR_syslog                88
+#define __NR_setitimer             89
+#define __NR_getitimer             90
+#define __NR_capget                91
+#define __NR_capset                92
+#define __NR_pread64               93
+#define __NR_pwrite64              94
+#define __NR_getcwd                95
+#define __NR_vhangup               96
+#define __NR_fstat64               97
+#define __NR_wait4                 98
+#define __NR_swapoff               99
+#define __NR_sysinfo              100
+#define __NR_shutdown             101
+#define __NR_fsync                102
+#define __NR_madvise              103
+#define __NR_clone                104
+#define __NR_setdomainname        105
+#define __NR_sendfile             106
+#define __NR_recvfrom             107
+#define __NR_adjtimex             108
+#define __NR_mprotect             109
+#define __NR_init_module          110
+#define __NR_delete_module        111
+#define __NR_quotactl             112
+#define __NR_getpgid              113
+#define __NR_fchdir               114
+#define __NR_bdflush              115
+#define __NR_sysfs                116
+#define __NR_personality          117
+#define __NR_setfsuid             118
+#define __NR_setfsgid             119
+#define __NR__llseek              120
+#define __NR_getdents             121
+#define __NR__newselect           122
+#define __NR_flock                123
+#define __NR_msync                124
+#define __NR_readv                125
+#define __NR_writev               126
+#define __NR_getsid               127
+#define __NR_fdatasync            128
+#define __NR__sysctl              129
+#define __NR_mlock                130
+#define __NR_munlock              131
+#define __NR_mlockall             132
+#define __NR_munlockall           133
+#define __NR_sched_setparam               134
+#define __NR_sched_getparam               135
+#define __NR_sched_setscheduler           136
+#define __NR_sched_getscheduler           137
+#define __NR_sched_yield                  138
+#define __NR_sched_get_priority_max       139
+#define __NR_sched_get_priority_min       140
+#define __NR_sched_rr_get_interval        141
+#define __NR_nanosleep            142
+#define __NR_mremap               143
+#define __NR_setresuid            144
+#define __NR_getresuid            145
+#define __NR_sigaltstack          146
+#define __NR_poll                 147
+#define __NR_nfsservctl           148
+#define __NR_setresgid            149
+#define __NR_getresgid            150
+#define __NR_prctl                151
+#define __NR_rt_sigreturn         152
+#define __NR_rt_sigaction         153
+#define __NR_rt_sigprocmask       154
+#define __NR_rt_sigpending        155
+#define __NR_rt_sigtimedwait      156
+#define __NR_rt_sigqueueinfo      157
+#define __NR_rt_sigsuspend        158
+#define __NR_chown                159
+#define __NR_setsockopt           160
+#define __NR_getsockopt           161
+#define __NR_sendmsg              162
+#define __NR_recvmsg              163
+#define __NR_semop                164
+#define __NR_semget               165
+#define __NR_semctl               166
+#define __NR_msgsnd               167
+#define __NR_msgrcv               168
+#define __NR_msgget               169
+#define __NR_msgctl               170
+#define __NR_shmat                171
+#define __NR_shmdt                172
+#define __NR_shmget               173
+#define __NR_shmctl               174
+#define __NR_lstat64              175
+#define __NR_truncate64           176
+#define __NR_ftruncate64          177
+#define __NR_getdents64           178
+#define __NR_fcntl64              179
+#define __NR_gettid               180
+#define __NR_readahead            181
+#define __NR_setxattr             182
+#define __NR_lsetxattr            183
+#define __NR_fsetxattr            184
+#define __NR_getxattr             185
+#define __NR_lgetxattr            186
+#define __NR_fgetxattr            187
+#define __NR_listxattr            188
+#define __NR_llistxattr           189
+#define __NR_flistxattr           190
+#define __NR_removexattr          191
+#define __NR_lremovexattr         192
+#define __NR_fremovexattr         193
+#define __NR_sendfile64           194
+#define __NR_tkill		  195
+#define __NR_tgkill               196
+#define __NR_restart_syscall	  197
+#define __NR_semtimedop           198
+#define __NR_set_tid_address      199
+#define __NR_sched_setaffinity    200
+#define __NR_sched_getaffinity    201
+#define __NR_futex                202
+#define __NR_exit_group           203
+#define __NR_io_setup             204
+#define __NR_io_destroy           205
+#define __NR_io_getevents         206
+#define __NR_io_submit         	  207
+#define __NR_io_cancel        	  208
+#define __NR_lookup_dcookie 	  209
+#define __NR_epoll_create         210
+#define __NR_epoll_ctl            211
+#define __NR_epoll_wait		  212
+#define __NR_mbind		  213
+#define __NR_get_mempolicy	  214
+#define __NR_set_mempolicy        215
+#define __NR_remap_file_pages     216
+#define __NR_fadvise64_64 	  217
+#define __NR_statfs64		  218
+#define __NR_fstatfs64 		  219
+#define __NR_waitid 	          220
+#define __NR_mq_open              221
+#define __NR_mq_unlink            222
+#define __NR_mq_timedsend         223
+#define __NR_mq_timedreceive      224
+#define __NR_mq_notify            225
+#define __NR_mq_getsetattr        226
+#define __NR_timer_create         227
+#define __NR_timer_settime        228
+#define __NR_timer_gettime        229
+#define __NR_timer_getoverrun     230
+#define __NR_timer_delete         231
+#define __NR_clock_settime        232
+#define __NR_clock_gettime        233
+#define __NR_clock_getres         234
+#define __NR_clock_nanosleep      235
+#define __NR_sys_kexec_load       236
+#define __NR_add_key              237
+#define __NR_request_key          238
+#define __NR_keyctl               239
+
+#define __NR_Linux_syscalls       240
+
+#ifndef __ASSEMBLY__
+
+#define __syscall_return(type)			\
+do {					        \
+	if(_sc_err) {errno=_sc_res;_sc_res=-1;}	\
+	return (type) (_sc_res); \
+} while (0)
+
+#define __syscall_clobber                                         \
+                       "memory",                                        \
+                       "r8",  "r9",  "r10", "r11",               	\
+                                                                 "r23",	\
+                       "r24", "r25", "r26", "r27", "r28", "r29", "r30", \
+                       "r31", "r32", "r33", "r34", "r35", "r36", "r37", \
+                       "r38", "r39", "r40", "r41", "r42", "r43", "r44", \
+                       "r45", "r46", "r47", "r48", "r49", "r50", "r51", \
+                       "r52", "r53", "r54", "r55", "r56", "r57", "r58", \
+                       "r59", "r60", "r61", "r62",                      \
+                       "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7"
+
+#define __syscall_input0 "r" (_sc_num)
+#define __syscall_input1 __syscall_input0,"r" (_sc_arg1)
+#define __syscall_input2 __syscall_input1,"r" (_sc_arg2)
+#define __syscall_input3 __syscall_input2,"r" (_sc_arg3)
+#define __syscall_input4 __syscall_input3,"r" (_sc_arg4)
+#define __syscall_input5 __syscall_input4,"r" (_sc_arg5)
+#define __syscall_input6 __syscall_input5,"r" (_sc_arg6)
+
+#define _syscall0(type,name)			\
+type name(void)                                 \
+{                                               \
+	register long _sc_num asm("r15");       \
+	register long _sc_res;			\
+	register long _sc_err;			\
+        _sc_num = __NR_##name;			\
+	__asm__ volatile ("syscall 0 \n"	\
+			  ";; \n"		\
+			  "mfb %0 = $b0 \n"	\
+			  "mov %1 = $r16\n"     \
+			  ";;\n"		\
+			  :"=r" (_sc_err),"=r" (_sc_res) \
+			  : __syscall_input0    \
+                          : __syscall_clobber, "r16","r17","r18","r19","r20","r21","r22");	\
+	__syscall_return(type);			\
+}
+
+#define _syscall1(type,name,type1,arg1)		\
+type name(type1 arg1)                           \
+{                                               \
+	register long _sc_num asm("r15");	\
+	register long _sc_res;	                \
+	register long _sc_arg1 asm("r16");	\
+	register long _sc_err;			\
+        _sc_num = __NR_##name;			\
+	_sc_arg1 = (long)arg1;			\
+	__asm__ volatile ("syscall 0 \n"	\
+			  ";; \n"		\
+			  "mfb %0 = $b0 \n"	\
+			  "mov %1 = $r16\n"     \
+			  ";;\n"	        \
+			  :"=r" (_sc_err),"=r" (_sc_res)    \
+			  : __syscall_input1    \
+                          : __syscall_clobber,"r17","r18","r19","r20","r21","r22" );	\
+	__syscall_return(type);	                \
+}
+
+#define _syscall2(type,name,type1,arg1,type2,arg2)	\
+type name(type1 arg1,type2 arg2)    		        \
+{                                                       \
+	register long _sc_num asm("r15");		\
+	register long _sc_res;				\
+	register long _sc_arg1 asm("r16");		\
+	register long _sc_arg2 asm("r17");		\
+	register long _sc_err;		                \
+        _sc_num = __NR_##name;				\
+	_sc_arg1 = (long)arg1;                          \
+	_sc_arg2 = (long)arg2;                          \
+	__asm__ volatile ("syscall 0 \n"		\
+			  ";; \n"			\
+			  "mfb %0 = $b0 \n"		\
+			  "mov %1 = $r16\n"		\
+			  ";;\n"			\
+			  :"=r" (_sc_err),"=r" (_sc_res)	\
+                          : __syscall_input2             \
+			  : __syscall_clobber,"r18","r19","r20","r21","r22" ); \
+	__syscall_return(type);	                        \
+}
+
+#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)		\
+type name(type1 arg1,type2 arg2,type3 arg3)			        \
+{                                                                       \
+	register long _sc_num asm("r15");				\
+	register long _sc_res;						\
+	register long _sc_arg1 asm("r16");				\
+	register long _sc_arg2 asm("r17");				\
+	register long _sc_arg3 asm("r18");				\
+	register long _sc_err;						\
+        _sc_num = __NR_##name;						\
+	_sc_arg1 = (long)arg1;						\
+	_sc_arg2 = (long)arg2;						\
+	_sc_arg3 = (long)arg3;						\
+	__asm__ volatile ("syscall 0 \n"				\
+			  ";; \n"					\
+			  "mfb %0 = $b0 \n"				\
+			  "mov %1 = $r16\n"				\
+			  ";;\n"					\
+			  :"=r" (_sc_err),"=r" (_sc_res)		\
+                          : __syscall_input3                             \
+			  : __syscall_clobber,"r19","r20","r21","r22" ); \
+	__syscall_return(type);						\
+}
+
+#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)\
+type name(type1 arg1,type2 arg2,type3 arg3,type4 arg4)   		\
+{                                                                       \
+	register long _sc_num asm("r15");				\
+	register long _sc_res;						\
+	register long _sc_arg1 asm("r16");				\
+	register long _sc_arg2 asm("r17");				\
+	register long _sc_arg3 asm("r18");				\
+	register long _sc_arg4 asm("r19");				\
+	register long _sc_err;						\
+        _sc_num = __NR_##name;						\
+	_sc_arg1 = (long)arg1;						\
+	_sc_arg2 = (long)arg2;						\
+	_sc_arg3 = (long)arg3;						\
+	_sc_arg4 = (long)arg4;						\
+	__asm__ volatile ("syscall 0 \n"				\
+			  ";; \n"					\
+			  "mfb %0 = $b0 \n"				\
+			  "mov %1 = $r16\n"				\
+			  ";;\n"					\
+			  :"=r" (_sc_err),"=r" (_sc_res)		\
+                          : __syscall_input4				\
+			  : __syscall_clobber,"r20","r21","r22"  );	\
+	__syscall_return(type);						\
+}
+
+#define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,type5,arg5) \
+type name(type1 arg1,type2 arg2,type3 arg3,type4 arg4,type5 arg5)	\
+{                                                                       \
+	register long _sc_num asm("r15");				\
+	register long _sc_res;						\
+	register long _sc_arg1 asm("r16");				\
+	register long _sc_arg2 asm("r17");				\
+	register long _sc_arg3 asm("r18");				\
+	register long _sc_arg4 asm("r19");				\
+	register long _sc_arg5 asm("r20");				\
+	register long _sc_err;						\
+        _sc_num = __NR_##name;						\
+	_sc_arg1 = (long)arg1;						\
+	_sc_arg2 = (long)arg2;						\
+	_sc_arg3 = (long)arg3;						\
+	_sc_arg4 = (long)arg4;						\
+	_sc_arg5 = (long)arg5;						\
+	__asm__ volatile ("syscall 0 \n"				\
+			  ";; \n"					\
+			  "mfb %0 = $b0 \n"				\
+			  "mov %1 = $r16\n"				\
+			  ";;\n"					\
+			  :"=r" (_sc_err),"=r" (_sc_res)		\
+                          : __syscall_input5				\
+			  : __syscall_clobber,"r21","r22" );		\
+	__syscall_return(type);						\
+}
+
+#define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,type5,arg5,type6,arg6) \
+type name(type1 arg1,type2 arg2,type3 arg3,type4 arg4,type5 arg5,type6 arg6) \
+{                                                                       \
+	register long _sc_num asm("r15");				\
+	register long _sc_res;						\
+	register long _sc_arg1 asm("r16");				\
+	register long _sc_arg2 asm("r17");				\
+	register long _sc_arg3 asm("r18");				\
+	register long _sc_arg4 asm("r19");				\
+	register long _sc_arg5 asm("r20");				\
+	register long _sc_arg6 asm("r21");				\
+	register long _sc_err;						\
+        _sc_num = __NR_##name;						\
+	_sc_arg1 = (long)arg1;						\
+	_sc_arg2 = (long)arg2;						\
+	_sc_arg3 = (long)arg3;						\
+	_sc_arg4 = (long)arg4;						\
+	_sc_arg5 = (long)arg5;						\
+	_sc_arg5 = (long)arg6;						\
+	__asm__ volatile ("syscall 0 \n"				\
+			  ";; \n"					\
+			  "mfb %0 = $b0 \n"				\
+			  "mov %1 = $r16\n"				\
+			  ";;\n"					\
+			  :"=r" (_sc_err),"=r" (_sc_res)		\
+                          : __syscall_input6				\
+			  : __syscall_clobber,"r22");			\
+	__syscall_return(type);						\
+}
+
+#ifdef __KERNEL_SYSCALLS__
+
+static __inline__ _syscall3(int, execve, const char *, file, char **, argv,
+			    char **, envp)
+#endif
+#ifdef __KERNEL__
+#define __ARCH_WANT_STAT64
+#define __ARCH_WANT_SYS_LLSEEK
+#define __ARCH_WANT_SYS_RT_SIGACTION
+#endif
+#define __IGNORE_fork		/* use clone */
+#define __IGNORE_time
+#define __IGNORE_alarm		/* use setitimer */
+#define __IGNORE_pause
+#define __IGNORE_mmap		/* use mmap2 */
+#define __IGNORE_vfork		/* use clone */
+#endif				/* __ASSEMBLY__ */
+/*
+ * "Conditional" syscalls
+ */
+#define cond_syscall(x) asm("\t.section .text\n\t.weak\t" #x "\n\t.set\t" #x ",sys_ni_syscall\n\t.previous");
+#endif				/* _ASM_ST200_UNISTD_H_ */
diff --git a/arch/st200/include/asm/user.h b/arch/st200/include/asm/user.h
new file mode 100644
index 0000000..33362e8
--- /dev/null
+++ b/arch/st200/include/asm/user.h
@@ -0,0 +1,60 @@
+#ifndef _ASM_ST200_USER_H
+#define _ASM_ST200_USER_H
+
+#include <asm/page.h>
+
+/*
+ * Core file format: The core file is written in such a way that gdb
+ * can understand it and provide useful information to the user (under
+ * linux we use the `trad-core' bfd, NOT the osf-core).  The file contents
+ * are as follows:
+ *
+ *  upage: 1 page consisting of a user struct that tells gdb
+ *	what is present in the file.  Directly after this is a
+ *	copy of the task_struct, which is currently not used by gdb,
+ *	but it may come in handy at some point.  All of the registers
+ *	are stored as part of the upage.  The upage should always be
+ *	only one page long.
+ *  data: The data segment follows next.  We use current->end_text to
+ *	current->brk to pick up all of the user variables, plus any memory
+ *	that may have been sbrk'ed.  No attempt is made to determine if a
+ *	page is demand-zero or if a page is totally unused, we just cover
+ *	the entire range.  All of the addresses are rounded in such a way
+ *	that an integral number of pages is written.
+ *  stack: We need the stack information in order to get a meaningful
+ *	backtrace.  We need to write the data from usp to
+ *	current->start_stack, so we round each of these in order to be able
+ *	to write an integer number of pages.
+ */
+
+struct user_regs_struct {
+	unsigned long pc;	/* program counter */
+	unsigned long psw;	/* processor status word */
+	unsigned long regs[64];	/* integer regs */
+	unsigned long br[8];	/* branch bits */
+	unsigned long debugregs[6];	/* debug registers */
+	unsigned long traceregs[1];	/* trace registers */
+	unsigned long unused[64];	/* future expansion */
+};
+
+struct user {
+	struct user_regs_struct regs;	/* entire machine state */
+	size_t u_tsize;		/* text size (pages) */
+	size_t u_dsize;		/* data size (pages) */
+	size_t u_ssize;		/* stack size (pages) */
+	unsigned long start_code;	/* text starting address */
+	unsigned long start_data;	/* data starting address */
+	unsigned long start_stack;	/* stack starting address */
+	long int signal;	/* signal causing core dump */
+	struct regs *u_ar0;	/* help gdb find registers */
+	unsigned long magic;	/* identifies a core file */
+	char u_comm[32];	/* user command name */
+};
+
+#define NBPG			PAGE_SIZE
+#define UPAGES			1
+#define HOST_TEXT_START_ADDR	(u.start_code)
+#define HOST_DATA_START_ADDR	(u.start_data)
+#define HOST_STACK_END_ADDR	(u.start_stack + u.u_ssize * NBPG)
+
+#endif /* _ASM_ST200_USER_H */
diff --git a/arch/st200/include/asm/vdso.h b/arch/st200/include/asm/vdso.h
new file mode 100644
index 0000000..31b127a
--- /dev/null
+++ b/arch/st200/include/asm/vdso.h
@@ -0,0 +1,30 @@
+/*
+ * include/asm-st200/vdso.h
+ *
+ * Copyright (C) 2010 STMicroelectronics Limited
+ *	Author: Stephen Clarke <stephen.clarke@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_VDSO_H
+#define _ASM_ST200_VDSO_H
+
+#ifdef __KERNEL__
+
+/* Default link addresses for the vDSO */
+#define VDSO_LBASE 0
+
+/* Default map addresses for the vDSO */
+#define VDSO_MBASE VDSO_LBASE
+
+#define VDSO_VERSION_STRING	LINUX_2.6.32
+
+#ifndef __ASSEMBLY__
+
+extern unsigned long vdso_sigrestorer;
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_ST200_VDSO_H */
diff --git a/arch/st200/kernel/Makefile b/arch/st200/kernel/Makefile
new file mode 100644
index 0000000..d293a5b
--- /dev/null
+++ b/arch/st200/kernel/Makefile
@@ -0,0 +1,14 @@
+#
+# Makefile for the linux kernel.
+#
+
+
+extra-y		:= head.o init_task.o vmlinux.lds
+
+obj-y	:= debugregs.o entry-common.o entry-st231.o io.o irq.o irq_st200.o  \
+	   process.o ptrace.o setup.o signal.o \
+	   stubs.o sys_st200.o syscall.o time.o traps.o vdso.o
+
+obj-y	+= vdso/
+
+obj-$(CONFIG_MODULES)           += st200_ksyms.o module.o
diff --git a/arch/st200/kernel/asm-offsets.c b/arch/st200/kernel/asm-offsets.c
new file mode 100644
index 0000000..cb24ea6
--- /dev/null
+++ b/arch/st200/kernel/asm-offsets.c
@@ -0,0 +1,134 @@
+/*
+ * Generate definitions needed by assembly language modules.
+ * This code generates raw asm output which is post-processed to extract
+ * and format the required data.
+ */
+
+#include <linux/types.h>
+#include <linux/stddef.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/kbuild.h>
+#include <asm/io.h>
+#include <asm/processor.h>
+
+#define PT_OFFSET(n) 	DEFINE(PT_R##n,offsetof(struct pt_regs,r##n))
+
+#define SS_OFFSET(n) 	DEFINE(SS_R##n,offsetof(struct switch_stack,r##n))
+
+void foo(void)
+{
+	DEFINE(TI_TASK, offsetof(struct thread_info, task));
+	DEFINE(TI_FLAGS, offsetof(struct thread_info, flags));
+	BLANK();
+
+	DEFINE(TS_SP, offsetof(struct thread_struct, sp));
+	DEFINE(TS_PC, offsetof(struct thread_struct, pc));
+	BLANK();
+
+	DEFINE(SIZEOF_PT_REGS, sizeof(struct pt_regs));
+	DEFINE(PT_PSW, offsetof(struct pt_regs, psw));
+	DEFINE(PT_PC, offsetof(struct pt_regs, pc));
+	DEFINE(PT_BR, offsetof(struct pt_regs, br));
+	DEFINE(PT_LR, offsetof(struct pt_regs, lr));
+
+	PT_OFFSET(8);
+	PT_OFFSET(9);
+	PT_OFFSET(10);
+	PT_OFFSET(11);
+	PT_OFFSET(12);
+
+	PT_OFFSET(15);
+	PT_OFFSET(16);
+	PT_OFFSET(17);
+	PT_OFFSET(18);
+	PT_OFFSET(19);
+
+	PT_OFFSET(20);
+	PT_OFFSET(21);
+	PT_OFFSET(22);
+	PT_OFFSET(23);
+	PT_OFFSET(24);
+	PT_OFFSET(25);
+	PT_OFFSET(26);
+	PT_OFFSET(27);
+	PT_OFFSET(28);
+	PT_OFFSET(29);
+
+	PT_OFFSET(30);
+	PT_OFFSET(31);
+	PT_OFFSET(32);
+	PT_OFFSET(33);
+	PT_OFFSET(34);
+	PT_OFFSET(35);
+	PT_OFFSET(36);
+	PT_OFFSET(37);
+	PT_OFFSET(38);
+	PT_OFFSET(39);
+
+	PT_OFFSET(40);
+	PT_OFFSET(41);
+	PT_OFFSET(42);
+	PT_OFFSET(43);
+	PT_OFFSET(44);
+	PT_OFFSET(45);
+	PT_OFFSET(46);
+	PT_OFFSET(47);
+	PT_OFFSET(48);
+	PT_OFFSET(49);
+
+	PT_OFFSET(50);
+	PT_OFFSET(51);
+	PT_OFFSET(52);
+	PT_OFFSET(53);
+	PT_OFFSET(54);
+	PT_OFFSET(55);
+	PT_OFFSET(56);
+	PT_OFFSET(57);
+	PT_OFFSET(58);
+	PT_OFFSET(59);
+
+	PT_OFFSET(60);
+	PT_OFFSET(61);
+	PT_OFFSET(62);
+
+	SS_OFFSET(1);
+	SS_OFFSET(2);
+	SS_OFFSET(3);
+	SS_OFFSET(4);
+	SS_OFFSET(5);
+	SS_OFFSET(6);
+	SS_OFFSET(7);
+
+	SS_OFFSET(13);
+	SS_OFFSET(14);
+
+	BLANK();
+
+	DEFINE(SIZEOF_SWITCH_STACK, sizeof(struct switch_stack));
+	BLANK();
+
+	/*
+	 * Size of the area pushed onto the stack below pt_regs or
+	 * switch_stack.  As pt_regs and switch_stack are both
+	 * multiples of 32 bytes, as is this, we guarantee that the
+	 * stack is always correctly aligned.  The bottom four words
+	 * are reserved for any called functions scratch area.  The
+	 * upper four are available for temporary storage.
+	 */
+	DEFINE(STACK_SCRATCH_AREA, (8 * 4));
+	BLANK();
+
+	DEFINE(SC_SS, offsetof(struct sigcontext, sc_ss));
+	DEFINE(SC_REGS, offsetof(struct sigcontext, sc_regs));
+	BLANK();
+
+	DEFINE(SIZEOF_STRUCT_PAGE, sizeof(struct page));
+	DEFINE(STRUCT_PAGE_FLAGS, offsetof(struct page, flags));
+	DEFINE(PG_arch_1, PG_arch_1);
+	BLANK();
+
+	DEFINE(CLONE_VM, CLONE_VM);
+	DEFINE(CLONE_VFORK, CLONE_VFORK);
+	DEFINE(SIGCHLD, SIGCHLD);
+}
diff --git a/arch/st200/kernel/asm_macros.h b/arch/st200/kernel/asm_macros.h
new file mode 100644
index 0000000..b0c729d
--- /dev/null
+++ b/arch/st200/kernel/asm_macros.h
@@ -0,0 +1,97 @@
+#ifndef __ASM_MACROS_H__
+#define __ASM_MACROS_H__
+
+#include <asm/asm-offsets.h>
+
+/* computes the correct offset into a given contiguous lump
+ * of saved registers
+ */
+
+#define PT_REG8_BLOCK(n)  (PT_R8+(((n)-8)*4))
+#define PT_REG15_BLOCK(n) (PT_R15+(((n)-15)*4))
+
+#define SS_REG1_BLOCK(n)  (SS_R1+(((n)-1)*4))
+#define SS_REG13_BLOCK(n) (SS_R13+(((n)-13)*4))
+
+
+/* All the macros below default to save via r12, they
+ * can also have an offset added to the index
+ */
+
+/* Saves a pt reg to the correct place */
+.macro save_pt reg offset=0 index=12
+.if (\reg >= 8) && (\reg <= 12)
+	stw	(PT_REG8_BLOCK(\reg) + \offset)[$r\index] = $r\reg
+	;;
+.elseif (\reg >= 15) && (\reg <= 62)
+	stw	(PT_REG15_BLOCK((\reg)) + \offset)[$r\index] = $r\reg
+	;;
+.else
+.err
+.endif
+.endm
+
+
+/* Saves a switch stack register to appropriate place */
+
+.macro save_ss reg offset=0 index=12
+.if (\reg >= 1) && (\reg <= 7)
+	stw	(SS_REG1_BLOCK(\reg) + \offset )[$r\index] = $r\reg
+	;;
+.elseif (\reg >= 13) && (\reg <= 14)
+	stw	(SS_REG13_BLOCK(\reg) + \offset)[$r\index] = $r\reg
+	;;
+.else
+.err
+.endif
+.endm
+
+
+.macro restore_pt reg offset=0 index=12
+.if (\reg >= 8) && (\reg <= 12)
+	ldw	$r\reg = (PT_REG8_BLOCK(\reg) + \offset)[$r\index]
+	;;
+.elseif (\reg >= 15) && (\reg <= 62)
+	ldw	$r\reg = (PT_REG15_BLOCK(\reg) + \offset)[$r\index]
+	;;
+.else
+.err
+.endif
+.endm
+
+.macro restore_ss reg offset=0 index=12
+.if (\reg >= 1) && (\reg <= 7)
+	ldw	$r\reg = (SS_REG1_BLOCK(\reg) + \offset)[$r\index]
+	;;
+.elseif (\reg >= 13) && (\reg <= 14)
+	ldw	$r\reg = (SS_REG13_BLOCK(\reg) + \offset)[$r\index]
+	;;
+.else
+.err
+.endif
+.endm
+
+
+#define PRESERVED_REG_LIST 1, 2, 3, 4, 5, 6, 7, 13, 14
+
+/* Save and restore the whole switch stack */
+
+.macro save_switch_stack offset=0 index=12
+.irp	reg, PRESERVED_REG_LIST
+save_ss	\reg \offset \index
+.endr
+.endm
+
+.macro restore_switch_stack offset=0 index=12
+.irp	reg, PRESERVED_REG_LIST
+restore_ss \reg \offset \index
+.endr
+.endm
+
+/* It would be good to have equivalents of the above for pt_regs, but
+ * the code is not uniform at the moment unfortunately, ie depending on
+ * what you are doing some registers are not restored
+ */
+
+
+#endif /* __ASM_MACROS_H__ */
diff --git a/arch/st200/kernel/debugregs.c b/arch/st200/kernel/debugregs.c
new file mode 100644
index 0000000..6fa620d
--- /dev/null
+++ b/arch/st200/kernel/debugregs.c
@@ -0,0 +1,40 @@
+/*
+ * linux/arch/st200/kernel/debugregs.c
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+
+#include <asm/ctrlregdef.h>
+#include <asm/debugregs.h>
+#include <asm/io.h>
+#include <asm/simtrace.h>
+
+void clear_debugregs(struct task_struct *task)
+{
+	ctrl_outl(0, DBREAK_CONTROL);
+	ctrl_outl(0, IBREAK_CONTROL);
+	sim_trace_off();
+}
+
+void set_debugregs(struct task_struct *task)
+{
+	struct thread_struct *thread = &task->thread;
+
+	if (thread->flags & ST200_THREAD_DEBUG_VALID) {
+		ctrl_outl(thread->debug.dbreak_upper, DBREAK_UPPER);
+		ctrl_outl(thread->debug.dbreak_lower, DBREAK_LOWER);
+		ctrl_outl(thread->debug.dbreak_control, DBREAK_CONTROL);
+		ctrl_outl(thread->debug.ibreak_upper, IBREAK_UPPER);
+		ctrl_outl(thread->debug.ibreak_lower, IBREAK_LOWER);
+		ctrl_outl(thread->debug.ibreak_control, IBREAK_CONTROL);
+	}
+
+	if (thread->flags & ST200_THREAD_TRACE_VALID) {
+		sim_trace_on(thread->trace.trace);
+	}
+}
diff --git a/arch/st200/kernel/dsu_st200.h b/arch/st200/kernel/dsu_st200.h
new file mode 100644
index 0000000..0ab357d
--- /dev/null
+++ b/arch/st200/kernel/dsu_st200.h
@@ -0,0 +1,61 @@
+#ifndef _DSU_ST200_H
+#define _DSU_ST200_H
+
+/* Debug support unit (DSU) registers */
+
+#define DSU_BASE	0x3000	/* Offset from PERIPHERIAL_BASE */
+#define DSU_ROM		0x4000	/* Offset from PERIPHERIAL_BASE */
+
+/* The DSU has 32 registers, DSR0 - DSR31 */
+
+#define DSR(x)	(x*8)
+
+/* The first three of these registers are used by the DSU hardware */
+
+/* DSR0: DSU version. */
+#define DSR0_PRODUCT_ID_MASK	0x0000ffff	/* Chip ID. */
+#define DSR0_CORE_VERSION_MASK	0x00ff0000	/* Core version number. */
+#define DSR0_DSU_VERSION	0xff000000	/* DSU design version number. */
+
+/* DSR1: DSU status. */
+#define DSR1_DEBUG_INTERRUPT_TAKEN	(1<<0)	/* Value of DEBUG_INTERRUPT_TAKEN signal, active high. */
+#define DSR1_SUPERVISOR_WRITE_ENABLE	(1<<1)	/* STBus writes enabled if the core is in supervisor mode (regardless of debug mode). */
+#define DSR1_USER_WRITE_ENABLE		(1<<2)	/* STBus writes enabled if the core is in user mode (regardless of debug mode). */
+#define DSR1_BIGENDIAN			(1<<3)	/* When 1 the core is in big endian mode. When 0 the core is in little endian. */
+
+/* DSR2: DSU output. */
+#define DSR2_DATA_MASK	0xff	/* Output data. */
+
+/* The remaining registers function is a software convention */
+
+#define DSR_USER_DEBUG_HANDLER	DSR(3)	/* Control switches to this address if content is non-zero. */
+#define DSU_ARG8	DSR(4)	/* Not used in current debug handler. */
+#define DSU_ARG7	DSR(5)	/* Not used in current debug handler. */
+#define DSU_ARG6	DSR(6)	/* Not used in current debug handler. */
+#define DSU_ARG5	DSR(7)	/* Not used in current debug handler. */
+#define DSU_ARG4	DSR(8)	/* Not used in current debug handler. */
+#define DSU_ARG3	DSR(9)	/* Command argument 3. */
+#define DSU_ARG2	DSR(10)	/* Command argument 2. Used by DSU_POKE and DSU_FLUSH. */
+#define DSU_ARG1	DSR(11)	/* Command argument 1. Used by all DSU commands. */
+#define DSU_COMMAND	DSR(12)	/* Command register. Written by HTI, cleared by target when command accepted. */
+#define DSU_RESPONSE	DSR(13)	/* Response register. Set by target to a completion code, cleared by HTI before issuing next command. */
+/*			DSR(14)	   Context saving Saves SCR4_REG */
+/*			DSR(15)	   Context saving Saves SCR1_REG */
+/*			DSR(16)	   Context saving Saves SCR2_REG */
+/*			DSR(17)	   Context saving Saves SCR3_REG */
+/*			DSR(18)	   Context saving Saves the branch bits */
+/*			DSR(19)	   Context saving Saves LINK_REG */
+/*			DSR(20)	   Context saving Saves HANDLER_PC */
+/*			DSR(21)	   Context saving Saves SAVED_SAVED_PSW */
+/*			DSR(22)	   Context saving Saves SAVED_SAVED_PC */
+/*			DSR(23)	   Context saving Saves SAVED_PSW */
+/*			DSR(24)	   Context saving Saves SAVED_PC */
+/*			DSR(25)	   Context saving Saves EXCAUSE */
+/*			DSR(26)	   Context saving Saves EXADDRESS */
+/*			DSR(27)	   Unused Unused */
+/*			DSR(28)	   Unused Unused */
+/*			DSR(29)	   Unused Unused */
+/*			DSR(30)	   Unused Unused */
+/*			DSR(31)	   Context saving Saves DSR1 */
+
+#endif
diff --git a/arch/st200/kernel/entry-common.S b/arch/st200/kernel/entry-common.S
new file mode 100644
index 0000000..3afe2e4
--- /dev/null
+++ b/arch/st200/kernel/entry-common.S
@@ -0,0 +1,743 @@
+/*
+ * linux/arch/st200/kernel/entry.S
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Authors: Stuart Menefy <stuart.menefy@st.com>,
+ *		 David McKay <david.mckay@st.com>
+ *
+ */
+
+#include <linux/linkage.h>
+#include <asm/page.h>
+#include <asm/ctrlregdef.h>
+#include <asm/thread_info.h>
+#include <asm/pgtable.h>
+#include <asm/cache.h>
+#include <asm/asm-offsets.h>
+#include "irq_st200.h"
+#include "asm_macros.h"
+
+
+/***********************************************************************/
+/* Second level exception handlers */
+
+ENTRY(extern_int)
+	ldw	$r61 = st200_irq_base[$r0]
+	mov	$r63 = ret_from_irq	/* This is where we come back to */
+	;;
+	/* We have to and with the mask, as pending is before the mask
+	 * register
+	 */
+	ldw	$r15 = INTMASK0[$r61]
+	;;
+	ldw	$r16 = INTPENDING0[$r61]
+	;;
+	and	$r16 = $r15,$r16
+	ldw	$r17 = INTMASK1[$r61]
+	;;
+	clz	$r16 = $r16
+	ldw	$r18 = INTPENDING1[$r61]
+	;;
+	cmpne	$b0 = $r16,32 /* $b0 set if interrupt on pending 0 */
+	mov	$r19 = $r16
+	and	$r17 = $r17,$r18
+	;;
+	sub	$r16 = 31,$r16 /* clz counts most significant zeroes */
+	clz	$r17 = $r17
+	;;
+	sub	$r17 = 63,$r17
+	add	$r19 = $r19,$r17
+	;;
+	cmpeq	$b1 = $r19,64	/* $b1 set if no interrupts */
+	slct	$r16 = $b0,$r16,$r17 /* Chose 0->31 over 32->63 */
+	;;
+	slctf	$r16 = $b1,$r16,-1 /* Hmm, nothing set. */
+	goto	do_IRQ
+	/* Need to restart */
+	;;
+
+/*
+ * On entry to st200_misaligned() the stack looks like this, with
+ * registers pointing into it:
+ *
+ *	+------------------------------
+ *	|  SIZEOF_PT_REGS
+ * $r16 >+------------------------------
+ *	|  SIZEOF_SWITCH_STACK
+ * $r17 >+------------------------------
+ *	|  SIZEOF_MISALIGNED_OLEX_AREA
+ * $r18 >+------------------------------
+ *	|  STACK_SCRATCH_AREA
+ * $r12 >+------------------------------
+ *
+ */
+
+#define SIZEOF_MISALIGNED_OLEX_AREA 64
+
+#define MISALIGNED_RESTORE_STACK_OFFSET (STACK_SCRATCH_AREA + SIZEOF_MISALIGNED_OLEX_AREA + SIZEOF_SWITCH_STACK)
+
+ENTRY(misaligned)
+	add	$r12 = $r12, -SIZEOF_MISALIGNED_OLEX_AREA
+	ldw	$r21 = PT_BR + STACK_SCRATCH_AREA + SIZEOF_SWITCH_STACK[$r12]
+	mov	$r20 = $r18		/* EXADDRESS */
+	;;
+	ldw	$r19 = PT_PC + MISALIGNED_RESTORE_STACK_OFFSET[$r12]
+	;;
+	add	$r16 = $r12, MISALIGNED_RESTORE_STACK_OFFSET
+	add	$r17 = $r12, STACK_SCRATCH_AREA + SIZEOF_MISALIGNED_OLEX_AREA
+	add	$r18 = $r12, STACK_SCRATCH_AREA
+	;;
+	call	$r63 = st200_misaligned
+	and	$r21 = $r21, 1<<8 	/* atomic flag */
+	;;
+
+	/* Can we put the succeed fail in a branch  bit to save doing this? */
+	cmpeq	$b0 = $r16,~0 /* Did we succeed or fail */
+	;;
+	add	$r63 = $r12,STACK_SCRATCH_AREA /* $r63 now contains start of olex area */
+	;;
+	/* Preserve $r17, as the RESTORE macros trog R16. We should not use R16 the RESTORE_BR macro */
+	mov	$r17 = $r16
+	/* We need to pop the olex area before doing a normal return */
+	add	$r15 = $r12,SIZEOF_MISALIGNED_OLEX_AREA
+	;;
+	slct	$r12 = $b0,$r15,$r12
+	br	$b0,ret_from_exception /* If we failed, then follow normal return path */
+	;;
+	ldw	$r15 = (PT_BR+ MISALIGNED_RESTORE_STACK_OFFSET)[$r12]
+	;;
+	/* OK, now we have to restore ALL the state, with the exception
+	 * of $r63, then execute the olex bundle.
+	 * Note that we DO NOT have to restore switch stack, because this should
+	 * have been restored when the C code exits.
+	 */
+
+#define RESTORE_BR(n) and $r16 = $r15, 1; ;; ; \
+                      mtb $b##n = $r16; ;; ; \
+                      shru $r15 = $r15,1 ; ;; ;
+
+	RESTORE_BR(0)
+	RESTORE_BR(1)
+	RESTORE_BR(2)
+	RESTORE_BR(3)
+	RESTORE_BR(4)
+	RESTORE_BR(5)
+	RESTORE_BR(6)
+	RESTORE_BR(7)
+
+	.irp	reg, 8,  9, 10, 11, \
+		18, 19, \
+		20, 21, 22, 23, 24, 25, 26, 27, 28, 29, \
+		30, 31, 32, 33, 34, 35, 36, 37, 38, 39, \
+		40, 41, 42, 43, 44, 45, 46, 47, 48, 49, \
+		50, 51, 52, 53, 54, 55, 56, 57, 58, 59, \
+		60, 61
+	restore_pt \reg,MISALIGNED_RESTORE_STACK_OFFSET
+	.endr
+
+
+misaligned_restore_atomic :
+	or	$r12 = $r12, 1		/* Set atomic flag */
+	mov	$r62 = misaligned_restore_atomic	/* Set roll back address */
+	;;
+	mov	$r15 = PSW_KERNEL_DEFAULT	/* Interrupts disabled */
+	;;
+	stw	SAVED_PSW[$r0] = $r15
+	;;
+	mov	$r15 = misaligned_restore_int_disabled
+	;;
+	stw	SAVED_PC[$r0] = $r15
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	and	$r12 = $r12, ~1		/* Clear atomic flag */
+	rfi
+	;;
+
+misaligned_restore_int_disabled:
+	/* interrupts are now OFF, we can restore rest of state and carry on
+	 *  Missing $r12,$r15,$r16,$r17, $r62. $r63 contains olex address
+	 */
+	ldw	$r15 = (MISALIGNED_RESTORE_STACK_OFFSET+PT_PSW)[$r12]
+	;;
+	stw	SAVED_PC[$r0]= $r17 /* $r17 contains the PC we return to */
+	;;
+	ldw	$r16 = (MISALIGNED_RESTORE_STACK_OFFSET+PT_R16)[$r12]
+	;;
+	stw	SAVED_PSW[$r0] = $r15
+	;;
+	ldw	$r15 = (MISALIGNED_RESTORE_STACK_OFFSET + PT_R15)[$r12]
+	;;
+	ldw	$r17 = (MISALIGNED_RESTORE_STACK_OFFSET + PT_R17)[$r12]
+	;;
+	ldw	$r62 = (MISALIGNED_RESTORE_STACK_OFFSET + PT_R62)[$r12]
+	;;
+	ldw	$r12 = (MISALIGNED_RESTORE_STACK_OFFSET + PT_R12)[$r12]
+	;;
+	/* Jump to generated OLEX code. The olex code restores $r63 to the
+	 * correct value, then executes the olex bundle, minus the branch
+	 * We don't need any nops for latency because the olex bundle has
+	 * one bundle to restore $r63 before the olex bundle is executed
+	 * Note that the olex bundle can NEVER fault or generate an exception
+	 * because there are no jumps loads or stores in it.
+	 */
+	goto	$r63
+	;;
+
+/***********************************************************************/
+/* Return from kernel to user code */
+
+ENTRY(ret_from_fork)
+	call	$r63 = schedule_tail
+	;;
+	mov	$r16 = $r0	/* result */
+	;;
+	/* Fall through into syscall_exit */
+
+	/*
+	 * Return from a 'normal' system call.
+	 *
+	 * Check $r16 for an error code, and convert into $b0
+	 * set/clear. Then disable interrupts to we do not miss an
+	 * interrupt setting one of the thread flags. Load the flag,
+	 * and if we need to do anything, call
+	 * work_pending_syscall. Otherwise ret to caller.
+	 * SIM: Could we use atomic sequences for this?
+	 *
+	 * Note we only restore $r12, $r63, psw and pc.
+	 * br0, $r16 and $r17 will be passed through.
+	 * SIM:	Do we need to $r0 any registers to prevent leaking
+	 * sensitive data from the kernel to user space?
+	 */
+ENTRY(syscall_exit)
+
+	or	$r12 = $r12, 1		/* Set atomic flag */
+	mov	$r62 = syscall_exit	/* Set roll back address */
+	;;
+	mov	$r24 = PSW_KERNEL_DEFAULT	/* Interrupts disabled */
+	mov	$r25 = 1f
+	;;
+	cmpgtu	$r26 = $r16, -4096	/* $r26 = (-1 >= $r16 >= -4095) */
+	stw	SAVED_PSW[$r0] = $r24
+	;;
+	sub	$r24 = $r0, $r16
+	stw	SAVED_PC[$r0] = $r25
+	;;
+	ldw	$r25 = PT_R15 + STACK_SCRATCH_AREA -1[$r12]
+	;;
+	and	$r11 = $r12, ~(THREAD_SIZE-1)
+	;;
+	nop
+	;;
+	nop
+	;;
+	andl	$b0 = $r25, $r26
+	and	$r12 = $r12, ~1		/* Clear atomic flag */
+	rfi
+	;;
+
+1:	slct	$r16 = $b0, $r24, $r16
+	ldw	$r20 = TI_FLAGS[$r11]
+	;;
+	ldw	$r28 = PT_PSW + STACK_SCRATCH_AREA[$r12]
+	;;
+	ldw	$r29 = PT_PC + STACK_SCRATCH_AREA[$r12]
+	;;
+	and	$r20 = $r20, _TIF_ALLWORK_MASK
+	ldw	$r63 = PT_LR + STACK_SCRATCH_AREA[$r12]
+	;;
+	cmpeq	$b1 = $r20, $r0		/* $b1 = nothing to do */
+	stw	SAVED_PSW[$r0] = $r28
+	;;
+	stw	SAVED_PC[$r0] = $r29
+	;;
+	nop
+	;;
+	brf	$b1, work_pending_syscall
+	;;
+	ldw	$r12 = PT_R12 + STACK_SCRATCH_AREA[$r12]
+	;;
+	nop
+	;;
+	rfi
+	;;
+/*
+ * This is where we return after exception handling.
+ */
+ENTRY(ret_from_exception)
+
+	restore_switch_stack STACK_SCRATCH_AREA
+
+	add	$r12 = $r12, SIZEOF_SWITCH_STACK
+	;;
+
+ENTRY(ret_from_exception_no_ss)
+
+#ifdef CONFIG_PREEMPT
+#error Normally interrupts would be disabled here. Can we replace it
+#error with setting the atomic flag?
+#endif
+
+ret_from_irq:
+
+	/* Are we returning to user mode or kernel mode? */
+	ldw	$r24 = PT_PSW + STACK_SCRATCH_AREA[$r12]
+	;;
+	nop
+	;;
+	nop
+	;;
+	and	$r24 = $r24, PSW_USER_MODE
+	;;
+	cmpeq	$b0 = $r24, $r0		/* $b0 = ret to kernel mode */
+	;;
+	nop
+	;;
+	nop
+	;;
+#ifdef CONFIG_PREEMPT
+	br	$b0, resume_kernel
+#else
+	br	$b0, restore_all
+#endif
+	;;
+
+	/* Returning to user mode, check for work to do */
+
+1:	or	$r12 = $r12, 1		/* Set atomic flag */
+	mov	$r62 = 1b
+	;;
+	mov	$r24 = PSW_KERNEL_DEFAULT /* Interrupts disabled */
+	;;
+	stw	SAVED_PSW[$r0] = $r24
+	mov	$r24 = 1f
+	;;
+	stw	SAVED_PC[$r0] = $r24
+	;;
+	and	$r11 = $r12, ~(THREAD_SIZE-1)
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	and	$r12 = $r12, ~1		/* Clear atomic flag */
+	rfi
+	;;
+1:
+
+	ldw	$r20 = TI_FLAGS[$r11]
+	;;
+	nop
+	;;
+	nop
+	;;
+	and	$r20 = $r20, _TIF_WORK_MASK
+	;;
+	cmpeq	$b1 = $r20, $r0		/* $b1 = flags clear -> nothing to do */
+	;;
+	mov	$r18 = $r0		/* indicate this was an exception/IRQ */
+	;;
+	nop
+	;;
+	brf	$b1, work_pending
+	;;
+
+/*
+ * This pops all the pt_regs registers, and restarts the interrupted code.
+ */
+restore_all:
+
+	add	$r12 = $r12,STACK_SCRATCH_AREA
+	;;
+
+	/* Restore branch bits */
+
+
+	ldw $r15 = PT_BR[$r12]
+	;;
+	nop
+	;;
+	nop
+	;;
+	RESTORE_BR(0)
+	RESTORE_BR(1)
+	RESTORE_BR(2)
+	RESTORE_BR(3)
+	RESTORE_BR(4)
+	RESTORE_BR(5)
+	RESTORE_BR(6)
+	RESTORE_BR(7)
+
+	.irp reg, 8, 9, 10, 11, \
+		  16, 17, 18, 19, \
+		  20, 21, 22, 23, 24, 25, 26, 27, 28, 29, \
+		  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, \
+		  40, 41, 42, 43, 44, 45, 46, 47, 48, 49, \
+		  50, 51, 52, 53, 54, 55, 56, 57, 58, 59, \
+		  60, 61
+	restore_pt \reg
+	.endr
+
+	/* Restore the LR */
+	ldw	$r63 = PT_LR[$r12]
+	;;
+
+	/* Ok lets switch off interrupt atomically */
+restore_atomic	:
+	or	$r12 = $r12, 1		/* Set atomic flag */
+	mov	$r62 = restore_atomic	/* Set roll back address */
+	;;
+	mov	$r15 = PSW_KERNEL_DEFAULT/* Interrupts disabled */
+	;;
+	stw	SAVED_PSW[$r0] = $r15
+	;;
+	mov $r15 = restore_int_disabled
+	;;
+	stw SAVED_PC[$r0] = $r15
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	and	$r12 = $r12, ~1		/* Clear atomic flag */
+	rfi
+	;;
+
+restore_int_disabled:
+	/* Ok interrupts are definately off when we get here, so
+	 * we don't have to worry about being interrupted before
+	 * we rfi
+	 *
+	 * Need to restore psw, pc, $r12, $r15 and $r62
+	 */
+	ldw	$r15 = PT_PSW[$r12]
+	;;
+	nop
+	;;
+	nop
+	;;
+	stw SAVED_PSW[$r0]=$r15
+	;;
+	ldw $r15 = PT_PC[$r12]  /* restore PC */
+	;;
+	nop
+	;;
+	nop
+	;;
+	stw SAVED_PC[$r0] = $r15
+	;;
+
+	ldw	$r15 = PT_R15[$r12]
+	;;
+	ldw	$r62 = PT_R62[$r12]
+	;;
+	ldw	$r12 = PT_R12[$r12]
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	rfi
+	;;
+
+	/*
+	 * Returning from a syscall which wants to restart with
+	 * restore_all.
+	 *
+	 * Nothing useful in registers, and interrupts still enabled.
+	 */
+ENTRY(syscall_exit_restore_all)
+1:	or	$r12 = $r12, 1		/* Set atomic flag */
+	mov	$r62 = 1b		/* Set roll back address */
+	;;
+	mov	$r24 = PSW_KERNEL_DEFAULT	/* Interrupts disabled */
+	;;
+	stw	SAVED_PSW[$r0] = $r24
+	mov	$r24 = 1f
+	;;
+	stw	SAVED_PC[$r0] = $r24
+	;;
+	and	$r11 = $r12, ~(THREAD_SIZE-1)
+	;;
+	mov	$r18 = $r0
+	;;
+	nop
+	;;
+	nop
+	;;
+	and	$r12 = $r12, ~1		/* clear atomic flag */
+	rfi
+	;;
+
+1:	ldw	$r20 = TI_FLAGS[$r11]
+	;;
+	nop
+	;;
+	goto	work_pending_syscall_nosave
+	;;
+
+	/*
+	 * Work needs to be done on return from syscall.
+	 *
+	 * This stores the results of the syscall into pt_regs so that
+	 * from now on we can return to user code through restore_all.
+	 *
+	 * $r11 = &thread_info
+	 * $r16 = result or error
+	 * $r17 = result2
+	 * $r20 = thread_info->flags
+	 * br0 = set if $r16 is an error
+	 *
+	 * Interrupts must be disabled.
+	 */
+work_pending_syscall:
+	ldw	$r19 = PT_R16 + STACK_SCRATCH_AREA[$r12]
+	mfb	$r18 = $b0
+	;;
+	stw	PT_R16 + STACK_SCRATCH_AREA[$r12] = $r16
+	;;
+	stw	PT_BR + STACK_SCRATCH_AREA[$r12] = $r18
+	br	$b0, work_pending_syscall_nosave
+	;;
+
+	/* We are not returning an error code, so $r17 may be valid.
+	 * Save it into pt_regs for restoring along with other registers.
+	 *
+	 * Note we cannot restart the system call in this case, so
+	 * there is no need to pass $r17 through to do_notify_resume().
+	 */
+	stw	PT_R17 + STACK_SCRATCH_AREA[$r12] = $r17
+	;;
+
+work_pending_syscall_nosave:
+	and	$r24 = $r20, _TIF_SYSCALL_TRACE
+	;;
+	cmpne	$b1 = $r24, $r0		/* $b1 = flags.TIF_SYSCALL_TRACE set */
+	;;
+	nop
+	;;
+	nop
+	;;
+	br	$b1, syscall_trace_exit
+	;;
+
+	/*
+	 * Perform work that needs to be done immediately before resumption
+	 * Context will be reloaded by restore_all.
+	 *
+	 * $r11 = &thread_info
+	 * $r18 = 1 if syscall which errored, 0 if exception or IRQ
+	 * $r19 = syscall $r16 (if $r18 == 1)
+	 * $r20 = thread_info->flags
+	 *
+	 * Interrupts should be disabled, and flags should have been loaded
+	 * with it set.
+	 */
+work_pending:
+	and	$r24 = $r20, _TIF_NEED_RESCHED
+	;;
+	cmpeq	$b1 = $r24, $r0		/* $b1 = NEED_RESCHED clear */
+	;;
+	nop
+	;;
+	nop
+	;;
+	br	$b1, work_notifysig
+	;;
+
+work_resched:
+
+	stw	16[$r12] = $r18
+	;;
+	stw	20[$r12] = $r19
+	call	$r63 = schedule
+	;;
+	ldw	$r19 = 20[$r12]
+	;;
+	ldw	$r18 = 16[$r12]
+	;;
+
+	/*
+	 * Disable interrupts, to ensure we do not miss an interrupt
+	 * setting one of the thread flags.
+	 */
+1:	or	$r12 = $r12, 1		/* Set atomic flag */
+	mov	$r62 = 1b
+	;;
+	mov	$r24 = PSW_KERNEL_DEFAULT	/* Interrupts disabled */
+	;;
+	stw	SAVED_PSW[$r0] = $r24
+	mov	$r24 = 1f
+	;;
+	stw	SAVED_PC[$r0] = $r24
+	;;
+	and	$r11 = $r12, ~(THREAD_SIZE-1)
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	and	$r12 = $r12, ~1		/* Clear atomic flag */
+	rfi
+	;;
+1:
+
+	ldw	$r20 = TI_FLAGS[$r11]
+	;;
+	nop
+	;;
+	nop
+	;;
+	and	$r20 = $r20, _TIF_WORK_MASK
+	and	$r25 = $r20, _TIF_NEED_RESCHED
+	;;
+	cmpeq	$b1 = $r20, $r0		/* $b1 = flags clear -> nothing to do */
+	cmpne	$b2 = $r25, $r0		/* $b2 = flags.TIF_NEED_RESCHED set */
+	;;
+	nop
+	;;
+	nop
+	;;
+	br	$b1, restore_all
+	;;
+	br	$b2, work_resched
+	;;
+
+	/* deal with pending signals and notify-resume requests */
+
+work_notifysig:
+
+	/* Push switch_stack */
+	add	$r12 = $r12, -SIZEOF_SWITCH_STACK
+	;;
+	save_switch_stack STACK_SCRATCH_AREA
+
+	add	$r16 = $r12, STACK_SCRATCH_AREA + SIZEOF_SWITCH_STACK
+	add	$r17 = $r12, STACK_SCRATCH_AREA
+	mov	$r21 = $r0
+	call	$r63 = do_notify_resume
+	;;
+
+	/* Restore switch_stack */
+	/* Strictly speaking, I don't need to do this, as the registers
+	 * are not usually changed by do_signal. But the one exception to
+	 * this is the signal restorer, which may use preserved registers.
+	 */
+	restore_switch_stack STACK_SCRATCH_AREA
+
+	add	$r12 = $r12, SIZEOF_SWITCH_STACK
+        goto	restore_all
+	;;
+
+	/* Trace syscall exit. */
+syscall_trace_exit:
+	mov	$r24 = PSW_INT_ENABLE|PSW_KERNEL_DEFAULT
+	;;
+	stw	SAVED_PSW[$r0] = $r24
+	mov	$r24 = 1f
+	;;
+	stw	SAVED_PC[$r0] = $r24	/* 4 bundles before rfi */
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	rfi
+	;;
+
+1:	add	$r12 = $r12, -SIZEOF_SWITCH_STACK
+	;;
+
+	save_switch_stack STACK_SCRATCH_AREA
+
+	call	$r63 = syscall_trace
+	;;
+
+	/* Reload the registers.
+	 * Note we must reload and recalculate everything, as the handler
+	 * may have modified the registers.
+	 */
+	restore_switch_stack STACK_SCRATCH_AREA
+
+	add	$r12 = $r12, SIZEOF_SWITCH_STACK
+	;;
+
+1:	or	$r12 = $r12, 1		/* Set atomic flag */
+	mov	$r62 = 1b		/* Set roll back address */
+	;;
+	mov	$r24 = PSW_KERNEL_DEFAULT	/* Interrupts disabled */
+	;;
+	stw	SAVED_PSW[$r0] = $r24
+	mov	$r24 = 1f
+	;;
+	stw	SAVED_PC[$r0] = $r24
+	;;
+	and	$r11 = $r12, ~(THREAD_SIZE-1)
+	;;
+	mov	$r18 = $r0
+	;;
+	nop
+	;;
+	nop
+	;;
+	and	$r12 = $r12, ~1		/* Clear atomic flag */
+	rfi
+	;;
+
+1:	ldw	$r20 = TI_FLAGS[$r11]
+	;;
+	nop
+	;;
+	goto	work_pending
+	;;
+
+/***********************************************************************/
+/* Data */
+
+/*
+ * These locations are accessed by every fault handler, so take care about
+ * layout to minimise cache misses.
+ */
+	.data
+	.align	32
+
+	/* This location points to the top of the current thread's supervisor stack */
+	.size	super_sp, 4
+	.globl	super_sp
+	.type	super_sp, @object
+super_sp:
+	.long	init_thread_union + THREAD_SIZE
+
+	.size	current_pgd, 4
+	.type	current_pgd, @object
+	.global current_pgd
+current_pgd:
+	.long	swapper_pg_dir
+
+	.irp	reg, 0, 1, 2, 3, 4, 5
+	.size	intsave\reg, 4
+	.type	intsave\reg, @object
+	.global	intsave\reg
+intsave\reg:
+	.long	0
+	.endr
diff --git a/arch/st200/kernel/entry-st231.S b/arch/st200/kernel/entry-st231.S
new file mode 100644
index 0000000..0b0417a
--- /dev/null
+++ b/arch/st200/kernel/entry-st231.S
@@ -0,0 +1,691 @@
+/*
+ * linux/arch/st200/kernel/entry-230.S
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Authors: Stuart Menefy <stuart.menefy@st.com>,
+ *		 David McKay <david.mckay@st.com>
+ *
+ */
+
+#include <linux/linkage.h>
+#include <asm/page.h>
+#include <asm/ctrlregdef.h>
+#include <asm/thread_info.h>
+#include <asm/pgtable.h>
+#include <asm/cache.h>
+#include <asm/asm-offsets.h>
+#include "irq_st200.h"
+#include "asm_macros.h"
+
+/* Save the struct switch_stack before entering C code */
+#define SAVE_SS		1
+
+
+/*
+ * I think the bare minimum miss handler would look like:
+ *
+ *	stw	tmp			we add 4 cycles here (check EXCAUSE first)
+ *	ldw	tmp = EXADDRESS
+ *	2*latency
+ *	shift
+ *	add
+ *	ldw
+ *	2*latency
+ *	add/check
+ *	check
+ *	ldw
+ *	2*latency
+ *	check
+ *	check				we add 2 cycles here (using branch)
+ *	3*stw	TLB_ENTRY[012]
+ *	stw	pte
+ *	4*ldw				we add 2 cycles here (using 6 registers)
+ *	nop
+ *	rte
+ *	-----				-----
+ *	26				34
+ */
+
+ENTRY(st200_trap_handler)
+	stw	intsave0[$r0] = $r24			/* s:	$r24 free */
+	mov	$r63 = $r63				/*  :	Required for SLR */
+	;;
+	ldw	$r24 = EXCAUSE[$r0]			/* :	$r24 = EXCAUSE */
+	;;
+	stw	intsave1[$r0] = $r25			/* s:	$r25 free */
+	slctf	$r25 = $b0, $r0, 1			/* s:	$b0 free */
+	;;
+	stw	intsave2[$r0] = $r26			/* s:	$r26 free */
+	mov	$r26 = EXCAUSE_ITLB | EXCAUSE_DTLB	/*  :	$r26 = cause mask */
+	;;
+	stw	intsave3[$r0] = $r27			/* s:	$r24-11 saved */
+	and	$r24 = $r24, $r26			/*  :	$r26 free */
+	cmpeq	$b0 = $r24, EXCAUSE_SYSCALL		/*  :	$b0 = SYSCALL */
+	;;
+	slctf	$r26 = $b1, $r0, 2			/* s:	$b1 free */
+	cmpne	$b1 = $r24, $r0				/*  :	$b1 = ITLB | UTLB, $r24 free */
+	ldw	$r24 = EXADDRESS[$r0]			/* 1:	$r24 = EXADDRESS */
+	;;
+	ldw	$r27 = current_pgd[$r0]			/* 1:	*/
+	or	$r25 = $r25, $r26			/* s:	$r26 free */
+	slctf	$r26 = $b2, $r0, 4			/* s:	$b2 free */
+	;;
+	or	$r25 = $r25, $r26			/* s:	$r26 free */
+	ldw	$r26 = TLB_EXCAUSE[$r0]			/* 3:	$r26 = TLB_EXCAUSE */
+	br	$b0, syscall
+	;;
+	stw	intsave4[$r0] = $r28			/* s:	$r28 now available */
+	shru	$r28 = $r24, PGDIR_SHIFT		/* 0:	$r28 = pgd offset */
+	;;
+
+	/*
+	 * This was a xTLB fault
+	 *
+	 * $r24-$r27,13 have been saved, $b0-1 have been copied to $r25
+	 *
+	 * $b0 = scratch
+	 * $b1 = scratch
+	 * $b2 = scratch
+	 * $r24 = EXADDRESS
+	 * $r25 = branch bits
+	 * $r26 = TLB_EXCAUSE (1 cycle latency)
+	 * $r27 = current_pgd
+	 * $r28 = pgd offset
+	 *
+	 * stream 0:
+	 *	calculate offset into pgd
+	 * stream 1:
+	 *	determine which pgd to use
+	 *	then load the address of the pagetable dir and check valid
+	 * stream 2:
+	 *	calculate the offset into the pte dir
+	 *	then load the pte
+	 * stream 3:
+	 *	determine the TLB cause and jump accordingly
+	 * stream 6:
+	 *	set up TLB_INDEX
+	 */
+
+	stw	intsave5[$r0] = $r29				/* s2:	$r29 free */
+	sh2add	$r27 = $r28, $r27				/* 0+1:	$r27 = pointer into pgd, $r28 free */
+	brf	$b1, 90f					/* trap_or_interrupt */
+	;;
+	ldw	$r27 = 0[$r27]					/* 1:	$r27 = pte dir */
+	and	$r28 = $r26, TLB_EXCAUSE_CAUSE_MASK		/* 3:	$r28 = TLB exception cause */
+	;;
+	ldw	$r29 = TLB_REPLACE[$r0]				/* 6:	$r29 = TLB_REPLACE */
+	shru	$r24 = $r24, PAGE_SHIFT				/* 2: */
+	cmpeq	$b0 = $r28, TLB_EXCAUSE_CAUSE_NO_MAPPING	/* 3:	$b0 = NO_MAPPING */
+	;;
+	and	$r24 = $r24, PTRS_PER_PTE-1			/* 2:	$r24 = pte offset */
+	cmpeq	$b1 = $r28, TLB_EXCAUSE_CAUSE_WRITE_TO_CLEAN	/* 3:	$b1 = WRITE TO CLEAN */
+	;;
+	sh2add	$r27 = $r24, $r27				/* 2:	$r27 = &pte, $r24 free */
+	cmpeq	$b2 = $r27, $r0					/* 1:	$b2 = pmd_none() */
+	ldw	$r24 = TLB_ASID[$r0]				/* 5a:	$r24 = TLB_ASID */
+	;;
+	mullhu	$r29 = $r29, $r29				/* 6:	*/
+	slctf	$r27 = $b2, $r27, EXCAUSE			/* 1:	Make $r27 valid */
+	;;
+	brf	$b0, 20f					/* 3:	not NO_MAPPING, $b0 free */
+	cmpeq	$b0 = $r28, TLB_EXCAUSE_CAUSE_PROT_VIOLATION	/* 3:	$b0 = PROT_VIO, $r28 free */
+	ldw	$r28 = 0[$r27]					/* 2:	$r28 = pte */
+	;;
+
+	/*
+	 * NO_MAPPING fault.
+	 * Check for pmd_none and pte_present, if OK install in TLB,
+	 * otherwise call C
+	 *
+	 * We also branch back here after a WRITE_TO_DIRTY fault, where
+	 * the entry was not un the UTLB, having set the DIRTY flag in pte.
+	 * All registers will have been reloaded to values in following list.
+	 *
+	 * Should we be setting the DIRTY bit if this is a write?
+	 *
+	 * $r24-$r27 and $r28-$r29 have been saved, $b0-2 have been copied to $r25
+	 *
+	 * $b0 = scratch
+	 * $b1 = scratch
+	 * $b2 = pmd_none()
+	 * $r24 = TLB_ASID
+	 * $r25 = branch bits
+	 * $r26 = TLB_EXCAUSE
+	 * $r27 = &pte (validity depends on $b2)
+	 * $r28 = pte (2 cycles of latency remaining, validity depends on $b2)
+	 * $r29 = TLB_REPLACE ready for storing into TLB_INDEX
+	 *
+	 * stream 4:
+	 *	determine whether pte is valid (pte_present(pte))
+	 * stream 5:
+	 *	start constructing TLB_ENTRY values
+	 *	a) $r26 TLB_ENTRY0
+	 *	b) $r29 TLB_ENTRY1
+	 *	c) $r28 TLB_ENTRY2
+	 * stream 8:
+	 *	set the PAGE_ACCESSED flag
+	 *
+	 */
+
+01:	or	$r24 = $r24, TLB_ENTRY0_EXTRABITS	/* 5a:	*/
+	br	$b2, 90f				/* 1=	pmd_none() $b2 free (1 cycle penalty here) */
+	shru	$r29 = $r29, 16				/* 6:	*/
+	;;
+	stw	TLB_INDEX[$r0] = $r29			/* 6=	$r29 free */
+	cmpltu	$b0 = $r28, 1 << _PAGE_BIT_SIZE0	/* 4:	$b0 = not present */
+	shru	$r26 = $r28, _PAGE_TLB_ENTRY0_0_SHIFT	/* 5a:	$r26 = ENTRY0_0 */
+	;;
+	and	$r26 = $r26, _PAGE_TLB_ENTRY0_0_MASK >> _PAGE_TLB_ENTRY0_0_SHIFT	/* 5a: */
+	shru	$r29 = $r28, _PAGE_TLB_ENTRY0_1_SHIFT	/* 5a:	$r29 = ENTRY0_1 */
+	;;
+	or	$r26 = $r26, $r24			/* 5a:	$r24 free */
+	ldw	$r24 = EXADDRESS[$r0]			/* 5b:	$r24 = ENTRY1 */
+	and	$r29 = $r29, _PAGE_TLB_ENTRY0_1_MASK >> _PAGE_TLB_ENTRY0_1_SHIFT	/* 5a:	 */
+	;;
+	br	$b0, 90f				/* 4=	not present */
+	or	$r26 = $r26, $r29			/* 5a:	$r26 complete, $r29 free */
+	mov	$r29 = _PAGE_ACCESSED			/* 8:   $r29 = _PAGE_ACCESSED */
+	;;
+	stw	TLB_ENTRY0[$r0] = $r26			/* 5a=	$r26 free */
+	and	$r26 = $r28, $r29			/* 8:	$r26 = pte & _PAGE_ACCESSED */
+	or	$r28 = $r28, $r29			/* 8:	pte |= _PAGE_ACCESSED, $r29 free */
+	;;
+	cmpne	$b0 = $r26, $r0				/* 8:	$b0 = pte & _PAGE_ACCESSED, $r26 free */
+	shru	$r24 = $r24, TLB_ENTRY1_VADDR_SHIFT	/* 5b:	$r24 complete */
+	ldw	$r29 = intsave5[$r0]			/* r:	 */
+	;;
+	stw	TLB_ENTRY1[$r0] = $r24			/* 5b=	$r24 free */
+	slctf	$r27 = $b0, $r27, EXADDRESS		/* 8:	black hole if _PAGE_ACCESSED set */
+	;;
+	stw	0[$r27] = $r28				/* 8=	$r27 free */
+	;;
+	stw	TLB_ENTRY2[$r0] = $r28			/* 5c=	$r28 free */
+	;;
+	ldw	$r24 = intsave0[$r0]			/* r:	 */
+	;;
+	ldw	$r28 = intsave4[$r0]			/* r:	 */
+	and	$r26 = $r25, 4				/* r:	$r26 = $b2 */
+	;;
+	ldw	$r27 = intsave3[$r0]			/* r:	 */
+	cmpne	$b2 = $r26, $r0				/* r:   $r26 free */
+	and	$r26 = $r25, 2				/* r:	$r26 = $b1 */
+	;;
+	ldw	$r26 = intsave2[$r0]			/* r:	 */
+	cmpne	$b1 = $r26, $r0				/* r:   $r26 free */
+	and	$r25 = $r25, 1				/* r:	*/
+	;;
+	ldw	$r25 = intsave1[$r0]			/* r:	 */
+	cmpne	$b0 = $r25, $r0				/* r:	$r25 free */
+	;;
+	nop
+	;;
+	rfi
+	;;
+
+	/*
+	 * xTLB fault, but not a NO_MAPPING
+	 * Assume it is a WRITE_TO_CLEAN
+	 *
+	 * We don't need to check for pte_none() in this path, as
+	 * the pte must have been valid when this entry was put into
+	 * the TLB.
+	 *
+	 * $r24-$r29 have been saved, $b0-2 have been copied to $r25
+	 *
+	 * $b0 = PROT_VIO (2 cycles latency remaining)
+	 * $b1 = WRITE_TO_CLEAN
+	 * $b2 = pmd_none()
+	 * $r24 = TLB_ASID
+	 * $r25 = branch bits
+	 * $r26 = TLB_EXCAUSE
+	 * $r27 = &pte (validity depends on $b2)
+	 * $r28 = pte (2 cycles of latency remaining, validity depends on $b2)
+	 * $r29 = TLB_REPLACE mid calculation
+	 *
+	 *
+	 * stream 20:
+	 *	branch if not WRITE_TO_CLEAN
+	 * stream 21:
+	 *	determine if we can fix up an existing UTLB entry
+	 * stream 22:
+	 *	make entry dirty
+	 * stream 23:
+	 *	assume entry not in UTLB, reload registers so we can
+	 *	jump back to the miss code.
+	 * stream 24:
+	 *	flush the DTLB
+	 * stream 25:
+	 *	fix up the existing UTLB entry
+	 */
+
+20:	brf	$b1, 30f				/* 20=	*/
+	and	$r24 = $r26, TLB_EXCAUSE_IN_UTLB	/* 21:	$r24 = TLB_EXCAUSE_IN_UTLB */
+	;;
+	cmpne	$b1 = $r24, $r0				/* 21:	$b1 = IN_UTLB, $r24 free */
+	mov	$r24 = TLB_CONTROL_DTLB_FLUSH		/* 24:	$r24 = TLB CONTROL flags */
+	;;
+	stw	TLB_CONTROL[$r0] = $r24			/* 24=	$r24 free */
+	or	$r28 = $r28, _PAGE_DIRTY|_PAGE_ACCESSED	/* 22:	*/
+	;;
+	ldw	$r24 = TLB_ASID[$r0]			/* 23:	*/
+	;;
+	stw	0[$r27] = $r28				/* 22=	(load latency for $r24) */
+	;;
+	brf	$b1, 01b				/* 21=	not in ITLB, treat as miss */
+	;;
+
+	/*
+	 * Entry in UTLB, mark dirty and continue.
+	 * $r24, $r27, $r28, $r29 free
+	 */
+
+	and	$r26 = $r26, TLB_EXCAUSE_INDEX_MASK	/* 25:	*/
+	;;
+	stw	TLB_INDEX[$r0] = $r26			/* 25:	$r26 free */
+	;;
+	ldw	$r24 = TLB_ENTRY0[$r0]			/* 25:	$r24 = ENTRY0 */
+	;;
+	ldw	$r29 = intsave5[$r0]			/* r:	*/
+	;;
+	ldw	$r28 = intsave4[$r0]			/* r:	*/
+	and	$r26 = $r25, 4				/* r:	$r26 = $b2 */
+	;;
+	or	$r24 = $r24, TLB_ENTRY0_DIRTY		/* 25:	*/
+	ldw	$r27 = intsave3[$r0]			/* r:	*/
+	;;
+	stw	TLB_ENTRY0[$r0] = $r24			/* 25:	$r24 free  */
+	cmpne	$b2 = $r26, $r0				/* r:	$r26 free */
+	and	$r26 = $r25, 2				/* r:	$r26 = $b1 */
+	;;
+	cmpne	$b1 = $r26, $r0				/* r:	$r26 free */
+	ldw	$r26 = intsave2[$r0]			/* r:	*/
+	and	$r25 = $r25, 1				/* r:	$r25 = $b0 */
+	;;
+	cmpne	$b0 = $r25, $r0				/* r:	$r25 free */
+	ldw	$r25 = intsave1[$r0]			/* r:	 */
+	;;
+	ldw	$r24 = intsave0[$r0]			/* r:	 */
+	;;
+	nop
+	;;
+	rfi
+	;;
+
+
+	/*
+	 * PROT_VIO or MULTI_MAP fault
+	 * Assume it is a PROT_VIO
+	 * Check for soft execute fix up, otherwise call C code.
+	 *
+	 * [ Note the fault could be caused by an NA/NA entry put in to fix up ]
+	 * [ spurious kernel speculation into user space. So we still have to  ]
+	 * [ validate the pte, and ignore the values in TLB_ENTRY[02].         ]
+	 *
+	 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+         * ! THE ABOVE IS NO LONGER TRUE. We do not support speculation in any way    !
+	 * ! either in user or kernel mode. Therefore this code can be optimised more.!
+	 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+	 *
+	 * And remember that while prginspg works on physical (plus hint for
+	 * cache alias which is derived from virtual), prgadd (D purge) works
+	 * on virtual addresses, so we must have a valid TLB first.
+	 *
+	 * I assume we must always have a valid UTLB entry, as the entry
+	 * must have been read from the UTLB to give this fault. (The only
+	 * circumstances in which this wouldn't happen is if we had previously
+	 * executed from the page in supervisor mode, causing it to be copied
+	 * into the ITLB, and then dropped from the UTLB. But we never do this.)
+	 *
+	 * This code runs with interrupts disabled. This could be a problem,
+	 * because writing back a full page from D cache takes a long time.
+	 * If this becomes a problem, we will need to re-enable interrupts.
+	 * And probably set up at least a partial pt_regs struct on the
+	 * supervisor stack.
+	 *
+	 * $r24-$r29 have been saved, $b0-1 have been copied to $r25
+	 *
+	 * $b0 = PROT_VIO (1 cycles latency remaining)
+	 * $b1 = scratch
+	 * $b2 = pmd_none()
+	 * $r24 = TLB_EXCAUSE_IN_UTLB
+	 * $r25 = branch bits
+	 * $r26 = TLB_EXCAUSE
+	 * $r27 = &pte (validity depends on $b2)
+	 * $r28 = pte (1 cycles of latency remaining, validity depends on $b2)
+	 * $r29 = scratch
+	 *
+	 *
+	 * stream 30:
+	 *	branch if not PROT_VIO
+	 * stream 31:
+	 *	check for soft execute and pte_present
+	 * stream 32:
+	 *	set up TLB_INDEX
+	 * stream 33:
+	 *	set page->flags.PG_arch_1
+	 */
+30:	br	$b2, 90f				/* 30:	pmd_none()->give up, $b2 free */
+	ldw	$r29 = EXCAUSENO[$r0]			/* 31:	$r29 = EXCAUSENO */
+	;;
+	brf	$b0, 90f				/* 30=	not PROT_VIO->give up, $b0 free */
+	and	$r24 = $r28, _PAGE_SOFT_USER_X | _PAGE_PROT_USER_X	| _PAGE_SIZE_MASK
+							/* 31:	$r24 = PAGE_PROT flags */
+	;;
+	cmpeq	$b0 = $r24, _PAGE_SOFT_USER_X | _PAGE_SIZE_8K
+							/* 31:	$b0 = soft exec fault, $r24 free */
+	;;
+	cmpeq	$b1 = $r29, EXCAUSENO_ITLB		/* 31:	$r29 = ITLB fault */
+	and	$r24 = $r26, TLB_EXCAUSE_INDEX_MASK	/* 32:	$r24 = TLB index, $r26 free */
+	and	$r26 = $r28, _PAGE_PADDR_MASK		/* 33:	$r26 = pfn */
+	;;
+	add	$r26 = $r26, -(ARCH_PFN_OFFSET)
+	;;
+	ldw	$r29 = mem_map[$r0]			/* 33:	$r29 = mem_map */
+	mullu	$r26 = $r26, SIZEOF_STRUCT_PAGE		/* 33: */
+	;;
+	brf	$b0, 90f				/* 31:	not soft X->give up, $b0 free */
+	stw	TLB_INDEX[$r0] = $r24			/* 32=	$r24 free */
+	;;
+	brf	$b1, 90f				/* 31=	$b1 free */
+	;;
+	add	$r29 = $r29, $r26			/* 33:	$r26 free */
+	;;
+	ldw	$r26 = STRUCT_PAGE_FLAGS[$r29]		/* 33:	$r26 = flags */
+	;;
+	nop
+	;;
+	ldw	$r24 = TLB_ASID[$r0]			/* 34a:	$r24 = TLB_ASID	 */
+	;;
+	or	$r26 = $r26, 1<<PG_arch_1
+	;;
+	stw	STRUCT_PAGE_FLAGS[$r29] = $r26		/* 33=	$r26 and $r29 free */
+	;;
+
+	/*
+	 * Set up the TLB_ENTRY[02]
+	 *
+	 * $b0 = scratch
+	 * $b1 = scratch
+	 * $r24 = TLB_ASID
+	 * $r25 = branch bits
+	 * $r26 = scratch
+	 * $r27 = &pte
+	 * $r28 = pte
+	 * $r29 = scratch
+	 *
+	 * stream 34:
+	 *	set up TLB_ENTRY
+	 *	a) $r26 ENTRY0
+	 *	b) $r28 ENTRY2
+	 * stream 35:
+	 *	Update the pte
+	 * stream 36:
+	 *	Flushed the ITLB
+	 */
+	or	$r28 = $r28, _PAGE_PROT_USER_X | _PAGE_ACCESSED	/* 35: */
+	or	$r29 = $r24, TLB_ENTRY0_EXTRABITS		/* 34a:	$r24 free */
+	;;
+	stw	0[$r27] = $r28					/* 35=	$r27 free */
+	shru	$r26 = $r28, _PAGE_TLB_ENTRY0_0_SHIFT		/* 34a:	$r26 = ENTRY0_0 */
+	;;
+	shru	$r24 = $r28, _PAGE_TLB_ENTRY0_1_SHIFT		/* 34a:	$r24 = ENTRY0_1 */
+	and	$r26 = $r26, _PAGE_TLB_ENTRY0_0_MASK >> _PAGE_TLB_ENTRY0_0_SHIFT	/* 34a: */
+	;;
+	and	$r24 = $r24, _PAGE_TLB_ENTRY0_1_MASK >> _PAGE_TLB_ENTRY0_1_SHIFT	/* 34a:	 */
+	or	$r26 = $r26, $r29				/* 34a:	$r29 free */
+	mov	$r29 = TLB_CONTROL_ITLB_FLUSH			/* 36:	$r29 = TLB CONTROL flags */
+	;;
+	or	$r26 = $r26, $r24				/* 34a:	$r26 complete, $r24 free */
+	stw	TLB_CONTROL[$r0] = $r29				/* 36=	$r29 free */
+	;;
+	stw	TLB_ENTRY0[$r0] = $r26				/* 34a=	$r26 free */
+	;;
+	stw	TLB_ENTRY2[$r0] = $r28				/* 34b= $r28 free */
+	;;
+
+	/*
+	 * Synchronise the caches
+	 *
+	 * $b0 = scratch
+	 * $b1 = scratch
+	 * $r24 = scratch
+	 * $r25 = branch bits
+	 * $r26 = scratch
+	 * $r27 = scratch
+	 * $r28 = TLB_ENTRY2 (paddr page num)
+	 * $r29 = scratch
+	 *
+	 * stream 38:
+	 *	Flush the I cache
+	 * stream 39:
+	 *	Flush the D cache
+	 */
+
+	shl	$r28 = $r28, PAGE_SHIFT				/* 38: */
+	;;
+	prginspg 0[$r28]					/* 38: */
+	;;
+	prginspg 1[$r28]					/* 38: */
+	;;
+	prginspg 2[$r28]					/* 38: */
+	;;
+	prginspg 3[$r28]					/* 38=	$r24 free */
+	;;
+
+	ldw	$r29 = EXADDRESS[$r0]				/* 39:	$r29 = vaddr */
+	;;
+	mov	$r26 = PAGE_SIZE / (L1_CACHE_BYTES * 4)		/* 39:	$r26 = loop counter */
+	;;
+	nop
+	;;
+	and	$r29 = $r29, PAGE_MASK				/* 39: */
+	;;
+31:	prgadd	(0*L1_CACHE_BYTES)[$r29]			/* 39: */
+	cmpeq	$b0 = $r26, 1					/* 39: */
+	;;
+	prgadd	(1*L1_CACHE_BYTES)[$r29]			/* 39: */
+	add	$r26 = $r26, -1					/* 39: */
+	;;
+	prgadd	(2*L1_CACHE_BYTES)[$r29]			/* 39: */
+	;;
+	prgadd	(3*L1_CACHE_BYTES)[$r29]			/* 39: */
+	brf	$b0, 31b					/* 39:*/
+	add	$r29 = $r29,4*L1_CACHE_BYTES			/* 39:*/
+	;;
+	sync							/* 39= */
+	;;
+	ldw	$r29 = intsave5[$r0]				/* r:	 */
+	;;
+	ldw	$r28 = intsave4[$r0]				/* r:	 */
+	and	$r26 = $r25, 4					/* r:	 */
+	;;
+	ldw	$r27 = intsave3[$r0]				/* r:	 */
+	cmpne	$b2 = $r26, $r0					/* r: */
+	and	$r26 = $r25, 2
+	;;
+	ldw	$r26 = intsave2[$r0]				/* r:	 */
+	cmpne	$b1 = $r26, $r0					/* r: */
+	and	$r25 = $r25, 1
+	;;
+	cmpne	$b0 = $r25, $r0					/* r:	$r25 free */
+	ldw	$r25 = intsave1[$r0]				/* r:	 */
+	;;
+	ldw	$r24 = intsave0[$r0]				/* r:	 */
+	;;
+	nop
+	;;
+	rfi
+	;;
+
+
+	/* Either:
+	 *	synchronous trap (stbus error, breakpoint, illegal, misaligned, sdi)
+	 *	interrupt
+	 *	NO_MAPPING with no pte
+	 *	PROT_VIO which is not caused by soft execute
+	 *	MULTI_MAPPING
+	 * call C fault handler
+	 *
+	 * stream 90:
+	 *	work out our new stack pointer
+	 * stream 91:
+	 *	save out branch bits
+	 * stream 92:
+	 *	handle atomic regions
+	 * stream 93:
+	 *	load and store intsave regs
+	 * stream 94:
+	 *	save other regs
+	 */
+90:	ldw	$r24 = SAVED_PSW[$r0]			/* 90:	$r24 = SAVED_PSW */
+	and	$r28 = $r12, 1				/* 92:	$r28 = in atomic region */
+	and	$r12 = $r12, ~1				/* 92: */
+	;;
+	ldw	$r29 = SAVED_PC[$r0]			/* 92:	$r29 = SAVED_PC */
+	cmpne	$b1 = $r28, $r0				/* 92:	$b1 = in atomic sequence, $r28 free */
+	;;
+	ldw	$r26 = super_sp[$r0]			/* 90:	$r26 = super_sp */
+	slctf	$r28 = $b1, $r0, (1<<8)			/* 92:	$r28 = atomic flag */
+	;;
+	and	$r27 = $r24, PSW_USER_MODE		/* 90:	$r27=user mode */
+	or	$r25 = $r25, $r28				/* 92:	$r28 free */
+	;;
+	cmpeq	$b0 = $r27, $r0				/* 90:	$b0=kernel mode, $r27 free */
+	slct	$r29 = $b1, $r62, $r29			/* 92:	$r29 = PC, $b1 free */
+	ldw	$r28 = intsave4[$r0]			/* 93:	$r28 = orig $r28 */
+	;;
+	slct	$r26 = $b0, $r12, $r26			/* 90: */
+	ldw	$r27 = intsave3[$r0]			/* 93:	$r27 = orig $r27 */
+	;;
+	add	$r26 = $r26,-SIZEOF_PT_REGS		/* 90=	drop stack */
+	stw	PT_PSW-SIZEOF_PT_REGS[$r26] = $r24	/* 93:	$r24 free */
+	;;
+	stw	PT_PC[$r26] = $r29			/* 92=	$r29 free */
+	;;
+	stw	PT_R12[$r26] = $r12			/* 94: */
+	;;
+	stw	PT_R27[$r26] = $r27			/* 93:	$r27 free */
+	;;
+	stw	PT_R28[$r26] = $r28			/* 93:	$r28 free */
+	mov	$r12 = $r26				/* 94:	$r26 free */
+	;;
+
+	/*
+	 * Now running on supervisor stack
+	 * Have saved PSW, PC, $r27-$r28
+	 * Continue saving out the intsave registers and the branch bits
+	 */
+
+	ldw	$r24 = intsave0[$r0]			/* 93:	$r24 = orig $r24 */
+	;;
+	ldw	$r27 = intsave1[$r0]			/* 93:	$r27 = orig $r25 */
+	slctf	$r28 = $b3, $r0, (1<<3)			/* 91: */
+	;;
+	ldw	$r26 = intsave2[$r0]			/* 93:	$r26 = orig $r26 */
+	slctf	$r28 = $b4, $r0, (1<<4)			/* 91:	 */
+	or	$r25 = $r25, $r28			/* 91:	 */
+	;;
+	ldw	$r29 = intsave5[$r0]			/* 93:	$r29 = orig $r29 */
+	slctf	$r28 = $b5, $r0, (1<<5)			/* 91:	 */
+	or	$r25 = $r25, $r28			/* 91:	 */
+	;;
+	stw	PT_R24[$r12] = $r24			/* 93:	$r24 free */
+	slctf	$r28 = $b6, $r0, (1<<6)			/* 91:	 */
+	or	$r25 = $r25, $r28			/* 91:	 */
+	;;
+	stw	PT_R25[$r12] = $r27			/* 93:	$r27 free */
+	slctf	$r28 = $b7, $r0, (1<<7)			/* 91:	 */
+	or	$r25 = $r25, $r28			/* 91:	 */
+	;;
+	stw	PT_R26[$r12] = $r26			/* 93:	$r26 free */
+	or	$r25 = $r25, $r28			/* 91:	 */
+	;;
+	stw	PT_R29[$r12] = $r29			/* 93:	$r29 free */
+	;;
+	stw	PT_BR[$r12] = $r25			/* 91=	$r25 free */
+	;;
+
+	/*
+	 * Have now saved PSW, PC, BR, $r24-$r29
+	 * Load up the exception related parameters, and then
+	 * enable interrupts, before saving the remainder
+	 * of the registers.
+	 */
+	ldw	$r25 = EXCAUSENO[$r0]
+	;;
+	ldw	$r24 = EXADDRESS[$r0]
+	;;
+	ldw	$r26 = TLB_EXCAUSE[$r0]
+	;;
+	stw	PT_LR[$r12] = $r63
+	sh2add	$r27 = $r25, 99f
+	;;
+	ldw	$r27 = 0[$r27]
+	;;
+	stw	PT_R15[$r12] = $r15
+	;;
+	stw	PT_R16[$r12] = $r16
+	;;
+	stw	PT_R17[$r12] = $r17
+	and	$r29 = $r27, PSW_INT_ENABLE
+	and	$r63  = $r27, ~PSW_INT_ENABLE
+	;;
+	pswset	$r29
+	and	$r27 = $r27, SAVE_SS
+	;;
+
+	cmpne	$b0 = $r27, $r0
+	/* Note this will bundle with first syllable below */
+
+	.irp	reg, 8, 9, 10, 11, \
+		18, 19, \
+		20, 21, 22, 23, \
+		30, 31, 32, 33, 34, 35, 36, 37, 38, 39, \
+		40, 41, 42, 43, 44, 45, 46, 47, 48, 49, \
+		50, 51, 52, 53, 54, 55, 56, 57, 58, 59, \
+		60, 61, 62
+	save_pt \reg
+	.endr
+
+	brf	$b0, 95f
+	mov	$r27 = ret_from_exception_no_ss
+	;;
+
+	/* Store the struct switch_stack */
+
+	add	$r12 = $r12,-SIZEOF_SWITCH_STACK
+	mov	$r27 = ret_from_exception
+	;;
+
+	save_switch_stack
+
+	/* Call the C code with the correct parameters */
+
+95:	mov	$r16 = $r25
+	mov	$r17 = $r26
+	mov	$r18 = $r24
+	;;
+	add	$r12 = $r12, -STACK_SCRATCH_AREA
+	goto	$r63
+	mov	$r63 = $r27
+	;;
+
+#define HANDLER(fn, enable, save) \
+	(fn) + (PSW_INT_ENABLE * (enable)) + (SAVE_SS * (save))
+
+	.align	32
+99:	.long	HANDLER(st200_stbus_error,		1, 1)	/*  0:	EXCAUSE_STBUS_IC_ERROR */
+	.long	HANDLER(st200_stbus_error,		1, 1)	/*  1:	EXCAUSE_STBUS_DC_ERROR */
+	.long	HANDLER(extern_int,			0, 0)	/*  2:	EXCAUSE_EXTERN_INT */
+	.long	HANDLER(st200_sbreak,			1, 1)	/*  3:	EXCAUSE_IBREAK */
+	.long	HANDLER(st200_tlb,			1, 0)	/*  4:	EXCAUSE_ITLB */
+	.long	HANDLER(st200_sbreak,			1, 1)	/*  5:	EXCAUSE_SBREAK */
+	.long	HANDLER(st200_illegal_instruction,	1, 1)	/*  6:	EXCAUSE_ILL_INST */
+	.long	HANDLER(st200_error,			1, 1)	/*  7:	EXCAUSE_SYSCALL */
+	.long	HANDLER(st200_dbreak,			1, 1)	/*  8:	EXCAUSE_DBREAK */
+	.long	HANDLER(misaligned,			0, 1)	/*  9:	EXCAUSE_MISALIGNED_TRAP */
+	.long	HANDLER(st200_creg_violation,		1, 1)	/* 10:	EXCAUSE_CREG_NO_MAPPING */
+	.long	HANDLER(st200_creg_violation,		1, 1)	/* 11:	EXCAUSE_CREG_ACCESS_VIOLATION */
+	.long	HANDLER(st200_tlb,			1, 0)	/* 12:	EXCAUSE_DTLB */
+	.long	HANDLER(st200_error,			1, 1)	/* 13:	Reserved */
+	.long	HANDLER(st200_sdi_timeout,		1, 1)	/* 14:	EXCAUSE_SDI_TIMEOUT */
diff --git a/arch/st200/kernel/head.S b/arch/st200/kernel/head.S
new file mode 100644
index 0000000..75e5e41
--- /dev/null
+++ b/arch/st200/kernel/head.S
@@ -0,0 +1,201 @@
+/*
+ * linux/arch/st200/kernel/head.S
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Authors: Stuart Menefy <stuart.menefy@st.com>,
+ *		 David McKay <david.mckay@st.com>
+ *
+ */
+
+#include <linux/linkage.h>
+#include <asm/page.h>
+#include <asm/thread_info.h>
+#include <asm/ctrlregdef.h>
+#include <asm/asm-offsets.h>
+
+/* Move this to page.h ? */
+#define PHYS_ADDR(x) ((x) - __PAGE_OFFSET + _MEMORY_PAGES)
+
+ENTRY(_runtimeversion)
+ENTRY(start)
+	/* The MMU *MUST* be OFF when we come in here */
+
+	/* Clear the micro I/D TLB's
+	 * We do this as there may be something in them if we come from a
+	 * a ROM bootstrap
+	 */
+	mov $r8 = TLB_CONTROL_ITLB_FLUSH | TLB_CONTROL_DTLB_FLUSH
+	;;
+	stw	TLB_CONTROL[$r0] = $r8
+	;;
+
+	/* Initialise the UTLB */
+	ldw $r9 = TLB_REPLACE[$r0]
+	mov $r8 = 0
+	;;
+	shru	$r9 = $r9, TLB_REPLACE_LIMIT_SHIFT
+	;;
+1:
+	stw TLB_INDEX[$r0]= $r8
+	;;
+	stw TLB_ENTRY0[$r0] = $r0
+	;;
+	stw TLB_ENTRY1[$r0] = $r0
+	;;
+	stw TLB_ENTRY2[$r0] = $r0
+	;;
+	stw TLB_ENTRY3[$r0] = $r0
+	add $r8 = $r8,1
+	;;
+	cmpeq	$b0 = $r8, $r9
+	;;
+	brf $b0,1b
+	;;
+
+
+	/* Set up the kernel ULB entry */
+	add	$r8 = $r9, -1
+	;;
+	stw	TLB_INDEX[$r0] = $r8
+	mov	$r8 =	TLB_ENTRY0_SHARED		| \
+			TLB_ENTRY0_PROT_SUPER_RWX	| \
+			TLB_ENTRY0_DIRTY		| \
+			TLB_ENTRY0_POLICY_CACHED	| \
+			TLB_ENTRY0_SIZE_256M
+	;;
+	stw	TLB_ENTRY0[$r0] = $r8
+	mov	$r8 = __PAGE_OFFSET >> TLB_ENTRY1_VADDR_SHIFT
+	;;
+	stw	TLB_ENTRY1[$r0] = $r8
+	mov	$r8 = ((CONFIG_MEMORY_START & PAGE_MASK_256M) >> TLB_ENTRY2_PADDR_SHIFT)
+	;;
+	stw	TLB_ENTRY2[$r0] = $r8
+	;;
+
+	/* Set up the SCU 
+	 * No regions initially set up. The kernel does not 
+	 * support speculative loads. Later code will set 
+	 * up at least one region
+	 */
+	mov	$r8 = 1
+	;;
+	stw	SCU_BASE0[$r0], $r8
+	;;
+	stw	SCU_BASE1[$r0], $r8
+	;;
+	stw	SCU_BASE2[$r0], $r8
+	;;
+	stw	SCU_BASE3[$r0], $r8
+	;;
+	stw	SCU_LIMIT0[$r0], $r0
+	;;
+	stw	SCU_LIMIT1[$r0], $r0
+	;;
+	stw	SCU_LIMIT2[$r0], $r0
+	;;
+	stw	SCU_LIMIT3[$r0], $r0
+	;;
+	sync
+	;;
+
+	/* Switch on MMU */
+	mov	$r8 = 1f		/* This should load the absolute virtual address */
+	;;
+	stw	SAVED_PC[$r0] = $r8
+	mov	$r8 = PSW_KERNEL_NOSPEC
+	;;
+	stw	SAVED_PSW[$r0] = $r8
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	rfi
+	;;
+1:
+
+
+	/* Initialise BSS */
+	mov	$r8 = __bss_start
+	mov	$r9 = __bss_stop
+	;;
+	goto	l2
+	;;
+l1:	stw	0[$r8] = $r0
+	add	$r8 = $r8, 4
+	;;
+l2:	cmpltu	$b0 = $r8, $r9	/* ptr < stop */
+	;;
+	nop
+	;;
+	nop
+	;;
+	br	$b0, l1
+	;;
+
+	/* Set the SP */
+	mov	$r12 = init_thread_union
+	;;
+	add	$r12 = $r12, THREAD_SIZE-STACK_SCRATCH_AREA
+	;;
+
+	/* Jump to main */
+	call	$r63 = start_kernel
+	;;
+
+	/* Should never return, but just in case... */
+1:	goto	1b
+	;;
+
+ENTRY(sim_exit)
+	/* Shuffle the arguements */
+	mov	$r17 = $r16
+	mov	$r16 = 0x1
+	goto	__dotsyscall
+	;;
+
+/*
+ * The parameter is a bitfield
+ * TRACE_OFF             0
+ * TRACE_USER_MODE       1
+ * TRACE_SUPER_MODE      2
+ * TRACE_ON  (TRACE_USER_MODE|TRACE_SUPER_MODE)
+*/
+
+ENTRY(sim_trace)
+	mov	$r17 = $r16
+	mov	$r16 = 100
+	goto	__dotsyscall
+	;;
+
+ENTRY(sim_write)
+	/* Shuffle the arguements */
+	mov	$r19 = $r18
+	mov	$r18 = $r17
+	mov	$r17 = $r16
+	mov	$r16 = 0x11
+	;;
+
+ENTRY(__dotsyscall) /* Simulator looks for this */
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	return $r63
+        ;;
+
+
+	.section .empty_zero_page,"aw"
+ENTRY(empty_zero_page)
+	.skip	PAGE_SIZE
+
+	.data
+	.align	1024
+ENTRY(swapper_pg_dir)
+	.skip	PAGE_SIZE
diff --git a/arch/st200/kernel/init_task.c b/arch/st200/kernel/init_task.c
new file mode 100644
index 0000000..5fe00d1
--- /dev/null
+++ b/arch/st200/kernel/init_task.c
@@ -0,0 +1,29 @@
+#include <linux/mm.h>
+#include <linux/mqueue.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/init_task.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+
+static struct signal_struct init_signals = INIT_SIGNALS(init_signals);
+static struct sighand_struct init_sighand = INIT_SIGHAND(init_sighand);
+
+/*
+ * Initial thread structure.
+ *
+ * We need to make sure that this is 8192-byte aligned due to the
+ * way process stacks are handled. This is done by having a special
+ * "init_task" linker map entry..
+ */
+
+union thread_union init_thread_union
+    __attribute__ ((__section__(".data.init_task"))) = {
+INIT_THREAD_INFO(init_task)};
+
+/*
+ * Initial task structure.
+ *
+ * All other task structs will be allocated on slabs in fork.c
+ */
+struct task_struct init_task = INIT_TASK(init_task);
diff --git a/arch/st200/kernel/io.c b/arch/st200/kernel/io.c
new file mode 100644
index 0000000..6fbdf08
--- /dev/null
+++ b/arch/st200/kernel/io.c
@@ -0,0 +1,167 @@
+/*
+ * I/O support routines.
+ *
+ */
+
+#include <linux/module.h>
+#include <asm/io.h>
+
+void outsb(unsigned long addr, const void *src, unsigned long count)
+{
+	int i;
+	volatile unsigned char *p = (volatile unsigned char *)src;
+
+	for (i = 0; i < count; i++) {
+		outb(p[i], addr);
+	}
+}
+
+EXPORT_SYMBOL(outsb);
+
+void outsw(unsigned long addr, const void *src, unsigned long count)
+{
+	int i;
+	volatile unsigned short *p = (volatile unsigned short *)src;
+
+	for (i = 0; i < count; i++) {
+		outw(p[i], addr);
+	}
+}
+
+EXPORT_SYMBOL(outsw);
+
+void outsl(unsigned long addr, const void *src, unsigned long count)
+{
+	int i;
+	volatile unsigned int *p = (volatile unsigned int *)src;
+	volatile unsigned blob;
+
+	for (i = 0; i < count; i++) {
+		memcpy(&blob, p + i, 4);
+		outl(blob, addr);
+	}
+}
+
+EXPORT_SYMBOL(outsl);
+
+void insb(unsigned long addr, void *dst, unsigned long count)
+{
+	int i;
+	volatile unsigned char *p = (volatile unsigned char *)dst;
+
+	for (i = 0; i < count; i++) {
+		p[i] = inb(addr);
+	}
+
+}
+
+EXPORT_SYMBOL(insb);
+
+void insw(unsigned long addr, void *dst, unsigned long count)
+{
+	int i;
+	volatile unsigned short *p = (volatile unsigned short *)dst;
+
+	for (i = 0; i < count; i++) {
+		p[i] = inw(addr);
+	}
+
+}
+
+EXPORT_SYMBOL(insw);
+
+void insl(unsigned long addr, void *dst, unsigned long count)
+{
+	int i;
+	volatile unsigned int *p = (volatile unsigned int *)dst;
+	unsigned int blob;
+
+	for (i = 0; i < count; i++) {
+		blob = inl(addr);
+		memcpy(p + i, &blob, 4);
+	}
+
+}
+
+EXPORT_SYMBOL(insl);
+
+void memcpy_fromio(void *a, unsigned long addr, int len)
+{
+	int i;
+
+	if (((long)a & 3) || (len & 3) || (addr & 3)) {
+		memcpy(a, (void *)addr, len);
+	} else {
+		unsigned *to = (unsigned *)a;
+		unsigned *from = (unsigned *)addr;
+
+		for (i = 0; i < len / 4; i++, to++, from++) {
+			*to = *from;
+		}
+	}
+}
+
+EXPORT_SYMBOL(memcpy_fromio);
+
+void memcpy_toio(unsigned long addr, void *a, int len)
+{
+	int i;
+
+	if (((long)a & 3) || (len & 3) || (addr & 3)) {
+		memcpy((void *)addr, a, len);
+	} else {
+		unsigned *to = (unsigned *)addr;
+		unsigned *from = (unsigned *)a;
+
+		for (i = 0; i < len / 4; i++, to++, from++) {
+			*to = *from;
+		}
+	}
+}
+
+EXPORT_SYMBOL(memcpy_toio);
+
+void memset_io(unsigned long addr, int c, int len)
+{
+	int i;
+
+	if ((len & 3) || (addr & 3)) {
+		memset((void *)addr, c, len);
+	} else {
+		unsigned *to = (unsigned *)addr;
+
+		for (i = 0; i < len / 4; i++, to++) {
+			*to = c;
+		}
+	}
+}
+
+EXPORT_SYMBOL(memset_io);
+
+void __raw_writesl(unsigned int addr, const void *a, int len)
+{
+	int i;
+	unsigned word;
+	volatile unsigned *from = (unsigned *)a;
+
+	for (i = 0; i < len; i++, from++) {
+		word = *from;
+		writel(word, addr);
+	}
+
+}
+
+EXPORT_SYMBOL(__raw_writesl);
+
+void __raw_readsl(unsigned int addr, const void *a, int len)
+{
+	int i;
+	unsigned word;
+	volatile unsigned *to = (unsigned *)a;
+
+	for (i = 0; i < len; i++, to++) {
+		*to = readl(addr);
+	}
+}
+
+EXPORT_SYMBOL(__raw_readsl);
diff --git a/arch/st200/kernel/irq.c b/arch/st200/kernel/irq.c
new file mode 100644
index 0000000..e819ae5
--- /dev/null
+++ b/arch/st200/kernel/irq.c
@@ -0,0 +1,103 @@
+#include <linux/module.h>
+#include <linux/seq_file.h>
+#include <linux/interrupt.h>
+#include <linux/kernel_stat.h>
+#include <linux/irq.h>
+#include <asm/uaccess.h>
+#include <asm/syscallparams.h>
+
+#ifdef CONFIG_PROC_FS
+int show_interrupts(struct seq_file *p, void *v)
+{
+	int i = *(loff_t *) v, j;
+	struct irqaction *action;
+	unsigned long flags;
+
+	if (i == 0) {
+		seq_printf(p, "           ");
+		for (j = 0; j < NR_CPUS; j++)
+			if (cpu_online(j))
+				p += seq_printf(p, "CPU%d       ", j);
+		seq_putc(p, '\n');
+	}
+
+	if (i < NR_IRQS) {
+		spin_lock_irqsave(&irq_desc[i].lock, flags);
+		action = irq_desc[i].action;
+		if (!action)
+			goto skip;
+
+		seq_printf(p, "%3d: ", i);
+#ifndef CONFIG_SMP
+		seq_printf(p, "%10u ", kstat_irqs(i));
+#else
+		for (j = 0; j < NR_CPUS; j++)
+			if (cpu_online(j))
+				p += seq_printf(p, "%10u ",
+						kstat_cpu(j).irqs[i]);
+#endif
+		seq_printf(p, " %14s", irq_desc[i].chip->name);
+		seq_printf(p, "  %s", action->name);
+
+		for (action = action->next; action; action = action->next)
+			seq_printf(p, ", %s", action->name);
+		seq_putc(p, '\n');
+skip:
+		spin_unlock_irqrestore(&irq_desc[i].lock, flags);
+	}
+
+	return 0;
+}
+
+#endif
+
+static inline void check_for_stack_overflow(void)
+{
+#ifdef CONFIG_DEBUG_STACKOVERFLOW
+	/* Debugging check for stack overflow: is there less than 1KB free? */
+	long offset;
+
+	__asm__
+	    volatile ("and %0 = $r12,%1\n":"=r" (offset):"i"(THREAD_SIZE - 1));
+
+	if (unlikely(offset < (sizeof(struct task_struct) + 1024))) {
+		printk("do_IRQ: stack overflow: %ld\n",
+		       offset - sizeof(struct task_struct));
+		dump_stack();
+	}
+#endif
+}
+
+void ack_bad_irq(unsigned int irq)
+{
+	printk("unexpected IRQ %d\n", irq);
+}
+
+asmlinkage unsigned int do_IRQ(int irq,
+			       int arg2, int arg3, int arg4,
+			       int arg5, int arg6, int arg7, int arg8,
+			       struct syscallparams params)
+{
+	struct pt_regs *regs = &params.regs;
+	struct pt_regs *old_regs = set_irq_regs(regs);
+
+	/* Hmm, we had an interrupt, but it went away when we tried to look for it
+	 * caused by the device dropping the interrupt line.
+	 */
+	if (irq == -1) {
+		printk("Spurious IRQ\n");
+		return 1;
+	}
+
+	check_for_stack_overflow();
+
+	irq_enter();
+
+	generic_handle_irq(irq);
+
+	irq_exit();
+
+	set_irq_regs(old_regs);
+
+	return 1;
+}
diff --git a/arch/st200/kernel/irq_st200.c b/arch/st200/kernel/irq_st200.c
new file mode 100644
index 0000000..090e670
--- /dev/null
+++ b/arch/st200/kernel/irq_st200.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2000 David J. Mckay (david.mckay@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/ioport.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+
+#include "irq_st200.h"
+
+void *st200_irq_base;
+
+static void disable_st200_irq(unsigned int irq)
+{
+	if (irq < 0 || irq >= NR_IRQS)
+		return;
+
+	if (irq < 32) {
+		writel(1 << irq, st200_irq_base + INTMASKCLR0);
+	} else {
+		irq -= 32;
+		writel(1 << irq, st200_irq_base + INTMASKCLR1);
+	}
+	mb();
+}
+
+static void enable_st200_irq(unsigned int irq)
+{
+
+	if (irq < 0 || irq >= NR_IRQS)
+		return;
+
+	if (irq < 32) {
+		writel(1 << irq, st200_irq_base + INTMASKSET0);
+	} else {
+		irq -= 32;
+		writel(1 << irq, st200_irq_base + INTMASKSET1);
+	}
+	mb();
+}
+
+/* This appears to be the bare minimum you can implement */
+static struct irq_chip st200_irq_controller = {
+	.name = "st200",
+	.mask = disable_st200_irq,
+	.unmask = enable_st200_irq,
+	.mask_ack = disable_st200_irq,
+};
+
+void __init init_st200_irq(unsigned long base_addr)
+{
+	int i;
+
+	if (!request_mem_region(base_addr, 1024, "Interrupt/Timers")) {
+		panic("Cannot request interrupt controller memory region\n");
+	}
+
+	st200_irq_base = ioremap(base_addr, 1024);
+
+	if (!st200_irq_base)
+		panic("Cannot map interrupt controller!!!\n");
+
+	for (i = 0; i < NR_IRQS; i++) {
+		set_irq_chip_and_handler(i, &st200_irq_controller,
+					 handle_level_irq);
+	}
+}
diff --git a/arch/st200/kernel/irq_st200.h b/arch/st200/kernel/irq_st200.h
new file mode 100644
index 0000000..87ebc9f
--- /dev/null
+++ b/arch/st200/kernel/irq_st200.h
@@ -0,0 +1,26 @@
+#ifndef _IRQ_ST200_H
+#define _IRQ_ST200_H
+
+#define INTCR_BASE  0x0000	/* Offset from PERIPHERIAL_BASE */
+
+#define INTPENDING0 0x0000	// Interrupt pending bits 31:0.
+#define INTPENDING1 0x0008	// Interrupt pending bits 63:32.
+#define INTMASK0    0x0010	// Interrupt mask bits 31:0.
+#define INTMASK1    0x0018	// Interrupt mask bits 63:32.
+#define INTTEST0    0x0020	// Interrupt test register bits 31:0.
+#define INTTEST1    0x0028	// Interrupt test register bits 63:32.
+#define INTCLR0     0x0030	// Interrupt clear register bits 31:0.
+#define INTCLR1     0x0038	// Interrupt clear register bits 63:32.
+#define INTSET0     0x0040	// Interrupt set register bits 31:0.
+#define INTSET1     0x0048	// Interrupt clear register bits 63:32.
+
+#define INTMASKCLR0 0x0108	// Interrupt mask clear bits 31:0.
+#define INTMASKCLR1 0x0110	// Interrupt mask clear bits 63:32.
+#define INTMASKSET0 0x0118	// Interrupt mask set bits 31:0.
+#define INTMASKSET1 0x0120	// Interrupt mask set bits 63:32.
+
+#ifndef __ASSEMBLY__
+extern void *st200_irq_base;
+#endif /* !__ASSEMBLY__ */
+
+#endif
diff --git a/arch/st200/kernel/module.c b/arch/st200/kernel/module.c
new file mode 100644
index 0000000..a34d254
--- /dev/null
+++ b/arch/st200/kernel/module.c
@@ -0,0 +1,324 @@
+/* -*- linux-c -*-
+ *  arch/st200/kernel/module.c - Kernel module help for st200.
+ *
+ *  st200 version
+ *    Copyright (C) 2004 STMicroelectronics
+ *    Author(s): Antonio Borneo (antonio.borneo@st.com)
+ *
+ *  based on i386 and on parisc versions
+ *    Copyright (C) 2001 Rusty Russell
+ *    Copyright (C) 2003 Randolph Chung <tausq@debian.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/moduleloader.h>
+#include <linux/elf.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+
+#if 0
+#define DEBUGP printk
+#else
+#define DEBUGP(fmt...)
+#endif
+
+#if defined(CONFIG_CPU_SUBTYPE_ST231)
+#define STUB_LEN 5
+#else
+#error Unknown CPU sub-type
+#endif
+
+struct stub_entry {
+	Elf32_Word insns[STUB_LEN];
+};
+
+#define STUB_ENTRY_SIZE sizeof(struct stub_entry)
+
+/*
+00000000 <stub_even>:
+   0:   15800000
+   4:   08000fc0     c0 mov $r0.63 = <val>
+   8:   80009fc0     c0 mov $r0.9 = $r0.63;;
+   c:   80000000     c0 nop ;;
+  10:   80000000     c0 nop ;;
+  14:   31800000     c0 goto $r0.63
+  18:   8003f240     c0 mov $r0.63 = $r0.9;;
+
+0000001c <stub_odd>:
+  1c:   08000fc0     c0 mov $r0.63 = <val>
+  20:   15000000
+  24:   80009fc0     c0 mov $r0.9 = $r0.63;;
+  28:   80000000     c0 nop ;;
+  2c:   80000000     c0 nop ;;
+  30:   31800000     c0 goto $r0.63
+  34:   8003f240     c0 mov $r0.63 = $r0.9;;
+*/
+
+static inline void fill_stub(struct stub_entry *s, unsigned long add)
+{
+	int i = 0;
+	unsigned long l, h;
+
+	h = (add >> 9) & 0x7fffff;
+	l = (add << 12) & 0x1ff000;
+
+	if (((int)s->insns) & 4) {
+		DEBUGP("in fill_stub() odd\n");
+		/* not 8 bytes aligned */
+		s->insns[i++] = 0x08000fc0 | l;	/* mov $r0.63 = <add>   */
+		s->insns[i++] = 0x15000000 | h;	/* long imm             */
+	} else {
+		DEBUGP("in fill_stub() even\n");
+		/* 8 bytes aligned */
+		s->insns[i++] = 0x15800000 | h;	/* long imm             */
+		s->insns[i++] = 0x08000fc0 | l;	/* mov $r0.63 = <add>   */
+	}
+	s->insns[i++] = 0x80009fc0;	/* mov $r0.9 = $r0.63;; */
+	s->insns[i++] = 0x31800000;	/* return $r0.63        */
+	s->insns[i++] = 0x8003f240;	/* mov $r0.63 = $r0.9;; */
+}
+
+#define CHECK_RELOC(val, bits) \
+	if ( ( !((val) & (1<<((bits)-1))) && ((val)>>(bits)) != 0 )  ||	\
+	     ( ((val) & (1<<((bits)-1))) && ((val)>>(bits)) != (((__typeof__(val))(~0))>>((bits)+2)))) { \
+		printk(KERN_ERR "module %s relocation of symbol %s is out of range (0x%lx in %d bits)\n", \
+		me->name, strtab + sym->st_name, (unsigned long)val, bits); \
+		return -ENOEXEC;			\
+	}
+
+static inline int is_init(struct module *me, void *loc)
+{
+	return (loc >= me->module_init &&
+		loc <= (me->module_init + me->init_size));
+}
+
+void *module_alloc(unsigned long size)
+{
+	if (size == 0)
+		return NULL;
+	return vmalloc(size);
+}
+
+/* Free memory returned from module_alloc */
+void module_free(struct module *mod, void *module_region)
+{
+	vfree(module_region);
+	/* FIXME: If module_region == mod->init_region, trim exception
+	   table entries. */
+}
+
+/* Have we already seen one of these relocations? */
+/* FIXME: we could look in other sections, too --RR */
+static int duplicate_reloc(const Elf32_Rela * rela, unsigned int num)
+{
+	unsigned int i;
+
+	for (i = 0; i < num; i++) {
+		if (rela[i].r_info == rela[num].r_info &&
+		    rela[i].r_addend == rela[num].r_addend)
+			return 1;
+	}
+	return 0;
+}
+
+/* Count how many stubs entries we may need */
+static unsigned long count_stubs(const Elf32_Rela * rela, unsigned long num)
+{
+	unsigned int i, ret = 0;
+
+	/* Sure, this is order(n^2), but it's usually short, and not
+	   time critical */
+	for (i = 0; i < num; i++) {
+		switch (ELF32_R_TYPE(rela[i].r_info)) {
+		case R_LX_23_PCREL:
+			if (!duplicate_reloc(rela, i))
+				ret++;
+			break;
+		}
+	}
+	return ret;
+}
+
+int module_frob_arch_sections(Elf_Ehdr * hdr,
+			      Elf_Shdr * sechdrs,
+			      char *secstrings, struct module *me)
+{
+	unsigned long stubs = 0, init_stubs = 0;
+	unsigned int i;
+
+	DEBUGP("in module_frob_arch_sections()\n");
+	for (i = 1; i < hdr->e_shnum; i++) {
+		const Elf32_Rela *rels = (void *)hdr + sechdrs[i].sh_offset;
+		unsigned long nrels = sechdrs[i].sh_size / sizeof(*rels), s;
+
+		if (sechdrs[i].sh_type != SHT_RELA)
+			continue;
+
+		s = count_stubs(rels, nrels);
+		if (strncmp(secstrings + sechdrs[i].sh_name,
+			    ".rela.init", 10) == 0)
+			init_stubs += s;
+		else
+			stubs += s;
+	}
+
+	/* align things a bit */
+	me->core_size = ALIGN(me->core_size, 8);
+	me->arch.stub_offset = me->core_size;
+	me->core_size += stubs * STUB_ENTRY_SIZE;
+
+	me->init_size = ALIGN(me->init_size, 8);
+	me->arch.init_stub_offset = me->init_size;
+	me->init_size += init_stubs * STUB_ENTRY_SIZE;
+
+	me->arch.stub_max = stubs;
+	me->arch.init_stub_max = init_stubs;
+
+	DEBUGP("added %ld stubs and %ld init_stubs\n", stubs, init_stubs);
+	return 0;
+}
+
+static Elf32_Addr get_stub(struct module *me, unsigned long val, long addend,
+			   int init_section)
+{
+	unsigned long i, j, value;
+	struct stub_entry *stub;
+	void *stubs;
+
+	if (init_section) {
+		i = me->arch.init_stub_count;
+		BUG_ON(me->arch.init_stub_count > me->arch.init_stub_max);
+		stubs = me->module_init + me->arch.init_stub_offset;
+	} else {
+		i = me->arch.stub_count;
+		BUG_ON(me->arch.stub_count > me->arch.stub_max);
+		stubs = me->module_core + me->arch.stub_offset;
+	}
+
+	/* Look for existing stub entry. */
+	for (j = 0; j < i; j++) {
+		Elf32_Word insn0, insn1;
+		unsigned long l, h, add;
+
+		stub = stubs + j * STUB_ENTRY_SIZE;
+		insn0 = stub->insns[0];
+		insn1 = stub->insns[1];
+		add = (unsigned long)stub->insns;
+		h = (((add & 4) ? insn1 : insn0) & 0x7fffff) << 9;
+		l = (((add & 4) ? insn0 : insn1) & 0x1ff000) >> 12;
+		value = l | h;
+		if (value == val + addend)
+			goto found;
+	}
+
+	stub = stubs + i * STUB_ENTRY_SIZE;
+	if (init_section)
+		++me->arch.init_stub_count;
+	else
+		++me->arch.stub_count;
+
+	fill_stub(stub, val + addend);
+
+found:
+	DEBUGP("stub placed in 0x%08x\n", (int)stub);
+	return (Elf32_Addr) stub;
+}
+
+int apply_relocate(Elf32_Shdr * sechdrs,
+		   const char *strtab,
+		   unsigned int symindex,
+		   unsigned int relsec, struct module *me)
+{
+	/* st200 should not need this ... */
+	printk(KERN_ERR "module %s: RELOCATION unsupported\n", me->name);
+	return -ENOEXEC;
+}
+
+int apply_relocate_add(Elf32_Shdr * sechdrs,
+		       const char *strtab,
+		       unsigned int symindex,
+		       unsigned int relsec, struct module *me)
+{
+	unsigned int i;
+	Elf32_Rela *rel = (void *)sechdrs[relsec].sh_addr;
+	Elf32_Sym *sym;
+	Elf32_Word *loc32;
+	Elf32_Addr val, dot;
+	Elf32_Sword addend;
+
+	DEBUGP("Applying relocate section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		/* This is where to make the change */
+		loc32 = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+		    + rel[i].r_offset;
+		/* This is the symbol it is referring to.  Note that all
+		   undefined symbols have been resolved.  */
+		sym = (Elf32_Sym *) sechdrs[symindex].sh_addr
+		    + ELF32_R_SYM(rel[i].r_info);
+		val = sym->st_value;
+		addend = rel[i].r_addend;
+		dot = (Elf32_Addr) loc32 & ~0x03;
+		DEBUGP("> loc32    = 0x%08x\n"
+		       "> value    = 0x%08x\n"
+		       "> addend   = 0x%08x\n"
+		       "> val+add  = 0x%08x\n"
+		       "> *loc32   = 0x%08x\n",
+		       (int)loc32, val, addend, val + addend, *loc32);
+
+		switch (ELF32_R_TYPE(rel[i].r_info)) {
+		case R_LX_32:
+			*loc32 = val + addend;
+			break;
+
+		case R_LX_23_PCREL:
+			/* 23-bit PC relative address */
+			val = get_stub(me, val, addend, is_init(me, loc32));
+			val = (val - dot) / 4;
+			CHECK_RELOC(val, 23)
+			    * loc32 = (*loc32 & ~0x7fffff) | (val & 0x7fffff);
+			break;
+
+		case R_LX_HI23:
+			*loc32 = (*loc32 & ~0x7fffff) |
+			    (((val + addend) >> 9) & 0x7fffff);
+			break;
+
+		case R_LX_LO9:
+			*loc32 = (*loc32 & ~0x1ff000) |
+			    (((val + addend) << 12) & 0x1ff000);
+			break;
+
+		default:
+			printk(KERN_ERR "module %s: Unknown relocation: %u\n",
+			       me->name, ELF32_R_TYPE(rel[i].r_info));
+			return -ENOEXEC;
+		}
+		DEBUGP("> *loc32++ = 0x%08x\n", *loc32);
+	}
+	return 0;
+}
+
+int module_finalize(const Elf_Ehdr * hdr,
+		    const Elf_Shdr * sechdrs, struct module *me)
+{
+	return 0;
+}
+
+void module_arch_cleanup(struct module *mod)
+{
+}
diff --git a/arch/st200/kernel/process.c b/arch/st200/kernel/process.c
new file mode 100644
index 0000000..1fc0c71
--- /dev/null
+++ b/arch/st200/kernel/process.c
@@ -0,0 +1,230 @@
+/*
+ * linux/arch/st200/kernel/process.c
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+
+#include <asm/uaccess.h>
+#include <asm/processor.h>
+#include <linux/err.h>
+#include <asm/ctrlregdef.h>
+#include <linux/mman.h>
+#include <asm/syscallparams.h>
+
+void (*pm_power_off) (void) = NULL;
+EXPORT_SYMBOL(pm_power_off);
+
+/*
+ * Powermanagement idle function, if any..
+ */
+void (*pm_idle) (void);
+
+/*
+ * We use this if we don't have any better
+ * idle routine..
+ */
+void default_idle(void)
+{
+	/* We have to actually come out of the idle loop when
+	 * we take an interrupt. The idle instruction is actually
+	 * a goto 0, so unless we do something we will sleep forever.
+	 * Fortunately, the rollback mechanism fixes this, as if we
+	 * interrupt we restart after the idle, and all is well.
+	 * This also fixes the silicon bug GNBvd64499, whereby you have
+	 * to do a sync before idle to avoid possible illegal stbus behaviour.
+	 * It ensures that the sync and idle are executed atomically, or if
+	 * interrupted the idle is not executed.
+	 */
+	asm volatile ("mov $r62 = 1f \n"
+		      "or $r12 = $r12,1 \n"
+		      "sync \n"
+		      ";; \n"
+		      "idle \n"
+		      ";; \n"
+		      "1: and $r12 = $r12, ~1 \n"
+		      : /* No output */ : /* No input */ : "r62");
+}
+
+/*
+ * The idle thread. There's no useful work to be
+ * done, so just try to conserve power and have a
+ * low exit latency (ie sit in a loop waiting for
+ * somebody to say that they'd like to reschedule)
+ */
+void cpu_idle(void)
+{
+	/* endless idle loop with no priority at all */
+	while (1) {
+		void (*idle) (void) = pm_idle;
+		if (!idle)
+			idle = default_idle;
+		while (!need_resched())
+			idle();
+		schedule();
+	}
+}
+
+/*
+ * Create a kernel thread
+ */
+int kernel_thread(int (*fn) (void *), void *arg, unsigned long flags)
+{
+	/* This forms the data structure which copy_thread expects */
+	struct {
+		struct switch_stack ss;
+		struct pt_regs regs;
+	} regs_ss;
+	struct pt_regs *regs = &regs_ss.regs;
+
+	void kernel_thread_helper(void);
+
+	memset(&regs_ss, 0, sizeof(regs_ss));
+	regs_ss.ss.r1 = (unsigned long)arg;
+	regs->lr = (unsigned long)fn;
+	regs->pc = (unsigned long)kernel_thread_helper;
+	regs->psw = PSW_INT_ENABLE | PSW_KERNEL_DEFAULT;
+	/* Ok, create the new process.. */
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, regs, 0, NULL,
+		       NULL);
+}
+
+/*
+ * Free current thread data structures etc..
+ */
+void exit_thread(void)
+{
+
+}
+
+void flush_thread(void)
+{
+}
+
+void release_thread(struct task_struct *dead_task)
+{
+}
+
+#warning "get_wchan IS NOT FULLY IMPLEMENTED"
+
+/*LXFIXME: THIS IS NOT COMPLETE */
+unsigned long get_wchan(struct task_struct *p)
+{
+	unsigned long pc;
+
+	pc = thread_saved_pc(p);
+
+	return pc;
+}
+
+/*
+ * We assumne that this is always called as a result of a fork, vfork or
+ * clone system call. In this case, immediatly below regs is a struct switch_stack,
+ * which we copy onto the new thread's stack, ready for switch_to to load from.
+ */
+int copy_thread(unsigned long clone_flags, unsigned long sp,
+		unsigned long unused,
+		struct task_struct *p, struct pt_regs *regs)
+{
+	struct pt_regs *childregs;
+	struct task_struct *tsk;
+	struct switch_stack *childstack, *stack;
+	asmlinkage void ret_from_fork(void);
+
+	//printk("copy_thread: task_struct %08x\n", p);
+	childregs =
+	    ((struct pt_regs *)(THREAD_SIZE +
+				(unsigned long)task_stack_page(p))) - 1;
+	*childregs = *regs;
+	if (user_mode(regs)) {
+		childregs->r12 = sp;
+	} else {
+		/* API gives called function a 16 byte scratch area */
+		/* but it must also be 32 byte aligned */
+		childregs->r12 =
+		    THREAD_SIZE + (unsigned long)(task_stack_page(p)) - 32;
+	}
+
+	stack = ((struct switch_stack *)regs) - 1;
+	childstack = ((struct switch_stack *)childregs) - 1;
+	childstack = (struct switch_stack *)((unsigned int)childstack - 32);	/* scratch area */
+	*childstack = *stack;
+
+	p->thread.sp = (unsigned long)childstack;
+	p->thread.pc = (unsigned long)ret_from_fork;
+
+	p->thread.flags = 0;
+
+	tsk = current;
+
+	/*
+	 * Set a new TLS for the child thread?
+	 */
+	if (clone_flags & CLONE_SETTLS) {
+		childstack->r13 = childregs->r20;
+	}
+	return 0;
+}
+
+/* Used by sysrq-p, among others. struct switch_stack is not available */
+void show_regs(struct pt_regs *regs)
+{
+	st200_show_regs(regs, NULL);
+	st200_show_stack_trace((unsigned long *) regs->r12);
+}
+
+void start_thread(struct pt_regs *regs, unsigned long pc, unsigned long sp)
+{
+	set_fs(USER_DS);
+	regs->r12 = sp;
+	regs->lr = 0;
+	regs->psw = PSW_USER_DEFAULT | PSW_INT_ENABLE;
+	regs->pc = pc;
+}
+
+asmlinkage int
+st200_clone(unsigned long clone_flags, unsigned long newsp,
+	    int __user * parent_tidptr, int __user * child_tidptr,
+	    unsigned long tls_value, int arg6, int arg7, int arg8,
+	    struct syscallparams_ss params)
+{
+	struct pt_regs *regs = &params.regs;
+
+#ifdef DEBUG
+	printk("sys_clone: pc %08x, psw %08x, r12 %08x\n", regs->pc, regs->psw,
+	       regs->r12);
+	printk("sys_clone: flags %08x newsp %08x\n", clone_flags, newsp);
+	printk("sys_clone: warning - no tid ID parameters yet!\n");
+#endif
+
+	if (newsp == 0)
+		newsp = regs->r12;
+
+	return do_fork(clone_flags, newsp, regs, 0, parent_tidptr,
+		       child_tidptr);
+}
+
+int sys_execve(char *name, char **argv, char **envp,
+	       int arg4,
+	       int arg5, int arg6, int arg7, int arg8,
+	       struct syscallparams syscallparams)
+{
+	char *filename = getname(name);
+	int error = PTR_ERR(filename);
+	struct pt_regs *regs = &syscallparams.regs;
+
+	if (!IS_ERR(filename)) {
+		error = do_execve(filename, argv, envp, regs);
+		putname(filename);
+	}
+
+	return error;
+}
diff --git a/arch/st200/kernel/ptrace.c b/arch/st200/kernel/ptrace.c
new file mode 100644
index 0000000..829430f
--- /dev/null
+++ b/arch/st200/kernel/ptrace.c
@@ -0,0 +1,392 @@
+/*
+ * linux/arch/st200/kernel/ptrace.c
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/ptrace.h>
+#include <linux/user.h>
+#include <linux/slab.h>
+#include <linux/security.h>
+
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+#include <asm/debugregs.h>
+
+#include "ptrace.h"
+
+#define DEBUG   (DBG_MEM | DBG_BPT | DBG_MEM_ALL)
+#undef DEBUG
+
+#ifdef DEBUG
+enum {
+	DBG_MEM = (1 << 0),
+	DBG_BPT = (1 << 1),
+	DBG_MEM_ALL = (1 << 2)
+};
+#define DBG(fac,args)	{if ((fac) & DEBUG) printk args;}
+#else
+#define DBG(fac,args)
+#endif
+
+/*
+ * The following table maps a register index into the stack offset at
+ * which the register is saved.  Register indices are defined in
+ * asm-st200/ptrace.h (PT_R0 etc). Note that R0 and the branch bits
+ * are special cases.
+ */
+#define PT_REG(reg) \
+	(THREAD_SIZE - sizeof(struct pt_regs) \
+	 + offsetof(struct pt_regs, reg))
+
+#define SW_REG(reg) \
+	(THREAD_SIZE - sizeof(struct pt_regs) - sizeof(struct switch_stack) \
+	 + offsetof(struct switch_stack, reg))
+
+static int regoff[] = {
+	PT_REG(pc), PT_REG(psw),
+	/* $r0 */ -1, SW_REG(r1), SW_REG(r2), SW_REG(r3),
+	SW_REG(r4), SW_REG(r5), SW_REG(r6), SW_REG(r7),
+	PT_REG(r8), PT_REG(r9), PT_REG(r10), PT_REG(r11),
+	PT_REG(r12), SW_REG(r13), SW_REG(r14), PT_REG(r15),
+	PT_REG(r16), PT_REG(r17), PT_REG(r18), PT_REG(r19),
+	PT_REG(r20), PT_REG(r21), PT_REG(r22), PT_REG(r23),
+	PT_REG(r24), PT_REG(r25), PT_REG(r26), PT_REG(r27),
+	PT_REG(r28), PT_REG(r29), PT_REG(r30), PT_REG(r31),
+	PT_REG(r32), PT_REG(r33), PT_REG(r34), PT_REG(r35),
+	PT_REG(r36), PT_REG(r37), PT_REG(r38), PT_REG(r39),
+	PT_REG(r40), PT_REG(r41), PT_REG(r42), PT_REG(r43),
+	PT_REG(r44), PT_REG(r45), PT_REG(r46), PT_REG(r47),
+	PT_REG(r48), PT_REG(r49), PT_REG(r50), PT_REG(r51),
+	PT_REG(r52), PT_REG(r53), PT_REG(r54), PT_REG(r55),
+	PT_REG(r56), PT_REG(r57), PT_REG(r58), PT_REG(r59),
+	PT_REG(r60), PT_REG(r61), PT_REG(r62), PT_REG(lr),
+	PT_REG(br), PT_REG(br), PT_REG(br), PT_REG(br),
+	PT_REG(br), PT_REG(br), PT_REG(br), PT_REG(br)
+};
+
+#define THREAD_REG(reg) \
+	(offsetof(struct thread_struct, reg))
+
+static int thread_regoff[] = {
+	THREAD_REG(debug.dbreak_control),
+	THREAD_REG(debug.dbreak_lower),
+	THREAD_REG(debug.dbreak_upper),
+	THREAD_REG(debug.ibreak_control),
+	THREAD_REG(debug.ibreak_lower),
+	THREAD_REG(debug.ibreak_upper),
+	THREAD_REG(trace.trace),
+};
+
+#define PTRACE_PSW_MASK (PSW_DBREAK_ENABLE| PSW_IBREAK_ENABLE)
+
+static unsigned long zero = 0;
+
+/*
+ * Get address of register REGNO in task TASK.
+ * This doesn't special case the branch registers.
+ */
+static unsigned long *get_reg_addr(struct task_struct *task,
+				   unsigned long regno)
+{
+	unsigned long *addr;
+
+	if ((regno >= PT_DEBUG(0)) && (regno <= PT_TRACE)) {
+		if (!
+		    (task->thread.
+		     flags & (ST200_THREAD_DEBUG_VALID |
+			      ST200_THREAD_TRACE_VALID))) {
+			memset(&task->thread.debug, 0,
+			       sizeof(task->thread.debug));
+			memset(&task->thread.trace, 0,
+			       sizeof(task->thread.trace));
+		}
+		if (regno == PT_TRACE) {
+			task->thread.flags |= ST200_THREAD_TRACE_VALID;
+		} else {
+			task->thread.flags |= ST200_THREAD_DEBUG_VALID;
+		}
+		regno -= PT_DEBUG(0);
+		addr =
+		    (unsigned long *)((unsigned long)&task->thread +
+				      thread_regoff[regno]);
+	} else if (regno == PT_R0 || regno >= PT_DEBUG(0)) {
+		addr = &zero;
+	} else {
+		addr =
+		    (unsigned long *)((unsigned long)(task_stack_page(task)) +
+				      regoff[regno]);
+	}
+	return addr;
+}
+
+/*
+ * Get contents of register REGNO in task TASK.
+ */
+static long get_reg(struct task_struct *task, unsigned long regno)
+{
+	unsigned long reg = *get_reg_addr(task, regno);
+	if ((regno >= PT_B(0)) && (regno <= PT_B(7))) {
+		reg = (reg >> (regno - PT_B(0))) & 1;
+	}
+	return reg;
+}
+
+/*
+ * Write contents of register REGNO in task TASK.
+ */
+static int put_reg(struct task_struct *task, unsigned long regno, long data)
+{
+	if ((regno >= PT_B(0)) && (regno <= PT_B(7))) {
+		unsigned long br = *get_reg_addr(task, regno);
+		unsigned long i = regno - PT_B(0);
+		data = (br & (~(1 << i))) | ((data & 1) << i);
+	}
+
+	/* The user is not allowed to change arbitrary bits in the PSW */
+	if (regno == PT_PSW) {
+		unsigned long psw =
+		    (*get_reg_addr(task, PT_PSW)) & ~PTRACE_PSW_MASK;
+
+		data = psw | (data & PTRACE_PSW_MASK);
+	}
+
+	/* Cannot write to $r0 */
+	if (regno != PT_R(0)) {
+		*get_reg_addr(task, regno) = data;
+	}
+	return 0;
+}
+
+static inline int
+read_int(struct task_struct *task, unsigned long addr, int *data)
+{
+	int copied = access_process_vm(task, addr, data, sizeof(int), 0);
+	return (copied == sizeof(int)) ? 0 : -EIO;
+}
+
+static inline int
+write_int(struct task_struct *task, unsigned long addr, int data)
+{
+	int copied = access_process_vm(task, addr, &data, sizeof(int), 1);
+	return (copied == sizeof(int)) ? 0 : -EIO;
+}
+
+void ptrace_set_step(struct task_struct *child)
+{
+	unsigned long pc, psw;
+
+	pc = get_reg(child, PT_PC);
+	put_reg(child, PT_DEBUG(DR_IBREAK_CONTROL), DR_BRK_OUT_RANGE);
+	put_reg(child, PT_DEBUG(DR_IBREAK_LOWER), pc);
+	put_reg(child, PT_DEBUG(DR_IBREAK_UPPER), pc);
+
+	psw = get_reg(child, PT_PSW);
+	put_reg(child, PT_PSW, psw | PSW_IBREAK_ENABLE);
+}
+
+void ptrace_cancel_step(struct task_struct *child)
+{
+	unsigned long psw;
+
+	/* This needs updating when we support hardware watchpoints */
+	put_reg(child, PT_DEBUG(DR_IBREAK_CONTROL), 0);
+	child->thread.flags &= ~ST200_THREAD_DEBUG_VALID;
+
+	psw = get_reg(child, PT_PSW);
+	put_reg(child, PT_PSW, psw & ~PSW_IBREAK_ENABLE);
+}
+
+/*
+ * Called by kernel/ptrace.c when detaching..
+ *
+ * Make sure single step is not active.
+ */
+void ptrace_disable(struct task_struct *child)
+{
+	ptrace_cancel_step(child);
+}
+
+asmlinkage long arch_ptrace(struct task_struct *child, long request, long addr,
+			    long data)
+{
+	unsigned long tmp;
+	size_t copied;
+	long ret;
+	unsigned long __user *datap = (unsigned long __user *)data;
+	int i;
+
+	switch (request) {
+	case PTRACE_PEEKTEXT:	/* read word at location addr. */
+	case PTRACE_PEEKDATA:
+		copied = access_process_vm(child, addr, &tmp, sizeof(tmp), 0);
+		ret = -EIO;
+		if (copied != sizeof(tmp))
+			break;
+
+		force_successful_syscall_return();
+		ret = tmp;
+		break;
+
+		/* Read register number ADDR. */
+	case PTRACE_PEEKUSR:
+		force_successful_syscall_return();
+		ret = get_reg(child, addr);
+		DBG(DBG_MEM, ("peek $%ld->%#lx\n", addr, ret));
+		break;
+
+	case PTRACE_POKETEXT:	/* write the word at location addr. */
+	case PTRACE_POKEDATA:
+		tmp = data;
+		copied = access_process_vm(child, addr, &tmp, sizeof(tmp), 1);
+		ret = (copied == sizeof(tmp)) ? 0 : -EIO;
+		break;
+
+	case PTRACE_POKEUSR:	/* write the specified register */
+		DBG(DBG_MEM, ("poke $%ld<-%#lx\n", addr, data));
+		ret = put_reg(child, addr, data);
+		break;
+
+	case PTRACE_SYSCALL:
+		/* continue and stop at next (return from) syscall */
+	case PTRACE_CONT:	/* restart after signal. */
+		ret = -EIO;
+		if ((unsigned long)data > _NSIG)
+			break;
+		if (request == PTRACE_SYSCALL)
+			set_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+		else
+			clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+		child->exit_code = data;
+		/* make sure single-step is disabled. */
+		ptrace_cancel_step(child);
+		wake_up_process(child);
+		ret = 0;
+		break;
+
+		/*
+		 * Make the child exit.  Best I can do is send it a sigkill.
+		 * perhaps it should be put in the status that it wants to
+		 * exit.
+		 */
+	case PTRACE_KILL:
+		ret = 0;
+		if (child->exit_state == EXIT_ZOMBIE)
+			break;
+		child->exit_code = SIGKILL;
+		/* make sure single-step is disabled */
+		ptrace_cancel_step(child);
+		wake_up_process(child);
+		break;
+
+	case PTRACE_SINGLESTEP:	/* execute single instruction. */
+		ret = -EIO;
+		if ((unsigned long)data > _NSIG)
+			break;
+		if ((child->thread.flags & ST200_THREAD_DEBUG_VALID) &&
+		    (child->thread.debug.ibreak_control != 0))
+			break;
+
+		ptrace_set_step(child);
+		clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+
+		wake_up_process(child);
+		child->exit_code = data;
+		/* give it a chance to run. */
+		ret = 0;
+		break;
+
+	case PTRACE_DETACH:	/* detach a process that was attached. */
+		ret = ptrace_detach(child, data);
+		break;
+
+	case PTRACE_GETREGS:	/* Get all gp regs from the child */
+		if (!access_ok(VERIFY_WRITE, datap, PT_GP_NREGS * sizeof(long))) {
+			ret = -EIO;
+			break;
+		}
+		for (i = 0; i < PT_GP_NREGS; i++) {
+			__put_user(get_reg(child, i), datap);
+			datap++;
+		}
+		ret = 0;
+		break;
+
+	case PTRACE_SETREGS:{	/* Set all gp regs in the child. */
+			unsigned long tmp;
+
+			if (!access_ok
+			    (VERIFY_READ, datap, PT_GP_NREGS * sizeof(long))) {
+				ret = -EIO;
+				break;
+			}
+			for (i = 0; i < PT_GP_NREGS; i++) {
+				__get_user(tmp, datap);
+				put_reg(child, i, tmp);
+				datap++;
+			}
+			ret = 0;
+			break;
+		}
+
+	default:
+		ret = ptrace_request(child, request, addr, data);
+		break;
+	}
+
+	return ret;
+}
+
+asmlinkage void syscall_trace(void)
+{
+	if (!test_thread_flag(TIF_SYSCALL_TRACE))
+		return;
+	if (!(current->ptrace & PT_PTRACED))
+		return;
+
+	/* the 0x80 provides a way for the tracing parent to distinguish
+	   between a syscall stop and SIGTRAP delivery */
+	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)
+				 ? 0x80 : 0));
+
+	/*
+	 * This isn't the same as continuing with a signal, but it will do
+	 * for normal use.  strace only continues with a signal if the
+	 * stopping signal is not SIGTRAP.  -brl
+	 */
+	if (current->exit_code) {
+		send_sig(current->exit_code, current, 1);
+		current->exit_code = 0;
+	}
+}
+
+#include <asm/elf.h>
+
+/* Not strictly related to ptrace, but as both effectivly generate a
+ * struct user_regs_struct it is useful to have it here.
+ */
+void st200_elf_core_copy_regs(struct pt_regs *regs, elf_gregset_t dst)
+{
+	/* We ignore the pt_regs passed in, and assume it is always current */
+	BUG_ON(st200_task_regs(current_thread_info()) != regs);
+	st200_elf_core_copy_task_regs(current, dst);
+}
+
+int st200_elf_core_copy_task_regs(struct task_struct *task, elf_gregset_t dst)
+{
+	int i;
+
+	for (i = 0; i < ELF_NGREG; i++) {
+		dst[i] = get_reg(task, i);
+	}
+	return 1;
+}
diff --git a/arch/st200/kernel/ptrace.h b/arch/st200/kernel/ptrace.h
new file mode 100644
index 0000000..6e4e520
--- /dev/null
+++ b/arch/st200/kernel/ptrace.h
@@ -0,0 +1,10 @@
+/*
+ *  linux/arch/st200/kernel/ptrace.h
+ *
+ *  Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+void ptrace_set_step(struct task_struct *child);
+void ptrace_cancel_step(struct task_struct *child);
diff --git a/arch/st200/kernel/setup.c b/arch/st200/kernel/setup.c
new file mode 100644
index 0000000..e433c89
--- /dev/null
+++ b/arch/st200/kernel/setup.c
@@ -0,0 +1,339 @@
+/*
+ * linux/arch/st200/kernel/setup.c
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Authors: Stuart Menefy <stuart.menefy@st.com>,
+ *		 David McKay <david.mckay@st.com>
+ *
+ * Param passing copied from arch/arm/kernel/setup.c
+ *               (c) Russell King
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/root_dev.h>
+#include <linux/ioport.h>
+#include <linux/console.h>
+#include <linux/seq_file.h>
+#include <linux/initrd.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/st_soc.h>
+#include <asm/serial.h>
+#include <asm/io.h>
+#include <asm/setup.h>
+
+extern void st200_init_task_union(void);
+extern void scu_init(void);
+extern void bootmem_init(unsigned long bios_initrd_start,
+			 unsigned long bios_initrd_size);
+
+unsigned long mem_size = CONFIG_MEMORY_SIZE;
+unsigned long mem_start = CONFIG_MEMORY_START;	/* Physical address */
+
+#ifdef CONFIG_LINK_IN_INITRD
+extern char __initrd_start, __initrd_end;
+#endif
+
+static char __initdata command_line[COMMAND_LINE_SIZE];
+static char default_command_line[COMMAND_LINE_SIZE] __initdata =
+    "mem=32m console=ttyAS0";
+
+int plugin_count;
+struct kernel_params *plugin_details;
+
+extern int root_mountflags;
+extern char _text, _etext, _edata, _end;
+
+static struct resource code_resource = {
+	.name = "Kernel code",
+	.flags = IORESOURCE_BUSY | IORESOURCE_MEM
+};
+
+static struct resource data_resource = {
+	.name = "Kernel data",
+	.flags = IORESOURCE_BUSY | IORESOURCE_MEM
+};
+
+#ifdef CONFIG_SIMULATOR_CONSOLE
+
+#include <linux/notifier.h>
+
+void __init simcons_console_init(void);
+
+extern void sim_exit(int code);
+extern struct atomic_notifier_head panic_notifier_list;
+
+static int sim_panic_event(struct notifier_block *block, unsigned long dummy,
+			   void *msg)
+{
+	sim_exit(1);
+}
+
+static struct notifier_block sim_panic_block = {
+	sim_panic_event,
+	NULL,
+	INT_MAX			/* try to do it first */
+};
+
+#endif /* CONFIG_SIMULATOR_CONSOLE */
+
+static void __init register_memory(void)
+{
+	struct resource *res;
+
+	res = alloc_bootmem_low(sizeof(struct resource));
+	res->start = mem_start;
+	res->end = mem_size + mem_start;
+	res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+	res->name = "System RAM";
+	request_resource(&iomem_resource, res);
+
+	request_resource(res, &code_resource);
+	request_resource(res, &data_resource);
+}
+
+static unsigned long phys_initrd_start __initdata = 0;
+static unsigned long phys_initrd_size __initdata = 0;
+
+static int __init early_initrd(char *p)
+{
+	unsigned long start, size;
+
+	start = memparse(p, &p);
+	if (*p == ',') {
+		size = memparse(p + 1, &p);
+
+		phys_initrd_start = start;
+		phys_initrd_size = size;
+	}
+
+	return 0;
+}
+
+early_param("initrd", early_initrd);
+
+/*
+ * Pick out the memory size.  We look for mem=size@start,
+ * where start and size are "size[KkMm]"
+ */
+static int __init early_mem(char *p)
+{
+	mem_size = memparse(p, &p);
+
+	if (*p == '@')
+		mem_start = memparse(p + 1, &p);
+
+	return 0;
+}
+
+early_param("mem", early_mem);
+
+/*
+ *  Tag parsing.
+ *
+ * This is the new way of passing data to the kernel at boot time.  Rather
+ * than passing a fixed inflexible structure to the kernel, we pass a list
+ * of variable-sized tags to the kernel.  The first tag must be a ATAG_CORE
+ * tag for the list to be recognised (to distinguish the tagged list from
+ * a param_struct).  The list is terminated with a zero-length tag (this tag
+ * is not parsed in any way).
+ */
+static int __init parse_tag_core(const struct tag *tag)
+{
+	if (tag->hdr.size > 2) {
+		if ((tag->core.flags & 1) == 0)
+			root_mountflags &= ~MS_RDONLY;
+		ROOT_DEV = new_decode_dev(tag->core.rootdev);
+	}
+	return 0;
+}
+
+__tagtable(ATAG_CORE, parse_tag_core);
+
+static int __init parse_tag_mem32(const struct tag *tag)
+{
+
+	mem_start = tag->mem.start;
+	mem_size = tag->mem.size;
+
+	return 0;
+}
+
+__tagtable(ATAG_MEM, parse_tag_mem32);
+
+static int __init parse_tag_initrd(const struct tag *tag)
+{
+	phys_initrd_start = tag->initrd.start;
+	phys_initrd_size = tag->initrd.size;
+	return 0;
+}
+
+__tagtable(ATAG_INITRD, parse_tag_initrd);
+
+static int __init parse_tag_cmdline(const struct tag *tag)
+{
+	strlcpy(command_line, tag->cmdline.cmdline, COMMAND_LINE_SIZE);
+
+	return 0;
+}
+
+__tagtable(ATAG_CMDLINE, parse_tag_cmdline);
+
+/*
+ * Scan the tag table for this tag, and call its parse function.
+ * The tag table is built by the linker from all the __tagtable
+ * declarations.
+ */
+static int __init parse_tag(const struct tag *tag)
+{
+	extern struct tagtable __tagtable_begin, __tagtable_end;
+	struct tagtable *t;
+
+	for (t = &__tagtable_begin; t < &__tagtable_end; t++)
+		if (tag->hdr.tag == t->tag) {
+			t->parse(tag);
+			break;
+		}
+
+	return t < &__tagtable_end;
+}
+
+/*
+ * Parse all tags in the list, checking both the global and architecture
+ * specific tag tables.
+ */
+static void __init parse_tags(const struct tag *t)
+{
+	for (; t->hdr.size; t = tag_next(t)) {
+		if (!parse_tag(t))
+			printk(KERN_WARNING
+			       "Ignoring unrecognised tag 0x%08x\n",
+			       t->hdr.tag);
+	}
+}
+
+/*
+ * This holds our defaults.
+ */
+static struct init_tags {
+	struct tag_header hdr1;
+	struct tag_core core;
+	struct tag_header hdr2;
+	struct tag_mem32 mem;
+	struct tag_header hdr3;
+} init_tags __initdata = {
+	{tag_size(tag_core), ATAG_CORE},
+	{ATAG_CORE_MAGIC, 1, Root_RAM0},
+	{tag_size(tag_mem32), ATAG_MEM},
+	{CONFIG_MEMORY_START, CONFIG_MEMORY_SIZE},
+	{0, ATAG_NONE}
+};
+
+/* The bootloader,st40load_gdb and the simulator place the command
+ * line tags into zero page. There is 8K of this which is more than
+ * enough.
+ */
+
+void __init setup_arch(char **cmdline_p)
+{
+	struct tag *tags = (struct tag *)empty_zero_page;
+	int i;
+	unsigned *p;
+
+#ifdef CONFIG_SIMULATOR_CONSOLE
+	/* Give us early printks */
+	simcons_console_init();
+
+	/* Exit the simulator if we panic */
+	atomic_notifier_chain_register(&panic_notifier_list, &sim_panic_block);
+#endif
+
+#ifdef CONFIG_LINK_IN_INITRD
+	phys_initrd_start = __pa(&__initrd_start);
+	phys_initrd_size = __pa(&__initrd_end) - phys_initrd_start;
+#endif
+
+	/* Bummer, we don't have anything - use defaults */
+	if (tags->hdr.tag != ATAG_CORE) {
+		tags = &init_tags;
+	}
+
+	strcpy(command_line, default_command_line);
+
+	parse_tags(tags);
+
+	init_mm.start_code = (unsigned long)&_text;
+	init_mm.end_code = (unsigned long)&_etext;
+	init_mm.end_data = (unsigned long)&_edata;
+	init_mm.brk = (unsigned long)&_end;
+
+	code_resource.start = __pa(&_text);
+	code_resource.end = __pa(&_etext) - 1;
+	data_resource.start = __pa(&_etext);
+	data_resource.end = __pa(&_edata) - 1;
+
+	/* Save unparsed command line copy for /proc/cmdline */
+	memcpy(boot_command_line, command_line, COMMAND_LINE_SIZE);
+	*cmdline_p = command_line;
+
+	//memcpy(saved_command_line,default_command_line, COMMAND_LINE_SIZE);
+	//saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
+
+	parse_early_param();
+
+	scu_init();
+
+	bootmem_init(phys_initrd_start, phys_initrd_size);
+
+	paging_init();
+	register_memory();
+	trap_init();
+
+	soc_setup();
+	board_setup();
+
+#ifdef CONFIG_VT
+#if defined(CONFIG_VGA_CONSOLE)
+	conswitchp = &vga_con;
+#elif defined(CONFIG_DUMMY_CONSOLE)
+	conswitchp = &dummy_con;
+#endif
+#endif
+}
+
+#ifdef CONFIG_PROC_FS
+static int show_cpuinfo(struct seq_file *m, void *v)
+{
+	extern void mm_show_cpuinfo(struct seq_file *m);
+
+	seq_printf(m, "ST200\n");
+	return 0;
+}
+
+static void *c_start(struct seq_file *m, loff_t * pos)
+{
+	return (void *)(*pos == 0);
+}
+
+static void *c_next(struct seq_file *m, void *v, loff_t * pos)
+{
+	return NULL;
+}
+
+static void c_stop(struct seq_file *m, void *v)
+{
+}
+
+struct seq_operations cpuinfo_op = {
+	.start = c_start,
+	.next = c_next,
+	.stop = c_stop,
+	.show = show_cpuinfo,
+};
+#endif
diff --git a/arch/st200/kernel/signal.c b/arch/st200/kernel/signal.c
new file mode 100644
index 0000000..5fc1bdf
--- /dev/null
+++ b/arch/st200/kernel/signal.c
@@ -0,0 +1,348 @@
+/*
+ * linux/arch/st200/kernel/signal.c
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/kernel.h>
+#include <linux/signal.h>
+#include <linux/errno.h>
+#include <linux/wait.h>
+#include <linux/unistd.h>
+#include <linux/stddef.h>
+#include <linux/personality.h>
+#include <linux/suspend.h>
+#include <linux/syscalls.h>
+#include <asm/uaccess.h>
+#include <asm/syscallparams.h>
+#include <asm/vdso.h>
+
+#define DEBUG_SIG 0
+
+#define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
+
+static int do_signal(struct pt_regs *regs, struct switch_stack *ss,
+		     int syscall, unsigned long syscall_r16, sigset_t * oldset);
+
+/*
+ * Atomically swap in the new signal mask, and wait for a signal.
+ */
+
+asmlinkage int
+st200_rt_sigsuspend(sigset_t * unewset, size_t sigsetsize,
+		    int arg3, int arg4,
+		    int arg5, int arg6, int arg7, int arg8,
+		    struct syscallparams_ss params)
+{
+	struct pt_regs *regs = &params.regs;
+	struct switch_stack *ss = &params.ss;
+	sigset_t saveset, newset;
+
+	/* XXX: Don't preclude handling different sized sigset_t's.  */
+	if (sigsetsize != sizeof(sigset_t))
+		return -EINVAL;
+
+	if (copy_from_user(&newset, unewset, sizeof(newset)))
+		return -EFAULT;
+	sigdelsetmask(&newset, ~_BLOCKABLE);
+
+	spin_lock_irq(&current->sighand->siglock);
+	saveset = current->blocked;
+	current->blocked = newset;
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+
+	/*
+	 * If we have got this far, then we will probably be returning
+	 * via a signal handler, and so need to return via
+	 * restore_all.  Indicate this by the "return 0"
+	 * below. However this bypasses the normal error code
+	 * handling, so set the error code here in regs directly.
+	 */
+	regs->r16 = EINTR;
+	regs->br = 1;
+
+	while (1) {
+		current->state = TASK_INTERRUPTIBLE;
+		schedule();
+		if (do_signal(regs, ss, 0, 0, &saveset))
+			return 0;
+	}
+}
+
+asmlinkage int
+sys_sigaltstack(const stack_t * uss, stack_t * uoss,
+		int arg3, int arg4,
+		int arg5, int arg6, int arg7, int arg8,
+		struct syscallparams params)
+{
+	struct pt_regs *regs = &params.regs;
+	return do_sigaltstack(uss, uoss, regs->r12);
+}
+
+struct sigframe {
+	struct sigcontext sc;
+	siginfo_t info;
+};
+
+asmlinkage void st200_rt_sigreturn(struct sigcontext *sc, struct pt_regs *regs)
+{
+	sigset_t set;
+	stack_t st;
+
+#if DEBUG_SIG
+	printk("SIG return (%s:%d): context=%p\n",
+	       current->comm, current->pid, sc);
+#endif
+
+	if (verify_area(VERIFY_READ, sc, sizeof(*sc)))
+		goto badframe;
+	if (__copy_from_user(&set, &sc->sc_mask, sizeof(set)))
+		goto badframe;
+
+	sigdelsetmask(&set, ~_BLOCKABLE);
+	spin_lock_irq(&current->sighand->siglock);
+	current->blocked = set;
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+
+	if (__copy_from_user(regs, &sc->sc_regs, sizeof(*regs)))
+		goto badframe;
+
+	if (__copy_from_user(&st, &sc->sc_stack, sizeof(st)))
+		goto badframe;
+	/* It is more difficult to avoid calling this function than to
+	   call it and ignore errors.  */
+	do_sigaltstack(&st, NULL, regs->r12);
+	return;
+
+badframe:
+	force_sig(SIGSEGV, current);
+}
+
+static inline void *get_sigframe(struct k_sigaction *ka, struct pt_regs *regs,
+				 size_t frame_size)
+{
+	unsigned long sp;
+
+	/* Default to using normal stack */
+	sp = regs->r12;
+
+	if ((ka->sa.sa_flags & SA_ONSTACK) && (!sas_ss_flags(sp))) {
+		sp = current->sas_ss_sp + current->sas_ss_size;
+	}
+
+	return (void *)((sp - frame_size) & (~31ul));
+}
+
+static inline int
+setup_sigcontext(struct sigcontext *sc,
+		 struct pt_regs *regs, struct switch_stack *ss,
+		 stack_t * stack, sigset_t * set)
+{
+	if (__put_user(0, &sc->sc_flags))
+		return 1;
+	if (__copy_to_user(&sc->sc_regs, regs, sizeof(*regs)))
+		return 1;
+	if (__copy_to_user(&sc->sc_ss, ss, sizeof(*ss)))
+		return 1;
+	if (__copy_to_user(&sc->sc_stack, stack, sizeof(*stack)))
+		return 1;
+	if (__copy_to_user(&sc->sc_mask, set, sizeof(*set)))
+		return 1;
+
+	return 0;
+}
+
+static void
+setup_frame(int sig, struct k_sigaction *ka, siginfo_t * info,
+	    sigset_t * set, struct pt_regs *regs, struct switch_stack *ss)
+{
+	struct sigframe *frame;
+	stack_t stack;
+	int err = 0;
+	unsigned long sp;
+
+	frame = get_sigframe(ka, regs, sizeof(*frame));
+
+	if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))
+		goto give_sigsegv;
+
+	stack.ss_sp = (void *)current->sas_ss_sp;
+	stack.ss_size = current->sas_ss_size;
+	stack.ss_flags = sas_ss_flags(regs->r12);
+	err |= setup_sigcontext(&frame->sc, regs, ss, &stack, set);
+	if (err)
+		goto give_sigsegv;
+
+	if (info) {
+		err |= copy_siginfo_to_user(&frame->info, info);
+		if (err)
+			goto give_sigsegv;
+	}
+
+	if (!vdso_sigrestorer && current->mm->context.vdso)
+		goto give_sigsegv;
+
+	regs->lr = current->mm->context.vdso + vdso_sigrestorer;
+
+	ss->r1 = (unsigned long)&frame->sc;
+
+	/* Work out the new sp */
+	sp = (unsigned long)frame;
+	sp -= 16;		/* Allow for scratch area */
+	sp &= ~31ul;		/* and align down */
+
+	/* Set up registers for signal handler */
+	regs->r12 = sp;
+	regs->pc = (unsigned long)ka->sa.sa_handler;
+	regs->r16 = sig;	/* arg0: signal number */
+	regs->r17 = (unsigned long)&frame->info;	/* arg1: siginfo */
+	regs->r18 = (unsigned long)&frame->sc;	/* arg2: sigcontext pointer */
+
+#if DEBUG_SIG
+	printk("SIG deliver (%s:%d): frame=%p, sp=%p pc=%p ra=%p\n",
+	       current->comm, current->pid, frame, sp, regs->pc, regs->lr);
+#endif
+
+	return;
+
+give_sigsegv:
+	force_sigsegv(sig, current);
+
+}
+
+/*
+ * OK, we're invoking a handler
+ */
+
+static inline void
+handle_signal(unsigned long sig, struct k_sigaction *ka,
+	      siginfo_t * info, sigset_t * oldset,
+	      struct pt_regs *regs, struct switch_stack *ss)
+{
+	/* Set up the stack frame */
+	setup_frame(sig, ka,
+		    (ka->sa.sa_flags & SA_SIGINFO) ? info : NULL,
+		    oldset, regs, ss);
+
+	if (ka->sa.sa_flags & SA_ONESHOT)
+		ka->sa.sa_handler = SIG_DFL;
+
+	if (!(ka->sa.sa_flags & SA_NODEFER)) {
+		spin_lock_irq(&current->sighand->siglock);
+		sigorsets(&current->blocked, &current->blocked,
+			  &ka->sa.sa_mask);
+		sigaddset(&current->blocked, sig);
+		recalc_sigpending();
+		spin_unlock_irq(&current->sighand->siglock);
+	}
+}
+
+static inline void
+syscall_restart(struct k_sigaction *ka,
+		struct pt_regs *regs, struct switch_stack *ss,
+		unsigned long syscall_r16)
+{
+	/* Check system call restarting.. */
+	switch (regs->r16) {
+	case ERESTART_RESTARTBLOCK:
+		current_thread_info()->restart_block.fn = do_no_restart_syscall;
+		/* fall through */
+
+	case ERESTARTNOHAND:
+		regs->r16 = EINTR;
+		break;
+
+	case ERESTARTSYS:
+		if (!(ka->sa.sa_flags & SA_RESTART)) {
+			regs->r16 = EINTR;
+			break;
+		}
+		/* fall through */
+
+	case ERESTARTNOINTR:
+		/* repeat the syscall */
+		regs->r16 = syscall_r16;
+		regs->pc -= 4;
+		break;
+	}
+}
+
+/*
+ * Note that 'init' is a special process: it doesn't get signals it doesn't
+ * want to handle. Thus you cannot kill init even with a SIGKILL even by
+ * mistake.
+ *
+ * Remember this is called from st200_rt_sigsuspend, as well as
+ * do_notify_resume.
+ *
+ * syscall is 1 if we came from a system call which errored, 0 otherwise.
+ * If syscall is 1, then syscall_r16 will contain the r16 on entry to
+ * the system call, in case we need to restart.
+ */
+static int do_signal(struct pt_regs *regs, struct switch_stack *ss,
+		     int syscall, unsigned long syscall_r16, sigset_t * oldset)
+{
+	siginfo_t info;
+	int signr;
+	struct k_sigaction ka;
+
+	if (!oldset)
+		oldset = &current->blocked;
+
+	signr = get_signal_to_deliver(&info, &ka, regs, NULL);
+
+	if (signr > 0) {
+		/* Whee!  Actually deliver the signal.  */
+		if (syscall)
+			syscall_restart(&ka, regs, ss, syscall_r16);
+		handle_signal(signr, &ka, &info, oldset, regs, ss);
+		return 1;
+	}
+
+	/* Did we come from a system call which errored? */
+	if (syscall) {
+		/* Restart the system call - no handlers present */
+		switch (regs->r16) {
+		case ERESTARTNOHAND:
+		case ERESTARTSYS:
+		case ERESTARTNOINTR:
+			regs->r16 = syscall_r16;
+			regs->pc -= 4;
+			break;
+
+		case ERESTART_RESTARTBLOCK:
+			regs->r15 = __NR_restart_syscall;
+			regs->pc -= 4;
+			break;
+		}
+	}
+	return 0;
+}
+
+/*
+ * notification of userspace execution resumption
+ * - triggered by current->work.notify_resume
+ * interrupts are still disabled
+ */
+void do_notify_resume(struct pt_regs *regs, struct switch_stack *ss,
+		      int syscall, unsigned long syscall_r16,
+		      __u32 thread_info_flags, sigset_t * oldset)
+{
+#if DEBUG_SIG
+	printk
+	    ("pid %d do_notify_resume(regs %x, ss %x, syscall %d, r16 %x, flags %x, oldset %x\n",
+	     current->pid, regs, ss, syscall, syscall_r16, thread_info_flags,
+	     oldset);
+#endif
+	if (thread_info_flags & _TIF_SIGPENDING) {
+		do_signal(regs, ss, syscall, syscall_r16, oldset);
+	}
+}
diff --git a/arch/st200/kernel/st200_ksyms.c b/arch/st200/kernel/st200_ksyms.c
new file mode 100644
index 0000000..69ea49b
--- /dev/null
+++ b/arch/st200/kernel/st200_ksyms.c
@@ -0,0 +1,43 @@
+/*
+ * linux/arch/st200/kernel/st200_ksyms.c
+ *
+ * Export the st200-specific functions that are needed for loadable
+ * modules.
+ */
+
+#include <linux/module.h>
+#include <net/checksum.h>
+#include <asm/uaccess.h>
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+#include <asm/delay.h>
+
+#define DECLARE_EXPORT_SYMBOL(name) extern void name(void);EXPORT_SYMBOL(name)
+
+/* libgcc functions */
+DECLARE_EXPORT_SYMBOL(__divl);
+DECLARE_EXPORT_SYMBOL(__divw);
+DECLARE_EXPORT_SYMBOL(__divul);
+DECLARE_EXPORT_SYMBOL(__divuw);
+DECLARE_EXPORT_SYMBOL(__modw);
+DECLARE_EXPORT_SYMBOL(__moduw);
+
+EXPORT_SYMBOL(__do_clear_user);
+EXPORT_SYMBOL(__do_copy_user);
+EXPORT_SYMBOL(__down);
+EXPORT_SYMBOL(__down_interruptible);
+EXPORT_SYMBOL(__down_trylock);
+EXPORT_SYMBOL(__get_user_asm_byte);
+EXPORT_SYMBOL(__get_user_asm_half);
+EXPORT_SYMBOL(__get_user_asm_word);
+EXPORT_SYMBOL(__put_user_asm_byte);
+EXPORT_SYMBOL(__put_user_asm_half);
+EXPORT_SYMBOL(__put_user_asm_word);
+EXPORT_SYMBOL(__sync);
+EXPORT_SYMBOL(__up);
+
+EXPORT_SYMBOL(__udelay);
+EXPORT_SYMBOL(__const_udelay);
+
+EXPORT_SYMBOL(memcpy);
+EXPORT_SYMBOL(memset);
diff --git a/arch/st200/kernel/stubs.S b/arch/st200/kernel/stubs.S
new file mode 100644
index 0000000..702e626
--- /dev/null
+++ b/arch/st200/kernel/stubs.S
@@ -0,0 +1,540 @@
+#include <asm/ctrlregdef.h>
+#include <linux/linkage.h>
+#include <asm/page.h>
+#include <asm/thread_info.h>
+#include <asm/errno.h>
+#include <asm/asm-offsets.h>
+#include <asm/unistd.h>
+#include "asm_macros.h"
+
+
+/*
+ * extern long __get_user_asm_byte(const void* ptr, long* retval);
+ * extern long __get_user_asm_half(const void* ptr, long* retval);
+ * extern long __get_user_asm_word(const void* ptr, long* retval);
+ */
+
+#define get_user(type, instr)		  \
+ENTRY(__get_user_asm_##type)		; \
+1:	instr	$r16 = 0[$r16]		; \
+	;;				; \
+	nop				; \
+	;;				; \
+	goto	$r63			; \
+	;;				; \
+	.section .fixup,"ax"		; \
+	.align	4			; \
+2:	mov	$r16 = -EFAULT		; \
+	;;				; \
+	stw	0[$r17] = $r16		; \
+	goto	$r63			; \
+	;;				; \
+	.previous			; \
+	.section __ex_table,"a"		; \
+	.align	4			; \
+	.long   1b, 2b			; \
+	.previous
+
+get_user(byte, ldb)
+get_user(half, ldh)
+get_user(word, ldw)
+
+/*
+ * extern long __get_user_asm_double(const void* ptr, long* retval);
+ */
+ENTRY(__get_user_asm_double)
+1:	ldw	$r16 = 0[$r16]
+	mov	$r8 = $r16
+	;;
+2:	ldw	$r17 = 4[$r8]
+	;;
+	nop
+	;;
+	goto	$r63
+	;;
+	.section .fixup,"ax"
+	.align	4
+3:	mov	$r16 = -EFAULT
+	;;
+	stw	0[$r17] = $r16
+	goto	$r63
+	;;
+	.previous
+	.section __ex_table,"a"
+	.align	4
+	.long	1b, 3b
+	.long	2b, 3b
+	.previous
+
+/*
+ * extern void __put_user_asm_byte(long x, void *ptr, long* retval);
+ * extern void __put_user_asm_half(long x, void *ptr, long* retval);
+ * extern void __put_user_asm_word(long x, void *ptr, long* retval);
+ */
+
+#define put_user(type, instr)		  \
+ENTRY(__put_user_asm_##type)		; \
+1:	instr	0[$r17] = $r16		; \
+	goto	$r63			; \
+	;;				; \
+	.section .fixup,"ax"		; \
+	.align	4			; \
+2:	mov	$r16 = -EFAULT		; \
+	;;				; \
+	stw	0[$r18] = $r16		; \
+	goto	$r63			; \
+	;;				; \
+	.previous			; \
+	.section __ex_table,"a"		; \
+	.align	4			; \
+	.long   1b, 2b			; \
+	.previous
+
+put_user(byte, stb)
+put_user(half, sth)
+put_user(word, stw)
+
+/*
+ * __put_user_asm_double(x,ptr,&retval);
+ */
+ENTRY(__put_user_asm_double)
+1:	stw	0[$r18] = $r16
+	;;
+2:	stw	4[$r18] = $r17
+	goto	$r63
+	;;
+	.section .fixup,"ax"
+	.align	4
+3:	mov	$r16 = -EFAULT
+	;;
+	stw	0[$r19] = $r16
+	goto	$r63
+	;;
+	.previous
+	.section __ex_table,"a"
+	.align	4
+	.long	1b, 3b
+	.long	2b, 3b
+	.previous
+
+/* unsigned long __do_copy_user(void *to, const void *from, unsigned long n); */
+/* Return the number of bytes NOT copied */
+ENTRY(__do_copy_user)
+1:	cmpeq	$b0 = $r18, 0	/* $b0 = zero length */
+	cmpltu	$b1 = $r18, 32	/* $b1 = count less than 32 */
+	or	$r8 = $r16, $r17
+	;;
+	and	$r8 = $r8, 3
+	;;
+	cmpeq	$b2 = $r8, 0	/* $b2 = word aligned */
+	;;
+	br	$b0, 40f	/* zero length */
+	cmpltu	$b0 = $r18, 4	/* $b0 = count < 4 */
+	;;
+	nop
+	;;
+	brf	$b2, 30f	/* not word aligned -> byte at a time copy */
+	;;
+	br	$b0, 30f	/* count < 4 -> byte at a time */
+	;;
+	br	$b1, 20f	/* count < 32 -> word at a time copy */
+	;;
+
+	/* 8 words at a time */
+2:	ldw	$r24  = 0x00[$r17]
+	;;
+3:	ldw	$r25  = 0x04[$r17]
+	;;
+4:	ldw	$r26 = 0x08[$r17]
+	;;
+5:	ldw	$r27 = 0x0c[$r17]
+	;;
+6:	ldw	$r28 = 0x10[$r17]
+	;;
+7:	ldw	$r29 = 0x14[$r17]
+	;;
+8:	ldw	$r30 = 0x18[$r17]
+	;;
+9:	ldw	$r31 = 0x1c[$r17]
+	add	$r17 = $r17, 32
+	;;
+
+10:	stw	0x00[$r16] = $r24
+	add	$r18 = $r18, -4
+	;;
+11:	stw	0x04[$r16] = $r25
+	add	$r18 = $r18, -4
+	;;
+12:	stw	0x08[$r16] = $r26
+	add	$r18 = $r18, -4
+	;;
+13:	stw	0x0c[$r16] = $r27
+	add	$r18 = $r18, -4
+	;;
+14:	stw	0x10[$r16] = $r28
+	add	$r18 = $r18, -4
+	cmpltu	$b0 = $r18, 32+16	/* $b0 = count < 32 at end of loop */
+	;;
+15:	stw	0x14[$r16] = $r29
+	add	$r18 = $r18, -4
+	cmpeq	$b2 = $r18, 12		/* $b2 = count == 0 at end of loop */
+	;;
+16:	stw	0x18[$r16] = $r30
+	add	$r18 = $r18, -4
+	cmpltu	$b1 = $r18, 4+8		/* $b1 = count < 4 at end of loop */
+	;;
+17:	stw	0x1c[$r16] = $r31
+	add	$r18 = $r18, -4
+	add	$r16 = $r16, 32
+	brf	$b0, 2b			/* repeat 8 word loop */
+	;;
+	br	$b2, 40f		/* finish */
+	;;
+	br	$b1, 30f		/* byte at a time loop */
+	;;
+
+	/* 1 word at a time */
+20:	ldw	$r24 = 0[$r17]
+	cmpltu	$b0 = $r18, 4+4		/* $b0 = count < 4 at end of loop */
+	;;
+	add	$r17 = $r17, 4
+	cmpeq	$b2 = $r18, 4		/* $b2 = count == 0 at end of loop */
+	;;
+	nop
+	;;
+21:	stw	0[$r16] = $r24
+	add	$r16 = $r16, 4
+	add	$r18 = $r18, -4
+	brf	$b0, 20b
+	;;
+	br	$b2, 40f		/* finish */
+	;;
+
+	/* 1 byte at a time */
+30:	ldb	$r24 = 0[$r17]
+	cmpeq	$b0 = $r18, 1		/* $b0 = count == 0 at end of loop */
+	;;
+	add	$r17 = $r17, 1
+	;;
+	nop
+	;;
+31:	stb	0[$r16] = $r24
+	add	$r16 = $r16, 1
+	add	$r18 = $r18, -1
+	brf	$b0, 30b
+	;;
+
+	/* Finish */
+40:	goto	$r63
+	mov	$r16 = $r18
+	;;
+
+	.section __ex_table,"a"
+	.align	4
+	.long   2b, 40b
+	.long   3b, 40b
+	.long   4b, 40b
+	.long   5b, 40b
+	.long   6b, 40b
+	.long   7b, 40b
+	.long   8b, 40b
+	.long   9b, 40b
+	.long   10b, 40b
+	.long   11b, 40b
+	.long   12b, 40b
+	.long   13b, 40b
+	.long   14b, 40b
+	.long   15b, 40b
+	.long   16b, 40b
+	.long   17b, 40b
+	.long   20b, 40b
+	.long   21b, 40b
+	.long   30b, 40b
+	.long   31b, 40b
+	.previous
+
+/* unsigned long __do_clear_user (void *to, unsigned long n); */
+/* Return the number of bytes NOT copied */
+ENTRY(__do_clear_user)
+1:	cmpeq	$b0 = $r17, 0
+	;;
+	nop
+	;;
+	nop
+	;;
+	br	$b0, 3f
+	;;
+2:	stb	0[$r16] = $r0
+	cmpeq	$b0 = $r17, 1
+	;;
+	add	$r16 = $r16, 1
+	;;
+	add	$r17 = $r17, -1
+	;;
+	brf	$b0, 2b
+	;;
+3:	goto	$r63
+	mov	$r16 = $r17
+	;;
+	.section __ex_table,"a"
+	.align	4
+	.long   2b, 3b
+	.previous
+
+/* long __do_strncpy_from_user (char *dst, const char *src, long count); */
+/*
+ * Return -EFAULT if exception, count if the entire buffer filled, else
+ * strlen (without trailing nul).
+ *  $r8  = tmp
+ *  $r9  = dst
+ *  $r16 = chars copied so far
+ *  $r17 = src
+ *  $r18 = count-1
+ */
+ENTRY(__do_strncpy_from_user)
+1:	cmpeq	$b0 = $r18, 0
+	;;
+	mov	$r9 = $r16
+	;;
+	mov	$r16 = $r0
+	add	$r18 = $r18, -1
+	;;
+	br	$b0, 4f
+	;;
+2:	ldb	$r8 = 0[$r17]
+	cmpeq	$b0 = $r16, $r18
+	;;
+	add	$r17 = $r17, 1
+	;;
+	add	$r16 = $r16, 1
+	;;
+	stb	0[$r9] = $r8
+	br	$b0, 4f
+	cmpeq	$b0 = $r8, 0
+	;;
+	nop
+	;;
+	add	$r9 = $r9, 1
+	;;
+	brf	$b0, 2b
+	;;
+3:	add	$r16 = $r16, -1
+	goto	$r63
+	;;
+4:	goto	$r63
+	;;
+5:	mov	$r16 = -EFAULT
+	goto	$r63
+	;;
+	.section __ex_table,"a"
+	.align	4
+	.long   2b, 5b
+	.previous
+
+/* long __do_strnlen_user(const char *s, long n); */
+/*
+ * strnlen_user returns 0 if exception before NUL or reaching the
+ * supplied limit (N), a value greater than N if the limit would be
+ * exceeded, else strlen (including trailing nul).
+ *  $r8  = tmp
+ *  $r9  = s
+ *  $r16 = chars copied so far
+ *  $r17 = count
+ */
+ENTRY(__do_strnlen_user)
+1:	cmpeq	$b0 = $r17, 0
+	;;
+	mov	$r9 = $r16
+	;;
+	mov	$r16 = $r0
+	;;
+	br	$b0, 4f
+	;;
+2:	ldb	$r8 = 0[$r9]
+	cmpeq	$b0 = $r16, $r17
+	;;
+	add	$r9 = $r9, 1
+	;;
+	add	$r16 = $r16, 1
+	;;
+	br	$b0, 3f
+	cmpeq	$b0 = $r8, 0
+	;;
+	nop
+	;;
+	nop
+	;;
+	brf	$b0, 2b
+	;;
+3:	goto	$r63
+	;;
+4:	mov	$r16 = 1
+	goto	$r63
+	;;
+5:	mov	$r16 = $r0
+	goto	$r63
+	;;
+	.section __ex_table,"a"
+	.align	4
+	.long   2b, 5b
+	.previous
+
+/*
+ * Entry point for a new kernel thread
+ *
+ * $r1 = arg
+ * $r63 = fn
+ */
+ENTRY(kernel_thread_helper)
+	mov	$r16 = $r1
+	call	$r63 = $r63
+	;;
+	goto	do_exit
+	;;
+
+#if 0
+ENTRY(__syscall0)
+	mov	$r15 = $r16
+	;;
+	syscall	0
+	;;
+	br	$b0, 1f
+	;;
+	goto	$r63
+	;;
+
+ENTRY(__syscall1)
+	mov	$r15 = $r17
+	;;
+	syscall	0
+	;;
+	br	$b0, 1f
+	;;
+	goto	$r63
+	;;
+
+ENTRY(__syscall3)
+	mov	$r15 = $r19
+	;;
+	syscall	0
+	;;
+	br	$b0, 1f
+	;;
+	goto	$r63
+	;;
+
+ENTRY(__syscall4)
+	mov	$r15 = $r20
+	;;
+	syscall	0
+	;;
+	br	$b0, 1f
+	;;
+	goto	$r63
+	;;
+
+	/* Error handling */
+1:	mov	$r8 = errno
+	;;
+	stw	0[$r8] = $r16
+	mov	$r16 = -1
+	goto	$r63
+	;;
+
+#endif
+
+/* int kernel_execve(const char *fname,char *const argv[],char * const envp[]) */
+
+ENTRY(kernel_execve)
+        mov $r15 = __NR_execve
+        ;;
+        syscall 0
+        ;;
+        return $r63
+        ;;
+
+
+
+
+
+/* Issues a sync, really should be done inline. But we don't have inline
+   assembler as yet
+ */
+ENTRY(__sync)
+	sync
+	goto $r63
+	;;
+
+ENTRY(__syncins)
+	syncins
+	;;
+	goto $r63
+	;;
+
+/* Ditto for these, should be done via intrinsics, but they don't
+   work at the moment !!
+ */
+	.align	32
+ENTRY(__prgins)
+	prgins
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	syncins
+	;;
+	goto $r63
+	;;
+
+ENTRY(__prgadd)
+	prgadd 0[$r16]
+	goto $r63
+	;;
+
+ENTRY(__prgset)
+	prgset 0[$r16]
+	goto $r63
+	;;
+
+/*
+ * struct task_struct* __switch_to(struct thread_struct* prev,	struct thread_struct* next,
+ *			unsigned long ssp, task_t* prev)
+ *
+ * This is a real function call, so the C code will have stored the caller
+ * save registers, so we only have to bother with the callee save registers.
+ * This is described in C terms in struct switch_stack.
+ *
+ * NOTE
+ * We return next (where it is assigned to last in switch_to()), plus it
+ * is used in ret_from_fork.
+ */
+ENTRY(__switch_to)
+	add	$r12 = $r12, -SIZEOF_SWITCH_STACK
+	;;
+
+	save_switch_stack
+
+	stw	TS_PC[$r16] = $r63
+	;;
+	ldw	$r63 = TS_PC[$r17]
+	;;
+	stw	TS_SP[$r16] = $r12	/* All state saved at this point */
+	;;
+	ldw	$r12 = TS_SP[$r17]	/* 2 bundles before use */
+	mov	$r9 = super_sp
+	;;
+	stw	0[$r9] = $r18		/* Save super stack pointer */
+	;;
+	mov	$r16 = $r19		/* Set up result */
+	;;
+
+	restore_switch_stack
+
+	;;
+	add	$r12 = $r12, SIZEOF_SWITCH_STACK
+	goto	$r63			/* 3 clear bundles after $r63 load */
+	;;
+
diff --git a/arch/st200/kernel/sys_st200.c b/arch/st200/kernel/sys_st200.c
new file mode 100644
index 0000000..4d08620
--- /dev/null
+++ b/arch/st200/kernel/sys_st200.c
@@ -0,0 +1,71 @@
+/*
+ * linux/arch/st200/kernel/sys_st200.c
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * This file contains various system calls that have different calling
+ * conventions on different platforms.
+ */
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/sched.h>
+#include <linux/shm.h>
+#include <linux/file.h>		/* doh, must come after sched.h... */
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/highuid.h>
+#include <linux/syscalls.h>
+
+#include <asm/shmparam.h>
+#include <asm/uaccess.h>
+#include <asm/syscallparams.h>
+
+asmlinkage unsigned long
+sys_mmap2(unsigned long addr, unsigned long len,
+	  unsigned long prot, unsigned long flags,
+	  unsigned long fd, unsigned long pgoff)
+{
+	int error = -EBADF;
+	struct file *file = NULL;
+
+	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
+	if (!(flags & MAP_ANONYMOUS)) {
+		file = fget(fd);
+		if (!file)
+			goto out;
+	}
+
+	down_write(&current->mm->mmap_sem);
+	error =
+	    do_mmap_pgoff(file, addr, len, prot, flags,
+			  pgoff >> (PAGE_SHIFT - 12));
+	up_write(&current->mm->mmap_sem);
+
+	if (file)
+		fput(file);
+out:
+	return error;
+}
+
+asmlinkage unsigned long st200_shmat(int shmid, void *shmaddr, int shmflg)
+{
+	unsigned long raddr;
+	int retval;
+
+	retval = do_shmat(shmid, shmaddr, shmflg, &raddr);
+	if (retval < 0)
+		return retval;
+
+	force_successful_syscall_return();
+	return raddr;
+}
+
+asmlinkage int st200_fadvise64_64(int fd, u32 offset0, u32 offset1,
+				  u32 len0, u32 len1, int advice)
+{
+	return sys_fadvise64_64(fd, (u64) offset1 << 32 | offset0,
+				(u64) len1 << 32 | len0, advice);
+}
diff --git a/arch/st200/kernel/syscall.S b/arch/st200/kernel/syscall.S
new file mode 100644
index 0000000..c0a60eb
--- /dev/null
+++ b/arch/st200/kernel/syscall.S
@@ -0,0 +1,463 @@
+/*
+ * linux/arch/st200/kernel/syscall.S
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Authors: Stuart Menefy <stuart.menefy@st.com>,
+ *		 David McKay <david.mckay@st.com>
+ *
+ */
+
+#include <linux/linkage.h>
+#include <asm/ctrlregdef.h>
+#include <asm/unistd.h>
+#include <asm/page.h>
+#include <asm/thread_info.h>
+#include <asm/asm-offsets.h>
+#include "asm_macros.h"
+
+
+	/*
+	 * Handle a system call
+	 * Have saved $r8-$r11 to intsave, and $b0-2 to $r9
+	 * Note interrupts are still disabled.
+	 *
+	 * Only save those registers we have to into pt_regs:
+	 *   psw, pc and $r63	to allow resumption
+	 *   $r12		dito
+	 *   $r15		(syscall no) to allow syscall restart
+	 *   $r16-$r21		(args) dito
+	 *
+	 * The C level system call code returns the result in $r16 as
+	 * normal. Values in the range -1 to -4095 are normally treated
+	 * as errors, however some calls (eg ptrace) want to return arbitary
+	 * values. So we use ptregs->$r15 as a flag. If 0 then the result
+	 * cannot be an error code, irrespective of the value.
+	 *
+	 * On exit we only restore:
+	 *   psw, pc and $r63
+	 *   $r12
+	 *   $b0		false = result, true = error
+	 *   $r16		result or error value
+	 */
+ENTRY(syscall)
+
+	ldw	$r8 = SAVED_PSW[$r0]			/* 90:	$r8 = SAVED_PSW */
+	;;
+	ldw	$r9 = SAVED_PC[$r0]
+	;;
+	ldw	$r10 = super_sp[$r0]			/* 90:	$r10 = super_sp */
+	;;
+	and	$r11 = $r8, PSW_USER_MODE			/* 90:	$r11=user mode */
+	;;
+	cmpeq	$b0 = $r11, $r0				/* 90:	$b0=kernel mode, $r11 free */
+	;;
+	slct	$r10 = $b0, $r12, $r10			/* 90: */
+	;;
+	add	$r10 = $r10,-SIZEOF_PT_REGS		/* 90=	drop stack */
+	;;
+	stw	PT_REG8_BLOCK(12)[$r10] = $r12	/* 94: */
+	mov	$r12 = $r10				/* 94:	$r10 free */
+	add	$r9 = $r9, 4		/* skip syscall instr */
+	;;
+	stw	PT_PC[$r12] = $r9			/* 92=	$r9 free */
+	;;
+	stw	PT_PSW[$r12] = $r8			/* 92=	$r8 free */
+	;;
+	stw	PT_LR[$r12] = $r63			/* 92=	$r63 free */
+	;;
+
+	.irp	reg, 15, 16, 17, 18, 19, 20, 21
+	save_pt	\reg
+	.endr
+
+	and	$r11 = $r12, ~(THREAD_SIZE-1)
+	;;
+	ldw	$r10 = TI_FLAGS[$r11]
+	;;
+	cmpgeu	$b0 = $r15, __NR_Linux_syscalls
+	sh2add	$r15 = $r15, .Lsys_call_table
+	;;
+	slctf	$r15 = $b0, $r15, .Lsys_call_table /* entry 0 is ni_syscall */
+	;;
+	ldw	$r15 = 0[$r15]		/* 2 bundles before use */
+	and	$r10 = $r10, _TIF_SYSCALL_TRACE
+	;;
+	mov	$r8 = PSW_INT_ENABLE|PSW_KERNEL_DEFAULT
+	cmpne	$b0 = $r10, $r0		/* $b0 = flags.TIF_SYSCALL_TRACE set */
+	;;
+	stw	SAVED_PSW[$r0] = $r8
+	add	$r12 = $r12,-STACK_SCRATCH_AREA
+	slctf	$r15 = $b0, $r15, syscall_trace_entry
+	;;
+	stw	SAVED_PC[$r0] = $r15	/* 4 bundles before rfi */
+	;;
+	mov	$r63 = syscall_exit
+	;;
+	nop
+	;;
+	nop
+	;;
+	nop
+	;;
+	rfi
+	;;
+
+	/*
+	 * System call with the TIF_SYSCALL_TRACE flag set.
+	 * Interrupts are now enabled.
+	 */
+syscall_trace_entry:
+	add	$r12 = $r12, -SIZEOF_SWITCH_STACK
+	;;
+
+	save_switch_stack STACK_SCRATCH_AREA
+
+	call	$r63 = syscall_trace
+	;;
+
+	/* Reload the registers.
+	 * Note we must reload and recalculate everything, as the handler
+	 * may have modified the registers.
+	 */
+	restore_switch_stack STACK_SCRATCH_AREA
+
+	add	$r12 = $r12, SIZEOF_SWITCH_STACK
+	ldw	$r15 = PT_R15 + STACK_SCRATCH_AREA + SIZEOF_SWITCH_STACK[$r12]
+	;;
+	ldw	$r16 = PT_R16 + STACK_SCRATCH_AREA[$r12]
+	;;
+	ldw	$r17 = PT_R17  + STACK_SCRATCH_AREA[$r12]
+	;;
+	ldw	$r18 = PT_R18 + STACK_SCRATCH_AREA[$r12]
+	cmpgeu	$b0 = $r15, __NR_Linux_syscalls	/* $b0 = set if illegal call */
+	sh2add	$r15 = $r15, .Lsys_call_table
+	;;
+	ldw	$r19 = PT_R19 + STACK_SCRATCH_AREA[$r12]
+	slctf	$r15 = $b0, $r15, .Lsys_call_table /* entry 0 is ni_syscall */
+	;;
+	ldw	$r63 = 0[$r15]
+	;;
+	ldw	$r20 = PT_R20 + STACK_SCRATCH_AREA[$r12]
+	;;
+	ldw	$r21 = PT_R21 + STACK_SCRATCH_AREA[$r12]
+	;;
+	nop
+	;;
+	goto	$r63			/* 3 clear bundles after load */
+	mov	$r63 = syscall_exit
+	;;
+
+
+/*
+ * sys_clone(unsigned long flags, unsigned long usp)
+ * This needs to be special, so that we can push a struct switch_stack below
+ * the struct pt_regs.
+ * Remember $r12 has already been decremented by STACK_SCRATCH_AREA.
+ *
+ */
+ENTRY(sys_clone)
+	add	$r12 = $r12, -SIZEOF_SWITCH_STACK
+	;;
+
+	save_switch_stack STACK_SCRATCH_AREA
+
+	call	$r63 = st200_clone
+	;;
+	add	$r12 = $r12, SIZEOF_SWITCH_STACK
+	goto	syscall_exit
+	;;
+
+/*
+ * int sys_rt_sigreturn(struct sigcontext* sc)
+ */
+ENTRY(sys_rt_sigreturn)
+	mov	$r14 = $r16
+	add	$r17 = $r12, STACK_SCRATCH_AREA
+	call	$r63 = st200_rt_sigreturn
+	;;
+
+	restore_switch_stack SC_SS,14 /* Must be last register of switch_stack */
+
+	/*
+	 * We need this to return via restore_all, not restore syscall,
+	 * to reload all the registers set up by setup_frame()
+	 */
+	goto	syscall_exit_restore_all
+	;;
+
+/*
+ * int sys_rt_sigsuspend(sigset_t *unewset, size_t sigsetsize)
+ */
+ENTRY(sys_rt_sigsuspend)
+	add	$r12 = $r12, -SIZEOF_SWITCH_STACK
+	;;
+
+	save_switch_stack STACK_SCRATCH_AREA
+
+	call	$r63 = st200_rt_sigsuspend
+	;;
+
+	/* Result of $r0 indicates we should return via restore_all */
+	mtb	$b0 = $r16
+	mov	$r63 = syscall_exit
+	;;
+
+	/* The only register which is ever modified is $r1 (sigcontext) */
+	ldw	$r1 = SS_R1+STACK_SCRATCH_AREA[$r12]
+	slct	$r63 = $b0, $r63, syscall_exit_restore_all
+	;;
+
+	add	$r12 = $r12, SIZEOF_SWITCH_STACK
+	goto	$r63
+	;;
+
+
+
+
+	.align	4
+.Lsys_call_table:
+	.long	sys_ni_syscall		/* 0  Invalid syscalls jump here */
+	.long	sys_exit
+	.long	sys_read
+	.long	sys_write
+	.long	sys_open
+	.long	sys_close
+	.long	sys_link
+	.long	sys_unlink
+	.long	sys_execve
+	.long	sys_chdir
+	.long	sys_mknod	/* 10 */
+	.long	sys_chmod
+	.long	sys_lchown
+	.long	sys_socket
+	.long	sys_newstat
+	.long	sys_lseek
+	.long	sys_getpid
+	.long	sys_mount
+	.long	sys_bind
+	.long	sys_setuid
+	.long	sys_getuid	/* 20 */
+	.long	sys_ptrace
+	.long	sys_newfstat
+	.long	sys_utimes
+	.long	sys_connect
+	.long	sys_listen
+	.long	sys_access
+	.long	sys_accept
+	.long	sys_sync
+	.long	sys_kill
+	.long	sys_rename	/* 30 */
+	.long	sys_mkdir
+	.long	sys_rmdir
+	.long	sys_dup
+	.long	sys_pipe
+	.long	sys_times
+	.long	sys_getsockname
+	.long	sys_brk
+	.long	sys_setgid
+	.long	sys_getgid
+	.long	sys_geteuid 	/* 40 */
+	.long	sys_getegid
+	.long	sys_acct
+	.long	sys_umount
+	.long	sys_getpeername
+	.long	sys_ioctl
+	.long	sys_fcntl
+	.long	sys_socketpair
+	.long	sys_setpgid
+	.long	sys_send
+	.long	sys_newuname	/* 50 */
+	.long	sys_umask
+	.long	sys_chroot
+	.long	sys_ustat
+	.long	sys_dup2
+	.long	sys_getppid
+	.long	sys_setsid
+	.long	sys_pivot_root
+	.long	sys_setreuid
+	.long	sys_setregid
+	.long	sys_mincore	/* 60 */
+	.long	sys_sethostname
+	.long	sys_setrlimit
+	.long	sys_getrlimit
+	.long	sys_getrusage
+	.long	sys_gettimeofday
+	.long	sys_settimeofday
+	.long	sys_getgroups
+	.long	sys_setgroups
+	.long	sys_sendto
+	.long	sys_symlink	/* 70 */
+	.long	sys_newlstat
+	.long	sys_readlink
+	.long	sys_uselib
+	.long	sys_swapon
+	.long	sys_reboot
+	.long	sys_mmap2
+	.long	sys_munmap
+	.long	sys_truncate
+	.long	sys_ftruncate
+	.long	sys_fchmod	/* 80 */
+	.long	sys_fchown
+	.long	sys_getpriority
+	.long	sys_setpriority
+	.long	sys_recv
+	.long	sys_statfs
+	.long	sys_fstatfs
+	.long	sys_stat64
+	.long	sys_syslog
+	.long	sys_setitimer
+	.long	sys_getitimer	/* 90 */
+	.long	sys_capget
+	.long	sys_capset
+	.long	sys_pread64
+	.long	sys_pwrite64
+	.long	sys_getcwd
+	.long	sys_vhangup
+	.long	sys_fstat64
+	.long	sys_wait4
+	.long	sys_swapoff
+	.long	sys_sysinfo	/* 100 */
+	.long	sys_shutdown
+	.long	sys_fsync
+	.long	sys_madvise
+	.long	sys_clone
+	.long	sys_setdomainname
+	.long	sys_sendfile
+	.long	sys_recvfrom
+	.long	sys_adjtimex
+	.long	sys_mprotect
+	.long	sys_init_module		/* 110 */
+	.long	sys_delete_module
+	.long	sys_quotactl
+	.long	sys_getpgid
+	.long	sys_fchdir
+	.long	sys_bdflush
+	.long	sys_sysfs
+	.long	sys_personality
+	.long	sys_setfsuid
+	.long	sys_setfsgid
+	.long	sys_llseek		/* 120 */
+	.long	sys_getdents
+	.long	sys_select
+	.long	sys_flock
+	.long	sys_msync
+	.long	sys_readv
+	.long	sys_writev
+	.long	sys_getsid
+	.long	sys_fdatasync
+	.long	sys_sysctl
+	.long	sys_mlock		/* 130 */
+	.long	sys_munlock
+	.long	sys_mlockall
+	.long	sys_munlockall
+	.long	sys_sched_setparam
+	.long	sys_sched_getparam
+	.long	sys_sched_setscheduler
+	.long	sys_sched_getscheduler
+	.long	sys_sched_yield
+	.long	sys_sched_get_priority_max
+	.long	sys_sched_get_priority_min	/* 140 */
+	.long	sys_sched_rr_get_interval
+	.long	sys_nanosleep
+	.long	sys_mremap
+	.long	sys_setresuid
+	.long	sys_getresuid
+	.long	sys_sigaltstack
+	.long	sys_poll
+	.long	sys_nfsservctl
+	.long	sys_setresgid
+	.long	sys_getresgid		/* 150 */
+	.long	sys_prctl
+	.long	sys_rt_sigreturn
+	.long	sys_rt_sigaction
+	.long	sys_rt_sigprocmask
+	.long	sys_rt_sigpending
+	.long	sys_rt_sigtimedwait
+	.long	sys_rt_sigqueueinfo
+	.long	sys_rt_sigsuspend
+	.long	sys_chown
+	.long	sys_setsockopt		/* 160 */
+	.long	sys_getsockopt
+	.long	sys_sendmsg
+	.long	sys_recvmsg
+	.long	sys_semop
+	.long	sys_semget
+	.long	sys_semctl
+	.long	sys_msgsnd
+	.long	sys_msgrcv
+	.long	sys_msgget
+	.long	sys_msgctl	/* 170 */
+	.long	st200_shmat
+	.long	sys_shmdt
+	.long	sys_shmget
+	.long	sys_shmctl
+	.long	sys_lstat64
+	.long	sys_truncate64
+	.long	sys_ftruncate64
+	.long	sys_getdents64
+	.long	sys_fcntl64
+	.long	sys_gettid	/* 180 */
+	.long	sys_readahead
+	.long  	sys_setxattr
+	.long 	sys_lsetxattr
+	.long 	sys_fsetxattr
+	.long 	sys_getxattr
+	.long 	sys_lgetxattr
+	.long 	sys_fgetxattr
+	.long 	sys_listxattr
+	.long 	sys_llistxattr
+	.long 	sys_flistxattr 	/* 190 */
+	.long 	sys_removexattr
+	.long 	sys_lremovexattr
+	.long 	sys_fremovexattr
+	.long 	sys_sendfile64
+	.long	sys_tkill
+	.long   sys_tgkill
+	.long	sys_restart_syscall
+	.long   sys_semtimedop
+	.long   sys_set_tid_address
+	.long   sys_sched_setaffinity /* 200 */
+	.long   sys_sched_getaffinity
+	.long   sys_futex
+	.long	sys_exit_group
+	.long 	sys_io_setup
+	.long 	sys_io_destroy
+	.long 	sys_io_getevents
+	.long 	sys_io_submit
+	.long 	sys_io_cancel
+	.long 	sys_lookup_dcookie
+	.long 	sys_epoll_create  /* 210 */
+	.long 	sys_epoll_ctl
+	.long 	sys_epoll_wait
+	.long   sys_mbind
+	.long   sys_get_mempolicy
+	.long   sys_set_mempolicy
+	.long 	sys_remap_file_pages
+	.long 	st200_fadvise64_64
+	.long 	sys_statfs64
+	.long 	sys_fstatfs64
+	.long 	sys_waitid	/* 220 */
+	.long 	sys_mq_open
+	.long 	sys_mq_unlink
+	.long 	sys_mq_timedsend
+	.long 	sys_mq_timedreceive
+	.long 	sys_mq_notify
+	.long 	sys_mq_getsetattr
+	.long 	sys_timer_create
+	.long 	sys_timer_settime
+	.long 	sys_timer_gettime
+	.long 	sys_timer_getoverrun	/* 230 */
+	.long 	sys_timer_delete
+	.long 	sys_clock_settime
+	.long 	sys_clock_gettime
+	.long 	sys_clock_getres
+	.long 	sys_clock_nanosleep
+	.long   sys_ni_syscall  /* Reserved for sys_kexec_load */
+	.long   sys_add_key
+	.long   sys_request_key
+	.long   sys_keyctl
+
+
+
+
+
diff --git a/arch/st200/kernel/time.c b/arch/st200/kernel/time.c
new file mode 100644
index 0000000..ce809be
--- /dev/null
+++ b/arch/st200/kernel/time.c
@@ -0,0 +1,218 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/clockchips.h>
+#include <linux/clocksource.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include "irq_st200.h"
+
+/*
+ * Offsets from base of interrupt controller. Fix!!!
+ */
+#define TIMER_BASE(n) (((n) * 0x18) + 0x0200)
+#define TIME_CONST(n) (TIMER_BASE(n) + 0x00)
+#define TIME_COUNT(n) (TIMER_BASE(n) + 0x08)
+#define TIME_CONTROL(n) (TIMER_BASE(n) + 0x10)
+
+#define TIME_DIVIDE   0x0248	/* Timer divide */
+
+/* TMU registers are effectively part of the interrupt controller */
+
+#define timer_write(num, reg) writel(num, st200_irq_base + (reg))
+#define timer_read(reg) readl(st200_irq_base + (reg))
+
+#define TIME_CONTROL_ENABLE 	(1 << 0)
+#define TIME_CONTROL_INTENABLE 	(1 << 1)
+#define TIME_CONTROL_STATUS	(1 << 2)
+
+static void timer_start(int timer)
+{
+	/* Start timer, enable interrupts, clear any status */
+	timer_write(TIME_CONTROL_ENABLE | TIME_CONTROL_INTENABLE |
+		    TIME_CONTROL_STATUS, TIME_CONTROL(timer));
+}
+
+/* Start the timer, but don't generate irqs from it. Used for free running
+ * timers
+ */
+static void timer_start_no_irq(int timer)
+{
+	/* Start timer, enable interrupts, clear any status */
+	timer_write(TIME_CONTROL_ENABLE | TIME_CONTROL_STATUS,
+		    TIME_CONTROL(timer));
+}
+
+static void timer_set_interval(int timer, unsigned long interval)
+{
+	timer_write(interval - 1, TIME_COUNT(timer));
+	timer_write(interval - 1, TIME_CONST(timer));
+}
+
+static void timer_stop(int timer)
+{
+	timer_write(TIME_CONTROL_STATUS, TIME_CONTROL(timer));
+}
+
+static cycle_t timer1_read(struct clocksource *cs)
+{
+	/*  Note the ~, as the clock count DOWN not up */
+	return ~timer_read(TIME_COUNT(1));
+}
+
+/* Dummy function */
+static cycle_t null_timer_read(struct clocksource *cs)
+{
+	return 0;
+}
+
+static int timer_set_next_event(unsigned long cycles,
+				struct clock_event_device *evt)
+{
+	timer_set_interval(0, cycles);
+	timer_start(0);
+
+	return 0;
+}
+
+static void timer_set_mode(enum clock_event_mode mode,
+			   struct clock_event_device *evt)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_ONESHOT:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		timer_stop(0);
+		break;
+	case CLOCK_EVT_MODE_PERIODIC:
+	case CLOCK_EVT_MODE_RESUME:
+		timer_start(0);
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+		break;
+	}
+}
+
+static struct clock_event_device timer0_clockevent = {
+	.name = "timer0",
+	.shift = 32,
+	.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.set_mode = timer_set_mode,
+	.set_next_event = timer_set_next_event
+};
+
+irqreturn_t timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &timer0_clockevent;
+
+	if (evt->mode == CLOCK_EVT_MODE_ONESHOT) {
+		timer_stop(0);
+	} else {
+		timer_start(0);
+	}
+
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction irq0 = {
+	.handler = timer_interrupt,
+	.flags = IRQF_DISABLED | IRQF_TIMER,
+	.name = "timer"
+};
+
+/*
+ * This needs to be BINNED. Replace with clock framework
+ */
+
+/* YUCK YUCK YUCK */
+#if defined(CONFIG_SOC_STV576)
+#define PERIPHERAL_CLK_FREQ	240	/* MHz */
+#elif defined(CONFIG_SOC_SIMULATOR)
+#define PERIPHERAL_CLK_FREQ	1	/* MHz */
+#elif defined(CONFIG_BOARD_MB427)
+#define PERIPHERAL_CLK_FREQ	65	/* MHz */
+#else
+#error NO TIMER CLOCK SPEED SELECTED!!!
+#endif
+
+struct clocksource timer_clocksource = {
+	.name = "ST200 timer",
+	.rating = 200,
+	.mask = CLOCKSOURCE_MASK(32),
+	.read = null_timer_read,
+	.shift = 16,
+	.flags = CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+/* Copied shamelessly from SH, which was copied shamelessly from
+ * MIPS and SPARC....
+ */
+static unsigned long timer_ticks_per_nsec_quotient __read_mostly;
+#define NSEC_PER_CYC_SHIFT 	10
+
+/* This overrides the default __weak function.
+ * Unfortunately, sched_clock() is called BEFORE time_init,
+ * To get around this, the .read function is set to a dummy
+ * function until we flip it to the real one in time_init()
+ */
+unsigned long long sched_clock(void)
+{
+	unsigned long long ticks = timer_clocksource.read(&timer_clocksource);
+
+	return (ticks * timer_ticks_per_nsec_quotient) >> NSEC_PER_CYC_SHIFT;
+}
+
+#define TIMER_IRQ 0
+
+void __init time_init(void)
+{
+	int i;
+	int ret;
+	unsigned long frequency = PERIPHERAL_CLK_FREQ * 1000000;
+	unsigned long interval = (frequency + HZ / 2) / HZ;
+
+	/* We can't use request_irq() as we are still too early */
+	ret = setup_irq(TIMER_IRQ, &irq0);
+
+	/* Just tick as fast as we can */
+	timer_write(0, TIME_DIVIDE);
+
+	/* Clear any outstanding interrupts */
+	for (i = 0; i < 3; i++)
+		timer_stop(i);
+
+	timer0_clockevent.mult =
+	    div_sc(frequency, NSEC_PER_SEC, timer0_clockevent.shift);
+
+	timer0_clockevent.max_delta_ns =
+	    clockevent_delta2ns(~0, &timer0_clockevent);
+
+	timer0_clockevent.min_delta_ns =
+	    clockevent_delta2ns(1, &timer0_clockevent);
+
+	timer0_clockevent.cpumask = cpumask_of(0);
+
+	/* Does not actually set the clock ticking */
+	timer_set_interval(0, interval);
+
+	/* This ends up calling timer_set_mode() which will set it ticking */
+	clockevents_register_device(&timer0_clockevent);
+
+	/* Now we need to configure timer1 as a free running timer */
+
+	/* Will do maximal count down when it hits zero */
+	timer_set_interval(1, ~0);
+	timer_start_no_irq(1);
+
+	timer_clocksource.mult =
+	    clocksource_hz2mult(frequency, timer_clocksource.shift);
+
+	timer_ticks_per_nsec_quotient =
+	    clocksource_hz2mult(frequency, NSEC_PER_CYC_SHIFT);
+
+	/* Now we have the real function */
+	timer_clocksource.read = timer1_read;
+
+	ret = clocksource_register(&timer_clocksource);
+}
diff --git a/arch/st200/kernel/traps.c b/arch/st200/kernel/traps.c
new file mode 100644
index 0000000..4847507
--- /dev/null
+++ b/arch/st200/kernel/traps.c
@@ -0,0 +1,734 @@
+/*
+ * linux/arch/st200/kernel/traps.c
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: David J. Mckay <david.mckay@st.com>
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/kallsyms.h>
+#include <linux/module.h>
+#include <linux/hardirq.h>
+
+#include <asm/ctrlregdef.h>
+#include <asm/io.h>
+#include <asm/syscallparams.h>
+#include <asm/uaccess.h>
+#include <linux/dma-mapping.h>
+
+#include "ptrace.h"
+
+#undef DEBUG
+//#define DEBUG
+
+extern void sim_exit(int code);
+
+static void dump_mem(const char *str, unsigned long bottom, unsigned long top)
+{
+	unsigned long first;
+	int i;
+
+	printk(KERN_NOTICE "%s(0x%08lx to 0x%08lx)\n", str, bottom, top);
+
+	for (first = bottom & ~31; first < top; first += 32) {
+		unsigned long p;
+		char str[sizeof(" 12345678") * 8 + 1];
+
+		memset(str, ' ', sizeof(str));
+		str[sizeof(str) - 1] = '\0';
+
+		for (p = first, i = 0; i < 8 && p < top; i++, p += 4) {
+			if (p >= bottom && p < top) {
+				unsigned long val;
+
+				if (__get_user(val, (unsigned int __user *)p) == 0)
+					sprintf(str + i * 9, " %08lx", val);
+				else
+					sprintf(str + i * 9, " ????????");
+			}
+		}
+
+		printk(KERN_NOTICE "%04lx:%s\n", first & 0xffff, str);
+	}
+}
+
+/*
+ * Stack unwinding is always going to a be a unreliable on the
+ * ST200 as we don't have a frame pointer.
+ * This is the quick and dirty version: simply assume all
+ * pointers on the stack into code are return pointers.
+ */
+void st200_show_stack_trace(unsigned long *sp)
+{
+	unsigned long addr;
+
+	printk(KERN_NOTICE "Call Trace:");
+	while (((unsigned long)sp & (THREAD_SIZE - 1)) != 0) {
+		addr = *sp++;
+		if (kernel_text_address(addr)) {
+			printk(KERN_NOTICE " [<%08lx>] %pS\n",
+			       addr, (void*)addr);
+		}
+	}
+	printk(KERN_NOTICE "\n");
+}
+
+void show_stack(struct task_struct *task, unsigned long *sp)
+{
+	unsigned long stack = (unsigned long) sp;
+	register unsigned long current_sp __asm("r12");
+
+	if (!task)
+		task = current;
+
+	if (!stack)
+		stack = (task == current) ? current_sp
+					  : task->thread.sp;
+
+	dump_mem("Stack: ", stack, THREAD_SIZE +
+		 (unsigned long)task_stack_page(task));
+
+	printk(KERN_NOTICE "\n");
+
+	st200_show_stack_trace((unsigned long *)stack);
+}
+
+void dump_stack(void)
+{
+	show_stack(NULL, NULL);
+}
+
+void st200_show_regs(struct pt_regs *regs, struct switch_stack *ss)
+{
+	int r;
+	unsigned long *rp;
+	int i;
+
+	printk(" pc=%08lx  psw=%08lx                  %s\n",
+	       regs->pc, regs->psw, print_tainted());
+	printk(" br=%02lx (", regs->br & 0xff);
+	for (r = 0; r < 8; r++) {
+		printk("br%d=%ld%s", r, (regs->br >> r) & 1,
+		       (r == 7) ? ")\n" : " ");
+	}
+	if (ss) {
+		printk(" r0 =zero      r1 =%08lx  r2 =%08lx  r3 =%08lx\n",
+		       ss->r1, ss->r2, ss->r3);
+		printk(" r4 =%08lx  r5 =%08lx  r6 =%08lx  r7 =%08lx\n",
+		       ss->r4, ss->r5, ss->r6, ss->r7);
+		printk(" r8 =%08lx  r9 =%08lx  r10=%08lx  r11=%08lx\n",
+		       regs->r8, regs->r9, regs->r10, regs->r11);
+		printk(" r12=%08lx  r13=%08lx  r14=%08lx  r15=%08lx\n",
+		       regs->r12, ss->r13, ss->r14, regs->r15);
+	} else {
+		for (i = 0; i < 8; i++) {
+			printk(" r%d =%s ", i,
+			       (i == 0) ? "zero    " : "********");
+			if (i == 3)
+				printk("\n");
+		}
+		printk("\n r8 =%08lx  r9 =%08lx  r10=%08lx  r11=%08lx\n",
+		       regs->r8, regs->r9, regs->r10, regs->r11);
+		printk(" r12=%08lx  r13=********  r14=********  r15=%08lx\n",
+		       regs->r12, regs->r15);
+	}
+
+	for (r = 16, rp = &regs->r16; r < 60; r += 4, rp += 4) {
+		printk(" r%d=%08lx  r%d=%08lx  r%d=%08lx  r%d=%08lx\n",
+		       r, rp[0], r + 1, rp[1], r + 2, rp[2], r + 3, rp[3]);
+	}
+	printk(" r60=%08lx  r61=%08lx  r62=%08lx  r63=%08lx\n",
+	       regs->r60, regs->r61, regs->r62, regs->lr);
+}
+
+
+void __init trap_init(void)
+{
+	extern void st200_trap_handler(void);
+
+	ctrl_outl((unsigned long)st200_trap_handler, HANDLER_PC);
+}
+
+void
+st200_stbus_error(unsigned long cause, unsigned tlb_cause, unsigned long addr,
+		  int arg4,
+		  int arg5, int arg6, int arg7, int arg8,
+		  struct syscallparams_ss params)
+{
+	die("STBUS Error", &params.regs);
+}
+
+void
+st200_illegal_instruction(unsigned long cause, unsigned tlb_cause,
+			  unsigned long addr, int arg4, int arg5, int arg6,
+			  int arg7, int arg8, struct syscallparams_ss params)
+{
+	siginfo_t info;
+	struct pt_regs *regs = &params.regs;
+
+	/* We could provide more information here, by decoding the instruction */
+	info.si_signo = SIGILL;
+	info.si_errno = 0;
+	info.si_code = ILL_ILLOPC;
+	info.si_addr = (void *)regs->pc;
+
+	force_sig_info(SIGILL, &info, current);
+
+	die_if_kernel("Illegal instruction", regs);
+}
+
+void
+st200_dbreak(unsigned long cause, unsigned tlb_cause, unsigned long addr,
+	     int arg4,
+	     int arg5, int arg6, int arg7, int arg8,
+	     struct syscallparams_ss params)
+{
+	siginfo_t info;
+
+#ifdef CONFIG_KGDB
+	kgdb_exception_handler(&params.regs);
+#else
+	ptrace_cancel_step(current);
+
+	info.si_signo = SIGTRAP;
+	info.si_errno = 0;
+	info.si_code = TRAP_BRKPT;
+	info.si_trapno = 0;
+	info.si_addr = (void *)params.regs.pc;
+
+	send_sig_info(SIGTRAP, &info, current);
+#endif
+}
+
+void
+st200_sbreak(unsigned long cause, unsigned tlb_cause, unsigned long addr,
+	     int arg4,
+	     int arg5, int arg6, int arg7, int arg8,
+	     struct syscallparams_ss params)
+{
+	siginfo_t info;
+
+#ifdef CONFIG_KGDB
+	kgdb_exception_handler(&params.regs);
+#else
+	ptrace_cancel_step(current);
+
+	info.si_signo = SIGTRAP;
+	info.si_errno = 0;
+	info.si_code = TRAP_BRKPT;
+	info.si_trapno = 0;
+	info.si_addr = (void *)params.regs.pc;
+
+	send_sig_info(SIGTRAP, &info, current);
+#endif
+	return;
+}
+
+#define MAIN_FORMAT_MASK ( (1<<29)|(1<<28) )
+#define MAIN_FORMAT(x) (((x)&MAIN_FORMAT_MASK)>>28)
+#define STOP_BIT (1<<31)
+
+#define FORMAT_LOAD_STORE_OPC_MASK ( 0x1f<<23)
+#define FORMAT_LOAD_STORE_OPC(x) (((x)&FORMAT_LOAD_STORE_OPC_MASK)>>23)
+
+#define FORMAT_CALL_OPC_MASK ( 0xf<<23)
+#define FORMAT_CALL_OPC(x) (((x)&FORMAT_CALL_OPC_MASK)>>23)
+
+#define FORMAT_BRANCH_OPC_MASK (0x1<<26)
+#define FORMAT_BRANCH_OPC(x)  (((x)&FORMAT_BRANCH_OPC_MASK)>>26)
+
+#define BCOND_MASK (0x7<<23)
+#define BCOND(x) (((x)&BCOND_MASK)>>23)
+
+#define SRC2_MASK  (0x3f<<6)
+#define SRC2(x)  ( ((x)&SRC2_MASK)>>6)
+
+enum load_store_ins { ldw, ldw_d, ldh, ldh_d, ldhu, ldhu_d, ldb, ldb_d, ldbu,
+	    ldbu_d,
+	stw, sth, stb, pft, prgadd, prgset, sync
+};
+
+enum call_ins { call, call_lr, go_to, go_to_lr };
+
+#define BTARG_MASK 0x7fffff
+#define BTARG(x) ((x)&BTARG_MASK)
+
+#define IMM_MASK 0x7fffff
+#define IMM(x) ((x)&IMM_MASK)
+
+#define SIGN_EXTEND(x,n) (  ((x)&1<<n) ? ((x)| (~((1<<n)-1))) : (x) )
+
+/* if pt_regs changes you must change this as well */
+static unsigned get_register_value(struct pt_regs *pt_regs,
+				   struct switch_stack *switch_regs, int reg)
+{
+	unsigned *pt8_12 = ((unsigned *)pt_regs) + 4;
+	unsigned *pt15_62 = ((unsigned *)pt_regs) + 9;
+	unsigned *ss = (unsigned *)switch_regs;
+
+	if (reg == 0)
+		return 0;
+	if (reg == 63)
+		return pt_regs->lr;
+
+	if (reg < 8)
+		return ss[reg - 1];
+
+	if (reg <= 12)
+		return pt8_12[reg - 8];
+
+	/* 13 and 14 are now in switch stack */
+	if (reg < 15)
+		return ss[reg - 13 + 7];
+
+	return pt15_62[reg - 15];
+}
+
+#define ADD_IMMEDIATE_OPCODE(dest_reg) ( (1<<27) | ((dest_reg)<<6 ) )
+#define IMML_OPCODE ( (1<<28) | (0xa<<23))
+#define IMMR_OPCODE ( (1<<28) | (0xb<<23))
+
+#define RFI_OPCODE ((0x32)<<24)
+#define NOP_OPCODE 0		/* add $r0=$r0,$r0 */
+
+static unsigned *generate_mov(unsigned *olex_area, int load_reg, unsigned value)
+{
+	unsigned immed = ((value & 0x1ff) << 12);
+	unsigned extend = IMM(value >> 9);
+
+	/* Do we have to generate an imml, or an immr?
+	 * This depends on the alignment of where you are generating to
+	 */
+	if (((unsigned)olex_area) & (1 << 2)) {
+		olex_area[0] = ADD_IMMEDIATE_OPCODE(load_reg) | immed;
+		olex_area[1] = STOP_BIT | IMML_OPCODE | extend;
+	} else {
+		olex_area[0] = IMMR_OPCODE | extend;
+		olex_area[1] =
+		    STOP_BIT | ADD_IMMEDIATE_OPCODE(load_reg) | immed;
+	}
+
+	return olex_area + 2;
+}
+
+static unsigned generate_olex_bundle(struct pt_regs *regs,
+				     struct switch_stack *switch_regs,
+				     unsigned *olex_area_start,
+				     unsigned bundle_pc, unsigned ibuffer[4],
+				     unsigned address)
+{
+	unsigned raw_ins;
+	unsigned iptr = bundle_pc;
+	int i;
+	enum load_store_ins ins;
+	unsigned value;
+	u16 value16;
+	signed btarg;
+	int take_jump = 0;
+	int new_r63 = 0;
+	int syllable;
+	int load = 0;
+	int load_reg;
+	unsigned *olex_area = olex_area_start;
+	unsigned *p;
+	unsigned new_pc;
+
+	/* The executed bundle MUST run with the correct value of r63,
+	 * we have to restore it because it will be wrong when we start
+	 * to execute this code
+	 */
+	olex_area = generate_mov(olex_area, 63, regs->lr);
+
+	/* We must preserve the alignment of the bundle */
+	if (((iptr) & 4) != (((unsigned)olex_area) & 4)) {
+		*olex_area++ = NOP_OPCODE | STOP_BIT;
+	}
+
+	/* We know this instruction must be legal, so we just scan for the stop bit */
+	for (syllable = 0; syllable < 4; syllable++) {
+		raw_ins = ibuffer[syllable];
+
+		switch (MAIN_FORMAT(raw_ins)) {
+		case 0:
+		case 1:
+			/* This is a normal instruction, we just copy it straight through */
+			*olex_area++ = raw_ins;
+			break;
+		case 2:
+			/* This is a load or store. We analyse it, to figure out what sort
+			 * of store this is, and then copy an add immediate r0 into the output.
+			 * the choice of an add immediate means that if the store is extended,
+			 * then it will still be correct.
+			 */
+			ins = FORMAT_LOAD_STORE_OPC(raw_ins);
+			load = 1;
+			load_reg = SRC2(raw_ins);
+			/* Add immediate zero, note we have to copy the stop bit */
+			*olex_area++ =
+			    (raw_ins & STOP_BIT) | ADD_IMMEDIATE_OPCODE(0);
+
+			switch (ins) {
+				/* Sure we could do something smarter here surely */
+			case ldw:
+				/* Can we access this address at all ? */
+				if (copy_from_user
+				    (&value, (unsigned char *)address, 4))
+					return ~0;
+				break;
+			case ldh:
+				if (copy_from_user
+				    (&value16, (unsigned char *)address, 2))
+					return ~0;
+				value = (s16) value16;
+				break;
+				/* As above, but does not sign extend */
+			case ldhu:
+				if (copy_from_user
+				    (&value16, (unsigned char *)address, 2))
+					return ~0;
+				value = value16;
+				break;
+			case stw:
+				load = 0;
+				value =
+				    get_register_value(regs, switch_regs,
+						       load_reg);
+				if (copy_to_user
+				    ((unsigned char *)address, &value, 4))
+					return ~0;
+				break;
+			case sth:
+				load = 0;
+				value =
+				    get_register_value(regs, switch_regs,
+						       load_reg);
+				if (copy_to_user
+				    ((unsigned char *)address, &value, 2))
+					return ~0;
+				break;
+			case ldw_d:
+			case ldh_d:
+			case ldhu_d:
+				panic
+				    ("Speculative misaligned load - PC was 0x%x\n",
+				     bundle_pc);
+				break;
+			default:
+				/* If we get here, we are screwed. This should NEVER happen */
+				panic
+				    ("Unfixable misaligned exception - PC was 0x%x\n",
+				     bundle_pc);
+				break;
+			}
+
+			break;
+		case 3:
+			/* This is a jump instruction. We have to remove this from the bundle,
+			 * decode it and emulate the effect when we do the restore sequence
+			 */
+
+			/* Change to NOP, copy through stop bit. Cannot be extended, so add $r0=$r0,r0 is OK */
+			*olex_area++ = NOP_OPCODE | (raw_ins & STOP_BIT);
+
+			btarg = SIGN_EXTEND(BTARG(raw_ins), 22);	/* Add this to the PC to get new PC value */
+			btarg <<= 2;	/* Signed shift */
+
+			/* Is this a brf or br, or a call type? */
+			if (raw_ins & (1 << 27)) {
+				unsigned bcond = BCOND(raw_ins);
+				int br;
+
+				/* It is a br */
+				bcond = BCOND(raw_ins);
+				/* Extract the correct branch bit from the saved state */
+				br = ((regs->br) & (1 << bcond)) >> bcond;
+
+				/* if brf, we branch on false */
+				if (FORMAT_BRANCH_OPC(raw_ins) == 1)
+					br = !br;
+
+				if (br) {
+					take_jump = 1;
+					new_pc = bundle_pc + btarg;
+				}
+			} else {
+				take_jump = 1;	/* we are definately jumping */
+				/* Must be a call or a goto or god forbid an rfi */
+				switch (FORMAT_CALL_OPC(raw_ins)) {
+				case call:
+					new_pc = bundle_pc + btarg;
+					new_r63 = 1;
+					break;
+				case call_lr:
+					new_pc = regs->lr;
+					new_r63 = 1;
+					break;
+				case go_to:
+					new_pc = bundle_pc + btarg;
+					break;
+				case go_to_lr:
+					new_pc = regs->lr;
+					break;
+				default:
+					panic
+					    ("Unfixable misaligned (rfi in bundle) -  PC was 0x%x\n",
+					     bundle_pc);
+					break;
+				}
+			}
+		}
+
+		iptr += 4;	/* Shift onto next instruction */
+		/* is the stop bit set - if so we are done! */
+		if (raw_ins & STOP_BIT)
+			break;
+
+	}
+
+	if (syllable == 4) {
+		panic
+		    ("Unfixable misaligned (too many syllables) -  PC was 0x%x\n",
+		     bundle_pc);
+	}
+
+	/* We have to update r63 with a new value if the bundle had a call,
+	 */
+	if (new_r63) {
+		olex_area = generate_mov(olex_area, 63, iptr);
+	}
+
+	/* Now update register set with correct value, if we did a load */
+	if (load) {
+		olex_area = generate_mov(olex_area, load_reg, value);
+	}
+
+	*olex_area++ = STOP_BIT | RFI_OPCODE;	/* Generate an rfi */
+
+	/* Flush all the caches */
+	/* We can do this more effeciently with prginspg */
+	st200_flush_dcache_range(olex_area_start,
+				 (olex_area - olex_area_start) * 4);
+
+__asm__(" prginspg 0[%0]\n":	/* No output */
+:"r"(virt_to_phys(olex_area_start) | ((((unsigned)olex_area_start) & 0x6000) >> 13))
+:"memory");
+
+	//  st200_flush_icache_all();
+
+	return (take_jump) ? new_pc : iptr;
+
+}
+
+unsigned st200_misaligned(struct pt_regs *regs,
+			  struct switch_stack *switch_regs, unsigned *olex_area,
+			  unsigned bundle_pc, unsigned address, int atomic)
+{
+	const struct exception_table_entry *fixup;
+	siginfo_t info;
+	mm_segment_t old_fs = get_fs();
+	unsigned long new_pc;
+	unsigned long ibuffer[4];
+	int i;
+	extern int exit_on_idle;
+
+	if (user_mode(regs)) {
+		/* Can't fixup misaligned atomic sequences, so die */
+		if (atomic) {
+			printk("Ukk, killing unaligned atomic access\n");
+			goto fail;
+		}
+		printk
+		    ("Fixing up misaligned acccess to 0x%08x from pc 0x%08x\n",
+		     address, bundle_pc);
+		/* Force interrupts back on so if we have to fault things in it
+		 * will actually work
+		 */
+		local_irq_enable();
+
+		set_fs(USER_DS);
+
+	} else {
+		if (atomic) {
+			panic
+			    ("cannot fixup misaligned loads in atomic sequences - pc is 0x%08x\n",
+			     bundle_pc);
+		}
+
+		/* We need to search the exception tables, as if the error is there
+		 * we do no attempt to fix it up, but simply jump to the error
+		 * handler.
+		 */
+		if ((fixup = search_exception_tables(regs->pc)) != 0) {
+			/* Nobble return PC, then indicate we fail */
+			regs->pc = fixup->fixup;
+			return ~0;
+		}
+		/* Disable range checking on access_ok */
+		set_fs(KERNEL_DS);
+	}
+
+	/* Now copy out the instructions using copy_user, a word at a time, until we see a stop
+	 * bit in the instruction.
+	 */
+	for (i = 0; i < 4; i++) {
+		if (get_user(ibuffer[i], (unsigned *)bundle_pc + i)) {
+			/* Oh dear, you can't access the instruction. This should never happen, otherwise
+			 * how did you get the fault in the first place?
+			 */
+			goto fail;
+		}
+		/* Look for the stop bit */
+		if (ibuffer[i] & STOP_BIT)
+			break;
+	}
+
+	/* We have managed to get an instruction without a stop bit. How ? */
+	if (i == 4)
+		goto fail;
+
+	new_pc =
+	    generate_olex_bundle(regs, switch_regs, olex_area, bundle_pc,
+				 ibuffer, address);
+
+	if (new_pc == ~0)
+		goto fail;
+
+	set_fs(old_fs);
+
+	return new_pc;
+
+fail:
+	set_fs(old_fs);
+
+	if (!user_mode(regs)) {
+		die("Misaligned instruction fixup failure", regs);
+	}
+
+	printk("Misaligned fixup failure, sending a SIGBUS to user code\n");
+
+	/* Send a SIGBUS */
+	info.si_signo = SIGBUS;
+	info.si_errno = 0;
+	info.si_code = BUS_ADRALN;
+	info.si_addr = (void *)address;
+	force_sig_info(SIGBUS, &info, current);
+
+	//exit_on_idle=1;
+	/* We go through the normal return sequence */
+	return ~0;
+}
+
+extern void do_page_fault(struct pt_regs *regs, unsigned long address,
+			  unsigned long cause, unsigned long tlb_cause);
+
+void st200_tlb(unsigned long cause, unsigned tlb_cause, unsigned long addr,
+	       int arg4,
+	       int arg5, int arg6, int arg7, int arg8,
+	       struct syscallparams params)
+{
+	struct pt_regs *regs = &params.regs;
+
+#ifdef DEBUG
+	printk
+	    ("IN %s FAULT HANDLER!! address 0x%08lx, TLB_EXCAUSE 0x%08lx, EXCAUSE 0x%08x\n",
+	     (cause == EXCAUSENO_ITLB) ? "ITLB" : (cause ==
+						   EXCAUSENO_DTLB) ? "DTLB" :
+	     "unknown", addr, tlb_cause, cause);
+	printk("Saved pc %08lx, psw %08lx\n", regs->pc, regs->psw);
+#endif
+	if ((tlb_cause & TLB_EXCAUSE_CAUSE_MASK) ==
+	    TLB_EXCAUSE_CAUSE_MULTI_MAPPING) {
+		panic("Multi-mapping");
+	}
+	do_page_fault(regs, addr, cause, tlb_cause);
+
+}
+
+void
+st200_sdi_timeout(unsigned long cause, unsigned tlb_cause, unsigned long addr,
+		  int arg4,
+		  int arg5, int arg6, int arg7, int arg8,
+		  struct syscallparams_ss params)
+{
+	die("SDI timeout", &params.regs);	/* How should these be handled ?? */
+}
+
+void
+st200_creg_violation(unsigned long cause, unsigned tlb_cause,
+		     unsigned long addr, int arg4, int arg5, int arg6, int arg7,
+		     int arg8, struct syscallparams_ss params)
+{
+	siginfo_t info;
+	struct pt_regs *regs = &params.regs;
+
+	info.si_signo = SIGSEGV;
+	info.si_errno = 0;
+	info.si_code = SEGV_MAPERR;
+	info.si_addr = (void *)addr;
+
+	force_sig_info(SIGSEGV, &info, current);
+
+	die_if_kernel("CREG violation", regs);
+}
+
+void
+st200_error(unsigned long cause, unsigned tlb_cause, unsigned long addr,
+	    int arg4,
+	    int arg5, int arg6, int arg7, int arg8,
+	    struct syscallparams_ss params)
+{
+	die("Illegal Trap", &params.regs);
+}
+
+static void __die(const char *str, struct thread_info *thread, struct pt_regs *regs)
+{
+	struct task_struct *tsk = thread->task;
+	static int die_counter;
+
+	printk(KERN_EMERG "Internal error: %s: [#%d]\n",
+	       str, ++die_counter);
+	sysfs_printk_last_file();
+	print_modules();
+	st200_show_regs(regs, NULL);
+	printk(KERN_EMERG "Process %.*s (pid: %d, stack limit = 0x%p)\n",
+		TASK_COMM_LEN, tsk->comm, task_pid_nr(tsk), thread + 1);
+
+	if (!user_mode(regs) || in_interrupt()) {
+		show_stack(NULL, (unsigned long *)regs->r12);
+	}
+}
+
+DEFINE_SPINLOCK(die_lock);
+
+void die(const char *str, struct pt_regs *regs)
+{
+	struct thread_info *thread = current_thread_info();
+
+	oops_enter();
+
+	spin_lock_irq(&die_lock);
+	console_verbose();
+	bust_spinlocks(1);
+	__die(str, thread, regs);
+	bust_spinlocks(0);
+	add_taint(TAINT_DIE);
+	spin_unlock_irq(&die_lock);
+	oops_exit();
+
+	if (in_interrupt())
+		panic("Fatal exception in interrupt");
+
+	if (panic_on_oops)
+		panic("Fatal exception");
+
+	do_exit(SIGSEGV);
+}
+
+void die_if_kernel(const char *str, struct pt_regs *regs)
+{
+	if (user_mode(regs))
+		return;
+	die(str, regs);
+}
diff --git a/arch/st200/kernel/vdso.c b/arch/st200/kernel/vdso.c
new file mode 100644
index 0000000..83b6cd4
--- /dev/null
+++ b/arch/st200/kernel/vdso.c
@@ -0,0 +1,304 @@
+/*
+ * linux/arch/st200/kernel/vdso.c
+ *
+ * Copyright (C) 2010 STMicroelectronics Limited
+ *	Author: Stephen Clarke <stephen.clarke@st.com>
+ *
+ * Based on arch/powerpc/kernel/vdso.c
+ */
+
+#include <linux/mm.h>
+#include <linux/elf.h>
+#include <asm/vdso.h>
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(fmt...) printk(fmt)
+#else
+#define DBG(fmt...)
+#endif
+
+/* Max supported size for symbol names */
+#define MAX_SYMNAME	64
+
+/* The alignment of the vDSO */
+#define VDSO_ALIGNMENT	PAGE_SIZE
+
+extern char vdso_start, vdso_end;
+static void *vdso_kbase = &vdso_start;
+static unsigned int vdso_pages;
+static struct page **vdso_pagelist;
+unsigned long vdso_sigrestorer;
+
+static int vdso_ready;
+
+/*
+ * Some infos carried around for each of them during parsing at
+ * boot time.
+ */
+struct lib32_elfinfo {
+	Elf32_Ehdr *hdr;	/* ptr to ELF */
+	Elf32_Sym *dynsym;	/* ptr to .dynsym section */
+	unsigned long dynsymsize;	/* size of .dynsym section */
+	char *dynstr;		/* ptr to .dynstr section */
+	unsigned long text;	/* offset of .text section in .so */
+};
+
+#ifdef DEBUG
+static void dump_one_vdso_page(struct page *pg, struct page *upg)
+{
+	printk(KERN_DEBUG "kpg: %p (c:%d,f:%08lx)",
+	       __va(page_to_pfn(pg) << PAGE_SHIFT), page_count(pg), pg->flags);
+	if (upg && !IS_ERR(upg) /* && pg != upg */) {
+		printk(KERN_DEBUG " upg: %p (c:%d,f:%08lx)",
+		       __va(page_to_pfn(upg)
+			    << PAGE_SHIFT), page_count(upg), upg->flags);
+	}
+	printk(KERN_DEBUG "\n");
+}
+
+static void dump_vdso_pages(struct vm_area_struct *vma)
+{
+	int i;
+
+	printk(KERN_DEBUG "vDSO @ %016lx:\n", (unsigned long)vdso_kbase);
+	for (i = 0; i < vdso_pages; i++) {
+		struct page *pg = virt_to_page(vdso_kbase + i * PAGE_SIZE);
+		struct page *upg = (vma && vma->vm_mm)
+		    ? follow_page(vma, vma->vm_start + i * PAGE_SIZE, 0)
+		    : NULL;
+		dump_one_vdso_page(pg, upg);
+	}
+}
+#endif /* DEBUG */
+
+/*
+ * This is called from binfmt_elf, we create the special vma for the
+ * vDSO and insert it into the mm struct tree
+ */
+int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
+{
+	struct mm_struct *mm = current->mm;
+	unsigned long vdso_base;
+	int rc;
+
+	if (!vdso_ready)
+		return 0;
+
+	current->mm->context.vdso = 0;
+
+	/* vDSO has a problem and was disabled, just don't "enable" it for the
+	 * process
+	 */
+	if (vdso_pages == 0)
+		return 0;
+
+	down_write(&mm->mmap_sem);
+
+	vdso_base = mm->mmap_base;
+
+	vdso_base = get_unmapped_area(NULL, vdso_base,
+				      (vdso_pages << PAGE_SHIFT) +
+				      ((VDSO_ALIGNMENT - 1) & PAGE_MASK), 0, 0);
+	if (IS_ERR_VALUE(vdso_base)) {
+		rc = vdso_base;
+		goto fail_mmapsem;
+	}
+
+	/* Add required alignment. */
+	vdso_base = ALIGN(vdso_base, VDSO_ALIGNMENT);
+
+	/* Put vDSO base into mm struct */
+	current->mm->context.vdso = vdso_base;
+
+	rc = install_special_mapping(mm, vdso_base, vdso_pages << PAGE_SHIFT,
+				     VM_READ | VM_EXEC |
+				     VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC |
+				     VM_ALWAYSDUMP, vdso_pagelist);
+
+	if (rc) {
+		current->mm->context.vdso = 0;
+		goto fail_mmapsem;
+	}
+
+	up_write(&mm->mmap_sem);
+	DBG(" pid %d arch_setup_additional_pages: %p\n", current->pid,
+	    (void *)current->mm->context.vdso);
+
+	return 0;
+
+fail_mmapsem:
+	up_write(&mm->mmap_sem);
+	DBG("arch_setup_additional_pages: FAILED\n");
+	return rc;
+}
+
+const char *arch_vma_name(struct vm_area_struct *vma)
+{
+	if (vma->vm_mm && vma->vm_start == vma->vm_mm->context.vdso)
+		return "[vdso]";
+	return NULL;
+}
+
+static void *__init find_section(Elf32_Ehdr * ehdr, const char *secname,
+				 unsigned long *size)
+{
+	Elf32_Shdr *sechdrs;
+	unsigned int i;
+	char *secnames;
+
+	/* Grab section headers and strings so we can tell who is who */
+	sechdrs = (void *)ehdr + ehdr->e_shoff;
+	secnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;
+
+	/* Find the section they want */
+	for (i = 1; i < ehdr->e_shnum; i++) {
+		if (strcmp(secnames + sechdrs[i].sh_name, secname) == 0) {
+			if (size)
+				*size = sechdrs[i].sh_size;
+			return (void *)ehdr + sechdrs[i].sh_offset;
+		}
+	}
+	*size = 0;
+	return NULL;
+}
+
+static Elf32_Sym *__init find_symbol(struct lib32_elfinfo *lib,
+				     const char *symname)
+{
+	unsigned int i;
+	char name[MAX_SYMNAME], *c;
+
+	for (i = 0; i < (lib->dynsymsize / sizeof(Elf32_Sym)); i++) {
+		if (lib->dynsym[i].st_name == 0)
+			continue;
+		strlcpy(name, lib->dynstr + lib->dynsym[i].st_name,
+			MAX_SYMNAME);
+		c = strchr(name, '@');
+		if (c)
+			*c = 0;
+		if (strcmp(symname, name) == 0)
+			return &lib->dynsym[i];
+	}
+	return NULL;
+}
+
+/* Note that we assume the section is .text and the symbol is relative to
+ * the library base
+ */
+static unsigned long __init find_function(struct lib32_elfinfo *lib,
+					  const char *symname)
+{
+	Elf32_Sym *sym = find_symbol(lib, symname);
+
+	if (sym == NULL) {
+		printk(KERN_WARNING "vDSO: function %s not found !\n", symname);
+		return 0;
+	}
+	return sym->st_value - VDSO_LBASE;
+}
+
+static __init int vdso_do_find_sections(struct lib32_elfinfo *v32)
+{
+	void *sect;
+
+	/*
+	 * Locate symbol tables & text section
+	 */
+
+	v32->dynsym = find_section(v32->hdr, ".dynsym", &v32->dynsymsize);
+	v32->dynstr = find_section(v32->hdr, ".dynstr", NULL);
+	if (v32->dynsym == NULL || v32->dynstr == NULL) {
+		printk(KERN_ERR "vDSO: required symbol section not found\n");
+		return -1;
+	}
+	sect = find_section(v32->hdr, ".text", NULL);
+	if (sect == NULL) {
+		printk(KERN_ERR "vDSO: the .text section was not found\n");
+		return -1;
+	}
+	v32->text = sect - vdso_kbase;
+
+	return 0;
+}
+
+static __init void vdso_setup_trampolines(struct lib32_elfinfo *v32)
+{
+	/*
+	 * Find signal trampolines
+	 */
+
+	vdso_sigrestorer = find_function(v32, "__kernel_sigrestorer");
+	DBG("vdso_setup_trampolines: vdso_sigrestorer = %lu\n",
+	    vdso_sigrestorer);
+}
+
+static __init int vdso_setup(void)
+{
+	struct lib32_elfinfo v32;
+	v32.hdr = vdso_kbase;
+
+	if (vdso_do_find_sections(&v32))
+		return -1;
+
+	vdso_setup_trampolines(&v32);
+	DBG("vdso_setup: OK\n");
+
+	return 0;
+}
+
+static int __init vdso_init(void)
+{
+	int i;
+
+	/*
+	 * Calculate the size of the vDSO
+	 */
+	vdso_pages = (&vdso_end - &vdso_start) >> PAGE_SHIFT;
+	DBG("vdso_kbase: %p, 0x%x pages\n", vdso_kbase, vdso_pages);
+
+	/*
+	 * Initialize the vDSO images in memory, that is do necessary
+	 * fixups of vDSO symbols, locate trampolines, etc...
+	 */
+	if (vdso_setup()) {
+		printk(KERN_ERR "vDSO setup failure, not enabled !\n");
+		vdso_pages = 0;
+		return 0;
+	}
+
+	/* Make sure pages are in the correct state */
+	vdso_pagelist = kzalloc(sizeof(struct page *) * (vdso_pages + 2),
+				GFP_KERNEL);
+	BUG_ON(vdso_pagelist == NULL);
+	for (i = 0; i < vdso_pages; i++) {
+		struct page *pg = virt_to_page(vdso_kbase + i * PAGE_SIZE);
+		ClearPageReserved(pg);
+		get_page(pg);
+		vdso_pagelist[i] = pg;
+	}
+	vdso_pagelist[i] = NULL;
+
+	smp_wmb();
+	vdso_ready = 1;
+
+	return 0;
+}
+
+arch_initcall(vdso_init);
+
+int in_gate_area_no_task(unsigned long addr)
+{
+	return 0;
+}
+
+int in_gate_area(struct task_struct *task, unsigned long addr)
+{
+	return 0;
+}
+
+struct vm_area_struct *get_gate_vma(struct task_struct *tsk)
+{
+	return NULL;
+}
diff --git a/arch/st200/kernel/vdso/Makefile b/arch/st200/kernel/vdso/Makefile
new file mode 100644
index 0000000..6062ae5
--- /dev/null
+++ b/arch/st200/kernel/vdso/Makefile
@@ -0,0 +1,53 @@
+#
+# Makefile for the vDSO.
+#
+
+obj-vdso = sigtramp.o note.o
+
+# Build rules
+
+targets := $(obj-vdso) vdso.so vdso.so.dbg
+obj-vdso := $(addprefix $(obj)/, $(obj-vdso))
+
+GCOV_PROFILE := n
+
+EXTRA_CFLAGS := -shared -fno-common -fno-builtin
+EXTRA_CFLAGS += -nostdlib -Wl,-soname=linux-vdso.so.1 \
+		$(call cc-ldoption, -Wl$(comma)--hash-style=sysv)
+EXTRA_AFLAGS := -s
+
+obj-y += vdso_wrapper.o
+extra-y += vdso.lds
+CPPFLAGS_vdso.lds += -P -C
+
+# Force dependency (incbin is bad)
+$(obj)/vdso_wrapper.o : $(obj)/vdso.so
+
+# link rule for the .so file, .lds has to be first
+$(obj)/vdso.so.dbg: $(src)/vdso.lds $(obj-vdso)
+	$(call if_changed,vdsold)
+
+# strip rule for the .so file
+$(obj)/%.so: OBJCOPYFLAGS := -S
+$(obj)/%.so: $(obj)/%.so.dbg FORCE
+	$(call if_changed,objcopy)
+
+# assembly rules for the .S files
+$(obj-vdso): %.o: %.S
+	$(call if_changed_dep,vdsoas)
+
+# actual build commands
+quiet_cmd_vdsold = VDSOL $@
+      cmd_vdsold = $(CC) $(c_flags) -Wl,-T,$^ -o $@
+quiet_cmd_vdsoas = VDSOA $@
+      cmd_vdsoas = $(CC) $(a_flags) -c -o $@ $<
+
+# install commands for the unstripped file
+quiet_cmd_vdso_install = INSTALL $@
+      cmd_vdso_install = cp $(obj)/$@.dbg $(MODLIB)/vdso/$@
+
+vdso.so: $(obj)/vdso.so.dbg
+	@mkdir -p $(MODLIB)/vdso
+	$(call cmd,vdso_install)
+
+vdso_install: vdso.so
diff --git a/arch/st200/kernel/vdso/note.S b/arch/st200/kernel/vdso/note.S
new file mode 100644
index 0000000..d4b5be4
--- /dev/null
+++ b/arch/st200/kernel/vdso/note.S
@@ -0,0 +1,25 @@
+/*
+ * This supplies .note.* sections to go into the PT_NOTE inside the vDSO text.
+ * Here we can supply some information useful to userland.
+ */
+
+#include <linux/uts.h>
+#include <linux/version.h>
+
+#define ASM_ELF_NOTE_BEGIN(name, flags, vendor, type)			      \
+	.section name, flags;						      \
+	.balign 4;							      \
+	.long 1f - 0f;		/* name length */			      \
+	.long 3f - 2f;		/* data length */			      \
+	.long type;		/* note type */				      \
+0:	.asciz vendor;		/* vendor name */			      \
+1:	.balign 4;							      \
+2:
+
+#define ASM_ELF_NOTE_END						      \
+3:	.balign 4;		/* pad out section */			      \
+	.previous
+
+	ASM_ELF_NOTE_BEGIN(".note.kernel-version", "a", UTS_SYSNAME, 0)
+	.long LINUX_VERSION_CODE
+	ASM_ELF_NOTE_END
diff --git a/arch/st200/kernel/vdso/sigtramp.S b/arch/st200/kernel/vdso/sigtramp.S
new file mode 100644
index 0000000..fe14f9b
--- /dev/null
+++ b/arch/st200/kernel/vdso/sigtramp.S
@@ -0,0 +1,161 @@
+/*
+ * linux/arch/st200/kernel/vdso/sigtramp.S
+ *
+ * Copyright (C) 2010 STMicroelectronics Limited
+ *	Author: Stephen Clarke <stephen.clarke@st.com>
+ *
+ */
+#include <asm/unistd.h>
+#include <asm/vdso.h>
+#include <asm/asm-offsets.h>
+
+	.text
+
+	.align 8
+	.proc __kernel_sigrestorer
+	.global __kernel_sigrestorer
+
+/* The nop is needed because the dwarf2 unwind routines subtract 1 from the
+   return address to get an address in the middle of the presumed call
+   instruction.  Since we don't have a call here, we artifically extend the
+   range covered by the unwind info by adding a nop before the real start. */
+
+.Lsigrestorer_start:
+	nop
+	;;
+__kernel_sigrestorer:
+	mov	$r16 = $r1
+	mov	$r15 = __NR_rt_sigreturn
+	;;
+	syscall 0
+	;;
+.Lsigrestorer_end:
+	.endp sigrestorer
+
+	.section .eh_frame,"a",@progbits
+
+/* Normally we use -4 as the data alignment factor, but in this case
+   all the saved register state is at a positive offset from the CFA,
+   and a negative data alignment factor would make it impossible to use
+   DW_CFA_offset. */
+#define DATA_ALIGNMENT_FACTOR 4
+
+/* Stuff PC in DWARF CFI column zero because we have no other
+   place for it: normally we would put it in column 63 since
+   the LR never needs to be restored when unwinding a function call.
+   But in the case of unwinding from a signal handler all registers,
+   including LR, must also be restored.  Column zero is a convenient
+   "spare" location since we never restore R0. */
+#define SAVED_PC_COLUMN 0
+
+/* Register REG can be found at offset OFS of a sigcontext structure,
+   The CFA points to the base of the sigcontext. */
+#define rsave(reg, ofs) 				\
+	.iflt reg - 64; 				\
+	.byte 0x80 | reg; /* DW_CFA_offset */ 		\
+	.uleb128 (ofs) / DATA_ALIGNMENT_FACTOR; 	\
+	.else; 						\
+	.byte 0x05;  /* DW_CFA_offset_extended */ 	\
+	.uleb128 reg; 					\
+	.uleb129 ofs; 					\
+	.endif
+
+/* Describe where general purpose regs are saved.  */
+#define EH_FRAME_GEN \
+	rsave ( 2, SC_SS   + SS_R2); \
+	rsave ( 3, SC_SS   + SS_R3); \
+	rsave ( 4, SC_SS   + SS_R4); \
+	rsave ( 5, SC_SS   + SS_R5); \
+	rsave ( 6, SC_SS   + SS_R6); \
+	rsave ( 7, SC_SS   + SS_R7); \
+	rsave ( 8, SC_REGS + PT_R8); \
+	rsave ( 9, SC_REGS + PT_R9); \
+	rsave (10, SC_REGS + PT_R10); \
+	rsave (11, SC_REGS + PT_R11); \
+	rsave (12, SC_REGS + PT_R12); \
+	rsave (13, SC_SS   + SS_R13); \
+	rsave (14, SC_SS   + SS_R14); \
+	rsave (15, SC_REGS + PT_R15); \
+	rsave (16, SC_REGS + PT_R16); \
+	rsave (17, SC_REGS + PT_R17); \
+	rsave (18, SC_REGS + PT_R18); \
+	rsave (19, SC_REGS + PT_R19); \
+	rsave (20, SC_REGS + PT_R20); \
+	rsave (21, SC_REGS + PT_R21); \
+	rsave (22, SC_REGS + PT_R22); \
+	rsave (23, SC_REGS + PT_R23); \
+	rsave (24, SC_REGS + PT_R24); \
+	rsave (25, SC_REGS + PT_R25); \
+	rsave (26, SC_REGS + PT_R26); \
+	rsave (27, SC_REGS + PT_R27); \
+	rsave (28, SC_REGS + PT_R28); \
+	rsave (29, SC_REGS + PT_R29); \
+	rsave (30, SC_REGS + PT_R30); \
+	rsave (31, SC_REGS + PT_R31); \
+	rsave (32, SC_REGS + PT_R32); \
+	rsave (33, SC_REGS + PT_R33); \
+	rsave (34, SC_REGS + PT_R34); \
+	rsave (35, SC_REGS + PT_R35); \
+	rsave (36, SC_REGS + PT_R36); \
+	rsave (37, SC_REGS + PT_R37); \
+	rsave (38, SC_REGS + PT_R38); \
+	rsave (39, SC_REGS + PT_R39); \
+	rsave (40, SC_REGS + PT_R40); \
+	rsave (41, SC_REGS + PT_R41); \
+	rsave (42, SC_REGS + PT_R42); \
+	rsave (43, SC_REGS + PT_R43); \
+	rsave (44, SC_REGS + PT_R44); \
+	rsave (45, SC_REGS + PT_R45); \
+	rsave (46, SC_REGS + PT_R46); \
+	rsave (47, SC_REGS + PT_R47); \
+	rsave (48, SC_REGS + PT_R48); \
+	rsave (49, SC_REGS + PT_R49); \
+	rsave (50, SC_REGS + PT_R50); \
+	rsave (51, SC_REGS + PT_R51); \
+	rsave (52, SC_REGS + PT_R52); \
+	rsave (53, SC_REGS + PT_R53); \
+	rsave (54, SC_REGS + PT_R54); \
+	rsave (55, SC_REGS + PT_R55); \
+	rsave (56, SC_REGS + PT_R56); \
+	rsave (57, SC_REGS + PT_R57); \
+	rsave (58, SC_REGS + PT_R58); \
+	rsave (59, SC_REGS + PT_R59); \
+	rsave (60, SC_REGS + PT_R60); \
+	rsave (61, SC_REGS + PT_R61); \
+	rsave (62, SC_REGS + PT_R62); \
+	rsave (63, SC_REGS + PT_LR);  \
+	rsave (SAVED_PC_COLUMN,  SC_REGS + PT_PC);  \
+	/* Restore r1 last because we are using it as CFA */ \
+	rsave ( 1, SC_SS   + SS_R1)
+
+.Lcie:
+	.word .Lcie_end - .Lcie_start
+.Lcie_start:
+	.word 0			/* CIE ID */
+	.byte 1			/* Version number */
+	.string "zRS"		/* NUL-terminated augmentation string */
+	.uleb128 1		/* Code alignment factor */
+	.sleb128 DATA_ALIGNMENT_FACTOR
+	.byte SAVED_PC_COLUMN   /* Return address register column */
+	.uleb128 1              /* Augmentation value length */
+	                        /* Augmentation Data: FDE pointer encoding */
+	.byte 0x1b		/* DW_EH_PE_pcrel | DW_EH_PE_sdata4 */
+	                        /* Initial Instructions */
+                                /* Define the CFA to be r1, since we know
+	                           that r1 points to a sigcontext with all
+	                           the required register state that we need
+	                           to restore */
+	.byte 0x0c,1,0          /* DW_CFA_def_cfa: r1 offset 0 */
+	.balign 4
+.Lcie_end:
+
+	/* FDE for sigrestorer */
+	.word .Lfde0_end - .Lfde0_start
+.Lfde0_start:
+	.word .Lfde0_start - .Lcie     			/* CIE pointer */
+	.word .Lsigrestorer_start - .          		/* PC start */
+	.word .Lsigrestorer_end - .Lsigrestorer_start   /* PC range */
+	.uleb128 0				/* Augmentation Length */
+	EH_FRAME_GEN            /* Locations of callee-save general regs */
+	.balign 4
+.Lfde0_end:
diff --git a/arch/st200/kernel/vdso/vdso.lds.S b/arch/st200/kernel/vdso/vdso.lds.S
new file mode 100644
index 0000000..cf69c85
--- /dev/null
+++ b/arch/st200/kernel/vdso/vdso.lds.S
@@ -0,0 +1,132 @@
+/*
+ * This is the infamous ld script for the 32 bits vdso
+ * library
+ */
+#include <asm/vdso.h>
+
+OUTPUT_FORMAT("elf32-littlelx-linux", "elf32-littlelx-linux", "elf32-littlelx-linux")
+OUTPUT_ARCH(lx)
+ENTRY(_start)
+
+SECTIONS
+{
+	. = VDSO_LBASE + SIZEOF_HEADERS;
+
+	.hash		: { *(.hash) }			:text
+	.gnu.hash	: { *(.gnu.hash) }
+	.dynsym		: { *(.dynsym) }
+	.dynstr		: { *(.dynstr) }
+	.gnu.version	: { *(.gnu.version) }
+	.gnu.version_d	: { *(.gnu.version_d) }
+	.gnu.version_r	: { *(.gnu.version_r) }
+
+	.note		: { *(.note.*) }		:text	:note
+
+	. = ALIGN(16);
+	.text		: {
+		*(.text .stub .text.* .gnu.linkonce.t.*)
+	} :text
+	PROVIDE(__etext = .);
+	PROVIDE(_etext = .);
+	PROVIDE(etext = .);
+
+	/*
+	 * Other stuff is appended to the text segment:
+	 */
+	.rodata		: { *(.rodata .rodata.* .gnu.linkonce.r.*) }
+	.rodata1	: { *(.rodata1) }
+
+	.dynamic	: { *(.dynamic) }		:text	:dynamic
+
+	.eh_frame_hdr	: { *(.eh_frame_hdr) }		:text	:eh_frame_hdr
+	.eh_frame	: { KEEP (*(.eh_frame)) }	:text
+	.gcc_except_table : { *(.gcc_except_table .gcc_except_table.*) }
+
+	.rela.dyn ALIGN(8) : { *(.rela.dyn) }
+	.got ALIGN(8)	: { *(.got .toc) }
+
+	_end = .;
+	PROVIDE(end = .);
+
+	/*
+	 * Stabs debugging sections are here too.
+	 */
+	.stab	       0 : { *(.stab) }
+	.stabstr       0 : { *(.stabstr) }
+	.stab.excl     0 : { *(.stab.excl) }
+	.stab.exclstr  0 : { *(.stab.exclstr) }
+	.stab.index    0 : { *(.stab.index) }
+	.stab.indexstr 0 : { *(.stab.indexstr) }
+	.comment       0 : { *(.comment) }
+
+	/*
+	 * DWARF debug sections.
+	 * Symbols in the DWARF debugging sections are relative to the
+	 * beginning of the section so we begin them at 0.
+	 */
+	/* DWARF 1 */
+	.debug		0 : { *(.debug) }
+	.line		0 : { *(.line) }
+	/* GNU DWARF 1 extensions */
+	.debug_srcinfo	0 : { *(.debug_srcinfo) }
+	.debug_sfnames	0 : { *(.debug_sfnames) }
+	/* DWARF 1.1 and DWARF 2 */
+	.debug_aranges	0 : { *(.debug_aranges) }
+	.debug_pubnames 0 : { *(.debug_pubnames) }
+	/* DWARF 2 */
+	.debug_info	0 : { *(.debug_info .gnu.linkonce.wi.*) }
+	.debug_abbrev	0 : { *(.debug_abbrev) }
+	.debug_line	0 : { *(.debug_line) }
+	.debug_frame	0 : { *(.debug_frame) }
+	.debug_str	0 : { *(.debug_str) }
+	.debug_loc	0 : { *(.debug_loc) }
+	.debug_macinfo	0 : { *(.debug_macinfo) }
+	/* SGI/MIPS DWARF 2 extensions */
+	.debug_weaknames 0 : { *(.debug_weaknames) }
+	.debug_funcnames 0 : { *(.debug_funcnames) }
+	.debug_typenames 0 : { *(.debug_typenames) }
+	.debug_varnames  0 : { *(.debug_varnames) }
+	/* DWARF 3 */
+	.debug_pubtypes 0 : { *(.debug_pubtypes) }
+	.debug_ranges	0 : { *(.debug_ranges) }
+	.gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }
+
+	. = ALIGN(4096);
+	PROVIDE(_vdso_data = .);
+
+	/DISCARD/	: {
+		*(.note.GNU-stack)
+		*(.branch_lt)
+		*(.data .data.* .gnu.linkonce.d.* .sdata*)
+		*(.bss .sbss .dynbss .dynsbss)
+	}
+}
+
+/*
+ * Very old versions of ld do not recognize this name token; use the constant.
+ */
+#define PT_GNU_EH_FRAME	0x6474e550
+
+/*
+ * We must supply the ELF program headers explicitly to get just one
+ * PT_LOAD segment, and set the flags explicitly to make segments read-only.
+ */
+PHDRS
+{
+	text		PT_LOAD FILEHDR PHDRS FLAGS(5);	/* PF_R|PF_X */
+	dynamic		PT_DYNAMIC FLAGS(4);		/* PF_R */
+	note		PT_NOTE FLAGS(4);		/* PF_R */
+	eh_frame_hdr	PT_GNU_EH_FRAME;
+}
+
+/*
+ * This controls what symbols we export from the DSO.
+ */
+VERSION
+{
+	VDSO_VERSION_STRING {
+	global:
+		__kernel_sigrestorer;
+	local: *;
+	};
+}
diff --git a/arch/st200/kernel/vdso/vdso_wrapper.S b/arch/st200/kernel/vdso/vdso_wrapper.S
new file mode 100644
index 0000000..2cd6c28
--- /dev/null
+++ b/arch/st200/kernel/vdso/vdso_wrapper.S
@@ -0,0 +1,14 @@
+#include <linux/init.h>
+#include <linux/linkage.h>
+#include <asm/page.h>
+
+	__PAGE_ALIGNED_DATA
+
+	.globl vdso_start, vdso_end
+	.balign PAGE_SIZE
+vdso_start:
+	.incbin "arch/st200/kernel/vdso/vdso.so"
+	.balign PAGE_SIZE
+vdso_end:
+
+	.previous
diff --git a/arch/st200/kernel/vmlinux.lds.S b/arch/st200/kernel/vmlinux.lds.S
new file mode 100644
index 0000000..72cc329
--- /dev/null
+++ b/arch/st200/kernel/vmlinux.lds.S
@@ -0,0 +1,187 @@
+/*
+ * ld script to make ST200 Linux kernel
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ */
+
+#define LOAD_OFFSET (__PAGE_OFFSET - ((CONFIG_MEMORY_START/BIG_PAGE_SIZE)*BIG_PAGE_SIZE))
+
+#include <asm/page.h>
+#include <asm/thread_info.h>
+#include <asm-generic/vmlinux.lds.h>
+
+#define BIG_PAGE_SIZE (256*1024*1024)
+#define OFFSET_TO_RAM_START (CONFIG_MEMORY_START%BIG_PAGE_SIZE)
+
+#define PHYSICAL(x) (x) - LOAD_OFFSET
+
+#include <asm-generic/vmlinux.lds.h>
+
+OUTPUT_FORMAT("elf32-littlelx-linux", "elf32-littlelx-linux", "elf32-littlelx-linux")
+OUTPUT_ARCH(lx)
+ENTRY(start_phys)
+jiffies = jiffies_64;
+
+/* Add 0 to register r8, due to limitations in linker */
+#define NOP 0x8000
+
+#define VIRT_SECTION(name) name : AT(ADDR(name) - LOAD_OFFSET)
+
+
+SECTIONS
+{
+#ifdef CONFIG_SIM_BOOT_FROM_ZERO
+  . = 0;
+  .boot : {
+	*(.boot)
+	} = NOP
+#endif
+
+  . = __PAGE_OFFSET + OFFSET_TO_RAM_START ;
+  _text = .;			/* Text and read-only data */
+  text = .;			/* Text and read-only data */
+
+  VIRT_SECTION(.empty_zero_page) {
+	*(.empty_zero_page)
+	} = 0
+
+  /* Needed for load tool to know where to put params */
+  empty_zero_page_phys = PHYSICAL(empty_zero_page) ;
+
+  _stext = .;			/* Start of text section */
+
+
+  start_phys = PHYSICAL(start)	;
+
+  VIRT_SECTION(.text)  {
+	*(.text)
+	SCHED_TEXT
+	*(.fixup)
+	*(.gnu.warning)
+	} = NOP
+
+  _etext = .;			/* End of text section */
+
+  . = ALIGN(16);		/* Exception table */
+  __start___ex_table = .;
+  VIRT_SECTION(__ex_table) { *(__ex_table) }
+  __stop___ex_table = .;
+
+  RODATA
+
+  VIRT_SECTION(.data) {			/* Data */
+	*(.data)
+	CONSTRUCTORS
+	}
+
+  . = ALIGN(8192);
+  __nosave_begin = .;
+  VIRT_SECTION(.data_nosave) { *(.data.nosave) }
+  . = ALIGN(8192);
+  __nosave_end = .;
+
+  . = ALIGN(8192);
+  VIRT_SECTION(.data.page_aligned) { *(.data.idt) }
+
+  . = ALIGN(32);
+  VIRT_SECTION(.data.cacheline_aligned) { *(.data.cacheline_aligned) }
+
+  _edata = .;			/* End of data section */
+
+  . = ALIGN(THREAD_SIZE);		/* init_task */
+  VIRT_SECTION(.data.init_task) { *(.data.init_task) }
+
+  /* will be freed after init */
+  . = ALIGN(8192);		/* Init code and data */
+  __init_begin = .;
+  VIRT_SECTION(.init.text) {
+	_sinittext = .		;
+	*(.init.text)
+	_einittext = .		;
+  }
+
+  VIRT_SECTION(.init.data) { *(.init.data) }
+  . = ALIGN(16);
+  VIRT_SECTION(.ctors) {
+	  __ctors_start = .;
+	  *(.ctors)
+	  __ctors_end = . ;
+  }
+
+  __setup_start = .;
+  VIRT_SECTION(.init.setup) { *(.init.setup) }
+  __setup_end = .;
+  __tagtable_begin = .;
+  VIRT_SECTION(.taglist) {*(.taglist)	}
+  __tagtable_end = .;
+  __early_param_begin = .;
+  VIRT_SECTION(.early_param) { *(__early_param) }
+  __early_param_end = .;
+  __start___param = .;
+  VIRT_SECTION(__param)  { *(__param) }
+  __stop___param = .;
+  __initcall_start = .;
+  VIRT_SECTION(.initcall.init) {
+	INITCALLS
+  }
+  __initcall_end = .;
+  __con_initcall_start = .;
+  VIRT_SECTION(.con_initcall.init) { *(.con_initcall.init) }
+  __con_initcall_end = .;
+  SECURITY_INIT
+  . = ALIGN(8192);
+  __initramfs_start = .;
+  VIRT_SECTION(.init.ramfs) { *(.init.ramfs) }
+  __initramfs_end = .;
+  . = ALIGN(32);
+  __per_cpu_start = .;
+  VIRT_SECTION(.data.percpu) { *(.data.percpu) }
+  __per_cpu_end = .;
+  . = ALIGN(8192);
+  __init_end = .;
+  /* freed after init ends here */
+
+  __bss_start = .;		/* BSS */
+  VIRT_SECTION(.bss) { *(.bss) }
+  __bss_stop = .;
+
+  _end = . ;
+
+  . = ALIGN(PAGE_SIZE);
+
+  /* This is for the linked in initrd */
+  /* Need to leave a gap big enough for the bootmem bit map.
+   * We should probably be a bit cleverer about this.
+   */
+  . = ALIGN(8192);
+  . = . + (8192 * 10);
+  __initrd_start = .;
+  VIRT_SECTION(.initrd) { *(.initrd) }
+  . = ALIGN(8192);
+  __initrd_end = .;
+
+
+  /* When something in the kernel is NOT compiled as a module, the
+   * module cleanup code and data are put into these segments.  Both
+   * can then be thrown away, as cleanup code is never called unless
+   * it's a module.
+   */
+  /DISCARD/ : {
+	*(.exit.text)
+	*(.exit.data)
+	*(.exitcall.exit)
+	}
+
+  /* keep the profile information for the icacheopt tool */
+  .profile_info 0 : { *(.profile_info) }
+
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+}
diff --git a/arch/st200/lib/Makefile b/arch/st200/lib/Makefile
new file mode 100644
index 0000000..5450512
--- /dev/null
+++ b/arch/st200/lib/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for ST200-specific library files..
+#
+
+lib-y := delay.o udelay.o string.o memcpy.o
diff --git a/arch/st200/lib/delay.S b/arch/st200/lib/delay.S
new file mode 100644
index 0000000..6edda2c
--- /dev/null
+++ b/arch/st200/lib/delay.S
@@ -0,0 +1,27 @@
+/*
+ * arch/st200/lib/delay.S
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Authors: Stuart Menefy <stuart.menefy@st.com>
+ *		 Thierry Strudel <thierry.strudel@st.com>
+ */
+#include <linux/linkage.h>
+
+/* This is really disapointing. I can't think of
+   a faster way to do the null loop. Which gives us
+   a crap bogomips figure.
+   Thierry: doing the compare and the br in the same bundle saves us 1 bundle,
+	this gives 25% more BogoMips :-)
+*/
+/* $r16 contains the number of times to loop */
+ENTRY(__delay)
+	cmpeq	$b0 = $r16,$r0
+	;;
+1:
+	add	$r16 = $r16,-1
+	;;
+	brf	$b0, 1b
+	cmpeq	$b0 = $r16,$r0
+	;;
+	goto $r63
+	;;
diff --git a/arch/st200/lib/memcpy.S b/arch/st200/lib/memcpy.S
new file mode 100644
index 0000000..407e078
--- /dev/null
+++ b/arch/st200/lib/memcpy.S
@@ -0,0 +1,491 @@
+/*
+ * arch/st200/lib/memcpy.S
+ *
+ * Copyright (C) 2010 STMicroelectronics
+ *   Author: David McKay <david.mckay@st.com>
+ */
+
+#include <linux/linkage.h>
+
+/* Optimised memcpy() for st231. More micro optimisations are possible with this, 
+ * in particular the single word copies could be changed to predicated load/stores 
+ * by using the 4 word stack scratch area to dump out unwanted load/stores. The 
+ * unaligned initial stores could also be pipelined that way.
+ * 
+ * There is also no reason why this code cannot be used for copy_to_user() in the 
+ * kernel as well. This will give a substantial performance boost. Revisit this code 
+ * when I optimise copy_to_user()
+ */ 
+
+#ifdef __ST240__
+.assume st240
+#elif defined __ST231__
+.assume st231
+#else
+#  error Unknown target.
+#endif
+
+
+.nonopinsertion
+
+/* memcpy $r16 = dst, $r17 = src $r18 = len */
+
+/* Global variables used, we are so spoilt for choice on the ST200 for registers it is
+ * almost embarrassing!
+ *
+ * $r16	- Original dst address - DO NOT MODIFY, used to return
+ * $r17 - Current src address for reading
+ * $r18 - Number of bytes left to copy
+ * $r19 - Current dst address
+ * $r20 - Current pft address - basically 256 bytes above current src
+ * $r21 - Address to prefetch from.
+ * $r22 - End address, start + len, if >= out of range
+ * $r23	- Word aligned end address. 
+ * $r24 - Dest alignment (dest & 0x3)
+ * $r25 - Shift for previous word in unaligned transfers
+ * $r26 - Shift for current word in unaligned transfers
+ *
+ */
+ 
+
+/* This code does "perfect prefetching", it issues exactly the correct number
+ * of prefetches required (well, except in the 0 length case). When the
+ * prefetch address is > the end address, prefetching is switched off by
+ * pointing the register at a control address. That's where the -228 comes from
+ * as 224 + -228 is still a control register. Initially I was using address
+ * zero, but that incurs a penalty on prefetch because the instruction will
+ * miss on the DTLB and will have to check the UTLB which incurs a 5 cycle
+ * penalty
+ */
+
+
+ENTRY(memcpy): 
+	pft	0[$r17]			/* We know we are going to look at these bytes */
+	cmpeq	$b0 = $r18, $r0	 	/* $b0 true if nothing to do */
+	or	$r42 = $r16, $r17
+	cmpltu	$b7 = $r18, 4		/* Less than a word, have to do byte at a time */
+	;;
+	mov	$r19 = $r16		/* $r19 contains dst */
+	and	$r42 = $r42, 0x3	/* $r42 true if src or dst not aligned */
+	cmpltu	$b2 = $r18, 32		/* Less than 32 bytes, do word at a time */
+	xor	$r24 = $r16, $r17	/* Check for same alignement */	
+	;;
+	convib	$b1 =  $r42		/* $b1 true if src or dst not aligned */
+	cmpltu	$b3 = $r18, 64		/* < 64 bytes, don't issue next prefetch */
+	slctf	$r21 = $b2, $r17, -228
+	and	$r24 = $r24, 0x3	/* Zero if same alignement */
+	;; 
+	br	$b0, .Ldone		/* Exit on len = 0, zero latency on $b0 */					
+	pft	32[$r21]		
+	slctf 	$r21 = $b3, $r17, -228
+	cmpltu	$b4 = $r18, 96
+	;;
+	slctf 	$r21 = $b4, $r17, -228
+	cmpltu	$b5 = $r18, 128
+	pft	64[$r21]
+	br	$b7, .Lbyte_at_a_time 	/* len < 4, so just copy byte at a time. Zero latency on $b7 */ 
+	;;
+	br	$b1, .Lstrange_align /* Byte at a time, zero latency on $b1 */
+	slctf	$r21 = $b5, $r17, -228
+	cmpltu  $b6 = $r18, 160
+	pft	96[$r21]
+	;;
+	brf	$b2, .Lpft_precharge_loop	/* Zero latency on $b2 */
+	pft	128[$r21]
+	cmpltu  $b7 = $r18, 160
+	slctf 	$r21 = $b6, $r17, -228
+	;;
+
+/* Must be at least one word to copy */
+.Lword_at_a_time:
+	ldw	$r50 = 0[$r17]
+	cmpeq	$b0 = $r18, 4
+	cmpltu	$b1 = $r18, 8
+	;;
+	add	$r17 = $r17, 4
+	;;
+	add	$r18 = $r18, -4
+	;;
+	stw	0[$r19] = $r50 /* 2 cycle stall for load */
+	add	$r19 = $r19, 4
+	brf	$b1 , .Lword_at_a_time
+	;;
+	br 	$b0, .Ldone
+	;;
+
+.Lbyte_at_a_time: 
+	ldb	$r50 = 0[$r17]
+	cmpeq	$b0 = $r18, 1
+	;;
+	add	$r17 = $r17, 1
+	;;
+	add	$r18 = $r18, -1
+	;;
+	stb	0[$r19] = $r50
+	add	$r19 = $r19, 1
+	brf	$b0, .Lbyte_at_a_time
+	;;
+.Ldone:
+	goto	$r63
+	;;
+
+
+.Lpft_precharge_loop:	
+	pft	160[$r21]
+	slctf	$r21 = $b7, $r17, -228
+	cmpltu	$b0 = $r18, 224
+	;;
+	pft	192[$r21]
+	slctf	$r21 = $b0, $r17, -228
+	mov	$r20 = $r17
+	add	$r22 = $r17, $r18	/* End address */
+	;;
+	pft	224[$r21]
+	add	$r20 = $r17, 256 	/* We should now have all 8 prefetch buffers running */
+	;;
+
+
+/* Pft in middle of loop. This is a hard one to call. If you put the pft at the
+ * end of the loop, you can do an extra check to see if the pft is still doing
+ * anything usefull and not execute it So this saves 1 cycle round the loop in
+ * the last 8 loops. However, if you issue the pft before the stores, you then
+ * gain an extra 9 cycles of latency on the prefetch. Which is best depends on
+ * what you are doing. You could have two loops, but it's not worth it. I've
+ * elected to gain the latency on the prefetch
+ */
+
+.Lcache_line_loop:
+	ldw	$r50	= 0[$r17]
+	cmpltu  $b2 = $r20, $r22 /* Prefetch next line ? */
+	;;
+	ldw	$r51 	= 4[$r17]
+	slct	$r21 = $b2, $r20, -228 /* Switch off prefetch */ 
+	;;
+	ldw	$r52	= 8[$r17]
+	;;
+	ldw	$r53	= 12[$r17]
+	;;
+	ldw	$r54	= 16[$r17]
+	;;
+	ldw	$r55	= 20[$r17]
+	;;
+	ldw	$r56	= 24[$r17]
+	;;
+	ldw	$r57	= 28[$r17]	/* Cache line consumed, prefetch buffer is empty */
+	add	$r17 = $r17, 32
+	add	$r18 = $r18, -32
+	;;
+	pft	0[$r21]		/* Issue next prefetch */
+	;;
+	stw	0[$r19]	= $r50
+	cmpltu	$b1 = $r18, 32 /* Terminate loop ? */
+	;;
+	stw	4[$r19]	= $r51
+	;;
+	stw	8[$r19]	= $r52
+	cmpeq	$b3 = $r18, 0  /* $b3 if memcpy complete */
+	cmpltu	$b4 = $r18, 4 /* $b4 if byte remainder */
+	;;
+	stw	12[$r19]= $r53
+	add	$r20 = $r20, 32	/* Prefetch address */
+	;;
+	stw	16[$r19]= $r54
+	;;
+	stw	20[$r19]= $r55
+	;;
+	stw	24[$r19]= $r56
+	;;
+	stw	28[$r19]= $r57
+	add	$r19 = $r19, 32
+	brf	$b1, .Lcache_line_loop	/* Branch if !done */
+	;;
+	br 	$b3, .Ldone
+	;;
+	br	$b4, .Lbyte_at_a_time 
+	;;
+	goto 	.Lword_at_a_time	
+	;;
+
+/* Copy 1-3  bytes from src to dst */
+.Lalign_src_dst_to_word:
+	ldb	$r50 = 0[$r17]
+	cmpeq	$b0 = $r24, 1
+	cmpltu	$b1 = $r25, 32		/* True if we have < 32 bytes at the end of this loop */
+	cmpltu	$b2 = $r25, 4		/* True if only bytes left after this loop */
+	;;
+	add	$r17 = $r17, 1
+	cmpne	$b3 = $r25, 0 		/* True if we are done! */
+	;;
+	add	$r24 = $r24, -1
+	add	$r18, $r18, -1
+	;;
+	stb	0[$r19] = $r50
+	add	$r19 = $r19, 1
+	brf	$b0, .Lalign_src_dst_to_word
+	;;
+	/* We are now word aligned. If > 32 bytes to
+  	 * copy, goto precharge_pft, otherwise go to 
+	 * word at a time copy 
+	 */
+	brf	$b1, .Lpft_precharge_loop
+	;;
+	br	$b2, .Lbyte_at_a_time
+	;;
+	br	$b3, .Lword_at_a_time
+	;;
+	goto	$r63
+	;;
+	
+/* We get here if 
+ *	- src and dst are not WORD ALIGNED!
+ *  	We check for if src and dst have the SAME alignement,
+ * 	in which case we just copy the correct number of bytes 	
+ * 	to word align, and then jump back into main loop. We have
+ * 	to do the missing prefetch or else we will pessimise everything
+ *	badly.
+ * 	- $r24 contains xor of src,dst and 0x3
+ *	- $b2 true if < 32, no latency 
+ * 	we assume that we are going to to be aligned on the same 
+ * 	boundary, so keep the prefetches going, then jump to the 
+ * 	correct loop
+ *
+ */
+
+/* We can probably shift the pft_precharge loop here as well, so 
+ * that we can jump straight into the word at a time case 
+ */
+.Lstrange_align:	
+	cmpeq	$b0  = $r24, 0
+	cmpltu	$b1  = $r18, 16			/* True if < 16 bytes */
+	pft	128[$r21]			/* Assume same alignment, have to keep pipeline prefetch going */
+	and	$r24 = $r17, 0x3		/* Alignement of src */
+	;;
+	cmpeq	$b2 = $r24, 0			/* True if  src is aligned */
+	cmpltu  $b7 = $r18, 160
+	slctf 	$r21 = $b6, $r17, -228
+	sub	$r24 = 4, $r24			/* Number of bytes to copy */
+	;;
+	sub	$r25 = $r18, $r24		/* We cannot be here for memcpy of < 4, so safe */ 
+	br	$b0, .Lalign_src_dst_to_word	/* Two cycle stall on $b0 - can we re-pipeline? */
+	add	$r22 = $r17, $r18		/* Last address */
+	;;
+	/* Curses. We are not aligned on the same boundary. That unfortunately means we 
+	 * have to do the horrible case of load, shift, and or.  Yuck
+	 */
+	br	$b1,	.Lbyte_at_a_time		/* < 16 bytes, so just do a simple byte loop */
+	and	$r24 = $r19, 0x3		/* dst alignment */
+	and	$r25 = $r17, 0x3		/* Alignement of src */
+	and	$r23 = $r22, ~0x3		/* Last word aligned address */
+	;;
+	br	$b2,	.Lsrc_aligned
+	sub	$r25 = 4, $r25
+	;;
+/* Store out n bytes, so that src is aligned  */
+.Lalign_src_to_word: 
+	ldb	$r50 = 0[$r17]
+	add	$r17 = $r17, 1
+	cmpeq	$b0 = $r25, 1 
+	add	$r25 = $r25, -1
+	;;
+	stb	0[$r19] = $r50
+	add	$r19 = $r19, 1
+	add	$r18 = $r18, -1		/* Change remaining bytes */
+	;;
+	brf	$b0, .Lalign_src_to_word;
+	and	$r24 = $r19, 0x3	/* New destination alignement */
+	;;
+	
+/* OK, at this point the src is aligned correctly. We now can load the word up, 
+   and then store it in the dst until it is aligned on a word boundary as well. 
+   We know that the dst must be misaligned here because we have already removed 
+   the case where the src and dst have the same alignment. Therefore as src is 
+   aligned dst can no longer be even if it was to start.
+ */
+
+.Lsrc_aligned:
+	ldw	$r50 = 0[$r17]		/* Aligned */
+	sub	$r25 = 4, $r24	/* Number of bytes to align dst */
+	add	$r17 = $r17, 4
+	shru	$r47 = $r18, 2	/* Number of complete words we can copy in upcoming loop */
+	;;
+	mov	$r53 = $r50
+	add	$r47 = $r47, -1 /* We have already read one word */
+	;;
+
+.Lalign_dst_to_word:
+	stb	0[$r19] = $r50
+	shru	$r50 = $r50, 8
+	cmpeq	$b0 = $r25, 1
+	;;
+	add	$r25 = $r25, -1
+	add	$r19 = $r19, 1
+	add	$r18 = $r18, -1 	/* $r18 always holds the number of bytes remaining */
+	brf	$b0, .Lalign_dst_to_word
+	;;
+	
+/* Now src and dst are both aligned, we can now start the main loop.
+
+/* $r24 contains dest alignment, this controls how much shifting we have to 
+ * do in order to get everything to work out right  
+ */
+.Lshifter_prep:	
+	shru	$r48 = $r47, 3	/* number of big loops */
+	shl	$r26 = $r24, 3	/* $r26 is shift for the new word */
+	sub 	$r25 = 4, $r24
+	;;
+	shl	$r25 = $r25, 3 /* $r25 is shift for the previous word */
+	mov	$r50 = $r53
+	cmpgtu	$b0 = $r48, 0 /* Do we go round the big loops or not?  */
+	;;
+	br 	$b0, .Lshifter_pft_precharge_loop # Stall reshcedule
+	;;
+
+/* This could be pipelined a bit better */
+.Lshifter_word_at_a_time:
+	ldw	$r51 = 0[$r17]
+	shru	$r50 = $r50, $r25
+	add	$r17 = $r17, 4
+	;;
+	shl	$r52 = $r51, $r26
+	cmpltu	$b0 = $r17, $r23
+	;;
+	or	$r52 = $r52, $r50
+	;;
+	stw	0[$r19] = $r52
+	mov	$r50 = $r51 /* new word is now the old word */
+	add	$r19 = $r19, 4
+	add	$r18 = $r18, -4
+	;;
+	br	$b0, .Lshifter_word_at_a_time
+	shru	$r53 = $r51, $r25	/* For tail operation */
+	;;
+
+/* Ok, we are now out of the main byte loop. We need to now dump out 
+ * n bytes from the last word read, byte at a time. There will always
+ * be something to dump out here, so no test is needed.
+ */ 
+.Ldump_tail:
+	stb	0[$r19] = $r53
+	shru	$r53 = $r53, 8
+	add	$r24 = $r24, -1
+	cmpeq	$b0 = $r24, 1
+	;;
+	add	$r18 = $r18, -1
+	cmpeq	$b1 = $r18, 1		/* True if nothing to do after loop finished */
+	add	$r19 = $r19, 1 
+	;;
+	brf	$b0, .Ldump_tail
+	;;
+	brf	$b1, .Lbyte_at_a_time
+	;;
+	goto	$r63
+	;;
+
+/* This should die, it can be subsumed into the above logic
+ * without any penalty. Here now for testing
+ */ 
+.Lshifter_pft_precharge_loop:	
+	pft	160[$r21]
+	slctf	$r21 = $b7, $r17, -228
+	cmpltu	$b0 = $r18, 224
+	;;
+	pft	192[$r21]
+	slctf	$r21 = $b0, $r17, -228
+	mov	$r20 = $r17
+	;;
+	pft	224[$r21]
+	add	$r20 = $r17, 256 	/* We should now have all 8 prefetch buffers running */
+	;;
+
+
+/* Can assume at least 32 bytes to do on entry to this loop, 
+ * and that both src and dst are aligned 
+ * Ensure $r50 contains starting word when you come into this loop.
+ */
+.Lshifter_line_at_a_time:
+	ldw	$r51 = 0[$r17]
+	add	$r48 = $r48, -1 # Decrement count
+	cmpltu	$b2 = $r20, $r22
+	;;
+	ldw	$r52 = 4[$r17]
+	slct	$r21 = $b2, $r20, -228	/* Stop prefetching */
+	cmpeq	$b0 = $r48, 0
+	;;
+	ldw	$r53 = 8[$r17]
+	;;
+	ldw	$r54 = 12[$r17]
+	;;
+	ldw	$r55 = 16[$r17] /* $r51 now available with no latency */
+	shru	$r49 = $r50, $r25	/* $r50 contains the previous value from end of loop! */
+	shl	$r31 = $r51, $r26
+	;;
+	ldw	$r56 = 20[$r17]		/* $r52 now available no latency */
+	shru	$r49 = $r51, $r25
+	shl	$r32 = $r52, $r26
+	or	$r31 = $r31, $r49	/* $r31 now contains word to store */
+	;;
+	ldw	$r57 = 24[$r17]
+	shru	$r49 = $r52, $r25
+	shl	$r33 = $r53, $r26
+	or	$r32 = $r32, $r49
+	;;
+	ldw	$r58 = 28[$r17]
+	shru	$r49 = $r53, $r25
+	shl	$r34 = $r54, $r26
+	or	$r33 = $r33, $r49
+	;;
+	pft	0[$r21]		/* Issue next prefetch */
+	shru	$r49 = $r54, $r25
+	shl	$r35 = $r55, $r26
+	or	$r34 = $r34, $r49
+	;;
+	stw	0[$r19] = $r31
+	shru	$r49 = $r55, $r25
+	shl	$r36 = $r56, $r26
+	or	$r35 = $r35, $r49
+	;;
+	stw	4[$r19] = $r32
+	shru	$r49 = $r56, $r25
+	shl	$r37 = $r57, $r26
+	or	$r36 = $r36, $r49
+	;;
+	stw	8[$r19] = $r33
+	shru	$r49 = $r57, $r25
+	shl	$r38 = $r58, $r26
+	or	$r37 = $r37, $r49
+	;;
+	stw	12[$r19] = $r34
+	or	$r38 = $r38, $r49	/* All done ! */ 
+	mov	$r50 = $r58		/* $r50 now becomes the stub for the next loop */
+	;;
+	stw	16[$r19] = $r35
+	add	$r17 	= $r17, 32
+	;;
+	stw	20[$r19] = $r36
+	cmpltu	$b1 = $r17, $r23	# $r23 contains last word address
+	;;
+	stw	24[$r19] = $r37
+	add	$r20	= $r20, 32	# Prefetch address 
+	;;
+	stw	28[$r19] = $r38
+	add	$r19	= $r19, 32	/* Onto next line */
+	add	$r18	= $r18, -32
+	brf	$b0, .Lshifter_line_at_a_time 
+	;;
+	/* End of loop */
+	/* Right, we are now out of the main unrolled loop, 
+	 * The rump data is now in $r50. So, if we have more than 
+	 * a word left to go, then have to jump to the word at a 
+	 * a time loop above. If not, then we have to jump to the dump_tail
+	 * unfortunately , we have to also set up the loop counters for the above 
+ 	 * loops. Would be better with invarients for these.
+	 */
+	br	$b1, .Lshifter_word_at_a_time;
+	shru	$r53 = $r50, $r25	/* For tail operation */
+	;;
+	goto	.Ldump_tail	// There are always some bytes to dump out
+	;;
+	
+ENDPROC(memcpy)
+
+
diff --git a/arch/st200/lib/string.S b/arch/st200/lib/string.S
new file mode 100644
index 0000000..be86430
--- /dev/null
+++ b/arch/st200/lib/string.S
@@ -0,0 +1,120 @@
+/*
+ * arch/st200/lib/string.S
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *
+ */
+
+#include <linux/linkage.h>
+
+/**
+ * memset - Fill a region of memory with the given value
+ * @s: Pointer to the start of the area. ($r16)
+ * @c: The byte to fill the area with ($r17)
+ * @count: The size of the area. ($r18)
+ *
+ * Do not use memset() to access IO space, use memset_io() instead.
+ */
+ENTRY(memset)
+	/*
+	 * We try and make the common case (word aligned, big blocks) the
+	 * direct path through this code, hence the odd ordering.
+	 */
+	cmpeq	$b2 = $r18, $r0		/* $b2 = count==0 */
+	and	$r20 = $r16, 3
+	and	$r17 = $r17, 0xff
+	;;
+	cmpeq	$b0 = $r20, $r0		/* $b0 = word aligned */
+	shl	$r21 = $r17, 8
+	shl	$r22 = $r17, 16
+	shl	$r23 = $r17, 24
+	;;
+	cmpltu	$b3 = $r18, 16		/* $b3 = count<16 */
+	mov	$r19 = $r16
+	cmpltu	$b1 = $r18, 4		/* $b1 = count<4  */
+	;;
+	br	$b2, 99f		/* Finished */
+	or	$r17 = $r17, $r21
+	or	$r22 = $r22, $r23
+	;;
+	brf	$b0, 10f		/* Misaligned */
+	or	$r17 = $r17, $r22
+	;;
+	br	$b3, 40f		/* Aligned but count<16 */
+	;;
+
+	/* Big loop */
+30:	stw	0[$r19] = $r17
+	cmpltu	$b0 = $r18, 16+16	/* $b0 = count<16 at end of loop */
+	cmpltu	$b1 = $r18, 4+16		/* $b1 = count<4 at end of loop */
+	cmpeq	$b2 = $r18, 16		/* $b2 = count==0 at end of loop */
+	;;
+	stw	4[$r19] = $r17
+	add	$r18 = $r18, -16
+	;;
+	stw	8[$r19] = $r17
+	;;
+	stw	12[$r19] = $r17
+	add	$r19 = $r19, 16
+	brf	$b0, 30b
+	;;
+
+	/* Less than 16 bytes remaining. See if we are finished. */
+	brf	$b2, 40f		/* not finished */
+	;;
+	goto	$r63
+	;;
+
+	/* Start not word aligned, byte at a time copy until aligned */
+10:	stb	0[$r19] = $r17
+	cmpeq	$b0 = $r20, 3		/* $b0 = will be aligned at end of loop */
+	cmpltu	$b1 = $r18, 4+1		/* $b1 = count<4 at end of loop */
+	cmpeq	$b2 = $r18, 1		/* $b2 = count==0 at end of loop */
+	;;
+	cmpltu	$b3 = $r18, 16+1		/* $b3 = count<16 at end of loop */
+	;;
+	add	$r19 = $r19, 1
+	add	$r18 = $r18, -1
+	br	$b2, 99f		/* Exit if done */
+	;;
+	brf	$b0, 10b
+	and	$r20 = $r19, 3
+	;;
+
+	/* Now word aligned. */
+	/* At least 1 byte remaining. If more then 15, use the big loop. */
+	brf	$b3, 30b
+	;;
+	/* Between 1 and 15 bytes remaining. If 4 or more copy word at a time. */
+40:	br	$b1, 50f		/* finish byte at a time */
+	;;
+
+	/* Finish word at a time */
+41:	stw	0[$r19] = $r17
+	cmpltu	$b1 = $r18, 4+4		/* $b1 = count<4 at end of loop */
+	;;
+	cmpeq	$b2 = $r18, 4		/* $b2 = count==0 at end of loop */
+	;;
+	add	$r19 = $r19, 4
+	add	$r18 = $r18, -4
+	;;
+	brf	$b1, 41b
+	;;
+
+	/* Less than 4 bytes remaining. See if we are finished. */
+	br	$b2, 99f		/* Finished */
+	;;
+
+	/* Finish byte at a time */
+50:	stb	0[$r19] = $r17
+	cmpeq	$b1 = $r18, 1		/* $b1 = count==0 at end of loop */
+	;;
+	add	$r19 = $r19, 1
+	;;
+	add	$r18 = $r18, -1
+	;;
+	brf	$b1, 50b
+	;;
+
+99:	goto	$r63
+	;;
diff --git a/arch/st200/lib/udelay.c b/arch/st200/lib/udelay.c
new file mode 100644
index 0000000..4e48ad2
--- /dev/null
+++ b/arch/st200/lib/udelay.c
@@ -0,0 +1,19 @@
+#include <linux/sched.h>
+#include <linux/delay.h>
+
+void __const_udelay(unsigned long xloops)
+{
+	unsigned long long t;
+
+	/* This could be optimised if we care */
+	t = ((unsigned long long)xloops * loops_per_jiffy) >> 32;
+
+	__delay(t * HZ);
+}
+
+void __udelay(unsigned long usecs)
+{
+
+	__const_udelay(usecs * 0x000010c6);	/* 2**32 / 1000000 */
+}
+
diff --git a/arch/st200/mm/Makefile b/arch/st200/mm/Makefile
new file mode 100644
index 0000000..94a16b2
--- /dev/null
+++ b/arch/st200/mm/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the linux ST200-specific parts of the memory manager.
+#
+
+obj-y	:= cache.o init.o pgtable.o scu.o ioremap.o fault.o dma-mapping.o
+
diff --git a/arch/st200/mm/cache.c b/arch/st200/mm/cache.c
new file mode 100644
index 0000000..bd6b8a9
--- /dev/null
+++ b/arch/st200/mm/cache.c
@@ -0,0 +1,88 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <asm/cache.h>
+#include <asm/tlbflush.h>
+
+extern void __prgset(unsigned addr);
+extern void __prgadd(unsigned addr);
+extern void __prgins(void);
+extern void __sync(void);
+
+/* Purges the entire Dcache */
+void st200_flush_dcache_all(void)
+{
+	unsigned i;
+
+	/* D-cache: size: 32K, line size 32 bytes, 4 ways */
+	for (i = 0; i < (8 * 1024); i += 32) {
+		__prgset(i);
+	}
+
+	__sync();
+
+}
+
+/* Flush a range of virtual addresses */
+void st200_flush_dcache_range(unsigned long start, unsigned long size)
+{
+	unsigned long last = (start + size - 1) & (~31ul);
+	for (start = start & (~31); start <= last; start += 32) {
+		__prgadd(start);
+	}
+	__sync();
+}
+EXPORT_SYMBOL(st200_flush_dcache_range);
+
+void st200_flush_icache_all(void)
+{
+	__prgins();
+}
+
+void st200_flush_cache_all(void)
+{
+	st200_flush_dcache_all();
+	st200_flush_icache_all();
+}
+
+void flush_dcache_page(struct page *page)
+{
+	/*
+	 * The kernel has just dirtied this page (via its page cache
+	 * address), so memory is no longer coherent.
+	 */
+	clear_bit(PG_arch_1, &page->flags);
+}
+
+/*
+ * We need to flush the kernel's icache after loading modules.  The
+ * only other use of this macro is in load_aout_interp which is not
+ * used on the ST200.
+ */
+void flush_icache_range(unsigned long start, unsigned long end)
+{
+	st200_flush_icache_all();
+	st200_flush_dcache_range(start, end - start);
+}
+
+/*
+ * Used when the kernel stores into addresses that are part of the
+ * address space of a user process. Data will have been written using
+ * the kernel's page cache address. This is only used by ptrace,
+ * usually to modify a single instruction, so the full I&D sync
+ * mechanism used by flush_dcache_page is overkill.
+ */
+void flush_icache_user_range(struct vm_area_struct *vma, struct page *page,
+			     unsigned long user_addr, int len)
+{
+	/* We don't need to do anything if this is not executable */
+	if (vma->vm_flags & VM_EXEC) {
+		unsigned long virtual;
+
+		st200_flush_icache_all();
+
+		virtual = (unsigned long)page_address(page);
+		virtual += ((user_addr) & ~PAGE_MASK);
+		st200_flush_dcache_range(virtual, len);
+	}
+}
diff --git a/arch/st200/mm/dma-mapping.c b/arch/st200/mm/dma-mapping.c
new file mode 100644
index 0000000..d0812d3
--- /dev/null
+++ b/arch/st200/mm/dma-mapping.c
@@ -0,0 +1,278 @@
+/*
+ * arch/st200/mm/consistent.c
+ *
+ * Copyright (C) 2010 David McKay
+ *
+ * Another copy based on ARM allocator to give interrupt safe alloc_coherent()
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-debug.h>
+#include <linux/vmalloc.h>
+#include <linux/io.h>
+#include <asm/cacheflush.h>
+
+/*
+ * This is yet another copy of the ARM (and powerpc) VM region allocation
+ * code (which is Copyright (C) 2000-2004 Russell King).
+ *
+ * We have to do this (rather than use get_vm_area()) because
+ * dma_alloc_coherent() can be (and is) called from interrupt level.
+ */
+
+static DEFINE_SPINLOCK(consistent_lock);
+
+/*
+ * VM region handling support.
+ *
+ * This should become something generic, handling VM region allocations for
+ * vmalloc and similar (ioremap, module space, etc).
+ *
+ * I envisage vmalloc()'s supporting vm_struct becoming:
+ *
+ *  struct vm_struct {
+ *    struct vm_region	region;
+ *    unsigned long	flags;
+ *    struct page	**pages;
+ *    unsigned int	nr_pages;
+ *    unsigned long	phys_addr;
+ *  };
+ *
+ * get_vm_area() would then call vm_region_alloc with an appropriate
+ * struct vm_region head (eg):
+ *
+ *  struct vm_region vmalloc_head = {
+ *	.vm_list	= LIST_HEAD_INIT(vmalloc_head.vm_list),
+ *	.vm_start	= VMALLOC_START,
+ *	.vm_end		= VMALLOC_END,
+ *  };
+ *
+ * However, vmalloc_head.vm_start is variable (typically, it is dependent on
+ * the amount of RAM found at boot time.)  I would imagine that get_vm_area()
+ * would have to initialise this each time prior to calling vm_region_alloc().
+ */
+struct st200_vm_region {
+	struct list_head vm_list;
+	unsigned long vm_start;
+	unsigned long vm_end;
+	struct page *vm_pages;
+};
+
+static struct st200_vm_region consistent_head = {
+	.vm_list = LIST_HEAD_INIT(consistent_head.vm_list),
+	.vm_start = CONSISTENT_START,
+	.vm_end = CONSISTENT_END,
+};
+
+static struct st200_vm_region *st200_vm_region_alloc(struct st200_vm_region
+						     *head, size_t size,
+						     gfp_t gfp)
+{
+	unsigned long addr = head->vm_start, end = head->vm_end - size;
+	unsigned long flags;
+	struct st200_vm_region *c, *new;
+
+	new = kmalloc(sizeof(struct st200_vm_region), gfp);
+	if (!new)
+		goto out;
+
+	spin_lock_irqsave(&consistent_lock, flags);
+
+	list_for_each_entry(c, &head->vm_list, vm_list) {
+		if ((addr + size) < addr)
+			goto nospc;
+		if ((addr + size) <= c->vm_start)
+			goto found;
+		addr = c->vm_end;
+		if (addr > end)
+			goto nospc;
+	}
+
+found:
+	/*
+	 * Insert this entry _before_ the one we found.
+	 */
+	list_add_tail(&new->vm_list, &c->vm_list);
+	new->vm_start = addr;
+	new->vm_end = addr + size;
+
+	spin_unlock_irqrestore(&consistent_lock, flags);
+	return new;
+
+nospc:
+	spin_unlock_irqrestore(&consistent_lock, flags);
+	kfree(new);
+out:
+	return NULL;
+}
+
+static struct st200_vm_region *st200_vm_region_find(struct st200_vm_region
+						    *head, unsigned long addr)
+{
+	struct st200_vm_region *c;
+
+	list_for_each_entry(c, &head->vm_list, vm_list) {
+		if (c->vm_start == addr)
+			goto out;
+	}
+	c = NULL;
+out:
+	return c;
+}
+
+static void *__consistent_map(struct page *page, size_t size, gfp_t gfp)
+{
+	struct st200_vm_region *c;
+	unsigned long vaddr;
+	unsigned long paddr;
+
+	c = st200_vm_region_alloc(&consistent_head, size,
+				  gfp & ~(__GFP_DMA | __GFP_HIGHMEM));
+	if (!c)
+		return NULL;
+
+	vaddr = c->vm_start;
+	paddr = page_to_phys(page);
+	if (ioremap_page_range(vaddr, vaddr + size, paddr, PAGE_KERNEL_NC)) {
+		list_del(&c->vm_list);
+		return NULL;
+	}
+
+	c->vm_pages = page;
+
+	return (void *)vaddr;
+}
+
+static struct page *__consistent_unmap(void *vaddr, size_t size)
+{
+	unsigned long flags;
+	struct st200_vm_region *c;
+	struct page *page;
+
+	spin_lock_irqsave(&consistent_lock, flags);
+	c = st200_vm_region_find(&consistent_head, (unsigned long)vaddr);
+	spin_unlock_irqrestore(&consistent_lock, flags);
+	if (!c)
+		goto no_area;
+
+	if ((c->vm_end - c->vm_start) != size) {
+		printk(KERN_ERR "%s: freeing wrong coherent size (%ld != %d)\n",
+		       __func__, c->vm_end - c->vm_start, size);
+		dump_stack();
+		size = c->vm_end - c->vm_start;
+	}
+
+	page = c->vm_pages;
+
+	unmap_kernel_range(c->vm_start, size);
+
+	spin_lock_irqsave(&consistent_lock, flags);
+	list_del(&c->vm_list);
+	spin_unlock_irqrestore(&consistent_lock, flags);
+
+	kfree(c);
+
+	return page;
+
+no_area:
+	printk(KERN_ERR "%s: trying to free invalid coherent area: %p\n",
+	       __func__, vaddr);
+	dump_stack();
+
+	return NULL;
+}
+
+#define PREALLOC_DMA_DEBUG_ENTRIES	4096
+
+static int __init dma_init(void)
+{
+	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
+	return 0;
+}
+
+fs_initcall(dma_init);
+
+void *dma_alloc_coherent(struct device *dev, size_t size,
+			 dma_addr_t *dma_handle, gfp_t gfp)
+{
+	void *ret;
+	int order = get_order(size);
+	struct page *page;
+	unsigned long phys_addr;
+	void *kernel_addr;
+
+	/* ignore region specifiers */
+	gfp &= ~(__GFP_DMA | __GFP_HIGHMEM);
+
+	size = PAGE_ALIGN(size);
+	order = get_order(size);
+
+	page = alloc_pages(gfp, order);
+	if (!page)
+		return NULL;
+
+	kernel_addr = page_address(page);
+	phys_addr = virt_to_phys(kernel_addr);
+	ret = __consistent_map(page, size, gfp);
+	if (!ret) {
+		__free_pages(page, order);
+		return NULL;
+	}
+
+	/* Is this needed? I'm not convinced that this is required
+	 * and other arches seem not to do it.
+	 */
+	memset(kernel_addr, 0, size);
+	/*
+	 * Pages from the page allocator may have data present in
+	 * cache. So flush the cache before using uncached memory.
+	 */
+	dma_cache_sync(dev, kernel_addr, size, DMA_BIDIRECTIONAL);
+
+	/*
+	 * Free the otherwise unused pages, unless got compound page
+	 */
+	if (!PageCompound(page)) {
+		struct page *end = page + (1 << order);
+
+		split_page(page, order);
+
+		for (page += size >> PAGE_SHIFT; page < end; page++)
+			__free_page(page);
+	}
+
+	*dma_handle = phys_addr;
+
+	debug_dma_alloc_coherent(dev, size, *dma_handle, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(dma_alloc_coherent);
+
+void dma_free_coherent(struct device *dev, size_t size,
+		       void *vaddr, dma_addr_t dma_handle)
+{
+	int order = get_order(size);
+	struct page *page;
+
+	debug_dma_free_coherent(dev, size, vaddr, dma_handle);
+
+	size = PAGE_ALIGN(size);
+	page = __consistent_unmap(vaddr, size);
+	if (page) {
+		if (PageCompound(page)) {
+			__free_pages(page, get_order(size));
+		} else {
+			int i;
+
+			for (i = 0; i < (size >> PAGE_SHIFT); i++)
+				__free_page(page + i);
+		}
+	}
+}
+EXPORT_SYMBOL(dma_free_coherent);
diff --git a/arch/st200/mm/fault.c b/arch/st200/mm/fault.c
new file mode 100644
index 0000000..01a076e
--- /dev/null
+++ b/arch/st200/mm/fault.c
@@ -0,0 +1,542 @@
+/*
+ * linux/arch/st200/mm/fault.c
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: David J. Mckay <david.mckay@st.com>
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/seq_file.h>
+#include <linux/interrupt.h>
+
+#include <asm/ctrlregdef.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/mmu_context.h>
+#include <asm/tlbflush.h>
+
+extern void tlb_update(unsigned long index, unsigned long tlb0,
+		       unsigned tlb1, unsigned long tlb2);
+
+//#define DEBUG
+
+extern void sim_exit(void);
+
+struct sp_count_struct {
+	unsigned long calls;
+	unsigned long soft_x;
+	unsigned long fixed;
+} sp_counts;
+
+struct miss_stats_struct {
+	unsigned long imiss;
+	unsigned long dmiss;
+	unsigned long write_to_clean1;
+	unsigned long write_to_clean2;
+	unsigned long ianddsync;
+	unsigned long misstime;
+} miss_stats;
+
+struct fault_counts_struct {
+	unsigned long faults;
+	unsigned long soft_x;
+} fault_counts;
+
+#define st200_wback_dpage(page) \
+	st200_flush_dcache_range(page_address(page), PAGE_SIZE)
+
+#define st200_invalidate_ipage(page, vaddr) \
+	st200_flush_icache_all()
+
+void set_pte(pte_t * ptep, pte_t pte)
+{
+	sp_counts.calls++;
+
+	/*
+	 * If the page is already marked as synchronised, and
+	 * the pte isn't, fix this here.
+	 */
+	if ((pte_val(pte) & (_PAGE_SOFT_USER_X | _PAGE_PROT_USER_X)) ==
+	    _PAGE_SOFT_USER_X) {
+		unsigned long pfn = pfn = pte_pfn(pte);
+		/*
+		 * I hope we're not mapping devices with execute permission,
+		 * but just in case we'll put a check in here
+		 */
+		sp_counts.soft_x++;
+		if (pfn_valid(pfn)) {
+			struct page *page = pfn_to_page(pfn);
+
+			if (test_bit(PG_arch_1, &page->flags)) {
+				//printk("PG_arch_1 set, setting PROT_USER_X old pte was %x\n",pte);
+				pte_val(pte) |= _PAGE_PROT_USER_X;
+				//printk("pte now %x\n",pte);
+				sp_counts.fixed++;
+			}
+		}
+	}
+	*(ptep) = pte;
+}
+
+#define SPLIT_PTE(pte, tlb0, tlb2)		\
+do {						\
+	unsigned long pteval;			\
+	pteval = pte_val(pte);			\
+	tlb0 = ((pteval & _PAGE_TLB_ENTRY0_0_MASK) >> _PAGE_TLB_ENTRY0_0_SHIFT) |	\
+	       ((pteval & _PAGE_TLB_ENTRY0_1_MASK) >> _PAGE_TLB_ENTRY0_1_SHIFT) |	\
+	       ctrl_inl(TLB_ASID) |		\
+	       TLB_ENTRY0_EXTRABITS;		\
+	tlb2 = pteval & _PAGE_TLB_ENTRY2_MASK;	\
+} while (0)
+
+void update_mmu_cache(struct vm_area_struct *vma,
+		      unsigned long address, pte_t pte)
+{
+	unsigned long tlb_replace, index;
+	unsigned long tlb0, tlb1, tlb2;
+
+	return;
+
+	/* ptrace may call this routine. */
+	if (vma && current->active_mm != vma->vm_mm)
+		return;
+
+	SPLIT_PTE(pte, tlb0, tlb2);
+	tlb1 = address >> TLB_ENTRY1_VADDR_SHIFT;
+
+	tlb_replace = ctrl_inl(TLB_REPLACE);
+
+	__asm__ volatile ("mullhu %0 = %1,%1\n"	/* Calculate the replacement index */
+			  ";;\n" "shru %0 = %0,16\n" ";;\n" "1:\n"	/* Start of atomic sequence */
+			  "mov	$r62 = 1b\n" "or	$r12 = $r12, 1\n"	/* Set atomic flag */
+			  ";;\n" "stw %5[$r0] = %0\n" ";;\n" "stw	%6[$r0] = $r0\n"	/* TLB_ENTRY0: Disable entry first */
+			  ";;\n" "stw	%8[$r0] = %4\n"	/* TLB_ENTRY 2 */
+			  ";;\n" "stw	%7[$r0] = %3\n"	/* TLB_ENTRY 1 */
+			  ";;\n" "stw	%6[$r0] = %2\n"	/* TLB_ENTRY 0 */
+			  "and	$r12 = $r12, ~1\n"	/* Clear atomic flag */
+			  ";;\n":"=&r" (index)	/* %0 */
+			  :"r"(tlb_replace),	/* %1 */
+			  "r"(tlb0),	/* %2 */
+			  "r"(tlb1),	/* %3 */
+			  "r"(tlb2),	/* %4 */
+			  "i"(TLB_INDEX),	/* %5 */
+			  "i"(TLB_ENTRY0),	/* %6 */
+			  "i"(TLB_ENTRY1),	/* %7 */
+			  "i"(TLB_ENTRY2)	/* %8 */
+			  :"r62");
+
+#define PP(tlb,BIT,letter) ( (tlb) & TLB_ENTRY0_PROT_##BIT ? letter : ' ' )
+
+#ifdef DEBUG
+	printk
+	    ("update_mmu_cache: address %08lx, pte %08lx, vma->vm_page_prot %08x\n",
+	     address, pte, vma->vm_page_prot);
+	printk("                  index 0x%02lx, 0:%08lx, 1:%08lx, 2:%08lx\n",
+	       index, tlb0, tlb1, tlb2, tlb0);
+	printk
+	    ("                : ASID %x SHARED %x SUPER %c%c%c USER %c%c%c POLICY %x SIZE %x\n",
+	     tlb0 & TLB_ENTRY0_ASID_MASK, (tlb0 & TLB_ENTRY0_SHARED >> 8) & 1,
+	     PP(tlb0, SUPER_R, 'R'), PP(tlb0, SUPER_W, 'W'), PP(tlb0, SUPER_X,
+								'X'), PP(tlb0,
+									 USER_R,
+									 'R'),
+	     PP(tlb0, USER_W, 'W'), PP(tlb0, USER_X, 'X'),
+	     (tlb0 & TLB_ENTRY0_POLICY_MASK) >> 16,
+	     (tlb0 & TLB_ENTRY0_SIZE_MASK) >> 20);
+#endif
+}
+
+/*
+ * We could choose to define a custom struct siginfo, which would allow
+ * the return of both cause and tlb_cause. However assuming the
+ * tlb_excause.index field is useless to a user, we can fold the two values
+ * together fairly easily.
+ */
+static inline int form_trapno(unsigned long cause, unsigned long tlb_cause)
+{
+	return (cause & 0xffff) | (tlb_cause & 0xffff0000);
+}
+
+/*
+ * This routine handles page faults.  It determines the address,
+ * and the problem, and then passes it off to one of the appropriate
+ * routines.
+ */
+void do_page_fault(struct pt_regs *regs, unsigned long address,
+		   unsigned long cause, unsigned long tlb_cause)
+{
+	struct task_struct *tsk;
+	struct mm_struct *mm;
+	struct vm_area_struct *vma;
+	const struct exception_table_entry *fixup;
+	int write;
+	int fault;
+	siginfo_t info;
+	static int addr_match;
+
+	//if(address==0x2ada4d0c && ++addr_match==3) sim_exit();
+
+#ifdef DEBUG
+	printk
+	    ("do_page_fault pc %08x cause %08x tlb_cause %08x addr %08x asid %d\n",
+	     regs->pc, cause, tlb_cause, address, ctrl_inl(TLB_ASID));
+#endif
+	fault_counts.faults++;
+	write = tlb_cause & TLB_EXCAUSE_WRITE;
+	tsk = current;
+
+	/*
+	 * We fault-in kernel-space virtual memory on-demand. The
+	 * 'reference' page table is init_mm.pgd.
+	 *
+	 * NOTE! We MUST NOT take any locks for this case. We may
+	 * be in an interrupt or a critical region, and should
+	 * only copy the information from the master page table,
+	 * nothing more.
+	 *
+	 * This verifies that the fault happens in kernel space
+	 * and that the fault was not a protection error.
+	 *
+	 */
+	if ((address >= TASK_SIZE) && !user_mode(regs) &&
+	    ((tlb_cause & TLB_EXCAUSE_CAUSE_MASK) ==
+	     TLB_EXCAUSE_CAUSE_NO_MAPPING)) {
+		goto vmalloc_fault;
+	}
+
+	/* The kernel cannot have any speculative loads. If it does, panic and die */
+	if ((tlb_cause & TLB_EXCAUSE_SPEC) && !user_mode(regs)) {
+		panic("Kernel speculative TLB miss");
+	}
+
+	mm = tsk->mm;
+	info.si_code = SEGV_MAPERR;
+
+	/*
+	 * If we're in an interrupt, have no user context or are running in an
+	 * atomic region then we must not take the fault..
+	 */
+	if (in_atomic() || !mm)
+		goto no_context;
+
+	down_read(&mm->mmap_sem);
+
+	vma = find_vma(mm, address);
+	if (!vma)
+		goto bad_area;
+	if (vma->vm_start <= address)
+		goto good_area;
+	if (!(vma->vm_flags & VM_GROWSDOWN))
+		goto bad_area;
+	if (user_mode(regs)) {
+		/*
+		 * accessing the stack below the stack pointer is always a bug.
+		 */
+		if (address < regs->r12)
+			goto bad_area;
+	}
+	if (expand_stack(vma, address))
+		goto bad_area;
+/*
+ * Ok, we have a good vm_area for this memory access, so
+ * we can handle it..
+ */
+good_area:
+	info.si_code = SEGV_ACCERR;
+	if (cause == EXCAUSENO_ITLB) {
+		/* ITLB fault */
+		if (!(vma->vm_flags & VM_EXEC))
+			goto bad_area;
+	} else {
+		/* DTLB Fault */
+		if (write) {
+			if (!(vma->vm_flags & VM_WRITE))
+				goto bad_area;
+		} else {
+			if (!(vma->vm_flags & VM_READ))
+				goto bad_area;
+		}
+	}
+
+survive:
+	/*
+	 * If for any reason at all we couldn't handle the fault,
+	 * make sure we exit gracefully rather than endlessly redo
+	 * the fault.
+	 */
+	fault = handle_mm_fault(mm, vma, address, write ? FAULT_FLAG_WRITE : 0);
+	if (unlikely(fault & VM_FAULT_ERROR)) {
+		if (fault & VM_FAULT_OOM)
+			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGBUS)
+			goto do_sigbus;
+		BUG();
+	}
+	if (fault & VM_FAULT_MAJOR)
+		tsk->maj_flt++;
+	else
+		tsk->min_flt++;
+
+	up_read(&mm->mmap_sem);
+	return;
+
+/*
+ * Something tried to access memory that isn't in our memory map..
+ * Fix it, but check if it's kernel or user first. Note that user
+ * mis-speculation will end up here.
+ */
+bad_area:
+	up_read(&mm->mmap_sem);
+
+#ifdef DEBUG
+	printk
+	    ("do_page_fault: bad_area address 0x%x cause 0x%x tlb_cause 0x%x pc 0x%x lr is 0x%x\n",
+	     address, cause, tlb_cause, regs->pc, regs->lr);
+	sim_exit();
+#endif
+
+	/* User mode accesses just cause a SIGSEGV */
+	if (user_mode(regs)) {
+		info.si_signo = SIGSEGV;
+		info.si_errno = 0;
+		/* info.si_code has been set above */
+		info.si_addr = (void *)address;
+		info.si_trapno = form_trapno(cause, tlb_cause);
+		force_sig_info(SIGSEGV, &info, tsk);
+		return;
+	}
+
+no_context:
+
+	/* Are we prepared to handle this kernel fault?  */
+	if ((fixup = search_exception_tables(regs->pc)) != 0) {
+		regs->pc = fixup->fixup;
+		return;
+	}
+
+/*
+ * Oops. The kernel tried to access some bad page. We'll have to
+ * terminate things with extreme prejudice.
+ */
+
+	bust_spinlocks(1);
+
+	if (address < PAGE_SIZE)
+		printk(KERN_ALERT
+		       "Unable to handle kernel NULL pointer dereference");
+	else
+		printk(KERN_ALERT "Unable to handle kernel paging request");
+	printk(" at virtual address %08lx\n", address);
+	printk(" pc %08lx\n", regs->pc);
+	printk(" cause %08lx\n", cause);
+	printk(" tlb_cause %08lx\n", tlb_cause);
+
+	st200_show_regs(regs, NULL);
+
+	die_if_kernel("Oops", regs);
+
+	bust_spinlocks(0);
+	do_exit(SIGKILL);
+
+/*
+ * We ran out of memory, or some other thing happened to us that made
+ * us unable to handle the page fault gracefully.
+ */
+out_of_memory:
+	up_read(&mm->mmap_sem);
+	if (tsk->pid == 1) {
+		yield();
+		down_read(&mm->mmap_sem);
+		goto survive;
+	}
+	printk("VM: killing process %s\n", tsk->comm);
+	if (user_mode(regs))
+		do_exit(SIGKILL);
+	goto no_context;
+
+do_sigbus:
+	up_read(&mm->mmap_sem);
+
+	/*
+	 * Send a sigbus, regardless of whether we were in kernel
+	 * or user mode.
+	 */
+	info.si_signo = SIGBUS;
+	info.si_errno = 0;
+	info.si_code = BUS_ADRERR;
+	info.si_addr = (void *)address;
+	info.si_trapno = form_trapno(cause, tlb_cause);
+	force_sig_info(SIGBUS, &info, tsk);
+
+	/* Kernel mode? Handle exceptions or die */
+	if (!user_mode(regs))
+		goto no_context;
+	return;
+
+vmalloc_fault:
+	{
+		/*
+		 * Synchronize this task's top level page-table
+		 * with the 'reference' page table.
+		 *
+		 * Do _not_ use "tsk" here. We might be inside
+		 * an interrupt in the middle of a task switch..
+		 */
+		int offset = pgd_index(address);
+		pgd_t *pgd, *pgd_k;
+		pmd_t *pmd, *pmd_k;
+		pte_t *pte_k;
+
+		pgd = current_pgd[smp_processor_id()] + offset;
+		pgd_k = init_mm.pgd + offset;
+
+		/* This will never happen with two level folded page tables */
+		if (!pgd_present(*pgd)) {
+			if (!pgd_present(*pgd_k))
+				goto no_context;
+			set_pgd(pgd, *pgd_k);
+			return;
+		}
+
+		pmd = pmd_offset(pgd, address);
+		pmd_k = pmd_offset(pgd_k, address);
+		if (!pmd_present(*pmd_k))
+			goto no_context;
+		set_pmd(pmd, *pmd_k);
+
+		pte_k = pte_offset_kernel(pmd_k, address);
+		if (!pte_present(*pte_k))
+			goto no_context;
+		update_mmu_cache(NULL, address, *pte_k);
+		return;
+	}
+}
+
+/* All the following functions need to be atomic between
+ * setting the index and the entry. Probably should be
+ * rewritten in  assembler using the atomic hack, or
+ * just give up and put a disable round the whole lot
+ */
+
+void flush_tlb_all(void)
+{
+	int i;
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	for (i = UTLB_USER_START; i <= UTLB_USER_LAST; i++) {
+		ctrl_outl(i, TLB_INDEX);
+		ctrl_outl(0, TLB_ENTRY0);
+	}
+
+	ctrl_outl(TLB_CONTROL_ITLB_FLUSH | TLB_CONTROL_DTLB_FLUSH, TLB_CONTROL);
+
+	local_irq_restore(flags);
+}
+
+void __flush_tlb_mm(unsigned long context)
+{
+	int i;
+	unsigned long tlb0;
+	unsigned long flags;
+	const unsigned long expected = context | TLB_ENTRY0_SIZE_8K;
+	const unsigned long mask = TLB_ENTRY0_ASID_MASK | TLB_ENTRY0_SIZE_MASK;
+
+	local_irq_save(flags);
+
+	for (i = UTLB_USER_START; i <= UTLB_USER_LAST; i++) {
+		ctrl_outl(i, TLB_INDEX);
+		tlb0 = ctrl_inl(TLB_ENTRY0);
+		if ((tlb0 & mask) == expected) {
+			ctrl_outl(0, TLB_ENTRY0);
+		}
+	}
+
+	ctrl_outl(TLB_CONTROL_ITLB_FLUSH | TLB_CONTROL_DTLB_FLUSH, TLB_CONTROL);
+
+	local_irq_restore(flags);
+}
+
+void __flush_tlb_page(unsigned long context, unsigned long addr)
+{
+	int i;
+	unsigned long tlb0, tlb1;
+	unsigned long flags;
+	const unsigned long expected = context | TLB_ENTRY0_SIZE_8K;
+	const unsigned long mask = TLB_ENTRY0_ASID_MASK | TLB_ENTRY0_SIZE_MASK;
+
+	local_irq_save(flags);
+
+	addr >>= TLB_ENTRY1_VADDR_SHIFT;
+	for (i = UTLB_USER_START; i <= UTLB_USER_LAST; i++) {
+		ctrl_outl(i, TLB_INDEX);
+		tlb1 = ctrl_inl(TLB_ENTRY1);
+		if (tlb1 == addr) {
+			tlb0 = ctrl_inl(TLB_ENTRY0);
+			if ((tlb0 & mask) == expected) {
+				ctrl_outl(0, TLB_ENTRY0);
+				break;
+			}
+		}
+	}
+
+	ctrl_outl(TLB_CONTROL_ITLB_FLUSH | TLB_CONTROL_DTLB_FLUSH, TLB_CONTROL);
+
+	local_irq_restore(flags);
+}
+
+void __flush_tlb_range(unsigned long context,
+		       unsigned long start, unsigned long end)
+{
+	int i;
+	unsigned long tlb0, tlb1;
+	unsigned long flags;
+	const unsigned long expected = context | TLB_ENTRY0_SIZE_8K;
+	const unsigned long mask = TLB_ENTRY0_ASID_MASK | TLB_ENTRY0_SIZE_MASK;
+
+	local_irq_save(flags);
+
+	start >>= TLB_ENTRY1_VADDR_SHIFT;
+	end >>= TLB_ENTRY1_VADDR_SHIFT;
+	for (i = UTLB_USER_START; i <= UTLB_USER_LAST; i++) {
+		ctrl_outl(i, TLB_INDEX);
+		tlb0 = ctrl_inl(TLB_ENTRY0);
+		tlb1 = ctrl_inl(TLB_ENTRY1);
+		if (((tlb0 & mask) == expected) &&
+		    (tlb1 >= start) && (tlb1 < end)) {
+			ctrl_outl(0, TLB_ENTRY0);
+		}
+	}
+
+	ctrl_outl(TLB_CONTROL_ITLB_FLUSH | TLB_CONTROL_DTLB_FLUSH, TLB_CONTROL);
+
+	local_irq_restore(flags);
+}
+
+#ifdef CONFIG_PROC_FS
+void mm_show_cpuinfo(struct seq_file *m)
+{
+	seq_printf(m, "set_pte():\n");
+	seq_printf(m, "  calls:                    %d\n", sp_counts.calls);
+	seq_printf(m, "  of which: soft X:         %d\n", sp_counts.soft_x);
+	seq_printf(m, "  of which: made hard X:    %d\n", sp_counts.fixed);
+
+	seq_printf(m, "TLB Faults fixed in assembler:\n");
+	seq_printf(m, "  ITLB trivial misses:      %d\n", miss_stats.imiss);
+	seq_printf(m, "  DTLB trivial misses:      %d\n", miss_stats.dmiss);
+	seq_printf(m, "  Write to clean (not UTLB):%d\n",
+		   miss_stats.write_to_clean1);
+	seq_printf(m, "  Write to clean (in UTLB): %d\n",
+		   miss_stats.write_to_clean2);
+	seq_printf(m, "  Prot vio for I&D sync:    %d\n", miss_stats.ianddsync);
+	seq_printf(m, "  Total miss time:          %d\n", miss_stats.misstime);
+
+	seq_printf(m, "TLB Faults fixed in C:\n");
+	seq_printf(m, "  count:                    %d\n", fault_counts.faults);
+	seq_printf(m, "  Prot vio for I&D sync:    %d\n", fault_counts.soft_x);
+}
+#endif
diff --git a/arch/st200/mm/init.c b/arch/st200/mm/init.c
new file mode 100644
index 0000000..fcfe6d9
--- /dev/null
+++ b/arch/st200/mm/init.c
@@ -0,0 +1,268 @@
+/*
+ * otmem
+ * linux/arch/st200/mm/init.c
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/initrd.h>
+#ifdef CONFIG_BLK_DEV_RAM
+#include <linux/blkdev.h>
+#endif
+#include <asm/mmu_context.h>
+#include <asm/tlb.h>
+#include <asm/io.h>
+#include <asm/scu.h>
+
+/* References to section boundaries */
+extern char _text, _etext, _edata, __bss_start, _end;
+extern char __init_begin, __init_end;
+
+static unsigned long lowmem_pages;
+extern unsigned long mem_size;
+extern unsigned long mem_start;
+
+/* Is a given physical address in RAM or not? Used for ioremap() and
+ * /dev/mem stuff
+ */
+int phys_is_ram(unsigned long physaddr)
+{
+	if (physaddr < mem_start || physaddr >= (mem_start + mem_size))
+		return 0;
+
+	return 1;
+}
+
+unsigned long asid_cache = ASID_FIRST_VERSION;
+DEFINE_PER_CPU(struct mmu_gather, mmu_gathers);
+unsigned long last_user_utlb_entry;
+
+void show_mem(void)
+{
+	int total = 0, reserved = 0;
+	int shared = 0, cached = 0;
+	int highmem = 0;
+	struct page *page;
+	pg_data_t *pgdat;
+	unsigned long i;
+
+	printk("Mem-info:\n");
+	show_free_areas();
+	printk("Free swap:       %6dkB\n", nr_swap_pages << (PAGE_SHIFT - 10));
+	for_each_online_pgdat(pgdat) {
+		for (i = 0; i < pgdat->node_spanned_pages; ++i) {
+			page = pgdat->node_mem_map + i;
+			total++;
+			if (PageHighMem(page))
+				highmem++;
+			if (PageReserved(page))
+				reserved++;
+			else if (PageSwapCache(page))
+				cached++;
+			else if (page_count(page))
+				shared += page_count(page) - 1;
+		}
+	}
+	printk("%d pages of RAM\n", total);
+	printk("%d pages of HIGHMEM\n", highmem);
+	printk("%d reserved pages\n", reserved);
+	printk("%d pages shared\n", shared);
+	printk("%d pages swap cached\n", cached);
+}
+
+/* Now we know exactly how much memory there is, re-initialise the SCU */
+void scu_init(void)
+{
+	if (request_scu_region(mem_start, mem_size))
+		panic("Cannot allocate main memory SCU region!!");
+}
+
+unsigned long __init
+bootmem_init(unsigned long bios_initrd_start, unsigned long bios_initrd_size)
+{
+	unsigned long bootmap_size;
+	unsigned long memstart_pfn, memend_pfn;
+
+	/*
+	 * The entire memory region which we will manage with the bootmem
+	 * allocator.
+	 */
+	memstart_pfn = PFN_UP(mem_start);
+	memend_pfn = PFN_DOWN(mem_start + mem_size);
+	lowmem_pages = memend_pfn - memstart_pfn;
+
+	/*
+	 * Usable pages (ie not currently containing kernel code or data).
+	 * These are global variables used by the generic code.
+	 */
+	min_low_pfn = PFN_UP(__pa(&_end));
+	max_low_pfn = memend_pfn;
+	max_pfn = memend_pfn;	/* No highmem */
+
+	/*
+	 * Initialize the boot-time allocator.
+	 * We place the bootmem bitmap right at the start of available memory.
+	 * (We should really check there is enough memory there first)
+	 * After this all memory is marked as reserved.
+	 */
+
+	printk("Bootmemory allocator at %ld describing 0x%08lx to 0x%08lx\n",
+	       min_low_pfn, PFN_PHYS(memstart_pfn), PFN_PHYS(memend_pfn));
+	bootmap_size = init_bootmem_node(NODE_DATA(0), min_low_pfn,
+					 memstart_pfn, memend_pfn);
+
+	/*
+	 * Mark the free region
+	 */
+	printk("freeing pages %ld:%ld\n", min_low_pfn, max_low_pfn);
+	free_bootmem(PFN_PHYS(min_low_pfn),
+		     PFN_PHYS(max_low_pfn - min_low_pfn));
+
+	/*
+	 * Reserve the bootmem bitmap itself.
+	 */
+	printk("reserving pages %ld:%ld\n",
+	       min_low_pfn, min_low_pfn + (PFN_UP(bootmap_size)));
+	reserve_bootmem(PFN_PHYS(min_low_pfn), bootmap_size, BOOTMEM_DEFAULT);
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (bios_initrd_start != 0) {
+		initrd_start = (unsigned long)__va(bios_initrd_start);
+		initrd_end = initrd_start + bios_initrd_size;
+		initrd_below_start_ok = 1;
+		printk("Initial ramdisk at: 0x%08lx (%lu bytes)\n",
+		       initrd_start, bios_initrd_size);
+		reserve_bootmem(__pa(initrd_start), bios_initrd_size,
+				BOOTMEM_DEFAULT);
+	}
+#endif
+
+	return max_low_pfn;
+}
+
+static void __init pagetable_init(void)
+{
+	int i;
+
+	/* Init entries of the first-level page table */
+	for (i = 0; i < PTRS_PER_PGD; i++)
+		set_pgd(swapper_pg_dir + i, __pgd(0));
+}
+
+static void __init mmu_context_init(void)
+{
+	/* Initialise the ASID handling */
+	asid_cache = ASID_FIRST_VERSION;
+	set_asid(asid_cache & ASID_MASK);
+
+	/*
+	 * Initialise the number of user TLBs variable
+	 */
+	last_user_utlb_entry =
+	    (ctrl_inl(TLB_REPLACE) >> TLB_REPLACE_LIMIT_SHIFT) - 2;
+
+	/* Initialise the TLB_REPLACE.LIMIT and .LSFR fields */
+	ctrl_outl((UTLB_USER_ENTRIES << TLB_REPLACE_LIMIT_SHIFT) |
+		  TLB_REPLACE_LFSR_MASK, TLB_REPLACE);
+}
+
+void __init mem_init(void)
+{
+	int codesize, reservedpages, datasize, initsize, bsssize, pagemapsize;
+	int i;
+
+	/* Global variables describing the memory map */
+	max_mapnr = num_physpages = lowmem_pages;
+	high_memory = (void *)__va(max_low_pfn * PAGE_SIZE);
+
+	/* clear the zero-page */
+	memset(empty_zero_page, 0, PAGE_SIZE);
+
+	/* this will put all low memory onto the freelists */
+	totalram_pages += free_all_bootmem();
+
+	reservedpages = 0;
+	for (i = 0; i < num_physpages; i++) {
+		/* Only count reserved RAM pages */
+		if (PageReserved(mem_map + i))
+			reservedpages++;
+	}
+
+	codesize = (unsigned long)&_etext - (unsigned long)&_text;
+	datasize = (unsigned long)&_edata - (unsigned long)&_etext;
+	bsssize = (unsigned long)&_end - (unsigned long)&__bss_start;
+	initsize = (unsigned long)&__init_end - (unsigned long)&__init_begin;
+	pagemapsize = (max_mapnr + 1) * sizeof(struct page);
+
+	printk
+	    ("Memory: %luk/%luk available (%dk reserved including: %dk kernel code, %dk data, %dk BSS, %dk init, %dk page map)\n",
+	     (unsigned long)nr_free_pages() << (PAGE_SHIFT - 10),
+	     max_mapnr << (PAGE_SHIFT - 10), reservedpages << (PAGE_SHIFT - 10),
+	     codesize >> 10, datasize >> 10, bsssize >> 10, initsize >> 10,
+	     pagemapsize >> 10);
+}
+
+static void __init zone_sizes_init(void)
+{
+	unsigned long zones_size[MAX_NR_ZONES];
+	int i;
+
+	/* We only have ZONE_NORMAL, you can DMA everywhere */
+	zones_size[ZONE_NORMAL] = lowmem_pages;
+
+	for (i = 1; i < MAX_NR_ZONES; i++)
+		zones_size[i] = 0;
+
+	/* We can't use free_area_init() because that assumes that memory layout is sane
+	 * which it isn't on the ST200 due to the fact that the chips it is integrated into have
+	 * an SH4 which has a 512M address limit. Thus DRAM usually starts at fairy odd boundaries.
+	 */
+	free_area_init_node(0, zones_size, ARCH_PFN_OFFSET, NULL);
+}
+
+void __init paging_init(void)
+{
+	pagetable_init();
+	mmu_context_init();
+	zone_sizes_init();
+}
+
+void free_initmem(void)
+{
+	unsigned long addr;
+
+	addr = (unsigned long)(&__init_begin);
+	printk("free_initmem: %08lx to %08lx\n", addr,
+	       (unsigned long)(&__init_end));
+	for (; addr < (unsigned long)(&__init_end); addr += PAGE_SIZE) {
+		struct page *page = virt_to_page(addr);
+		ClearPageReserved(page);
+		init_page_count(page);
+		free_page(addr);
+		totalram_pages++;
+	}
+	printk(KERN_INFO "Freeing unused kernel memory: %dk freed\n",
+	       (&__init_end - &__init_begin) >> 10);
+}
+
+#ifdef CONFIG_BLK_DEV_INITRD
+void free_initrd_mem(unsigned long start, unsigned long end)
+{
+	if (start < end)
+		printk(KERN_INFO "Freeing initrd memory: %ldk freed\n",
+		       (end - start) >> 10);
+	for (; start < end; start += PAGE_SIZE) {
+		struct page *page = virt_to_page(start);
+		ClearPageReserved(page);
+		init_page_count(page);
+		free_page(start);
+		totalram_pages++;
+	}
+}
+#endif
diff --git a/arch/st200/mm/ioremap.c b/arch/st200/mm/ioremap.c
new file mode 100644
index 0000000..4370771
--- /dev/null
+++ b/arch/st200/mm/ioremap.c
@@ -0,0 +1,205 @@
+/*
+ * linux/arch/st200/mm/ioremap.c
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ * Large portions copied from arch/i386/mm/ioremap.c which was:
+ *	(C) Copyright 1995 1996 Linus Torvalds
+ *
+ * Re-map IO memory to kernel address space so that we can access it.
+ */
+
+#include <linux/vmalloc.h>
+#include <linux/ioport.h>
+#include <linux/bootmem.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <asm/io.h>
+#include <asm/pgalloc.h>
+#include <asm/cacheflush.h>
+#include <asm/tlbflush.h>
+#include <asm/pgtable.h>
+
+static inline void remap_area_pte(pte_t * pte, unsigned long address,
+				  unsigned long size, unsigned long phys_addr,
+				  pgprot_t prot)
+{
+	unsigned long end;
+	unsigned long pfn;
+
+	address &= ~PMD_MASK;
+	end = address + size;
+	if (end > PMD_SIZE)
+		end = PMD_SIZE;
+	if (address >= end)
+		BUG();
+	pfn = phys_addr >> PAGE_SHIFT;
+#if DEBUG
+	printk("%s:pte 0x%p address %p size 0x%x phys_addr 0x%x\n",
+	       __FUNCTION__, pte, address, size, phys_addr);
+#endif
+	do {
+		if (!pte_none(*pte)) {
+			printk("remap_area_pte: page already exists\n");
+			BUG();
+		}
+		set_pte(pte, pfn_pte(pfn, prot));
+		address += PAGE_SIZE;
+		pfn++;
+		pte++;
+	} while (address && (address < end));
+}
+
+static inline int remap_area_pmd(pmd_t * pmd, unsigned long address,
+				 unsigned long size, unsigned long phys_addr,
+				 pgprot_t prot)
+{
+	unsigned long end;
+
+	address &= ~PGDIR_MASK;
+	end = address + size;
+	if (end > PGDIR_SIZE)
+		end = PGDIR_SIZE;
+	phys_addr -= address;
+	if (address >= end)
+		BUG();
+	do {
+		pte_t *pte = pte_alloc_kernel(pmd, address);
+		if (!pte)
+			return -ENOMEM;
+		remap_area_pte(pte, address, end - address, address + phys_addr,
+			       prot);
+		address = (address + PMD_SIZE) & PMD_MASK;
+		pmd++;
+	} while (address && (address < end));
+	return 0;
+}
+
+static int remap_area_pages(unsigned long address, unsigned long phys_addr,
+			    unsigned long size, pgprot_t prot)
+{
+	int error;
+	pgd_t *dir;
+	unsigned long end = address + size;
+
+	phys_addr -= address;
+	dir = pgd_offset(&init_mm, address);
+	flush_cache_all();
+	if (address >= end)
+		BUG();
+	spin_lock(&init_mm.page_table_lock);
+	do {
+		pmd_t *pmd;
+		pmd = pmd_alloc(&init_mm, dir, address);
+		error = -ENOMEM;
+		if (!pmd)
+			break;
+		if (remap_area_pmd(pmd, address, end - address,
+				   phys_addr + address, prot))
+			break;
+		error = 0;
+		address = (address + PGDIR_SIZE) & PGDIR_MASK;
+		dir++;
+	} while (address && (address < end));
+	spin_unlock(&init_mm.page_table_lock);
+	flush_tlb_all();
+	return error;
+}
+
+/*
+ * Generic mapping function (not visible outside):
+ */
+
+static void *remap(unsigned long phys_addr, unsigned long size, pgprot_t prot,
+		   int io)
+{
+
+	void *addr;
+	struct vm_struct *area;
+	unsigned long offset, last_addr;
+
+	/* Don't allow wraparound or zero size */
+	last_addr = phys_addr + size - 1;
+	if (!size || last_addr < phys_addr)
+		return NULL;
+
+	/*
+	 * Don't allow anybody to remap normal RAM that we're using..
+	 */
+	if (io && phys_is_ram(phys_addr)) {
+		char *t_addr, *t_end;
+		struct page *page;
+
+		t_addr = __va(phys_addr);
+		t_end = t_addr + (size - 1);
+
+		for (page = virt_to_page(t_addr); page <= virt_to_page(t_end);
+		     page++)
+			if (!PageReserved(page))
+				return NULL;
+	}
+
+	/*
+	 * Mappings have to be page-aligned
+	 */
+	offset = phys_addr & ~PAGE_MASK;
+	phys_addr &= PAGE_MASK;
+	size = PAGE_ALIGN(last_addr) - phys_addr;
+
+	/*
+	 * Ok, go for it..
+	 */
+	area = get_vm_area(size, (io) ? VM_IOREMAP : VM_ALLOC);
+	if (!area)
+		return NULL;
+	area->phys_addr = phys_addr;
+	addr = area->addr;
+	if (remap_area_pages(VMALLOC_VMADDR(addr), phys_addr, size, prot)) {
+		vunmap(addr);
+		return NULL;
+	}
+	return (void *)(offset + (char *)addr);
+
+}
+
+/*
+ * Remap an arbitrary physical address space into the kernel virtual
+ * address space. Needed when the kernel wants to access high addresses
+ * directly.
+ *
+ * NOTE! We need to allow non-page-aligned mappings too: we will obviously
+ * have to convert them into an offset in a page-aligned mapping, but the
+ * caller shouldn't need to know that small detail.
+ */
+void *__ioremap(unsigned long phys_addr, unsigned long size, pgprot_t prot)
+{
+	return remap(phys_addr, size, prot, 1);
+}
+EXPORT_SYMBOL(__ioremap);
+
+void *coherent_remap(unsigned long phys_addr, unsigned long size)
+{
+
+	return remap(phys_addr, size, PAGE_KERNEL_NC, 0);
+}
+
+void coherent_unmap(void *addr)
+{
+	iounmap(addr);
+}
+
+void iounmap(void *addr)
+{
+	struct vm_struct *p;
+	if (addr <= high_memory)
+		return;
+	p = remove_vm_area((void *)(PAGE_MASK & (unsigned long)addr));
+	if (!p) {
+		printk("__iounmap: bad address %p\n", addr);
+		return;
+	}
+
+	kfree(p);
+}
+EXPORT_SYMBOL(iounmap);
+
diff --git a/arch/st200/mm/pgtable.c b/arch/st200/mm/pgtable.c
new file mode 100644
index 0000000..0de200f
--- /dev/null
+++ b/arch/st200/mm/pgtable.c
@@ -0,0 +1,88 @@
+/*
+ * linux/arch/st200/mm/pgtable.c
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#include <linux/sched.h>
+#if 0
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <linux/swap.h>
+#include <linux/smp.h>
+#include <linux/highmem.h>
+#endif
+#include <linux/slab.h>
+
+#if 0
+#include <asm/system.h>
+#endif
+#include <asm/pgtable.h>
+#include <asm/pgalloc.h>
+#if 0
+#include <asm/fixmap.h>
+#include <asm/e820.h>
+#include <asm/tlb.h>
+#include <asm/tlbflush.h>
+#endif
+
+pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
+{
+	int count = 0;
+	pte_t *pte;
+
+	do {
+		pte = (pte_t *) __get_free_page(GFP_KERNEL);
+		if (pte)
+			clear_page(pte);
+		else {
+			current->state = TASK_UNINTERRUPTIBLE;
+			schedule_timeout(HZ);
+		}
+	} while (!pte && (count++ < 10));
+	return pte;
+}
+
+#if 0
+struct page *pte_alloc_one(struct mm_struct *mm, unsigned long address)
+{
+	int count = 0;
+	struct page *pte;
+
+	do {
+		pte = alloc_pages(GFP_KERNEL, 0);
+		if (pte)
+			clear_highpage(pte);
+		else {
+			current->state = TASK_UNINTERRUPTIBLE;
+			schedule_timeout(HZ);
+		}
+	} while (!pte && (count++ < 10));
+	return pte;
+}
+#endif
+
+#if 0
+pgd_t *pgd_alloc(struct mm_struct * mm)
+{
+	pgd_t *pgd = (pgd_t *) __get_free_page(GFP_KERNEL);
+
+	if (pgd) {
+		memset(pgd, 0, USER_PTRS_PER_PGD * sizeof(pgd_t));
+		memcpy(pgd + USER_PTRS_PER_PGD,
+		       swapper_pg_dir + USER_PTRS_PER_PGD,
+		       (PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
+	}
+	return pgd;
+}
+#endif
+
+#if 0
+void pgd_free(pgd_t * pgd)
+{
+	free_page((unsigned long)pgd);
+}
+#endif
diff --git a/arch/st200/mm/scu.c b/arch/st200/mm/scu.c
new file mode 100644
index 0000000..fb20f04
--- /dev/null
+++ b/arch/st200/mm/scu.c
@@ -0,0 +1,144 @@
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/semaphore.h>
+#include <asm/io.h>
+#include <asm/ctrlregdef.h>
+#include <asm/scu.h>
+
+static DECLARE_MUTEX(scu_sem);
+
+struct scu_entry {
+	unsigned long start;
+	unsigned long end;
+	int ref;
+};
+
+static struct scu_entry scu_table[SCU_NUM_ENTRIES];
+
+#define SCU_INDEX_NUM(x) ((x)-scu_table)
+
+static void update_scu_entry(struct scu_entry *scu)
+{
+	unsigned n = SCU_INDEX_NUM(scu);
+
+	BUG_ON(n >= SCU_NUM_ENTRIES);
+
+	if (scu->ref == 0) {
+		/* Disable */
+		ctrl_outl(~0 >> SCU_SHIFT, SCU_BASE(n));
+		ctrl_outl(0, SCU_LIMIT(n));
+	} else {
+		/* Disable first, then enable */
+		ctrl_outl(~0 >> SCU_SHIFT, SCU_BASE(n));
+		ctrl_outl(scu->end >> SCU_SHIFT, SCU_LIMIT(n));
+		ctrl_outl(scu->start >> SCU_SHIFT, SCU_BASE(n));
+	}
+}
+
+static struct scu_entry *search_scu_table(unsigned long start,
+					  unsigned long end)
+{
+	int i;
+
+	/* Scan allocated regions for submatch */
+	for (i = 0; i < SCU_NUM_ENTRIES; i++) {
+		/* Only scan allocated entries */
+		if (scu_table[i].ref && scu_table[i].start >= start
+		    && scu_table[i].end <= end)
+			return scu_table + i;
+	}
+	return NULL;
+}
+
+static struct scu_entry *find_empty_scu(void)
+{
+	int i;
+
+	for (i = 0; i < SCU_NUM_ENTRIES; i++) {
+		if (scu_table[i].ref == 0)
+			return scu_table + i;
+	}
+	return NULL;
+}
+
+/* Check to see if the given range overlaps any of the scu. Note that
+ * this routine does not regard regions within one of the entries
+ * as an overlap
+ */
+static int check_for_overlap(unsigned long start, unsigned long end)
+{
+	int i;
+
+	for (i = 0; i < SCU_NUM_ENTRIES; i++) {
+		if (scu_table[i].ref &&
+		    ((start < scu_table[i].start && end > scu_table[i].start) ||
+		     (start < scu_table[i].end && end > scu_table[i].end)))
+			return 1;
+	}
+	return 0;
+}
+
+/* Give me a SCU region if you can */
+int request_scu_region(unsigned long start, unsigned size)
+{
+	int index;
+	unsigned long end;
+	struct scu_entry *scu;
+
+	BUG_ON(in_interrupt());
+
+	/* We can only cope with requests that are page aligned and a multiple
+	 * of the page size.
+	 */
+	if ((size == 0) || (start & (PAGE_SIZE - 1))
+	    || (size & (PAGE_SIZE - 1))) {
+		return -EINVAL;
+	}
+
+	end = start + size - 1;
+
+	down(&scu_sem);
+
+	scu = search_scu_table(start, end);
+
+	if (scu) {
+		scu->ref++;
+	} else {
+		if (!check_for_overlap(start, end)) {
+			scu = find_empty_scu();
+			if (scu) {
+				scu->start = start;
+				scu->end = end;
+				scu->ref = 1;
+				update_scu_entry(scu);
+			}
+		}
+	}
+
+	up(&scu_sem);
+
+	return (scu) ? 0 : -EBUSY;
+}
+
+void release_scu_region(unsigned long start, unsigned size)
+{
+	struct scu_entry *scu;
+	unsigned end;
+
+	BUG_ON(in_interrupt());
+
+	end = start + size - 1;
+
+	down(&scu_sem);
+
+	scu = search_scu_table(start, end);
+
+	if (scu) {
+		scu->ref--;
+		if (scu->ref == 0) {
+			update_scu_entry(scu);
+		}
+	}
+
+	up(&scu_sem);
+}
diff --git a/arch/st200/oprofile/Makefile b/arch/st200/oprofile/Makefile
new file mode 100644
index 0000000..e9feca1
--- /dev/null
+++ b/arch/st200/oprofile/Makefile
@@ -0,0 +1,9 @@
+obj-$(CONFIG_OPROFILE) += oprofile.o
+
+DRIVER_OBJS = $(addprefix ../../../drivers/oprofile/, \
+		oprof.o cpu_buffer.o buffer_sync.o \
+		event_buffer.o oprofile_files.o \
+		oprofilefs.o oprofile_stats.o \
+		timer_int.o )
+
+oprofile-y				:= $(DRIVER_OBJS) init.o
diff --git a/arch/st200/oprofile/init.c b/arch/st200/oprofile/init.c
new file mode 100644
index 0000000..107f07e
--- /dev/null
+++ b/arch/st200/oprofile/init.c
@@ -0,0 +1,14 @@
+#include <linux/kernel.h>
+#include <linux/oprofile.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+
+int __init oprofile_arch_init(struct oprofile_operations *ops)
+{
+	/* This will cause the generic code to fall back to using timers */
+	return -ENODEV;
+}
+
+void oprofile_arch_exit(void)
+{
+}
diff --git a/arch/st200/soc/fpga/Makefile b/arch/st200/soc/fpga/Makefile
new file mode 100644
index 0000000..dfa8437
--- /dev/null
+++ b/arch/st200/soc/fpga/Makefile
@@ -0,0 +1,2 @@
+obj-y 	+= platform.o
+
diff --git a/arch/st200/soc/fpga/platform.c b/arch/st200/soc/fpga/platform.c
new file mode 100644
index 0000000..9b62ebe
--- /dev/null
+++ b/arch/st200/soc/fpga/platform.c
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2010 STMicroelectronics Limited
+ * Author: David McKay <david.mckay@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License V2.  See linux/COPYING for more information.
+ *
+ * Support for the FPGA based core used in the  MB427 FPGA board
+ */
+
+#include <linux/device.h>
+#include <linux/st_soc.h>
+#include <asm/ctrlregdef.h>
+#include <linux/io.h>
+
+struct soc_info soc_data = {
+	.devices = NULL,
+	.num_devices = 0,
+	.uarts = NULL,
+	.num_uarts = 0
+};
+
+/* This needs to die, there is no need for this to be in the SOC layer */
+extern void __init init_st200_irq(unsigned long base_addr);
+
+void __init init_IRQ(void)
+{
+	init_st200_irq(ctrl_inl(PERIPHERAL_BASE));
+}
+
+/*
+ * There is nothing to do here - the fpga doesn't have anything other than a
+ * core
+ */
+
+int __init soc_setup(void)
+{
+	return 0;
+}
+
+/* Insufficient information to actually implement these. Ideally
+ * a watchdog timer would be used, but there is no driver for that
+ */
+void soc_machine_restart(char *cmd)
+{
+	for (;;)
+		/* Do Nothing */;
+}
+
+void soc_machine_halt(void)
+{
+	for (;;)
+		;
+}
+
+void soc_machine_power_off(void)
+{
+	for (;;)
+		;
+}
diff --git a/arch/st200/soc/sim/Makefile b/arch/st200/soc/sim/Makefile
new file mode 100644
index 0000000..dfa8437
--- /dev/null
+++ b/arch/st200/soc/sim/Makefile
@@ -0,0 +1,2 @@
+obj-y 	+= platform.o
+
diff --git a/arch/st200/soc/sim/platform.c b/arch/st200/soc/sim/platform.c
new file mode 100644
index 0000000..e8be65e
--- /dev/null
+++ b/arch/st200/soc/sim/platform.c
@@ -0,0 +1,138 @@
+#include <linux/platform_device.h>
+#include <linux/st_soc.h>
+
+/* Simulated  ethernet device */
+
+#define SIMETH_START 0x1f200000
+#define SIMETH_END   0x1f20001f
+#define SIMETH_IRQ   4
+
+static struct resource simeth_resources[] = {
+	[0] = {
+		.start = SIMETH_START,
+		.end = SIMETH_END,
+		.flags = IORESOURCE_MEM
+	},
+	[1] = {
+		.start = SIMETH_IRQ,
+		.flags = IORESOURCE_IRQ
+	}
+};
+
+static struct platform_device simeth_device = {
+	.name = "STM-simeth",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(simeth_resources),
+	.resource = simeth_resources
+};
+
+#define SIMKBD_START 0x1f400100
+#define SIMKBD_END   0x1f400107
+#define SIMKBD_IRQ   5
+
+static struct resource simkbd_resources[] = {
+	[0] = {
+		.start = SIMKBD_START,
+		.end = SIMKBD_END,
+		.flags = IORESOURCE_MEM},
+	[1] = {
+		.start = SIMKBD_IRQ,
+		.flags = IORESOURCE_IRQ
+	}
+};
+
+static struct platform_device simkbd_device = {
+	.name = "STM-simkbd",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(simkbd_resources),
+	.resource = simkbd_resources
+};
+
+#define SIMMOUSE_START 0x1f400200
+#define SIMMOUSE_END   0x1f40020b
+#define SIMMOUSE_IRQ   6
+
+static struct resource simmouse_resources[] = {
+	[0] = {
+		.start = SIMMOUSE_START,
+		.end = SIMMOUSE_END,
+		.flags = IORESOURCE_MEM
+	},
+	[1] = {
+		.start = SIMMOUSE_IRQ,
+		.flags = IORESOURCE_IRQ
+	}
+};
+
+static struct platform_device simmouse_device = {
+	.name = "STM-simmouse",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(simmouse_resources),
+	.resource = simmouse_resources
+};
+
+#define SIMFB_CTRL_START 0x1f400000
+#define SIMFB_CTRL_END   0x1f4000ff
+
+#define SIMFB_FB_START   0x1f500000
+#define SIMFB_FB_END     0x1f9fffff
+
+static struct resource simfb_resources[] = {
+	[0] = {
+	       .start = SIMFB_CTRL_START,
+	       .end = SIMFB_CTRL_END,
+	       .flags = IORESOURCE_MEM},
+	[1] = {
+	       .start = SIMFB_FB_START,
+	       .end = SIMFB_FB_END,
+	       .flags = IORESOURCE_MEM}
+};
+
+static struct platform_device simfb_device = {
+	.name = "STM-simfb",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(simfb_resources),
+	.resource = simfb_resources
+};
+
+/* This is the globally exported list of devices supported by this soc */
+static struct platform_device *__initdata soc_device_list[] = {
+	&simeth_device,
+	&simmouse_device,
+	&simkbd_device,
+	&simfb_device,
+};
+
+struct soc_info soc_data = {
+	.devices = soc_device_list,
+	.num_devices = ARRAY_SIZE(soc_device_list),
+	.uarts = NULL,
+	.num_uarts = 0
+};
+
+#define PERIPHERIAL_BASE    0x1f000000
+
+extern void __init init_st200_irq(unsigned long base_addr);
+
+void __init init_IRQ(void)
+{
+	init_st200_irq(PERIPHERIAL_BASE);
+}
+
+int __init soc_setup(void)
+{
+	return 0;
+}
+/* These all just exit - though we could actually implement restart()
+ * in the simulator quite easily
+ */
+
+
+extern void sim_exit(int);
+
+void soc_machine_restart(char *cmd) { sim_exit(0); }
+void soc_machine_halt(void) { sim_exit(0); }
+void soc_machine_power_off(void) { sim_exit(0); }
+
+
+
diff --git a/arch/st200/soc/stv576/Makefile b/arch/st200/soc/stv576/Makefile
new file mode 100644
index 0000000..dfa8437
--- /dev/null
+++ b/arch/st200/soc/stv576/Makefile
@@ -0,0 +1,2 @@
+obj-y 	+= platform.o
+
diff --git a/arch/st200/soc/stv576/platform.c b/arch/st200/soc/stv576/platform.c
new file mode 100644
index 0000000..8783b48
--- /dev/null
+++ b/arch/st200/soc/stv576/platform.c
@@ -0,0 +1,506 @@
+#include <linux/platform_device.h>
+#include <linux/st_soc.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/irq-reflector.h>
+
+/* ST RS serial port */
+
+#define STRS_UART1_START 0x3c0fb000
+#define STRS_UART1_END   0x3c0fb011
+#define STRS_UART1_IRQ   64
+
+static struct resource strs_resources[] = {
+	[0] = {
+	       .start = STRS_UART1_START,
+	       .end = STRS_UART1_END,
+	       .flags = IORESOURCE_MEM},
+	[1] = {
+	       .start = STRS_UART1_IRQ,
+	       .flags = IORESOURCE_IRQ}
+};
+
+static struct platform_device strs_device = {
+	.name = "strs",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(strs_resources),
+	.resource = strs_resources
+};
+
+struct platform_device *strs_configured_devices[] = { &strs_device };
+
+int strs_configured_devices_count = 1;
+int strs_console_device = 0;
+
+static u64 stv576_dma_mask = DMA_32BIT_MASK;
+
+static struct plat_stv576_usb_data stv576_usb_data = {
+	.usb_ctrl_addr = 0x3c0c3400,
+	.usb_phy_addr  = 0x3c042400,
+	.initialised = 0,
+};
+
+static struct platform_device stv576_ohci_device = {
+	.name = "stv576-ohci",
+	.id = 0,
+	.dev = {
+		.dma_mask = &stv576_dma_mask,
+		.coherent_dma_mask = DMA_32BIT_MASK,
+		.platform_data =  &stv576_usb_data,
+	},
+	.num_resources = 2,
+	.resource = (struct resource[]) {
+		[0] = {
+			.start = 0x3c0c3c00,
+			.end   = 0x3c0c3cff,
+			.flags = IORESOURCE_MEM,
+		},
+		[1] = {
+			.start = 67,
+			.end   = 67,
+			.flags = IORESOURCE_IRQ,
+		}
+	}
+};
+
+static struct platform_device stv576_ehci_device = {
+	.name = "stv576-ehci",
+	.id = 0,
+	.dev = {
+		.dma_mask = &stv576_dma_mask,
+		.coherent_dma_mask = DMA_32BIT_MASK,
+		.platform_data =  &stv576_usb_data,
+	},
+	.num_resources = 2,
+	.resource = (struct resource[]) {
+		[0] = {
+			.start = 0x3c0c3800,
+			.end   = 0x3c0c38ff,
+			.flags = IORESOURCE_MEM,
+		},
+		[1] = {
+			.start = 66,
+			.end   = 66,
+			.flags = IORESOURCE_IRQ,
+		}
+	}
+};
+
+/* This is crap, we really need to set the physical address of the IRQ
+ * reflector block in the BSP, as that is where we know where it is.
+ * Hack for now by #ifdefing, fix in updated kernel
+ */
+
+#if defined(CONFIG_BOARD_STV576_REF)
+#define REFLECT_BLOCK_PHYS 0x27fe0000
+#elif defined(CONFIG_BOARD_STV576_DUAL_REF)
+#define REFLECT_BLOCK_PHYS 0x2ffe0280
+#else
+#error STV576 INTERRUPT REFLECTOR BLOCK ADDRESS NOT DEFINED
+#endif
+
+static struct resource stv576_fb_resources[] = {
+       [0] = {
+		/* Info block. Will die */
+		.start = REFLECT_BLOCK_PHYS + 0x1002c,
+		.end   = REFLECT_BLOCK_PHYS + 0x1002c + 0xf ,
+		.flags = IORESOURCE_MEM,
+		.name  = "clcd info"
+       },
+       [1] = {
+	       .start = 0x3c0f4000, /* CLCD_REGISTERS */
+	       .end   = 0x3c0f4051,
+	       .flags = IORESOURCE_MEM,
+	       .name  = "clcd",
+       },
+       [2] = {
+	       .start = 0x3c0f4400,	/* CLCD STRIP_GEN */
+	       .end   = 0x3c0f442b,
+	       .flags = IORESOURCE_MEM,
+	       .name  = "clcd strip gen"
+       },
+       [3] = {
+	       .start = 0x3c0f4800, /* CLCD SRAM */
+	       .end   = 0x3c0f4811,
+	       .flags = IORESOURCE_MEM,
+	       .name  = "clcd sram"
+       },
+       [4] = {
+	       .start = 0x3c0f5800, /* CLCD DMA */
+	       .end   = 0x3c0f6033,
+	       .flags = IORESOURCE_MEM,
+	       .name  = "clcd dma"
+       },
+};
+
+static struct platform_device stv576_fb_device = {
+	.name = "stv576-fb",
+	.id = -1,
+	.num_resources = 5,
+	.resource = stv576_fb_resources,
+};
+
+/* No partitions by default */
+static struct plat_stv576_nand_data stv576_nand_data = {
+       .mtd_parts = NULL,
+       .nr_parts = 0,
+       .boot_device = 1,
+       .options = 0
+};
+
+
+
+/* These addresses are different depending on if you boot from NAND or SPI.
+ * The axi_sticky_block tells you which device you have booted from and will
+ * mangle the addresses before it is passed onto the NAND driver. We assume we
+ * boot from NAND, and then change the address if not.
+ */
+
+static struct platform_device  stv576_nand_device = {
+	.name 		="stv576_nand",
+	.id		= -1,
+	.num_resources 	= 1,
+	.resource 	= (struct resource[]) {
+		[0]	= {
+				.start = 0x00008000,
+				.end   = 0x0000810f,
+				.flags = IORESOURCE_MEM
+		}
+	},
+	.dev		= {
+		/* Override at board level */
+		.platform_data = &stv576_nand_data,
+	}
+};
+
+/* Should be done as a proper platform device */
+static struct platform_device axi_sticky_block = {
+	.name = "axi sticky block",
+	.id   = -1,
+	.num_resources = 1,
+	.resource = (struct resource[]) {
+		[0] = {
+			.start = 0x3c066000,
+			.end   = 0x3c06600f,
+			.flags = IORESOURCE_MEM,
+		}
+	}
+};
+
+static void *axi_sticky_block_iobase;
+
+#define BOOT_DEVICE 0x00
+#define BOOT_FROM_SPIRF_0_N (1 << 0)
+
+static int __init axi_sticky_block_init(void)
+{
+	struct resource *res = axi_sticky_block.resource;
+	long reslen = res->end - res->start + 1;
+	int boot_from_spi;
+
+	if (!request_mem_region(res->start, reslen, "axi sticky block"))
+		return -EBUSY;
+
+	axi_sticky_block_iobase = ioremap(res->start, reslen);
+
+	if (!axi_sticky_block_iobase)
+		return -ENOMEM;
+
+	/* Read the boot device to figure out where we came from */
+	boot_from_spi = !(readw_be(axi_sticky_block_iobase + BOOT_DEVICE) &
+				   BOOT_FROM_SPIRF_0_N) ;
+
+	if (boot_from_spi) {
+		stv576_nand_data.boot_device = 0;
+		/* NAND controller appears at 0x08008000 */
+		stv576_nand_device.resource[0].start |= (1<<27);
+		stv576_nand_device.resource[0].end |= (1<<27);
+	}
+
+	return 0;
+}
+
+static struct plat_stv576_audio_data stv576_audio_data = {
+	.audio_clock = 48000000,
+	.dma_min_burst_words = 3,
+	.dma_max_burst_words = 16
+};
+
+
+static struct platform_device stv576_audio_device = {
+	.name = "stv576_audio",
+	.id = 0,
+	.num_resources = 2,
+	.resource = (struct resource[]) {
+		[0] = {
+			.start = 0x3c0f6400,
+			.end = 0x3c0f644d,
+			.flags = IORESOURCE_MEM
+		},
+		[1] = {
+			.start = 69,
+			.flags = IORESOURCE_IRQ
+		}
+	},
+	.dev 	= {
+		.platform_data = &stv576_audio_data,
+	}
+};
+
+
+static void *pie;
+
+static void *arm_irq;
+
+#define INT_STATUS_FROM_PIE	0x10
+#define INT_STATUS_TO_PIE	0x12
+
+#define ARM_IRQ_PHYS	0x3c040c00
+
+#define ARM_IRQ_MASK_ADDR(bit) ( 0x20 +  ((3 - ((bit) >> 5)) << 2) )
+#define ARM_IRQ_MASK(bit)  (1 << ((bit) & 0x1f))
+
+static void pie_init(void)
+{
+	pie = ioremap(0x3c310000, 14);
+
+	arm_irq = ioremap(ARM_IRQ_PHYS, 0xff);
+
+	if (pie == NULL)
+		panic("Cannot remap pie block\n");
+}
+
+static inline void pie_set_local_interrupt(int value)
+{
+	writew_be(value, pie + INT_STATUS_TO_PIE);
+	/* Read back to overcome write posting. Otherwise we may observe the
+	 * interrupt being raised as the line has not been dropped before
+	 * interrupts are re-enabled
+	 */
+	readw_be(pie + INT_STATUS_TO_PIE);
+}
+
+static void pie_ack_multiplex_irq(void)
+{
+	pie_set_local_interrupt(0);
+}
+
+static void pie_set_remote_interrupt(int value)
+{
+	writew_be(value, pie + INT_STATUS_FROM_PIE);
+}
+
+static u8 irq_to_bit[32] = { 66,	/* UART1INT */
+	42,			/* USB2_HOST_INT */
+	43,			/* USB2_HOST_EHCI_INT */
+	44,			/* USB2_HOST_OHCI_0_INT */
+	4,			/* NFLASH_INT */
+	54			/* AUDIOINT */
+};
+
+static void arm_disable_irq(int n, int prev_enabled)
+{
+	int bit = irq_to_bit[n];
+	u32 mask, new_mask;
+
+	/* Set the bit in the mask register */
+	mask = readl_be(arm_irq + ARM_IRQ_MASK_ADDR(bit)); mask |=
+		ARM_IRQ_MASK(bit); writel_be(mask, arm_irq +
+				ARM_IRQ_MASK_ADDR(bit));
+	/* Read back for write posting */
+	new_mask = readl_be(arm_irq + ARM_IRQ_MASK_ADDR(bit));
+	/* Check that nobody else is messing around with these bits. If this
+	 * gets triggered, then it means that either somebody on the ARM side
+	 * is manipulating these registers outside of the shared memory
+	 * spinlock, or that the spin lock has failed. Both of these are very
+	 * bad.
+	 */
+	BUG_ON(mask != new_mask);
+}
+
+static void arm_enable_irq(int n, int prev_enabled)
+{
+	int bit = irq_to_bit[n];
+	u32 mask, new_mask;
+
+	/* Set the bit in the mask register */
+	mask = readl_be(arm_irq + ARM_IRQ_MASK_ADDR(bit));
+	mask &= ~ARM_IRQ_MASK(bit);
+	writel_be(mask, arm_irq + ARM_IRQ_MASK_ADDR(bit));
+	/* Write posting */
+	new_mask = readl_be(arm_irq + ARM_IRQ_MASK_ADDR(bit));
+	/* Sanity check */
+	BUG_ON(mask != new_mask);
+}
+
+void dump_pie_irqs(void)
+{
+
+	static int count = 0;
+
+	printk("TO_PIE (LOCAL) %d\n", readw_be(pie + INT_STATUS_TO_PIE));
+	printk("TO_ARM (REMOTE) %d\n", readw_be(pie + INT_STATUS_FROM_PIE));
+}
+
+static struct resource pie_resources[] = {
+	{
+	 .start = 0x3c310000,
+	 .end = 0x3c310013,
+	 .flags = IORESOURCE_MEM,
+	 }
+};
+
+static struct platform_device pie_block = {
+	.name = "pie block",
+	.id = -1,
+	.num_resources = 1,
+	.resource = pie_resources,
+};
+
+#define RESET_BLOCK_PHYS 	0x3c043800
+
+/* Various reset controls for USB */
+#define USB_HS_INTERFACE_RESET 	0x3a
+#define USB_FSHOST_RST		0x3b
+#define USB_FSHOSTPLL_RST	0x3c
+#define USB_SWITCH_RST		0x3d
+#define USB2_HOST_RST		0x41
+#define AUDIO_RST		0x48
+
+static void *reset_block;
+
+static void init_reset_block(void)
+{
+	reset_block = ioremap(RESET_BLOCK_PHYS, 0x26);
+}
+
+#define STV576_RESET_ADDR(bit) (((7 - ((bit) >> 5)) << 2) )
+#define STV576_RESET(bit)  (1 << ((bit) & 0x1f))
+
+void stv576_release_reset(int block_id)
+{
+	u32 reset;
+
+	reset = readl_be(reset_block + STV576_RESET_ADDR(block_id));
+
+	writel_be(reset & ~STV576_RESET(block_id),
+		  reset_block + STV576_RESET_ADDR(block_id));
+}
+
+void stv576_set_reset(int block_id)
+{
+	u32 reset;
+
+	reset = readl_be(reset_block + STV576_RESET_ADDR(block_id));
+
+	writel_be(reset | STV576_RESET(block_id),
+		  reset_block + STV576_RESET_ADDR(block_id));
+}
+
+static struct plat_irq_reflector_data irq_reflector_data = {
+	.boot_first = 0,	/* The ARM starts first */
+	.big_endian = 1,	/* Yuck */
+	.ack_multiplex_irq = pie_ack_multiplex_irq,
+	.enable_remote_irq = arm_enable_irq,
+	.disable_remote_irq = arm_disable_irq,
+};
+
+#define REFLECT_FIRST_IRQ 64	/* Immediately above the real interrupts */
+
+static struct resource irq_reflector_resources[] = {
+	{
+	 .start = REFLECT_BLOCK_PHYS,
+	 .end = REFLECT_BLOCK_PHYS + sizeof(struct reflect_block) - 1,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = 3,		/* STV576 only has one external interrupt */
+	 .end = 3,
+	 .flags = IORESOURCE_IRQ,
+	 },
+	{
+	 .start = REFLECT_FIRST_IRQ,
+	 .end = REFLECT_FIRST_IRQ + 31,
+	 .flags = IORESOURCE_IRQ
+	}
+};
+
+static struct platform_device irq_reflector = {
+	.name = "irq_reflector",
+	.id = 0,
+	.num_resources = 3,
+	.resource = irq_reflector_resources,
+	.dev = {
+		.platform_data = &irq_reflector_data,
+		}
+};
+
+/* This is the globally exported list of devices supported by this soc */
+static struct platform_device *__initdata soc_device_list[] = {
+	&strs_device,
+	&stv576_fb_device,
+	&stv576_ohci_device,
+	&stv576_ehci_device,
+	&stv576_nand_device,
+	&stv576_audio_device,
+};
+
+struct soc_info soc_data = {
+	.devices = soc_device_list,
+	.num_devices = ARRAY_SIZE(soc_device_list),
+	.uarts = NULL,
+	.num_uarts = 0
+};
+
+#define PERIPHERIAL_BASE    0x1fb00000
+
+extern void __init init_st200_irq(unsigned long base_addr);
+
+void __init init_IRQ(void)
+{
+	init_st200_irq(PERIPHERIAL_BASE);
+}
+
+static int __init stv576_subsys_setup(void)
+{
+
+	pie_init();
+	init_reset_block();
+	axi_sticky_block_init();
+
+	stv576_set_reset(AUDIO_RST);
+	stv576_release_reset(AUDIO_RST);
+
+/* This is rubbish, it should really be done via the
+ * platform code. Fix later
+ */
+#ifdef CONFIG_STM_IRQ_REFLECTOR
+	irq_reflector_early_init(&irq_reflector);
+#endif
+	return 0;
+}
+
+subsys_initcall(stv576_subsys_setup);
+
+int __init soc_setup(void)
+{
+	return 0;
+}
+
+/* Insufficient information to actually implement these. Ideally
+ * a watchdog timer would be used, but there is no driver for that
+ */
+void soc_machine_restart(char *cmd)
+{
+	for (;;) ;
+}
+
+void soc_machine_halt(void)
+{
+	for (;;) ;
+}
+
+void soc_machine_power_off(void)
+{
+	for (;;) ;
+}
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index ee98b1b..aa1a32f 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -423,4 +423,11 @@ config KEYBOARD_W90P910
 	  To compile this driver as a module, choose M here: the
 	  module will be called w90p910_keypad.
 
+config KEYBOARD_ST200SIM
+        tristate "ST200 simulator Keyboard support"
+        depends on ARCH_ST200 && INPUT && INPUT_KEYBOARD
+        help
+          Support for and ST200 simulator keyboard.
+
+
 endif
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index babad5e..7843925 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -32,6 +32,7 @@ obj-$(CONFIG_KEYBOARD_QT2160)		+= qt2160.o
 obj-$(CONFIG_KEYBOARD_SH_KEYSC)		+= sh_keysc.o
 obj-$(CONFIG_KEYBOARD_SPITZ)		+= spitzkbd.o
 obj-$(CONFIG_KEYBOARD_STOWAWAY)		+= stowaway.o
+obj-$(CONFIG_KEYBOARD_ST200SIM)		+= st200simkbd.o
 obj-$(CONFIG_KEYBOARD_SUNKBD)		+= sunkbd.o
 obj-$(CONFIG_KEYBOARD_TOSA)		+= tosakbd.o
 obj-$(CONFIG_KEYBOARD_TWL4030)		+= twl4030_keypad.o
diff --git a/drivers/input/keyboard/st200simkbd.c b/drivers/input/keyboard/st200simkbd.c
new file mode 100644
index 0000000..096934c
--- /dev/null
+++ b/drivers/input/keyboard/st200simkbd.c
@@ -0,0 +1,219 @@
+/*
+ * ST200 simulator keyboard driver
+ *
+ * Copyright (c) 2003 STMicroelectronics
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/serio.h>
+#include <linux/workqueue.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+
+#include <linux/io.h>
+
+MODULE_AUTHOR("Stuart Menefy <stuart.menefy@st.com>");
+MODULE_DESCRIPTION("ST200 simulator keyboard driver");
+MODULE_LICENSE("GPL");
+
+/*
+ * Hardware interface
+ */
+
+#define SIMFB_INPUT_STATUS	0x000
+#define SIMFB_INPUT_KEY		0x004
+
+#define SIMFB_INPUT_STATUS_KEY	1
+
+static char* st200_base;
+static struct input_dev *simkbd_dev;
+
+static unsigned char simkbd_keycode[512] = {
+/*        0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /* 00 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /* 10 */
+	 57,  0,  0, 43,  0,  0,  0, 40,  0,  0,  0,  0, 51, 12, 52, 53, /* 20 */
+	 11,  2,  3,  4,  5,  6,  7,  8,  9, 10,  0, 39,  0, 13,  0,  0, /* 30 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /* 40 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 26, 43, 27,  0,  0, /* 50 */
+	  0, 30, 48, 46, 32, 18, 33, 34, 35, 23, 36, 37, 38, 50, 49, 24, /* 60 */
+	 25, 16, 19, 31, 20, 22, 47, 17, 45, 21, 44,  0,  0,  0,  0,  0, /* 70 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /* 80 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /* 90 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /* A0 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /* B0 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /* C0 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /* D0 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /* E0 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /* F0 */
+	  0,  0,  0,  0,  0,  0,  0,  0, 14, 15,  0,  0,  0, 28,  0,  0, /*100 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0, /*110 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /*120 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /*130 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /*140 */
+	102,105,103,106,108,104,109,107,  0,  0,  0,  0,  0,  0,  0,  0, /*150 */
+	  0,  0,  0,110,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /*160 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /*170 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /*180 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /*190 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /*1a0 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 59, 60, /*1b0 */
+	 61, 62, 63, 64, 65, 66, 67, 68,  0,  0,  0,  0,  0,  0,  0,  0, /*1c0 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /*1d0 */
+	  0, 42, 54, 29,  0, 58,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, /*1e0 */
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,111  /*1f0 */
+};
+
+static int simkbd_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
+{
+	switch (type) {
+
+		case EV_LED:
+
+			printk("simfb.c: LED change 0x%x\n", dev->led);
+			return 0;
+	}
+
+	return -1;
+}
+
+/*
+ * simkbd_interrupt(). Here takes place processing of data received from
+ * the keyboard into events.
+ * Note that 'keycodes' are actually X unmodified (ie no modifiers) keysyms.
+ */
+
+static irqreturn_t simkbd_interrupt(int irq, void *dev_id)
+{
+	unsigned long status;
+
+	status = readl(st200_base+SIMFB_INPUT_STATUS);
+
+	if (status & SIMFB_INPUT_STATUS_KEY) {
+		unsigned long keycode;
+		int down;
+		keycode = readl(st200_base+SIMFB_INPUT_KEY);
+
+		down = !(keycode & 0x10000);
+		keycode &= 0x1ff;
+
+		input_report_key(simkbd_dev, simkbd_keycode[keycode], down);
+		input_sync(simkbd_dev);
+
+		writel(SIMFB_INPUT_STATUS_KEY, st200_base+SIMFB_INPUT_STATUS);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int __init simkbd_probe(struct platform_device *pdev)
+{
+	int i;
+	struct resource *res;
+	int reslen;
+	int irq;
+
+	res=platform_get_resource(pdev,IORESOURCE_MEM,0);
+	if (!res) {
+		return -ENODEV;
+		//	goto out;
+	}
+
+	reslen=res->end - res->start + 1;
+
+
+	if (!request_mem_region(res->start,reslen, "simkbd"))
+		return -EBUSY;
+
+	st200_base = ioremap(res->start,reslen);
+	if (st200_base == NULL) {
+		release_mem_region(res->start, reslen);
+		return -ENOMEM;
+	}
+
+
+	irq=platform_get_irq(pdev,0);
+
+	if (request_irq(irq, simkbd_interrupt, 0, "simkbd", NULL)) {
+		iounmap(st200_base);
+		release_mem_region(res->start, reslen);
+		return -1;
+	}
+
+	simkbd_dev = input_allocate_device();
+	if(!simkbd_dev) return -ENOMEM;
+
+
+	simkbd_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) | BIT_MASK(EV_LED);
+	simkbd_dev->keycode = simkbd_keycode;
+	simkbd_dev->keycodesize = sizeof(unsigned char);
+	simkbd_dev->keycodemax = ARRAY_SIZE(simkbd_keycode);
+
+	simkbd_dev->ledbit[0] = BIT_MASK(LED_NUML) | BIT_MASK(LED_CAPSL) | BIT_MASK(LED_SCROLLL);
+	simkbd_dev->event = simkbd_event;
+
+	simkbd_dev->name = "ST200 simulator keyboard";
+	simkbd_dev->phys = "simkbd/input0";
+	simkbd_dev->id.bustype = BUS_HOST;
+	simkbd_dev->id.vendor = 0x0001;
+	simkbd_dev->id.product = 0;
+	simkbd_dev->id.version = 0;
+
+	for (i = 0; i < 512; i++)
+		if (simkbd_keycode[i])
+			set_bit(simkbd_keycode[i], simkbd_dev->keybit);
+
+	input_register_device(simkbd_dev);
+
+	printk(KERN_INFO "input: %s on %s at %#x irq %d\n",
+
+	       simkbd_dev->name, simkbd_dev->phys,
+	       st200_base,irq);
+
+	return 0;
+}
+
+static int simkbd_remove(struct platform_device *pdev)
+{
+	input_unregister_device(simkbd_dev);
+	//	free_irq(dev->irq, NULL);
+	iounmap(st200_base);
+
+	//	release_mem_region(SIMFB_INPUT_BASE, SIMFB_INPUT_SIZE);
+}
+
+
+static struct platform_driver simkbd_driver = {
+	.probe		= simkbd_probe,
+	.remove		= simkbd_remove,
+//	.suspend	= simkbd_drv_suspend,
+//	.resume		= simkbd_drv_resume,
+	.driver = {
+		.name		= "STM-" "simkbd",
+	}
+};
+
+static int __init simkbd_init(void)
+{
+	return platform_driver_register(&simkbd_driver);
+}
+
+static void __exit simkbd_cleanup(void)
+{
+	platform_driver_unregister(&simkbd_driver);
+}
+
+module_init(simkbd_init);
+module_exit(simkbd_cleanup);
+
diff --git a/drivers/input/mouse/Kconfig b/drivers/input/mouse/Kconfig
index 3feeb3a..a20b950 100644
--- a/drivers/input/mouse/Kconfig
+++ b/drivers/input/mouse/Kconfig
@@ -321,4 +321,10 @@ config MOUSE_SYNAPTICS_I2C
 	  To compile this driver as a module, choose M here: the
 	  module will be called synaptics_i2c.
 
+config MOUSE_ST200_SIM
+        tristate "ST200 simulator Mouse support"
+        depends on ARCH_ST200 && SOC_SIMULATOR
+        help
+          Support for and ST200 simulator mouse.
+
 endif
diff --git a/drivers/input/mouse/Makefile b/drivers/input/mouse/Makefile
index 570c84a..c5152c5 100644
--- a/drivers/input/mouse/Makefile
+++ b/drivers/input/mouse/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_MOUSE_RISCPC)		+= rpcmouse.o
 obj-$(CONFIG_MOUSE_SERIAL)		+= sermouse.o
 obj-$(CONFIG_MOUSE_SYNAPTICS_I2C)	+= synaptics_i2c.o
 obj-$(CONFIG_MOUSE_VSXXXAA)		+= vsxxxaa.o
+obj-$(CONFIG_MOUSE_ST200_SIM)           += st200simmouse.o
 
 psmouse-objs := psmouse-base.o synaptics.o
 
diff --git a/drivers/input/mouse/st200simmouse.c b/drivers/input/mouse/st200simmouse.c
new file mode 100644
index 0000000..a26cbc0
--- /dev/null
+++ b/drivers/input/mouse/st200simmouse.c
@@ -0,0 +1,179 @@
+/*
+ * ST200 simulator mouse driver
+ *
+ * Copyright (c) 2003 STMicroelectronics
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/serio.h>
+#include <linux/workqueue.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+MODULE_AUTHOR("Stuart Menefy <stuart.menefy@st.com>");
+MODULE_DESCRIPTION("ST200 simulator mouse driver");
+MODULE_LICENSE("GPL");
+
+/*
+ * Hardware interface
+ */
+
+#define SIMFB_MOUSE_STATUS	0x000
+#define SIMFB_MOUSE_X		0x004
+#define SIMFB_MOUSE_Y		0x008
+#define SIMFB_MOUSE_BUTTON	0x00c
+
+#define SIMFB_MOUSE_STATUS_INT		1
+#define SIMFB_MOUSE_STATUS_RESYNC	2
+
+static char *st200_base;
+static struct input_dev *simmouse_dev;
+static int simmouse_used = 0;
+
+static irqreturn_t simmouse_interrupt(int irq, void *dev_id)
+{
+	unsigned long status;
+	unsigned long x, y, buttons;
+	static unsigned int lastx, lasty;
+
+	status = readl(st200_base + SIMFB_MOUSE_STATUS);
+	x = readl(st200_base + SIMFB_MOUSE_X);
+	y = readl(st200_base + SIMFB_MOUSE_Y);
+	buttons = readl(st200_base + SIMFB_MOUSE_BUTTON);
+
+	if (status & SIMFB_MOUSE_STATUS_RESYNC) {
+		lastx = x;
+		lasty = y;
+	}
+
+	input_report_rel(simmouse_dev, REL_X, (int)x - lastx);
+	input_report_rel(simmouse_dev, REL_Y, (int)y - lasty);
+
+	lastx = x;
+	lasty = y;
+
+	input_report_key(simmouse_dev, BTN_LEFT, buttons & 1);
+	input_report_key(simmouse_dev, BTN_MIDDLE, buttons & 2);
+	input_report_key(simmouse_dev, BTN_RIGHT, buttons & 4);
+
+	input_sync(simmouse_dev);
+
+	writel(SIMFB_MOUSE_STATUS_INT, st200_base + SIMFB_MOUSE_STATUS);
+
+	return IRQ_HANDLED;
+}
+
+static int simmouse_open(struct input_dev *dev)
+{
+	if (simmouse_used++)
+		return 0;
+
+	return 0;
+}
+
+static void simmouse_close(struct input_dev *dev)
+{
+	//        if (--simmouse_used == 0)
+	//            free_irq(SIMFB_MOUSE_IRQ, NULL);
+}
+
+static int __init simmouse_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int reslen;
+	int irq;
+	int i;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		return -ENODEV;
+		//      goto out;
+	}
+
+	reslen = res->end - res->start + 1;
+
+	if (!request_mem_region(res->start, reslen, "simmouse"))
+		return -EBUSY;
+
+	st200_base = ioremap(res->start, reslen);
+	if (st200_base == NULL) {
+		release_mem_region(res->start, reslen);
+		return -ENOMEM;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+
+	if (request_irq(irq, simmouse_interrupt, 0, "simmouse", NULL)) {
+		simmouse_used--;
+		printk(KERN_ERR "st200simmouse.c: Can't allocate irq %d\n",
+		       irq);
+		return -EBUSY;
+	}
+
+	simmouse_dev = input_allocate_device();
+	if (!simmouse_dev)
+		return -ENOMEM;
+
+	simmouse_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);
+	simmouse_dev->relbit[0] = BIT_MASK(REL_X) | BIT(REL_Y);
+	simmouse_dev->keybit[BIT_WORD(BTN_MOUSE)] =
+	    BIT_MASK(BTN_LEFT) | BIT_MASK(BTN_MIDDLE) | BIT_MASK(BTN_RIGHT);
+	simmouse_dev->open = simmouse_open;
+	simmouse_dev->close = simmouse_close;
+
+	simmouse_dev->name = "ST200 simulator mouse";
+	simmouse_dev->phys = "simmouse/input0";
+	simmouse_dev->id.bustype = BUS_HOST;
+	simmouse_dev->id.vendor = 0x0001;
+	simmouse_dev->id.product = 0;
+	simmouse_dev->id.version = 0;
+
+	input_register_device(simmouse_dev);
+
+	printk(KERN_INFO "input: %s on %s at %#x irq %d\n",
+	       simmouse_dev->name, simmouse_dev->phys, st200_base, irq);
+
+	return 0;
+}
+
+static int simmouse_remove(struct platform_device *pdev)
+{
+	input_unregister_device(simmouse_dev);
+	iounmap(st200_base);
+//      release_mem_region(SIMFB_INPUT_BASE, SIMFB_INPUT_SIZE);
+}
+
+static struct platform_driver simmouse_driver = {
+	.probe = simmouse_probe,
+	.remove = simmouse_remove,
+//      .suspend        = simmouse_drv_suspend,
+//      .resume         = simmouse_drv_resume,
+	.driver = {
+		   .name = "STM-" "simmouse",
+		   }
+};
+
+static int __init simmouse_init(void)
+{
+	return platform_driver_register(&simmouse_driver);
+}
+
+static void __exit simmouse_cleanup(void)
+{
+	platform_driver_unregister(&simmouse_driver);
+}
+
+module_init(simmouse_init);
+module_exit(simmouse_cleanup);
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 2fda0b6..93de271 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -482,4 +482,11 @@ config MTD_NAND_W90P910
 	  This enables the driver for the NAND Flash on evaluation board based
 	  on w90p910.
 
+config MTD_NAND_STV576
+	tristate "Support for NAND Flash on STMicro STV576"
+	depends on SOC_STV576
+	help
+	  Enables support for NAND flash chips on the STMicro STV576 SoCs
+
+
 endif # MTD_NAND
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 6950d3d..0475611 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -42,5 +42,6 @@ obj-$(CONFIG_MTD_NAND_SOCRATES)		+= socrates_nand.o
 obj-$(CONFIG_MTD_NAND_TXX9NDFMC)	+= txx9ndfmc.o
 obj-$(CONFIG_MTD_NAND_W90P910)		+= w90p910_nand.o
 obj-$(CONFIG_MTD_NAND_NOMADIK)		+= nomadik_nand.o
+obj-$(CONFIG_MTD_NAND_STV576)		+= stv576_nand.o
 
 nand-objs := nand_base.o nand_bbt.o
diff --git a/drivers/mtd/nand/stv576_nand.c b/drivers/mtd/nand/stv576_nand.c
new file mode 100644
index 0000000..20130c1
--- /dev/null
+++ b/drivers/mtd/nand/stv576_nand.c
@@ -0,0 +1,1154 @@
+/* drivers/mtd/nand/sv576_nand.c: NAND driver for hardware on STV576.
+ *
+ * Copyright (c) 2009 David McKay <david.mckay@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 only.
+ * See linux/COPYING for more info
+ *
+ * TODO:
+ * 	Implement interrupt operation
+ * 	Optimize NAND timings for improved performance
+ * 	Improved error handling
+ * 	Test with small page devices
+ */
+
+#include <linux/platform_device.h>
+#include <linux/st_soc.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/cache.h>
+#include <linux/delay.h>
+#include <asm/unaligned.h>
+
+#include "stv576_nand.h"
+
+#define ID_BUF_SIZE 8
+
+#define DMA_ALIGN_SIZE ((L1_CACHE_BYTES < 32) ? L1_CACHE_BYTES : 32)
+
+#define DMA_BUFFER_ALIGNED(x) (!((unsigned long)(x) & (DMA_ALIGN_SIZE - 1)))
+#define DMA_ALIGN_BUFFER(x)   ((((unsigned long)(x)) + DMA_ALIGN_SIZE - 1)  & \
+			      ~(DMA_ALIGN_SIZE - 1))
+#define DMA_BUFFER_WORD_ALIGNED(x)  (!((unsigned long)(x) & 3))
+
+/* The documentation says the hardware can do 4 byte transfers if ECC is off
+ * However, I have seen lock up when starting with a 4 byte transfer so I
+ * suspect the hardware is not doing the right thing, though it appears to
+ * break only on reads.
+ */
+#define DMA_MIN_LEN 8
+
+/* #define NAND_DEBUG */
+
+#ifdef NAND_DEBUG
+#define dprintk(format, a...) printk(format, ##a)
+#else
+#define dprintk(format, a...)
+#endif
+
+struct dma_descriptor {
+	uint32_t src_addr;	/* All big endian in memory */
+	uint32_t len;
+	uint32_t next;		/* Set bottom bit to chain */
+};
+
+/* We read or write a page plus the OOB data. This can always be split
+ * into a maximum of 4 dma units, thus we only 3 descriptors because one
+ * of them is implicit in the registers
+ */
+
+#define MAX_DMA_CHAIN_SIZE 4
+#define MAX_BOUNCE_BUFFERS 2
+
+struct bounce_buffer {
+	uint8_t *buffer;	/* Pointer to kmalloced buffer */
+	dma_addr_t dma_addr;	/* DMA address */
+	int len;		/* How many valid bytes there are in it */
+	uint8_t *copy_to;	/* Where to copy it back to */
+};
+
+struct dma_descriptor_info {
+	struct dma_descriptor *descriptor;
+	dma_addr_t data_dma_addr;	/* DMA addr of data in descriptor */
+	int data_len;		/* Size of data held */
+	dma_addr_t descriptor_dma_addr;	/* DMA addr of this descriptor */
+};
+
+struct stv576_nand_info {
+	struct nand_chip nand_chip;
+	struct mtd_info mtd;
+	void __iomem *iobase;
+	uint8_t id_buf[ID_BUF_SIZE];	/* Used for holding READID data */
+	int id_len;		/* How many valid bytes are in there */
+	int id_pos;		/* How many bytes we have read out */
+	int cmd;		/* Next command */
+	uint32_t addr;		/* Address for next operation */
+	struct dma_descriptor_info dma_chain[MAX_DMA_CHAIN_SIZE];
+	int chain_len;		/* Next in chain */
+	int dma_reading;	/* True if DMA reading, false writing */
+	struct bounce_buffer bounce[MAX_BOUNCE_BUFFERS];
+	int bounce_used;	/* How many we have used */
+	uint8_t *verify_buf;	/* One page */
+};
+
+static void wait_for_transfer_complete(struct stv576_nand_info *info)
+{
+	while (!(readl_be(info->iobase + NFLASH_INTSTS_REG) &
+		 INTSTS_TRANSFER_COMPLETE)) ;
+
+	writel_be(~0, info->iobase + NFLASH_INTSTS_REG);
+}
+
+static char *nand_command_string(const int command)
+{
+	switch (command) {
+	case NAND_CMD_READ0:
+		return "READ0";
+	case NAND_CMD_READ1:
+		return "READ1";
+	case NAND_CMD_RNDOUT:
+		return "RNDOUT";
+	case NAND_CMD_PAGEPROG:
+		return "PAGEPROG";
+	case NAND_CMD_READOOB:
+		return "READOOB";
+	case NAND_CMD_ERASE1:
+		return "ERASE1";
+	case NAND_CMD_STATUS:
+		return "STATUS";
+	case NAND_CMD_STATUS_MULTI:
+		return "STATUS_MULTI";
+	case NAND_CMD_SEQIN:
+		return "SEQIN";
+	case NAND_CMD_RNDIN:
+		return "RNDIN";
+	case NAND_CMD_READID:
+		return "READID";
+	case NAND_CMD_ERASE2:
+		return "ERASE2";
+	case NAND_CMD_RESET:
+		return "RESET";
+	}
+
+	return "UNKNOWN";
+
+}
+
+static uint8_t stv576_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct stv576_nand_info *info = chip->priv;
+	uint8_t data;
+
+	if (!((info->cmd == NAND_CMD_READID) ||
+	      (info->cmd == NAND_CMD_STATUS))) {
+		printk(KERN_ERR
+		       "read_byte called for something other than "
+		       "READID or STATUS %s 0x%x\n",
+		       nand_command_string(info->cmd), info->cmd);
+		return 0;
+	}
+
+	/* Just return the same thing again */
+	if (info->id_pos >= info->id_len)
+		info->id_pos = 0;
+
+	data = info->id_buf[info->id_pos++];
+
+	dprintk("read_byte() returns 0x%x\n", data);
+
+	return data;
+}
+
+#define NO_CALL() printk(KERN_ERR "Function %s called!!\n", __func__)
+
+static u16 stv576_read_word(struct mtd_info *mtd)
+{
+	NO_CALL();
+
+	return 0;
+}
+
+static int stv576_write_direct(struct stv576_nand_info *priv,
+			       const uint8_t *buf, int len)
+{
+	int i;
+	int left = len;
+	uint32_t data;
+	uint32_t *p = (uint32_t *) buf;
+	int cmd_issued = 0;
+
+	/* Do nothing for a zero byte read */
+	if (len == 0)
+		return 0;
+
+	/* Set up the address, this is computed in stv576_cmdfunc() */
+	writel_be(priv->addr, priv->iobase + NFLASH_ADDR_REG);
+
+	if (priv->cmd != NAND_CMD_SEQIN) {
+		printk(KERN_ERR "stv576_nand: %s - invalid command 0x%x\n",
+		       __func__, priv->cmd);
+		return -EINVAL;
+	}
+
+	do {
+		/* Now write the data to the registers */
+		/* memcpy_from_io might be cleaner here */
+		for (i = 0; i < 8 && left >= 4; i++, left -= 4, p++) {
+			data = get_unaligned(p);
+			writel(data, priv->iobase + NFLASH_DATA_REG(i));
+		}
+
+		/* Copy over the remainder */
+		if (left && (left < 4) && (i < 8)) {
+			data = 0;
+			memcpy(&data, p, left);
+			writel(data, priv->iobase + NFLASH_DATA_REG(i));
+			left = 0;
+		}
+
+		if (!cmd_issued) {
+			/* Issue the write request */
+			writel_be(CMD_NFC(NFC_MAIN_REDUNDANT) |
+				  CMD_INIT_TRANSFER | CMD_WRITE |
+				  CMD_DATA_COUNT(len - 1),
+				  priv->iobase + NFLASH_CMD_REG);
+			cmd_issued = 1;
+		}
+
+		wait_for_transfer_complete(priv);
+
+	} while (left);
+
+	/* Update address */
+	priv->addr += len;
+
+	return 0;
+}
+
+static inline int wait_for_dma_write_completion(struct stv576_nand_info *priv)
+{
+	const uint32_t error_mask =
+	    (INTSTS_PROGRAM_FAILURE | INTSTS_BUSY_NOT_ASSERTED);
+	uint32_t status;
+
+	dprintk("Waiting for DMA write to complete...\n");
+	while (!(status = readl_be(priv->iobase + NFLASH_INTSTS_REG) &
+		 (error_mask | INTSTS_DMA_WRITE_DONE))) {
+		cond_resched();
+	}
+
+	writel_be(~0, priv->iobase + NFLASH_INTSTS_REG);
+
+	if (status & error_mask) {
+		printk(KERN_ERR "stv576_nand: %s() %x\n", __func__, status);
+		return -EIO;
+	}
+
+	return 0;
+
+}
+
+static void add_descriptor(struct stv576_nand_info *priv, const uint8_t * buf,
+			   int len, dma_addr_t dma_addr)
+{
+	int chain_len = priv->chain_len;
+
+	if (len == 0)
+		return;
+
+	if (priv->chain_len == 0) {
+		writel_be(dma_addr, priv->iobase + NFLASH_SADDR_REG);
+		writel_be(len, priv->iobase + NFLASH_BYTE_CNT_REG);
+	} else {
+		struct dma_descriptor *d =
+		    priv->dma_chain[chain_len].descriptor;
+		d->src_addr = cpu_to_be32(dma_addr);
+		d->len = cpu_to_be32(len);
+	}
+	priv->dma_chain[chain_len].data_dma_addr = dma_addr;
+	priv->dma_chain[chain_len].data_len = len;
+	priv->chain_len++;
+}
+
+static void link_and_flush_descriptor_chain(struct stv576_nand_info *priv)
+{
+	int chain_len = priv->chain_len;
+	int i;
+
+	BUG_ON(chain_len == 0);
+
+	if (chain_len == 1) {
+		/* Only one block, nothing much to do */
+		writel_be(0, priv->iobase + NFLASH_DESCR_ADDR_REG);
+	} else {
+		writel_be(priv->
+			  dma_chain[1].descriptor_dma_addr |
+			  DESCR_ADDR_ENABLE_DMA_CHAINING,
+			  priv->iobase + NFLASH_DESCR_ADDR_REG);
+	}
+
+	/* Proceed down the chain, a flushing as we go
+	 * We go backwards as we have to flush the data
+	 * we have just written.
+	 */
+	for (i = chain_len - 1; i >= 1; i--) {
+		struct dma_descriptor_info *dinfo = priv->dma_chain + i;
+		struct dma_descriptor *d = dinfo->descriptor;
+
+		if (i == (chain_len - 1)) {
+			d->next = cpu_to_be32(0);
+		} else {
+			d->next =
+			    cpu_to_be32(priv->
+					dma_chain[i +
+						  1].descriptor_dma_addr |
+					DESCR_ADDR_ENABLE_DMA_CHAINING);
+		}
+		dma_sync_single(NULL, dinfo->descriptor_dma_addr,
+				sizeof(struct dma_descriptor), DMA_TO_DEVICE);
+	}
+}
+
+static void unmap_descriptor_chain(struct stv576_nand_info *priv)
+{
+	int i;
+
+	/* Completely pointless on the ST231, but hey you never know... */
+	for (i = 0; i < priv->chain_len; i++) {
+		dma_unmap_single(NULL, priv->dma_chain[i].data_dma_addr,
+				 priv->dma_chain[i].data_len,
+				 priv->dma_reading ? DMA_FROM_DEVICE :
+				 DMA_TO_DEVICE);
+	}
+}
+
+/* Some of the upper layers insist on pasing vmalloc pointers down to the
+ * actual driver layer.  This is broken in my opinion, but it looks as if UBI
+ * in particular is keen on this. It is used when dealing with whole erase
+ * blocks, which are 128K or bigger, and thus too big for kmalloc. We put some
+ * checks in here to cope with this case, as you cannot easily DMA from
+ * vmalloced blocks. Some higher level mechanism should be introduced to handle
+ * this better, rather than forcing the drivers to do vile hackery.
+ */
+
+#define IS_VMALLOC(x) \
+	((unsigned long)(x) >= VMALLOC_START && \
+	 (unsigned long)(x) < VMALLOC_END)
+
+static void dma_add_buffer(struct stv576_nand_info *priv, uint8_t * buf,
+			   int len)
+{
+	int chunk;
+	struct bounce_buffer *bounce;
+	uint8_t *p = buf;
+	dma_addr_t dma_addr;
+	int read = priv->dma_reading;
+	int is_vmalloc = IS_VMALLOC(buf);
+
+	/* Check if the upper layers have passed a buffer that is not aligned
+	 * to a word. It is impossible to construct a DMA chain for this case,
+	 * as we will always have an odd number of bytes in one of the
+	 * transfers.  Therefore we simply bounce the whole lot over
+	 *
+	 * Similarly for vmalloc pointers. We could do a
+	 * vmalloc_to_page and then pass that pointer instead to
+	 * dma_sync_single, but this will break if you have any form of dcache
+	 * aliasing. Therefore, it is safer to simply use the existing
+	 * bounce mechanism to cope with vmalloced buffer as this will
+	 * always work, even though it is not as efficient. May need to come
+	 * back to this decision if UBIFS makes very extensive use of this.
+	 */
+
+	dprintk("%s: buf 0x%x, len %d\n", __func__, buf, len);
+
+	if (!DMA_BUFFER_ALIGNED(buf) || is_vmalloc) {
+		/* We'll have to use the bounce buffer */
+		bounce = priv->bounce + priv->bounce_used;
+
+		chunk = (DMA_BUFFER_WORD_ALIGNED(buf) && !is_vmalloc) ?
+		    ((uint8_t *) DMA_ALIGN_BUFFER(buf)) - buf : len;
+
+		/* The hardware says it can handle transactions of 4 bytes.
+		 * Don't believe it, though it only seems to cause problems on
+		 * read not write. Strange
+		 */
+		if (priv->dma_reading && (chunk < DMA_MIN_LEN))
+			chunk += DMA_ALIGN_SIZE;
+
+		if (chunk > len)
+			chunk = len;
+
+		if (read)
+			bounce->copy_to = buf;
+		else
+			memcpy(bounce->buffer, buf, chunk);
+
+		dma_sync_single(NULL, bounce->dma_addr, chunk,
+				read ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+		p += chunk;
+		len -= chunk;
+		bounce->len = chunk;
+		priv->bounce_used++;
+		/* Link in */
+		add_descriptor(priv, bounce->buffer, chunk, bounce->dma_addr);
+	}
+
+	if (len) {
+		/* Map in main chunk and sync */
+		dma_addr =
+		    dma_map_single(NULL, p, len,
+				   read ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+
+		add_descriptor(priv, p, len, dma_addr);
+	}
+
+}
+
+static inline void reset_dma_chain(struct stv576_nand_info *priv, int reading)
+{
+	priv->chain_len = 0;
+	priv->bounce_used = 0;
+	priv->dma_reading = reading;
+}
+
+static inline void init_dma_chain_for_read(struct stv576_nand_info *priv)
+{
+	reset_dma_chain(priv, 1);
+}
+
+static inline void init_dma_chain_for_write(struct stv576_nand_info *priv)
+{
+	reset_dma_chain(priv, 0);
+}
+
+static inline void init_dma_write(struct stv576_nand_info *priv)
+{
+	dprintk("flash_addr = 0x%x ", priv->addr);
+	dprintk("dma_addr = 0x%x ", readl_be(priv->iobase + NFLASH_SADDR_REG));
+	dprintk("byte_count = 0x%x ",
+		readl_be(priv->iobase + NFLASH_BYTE_CNT_REG));
+	dprintk("next = 0x%0x\n",
+		readl_be(priv->iobase + NFLASH_DESCR_ADDR_REG));
+
+	/* Set up the address, this is computed in stv576_cmdfunc() */
+	writel_be(priv->addr, priv->iobase + NFLASH_ADDR_REG);
+
+	/* Initiate the transfer */ ;
+	writel_be(DMACNTL_BURST_LENGTH(32) | DMACNTL_ENABLE,
+		  priv->iobase + NFLASH_DMACNTL_REG);
+}
+
+static inline void init_dma_read(struct stv576_nand_info *priv)
+{
+	dprintk("dma_addr = 0x%x\n", readl_be(priv->iobase + NFLASH_SADDR_REG));
+	dprintk("byte_count = 0x%x\n",
+		readl_be(priv->iobase + NFLASH_BYTE_CNT_REG));
+	dprintk("next = 0x%0x\n",
+		readl_be(priv->iobase + NFLASH_DESCR_ADDR_REG));
+
+	/* Set up the address, this is computed in stv576_cmdfunc() */
+	writel_be(priv->addr, priv->iobase + NFLASH_ADDR_REG);
+
+	/* Initiate the transfer */ ;
+	writel_be(DMACNTL_BURST_LENGTH(32) | DMACNTL_REVERSE | DMACNTL_ENABLE,
+		  priv->iobase + NFLASH_DMACNTL_REG);
+}
+
+static int complete_dma_write(struct stv576_nand_info *priv)
+{
+	int ret;
+
+	link_and_flush_descriptor_chain(priv);
+
+	init_dma_write(priv);
+
+	ret = wait_for_dma_write_completion(priv);
+
+	unmap_descriptor_chain(priv);
+
+	return ret;
+}
+
+static inline int stv576_write_dma(struct stv576_nand_info *priv,
+				   const uint8_t *buf, int len)
+{
+	int ret;
+
+	if (len == 0)
+		return 0;
+
+	init_dma_chain_for_write(priv);
+
+	dma_add_buffer(priv, (uint8_t *) buf, len);
+
+	ret = complete_dma_write(priv);
+
+	priv->addr += len;
+
+	return ret;
+}
+
+static void stv576_write_buf(struct mtd_info *mtd, const uint8_t * buf, int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct stv576_nand_info *priv = chip->priv;
+	int chunk;
+	int left = len;
+	const uint8_t *p = buf;
+
+	dprintk("%s: buf %p len %d address 0x%x\n", __func__, buf, len,
+		priv->addr);
+
+	/* Word align the rest */
+	chunk = left & ~3;
+	/* Now do the rest via DMA */
+	stv576_write_dma(priv, p, chunk);
+	p += chunk;
+
+	left &= 3;
+	/* And the last bit */
+	if (left)
+		stv576_write_direct(priv, p, left);
+}
+
+static void stv576_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf)
+{
+	struct stv576_nand_info *priv = chip->priv;
+
+	dprintk("%s, buf %p ALIGNED %d %d %d \n", __func__, buf,
+		DMA_BUFFER_ALIGNED(buf), mtd->writesize, mtd->oobsize);
+
+	init_dma_chain_for_write(priv);
+
+	dma_add_buffer(priv, (uint8_t *) buf, mtd->writesize);
+	dma_add_buffer(priv, chip->oob_poi, mtd->oobsize);
+
+	complete_dma_write(priv);
+
+	priv->addr += mtd->writesize + mtd->oobsize;
+
+}
+
+static int stv576_read_direct(struct stv576_nand_info *priv, uint8_t * buf,
+			      int len)
+{
+	int i;
+	int left = len;
+	uint32_t data;
+	uint32_t *p = (uint32_t *) buf;
+	int nfc;
+
+	/* Do nothing for a zero byte read */
+	if (len == 0)
+		return 0;
+
+	/* large page device should only see read0 */
+	switch (priv->cmd) {
+	case NAND_CMD_READOOB:
+		nfc = NFC_REDUNDANT_ONLY;
+		break;
+	case NAND_CMD_READ0:
+	case NAND_CMD_READ1:
+		nfc = NFC_MAIN_REDUNDANT;
+		break;
+	default:
+		printk(KERN_ERR "stv576_nand: %s - invalid command 0x%x\n",
+		       __func__, priv->cmd);
+		return -EINVAL;
+		break;
+	}
+
+	/* Set up the address, this is computed in stv576_cmdfunc() */
+	writel_be(priv->addr, priv->iobase + NFLASH_ADDR_REG);
+
+	/* Issue the read request */
+	writel_be(CMD_NFC(nfc) | CMD_INIT_TRANSFER | CMD_READ |
+		  CMD_DATA_COUNT(len - 1), priv->iobase + NFLASH_CMD_REG);
+
+	do {
+		wait_for_transfer_complete(priv);
+
+		/* Now suck out the data from the registers */
+		/* memcpy_from_io might be cleaner here */
+		for (i = 0; i < 8 && left >= 4; i++, left -= 4, p++) {
+			data = readl(priv->iobase + NFLASH_DATA_REG(i));
+			put_unaligned(data, p);
+		}
+
+		/* Copy over the remainder */
+		if (left && (left < 4) && (i < 8)) {
+			data = readl(priv->iobase + NFLASH_DATA_REG(i));
+			memmove(p, &data, left);
+			left = 0;
+		}
+
+	} while (left);
+
+	priv->addr += len;
+
+	return 0;
+}
+
+static inline int wait_for_dma_read_completion(struct stv576_nand_info *priv)
+{
+	while (!(readl_be(priv->iobase + NFLASH_INTSTS_REG) &
+		INTSTS_DMA_READ_DONE)) ;
+
+	/* Reset the status */
+	writel_be(~0, priv->iobase + NFLASH_INTSTS_REG);
+
+	return 0;
+}
+
+static int complete_dma_read(struct stv576_nand_info *priv)
+{
+	int i;
+	int ret;
+
+	link_and_flush_descriptor_chain(priv);
+
+	init_dma_read(priv);
+
+	ret = wait_for_dma_read_completion(priv);
+
+	/* Copy data (if any) from bounce buffers */
+	for (i = 0; i < priv->bounce_used; i++) {
+		memcpy(priv->bounce[i].copy_to, priv->bounce[i].buffer,
+		       priv->bounce[i].len);
+	}
+
+	unmap_descriptor_chain(priv);
+
+	return ret;
+}
+
+static inline int stv576_read_dma(struct stv576_nand_info *priv, uint8_t * buf,
+				  int len)
+{
+	int ret;
+
+	if (len == 0)
+		return 0;
+
+	init_dma_chain_for_read(priv);
+
+	dma_add_buffer(priv, buf, len);
+
+	ret = complete_dma_read(priv);
+
+	priv->addr += len;
+
+	return ret;
+}
+
+static void stv576_read_buf(struct mtd_info *mtd, uint8_t * buf, int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct stv576_nand_info *priv = chip->priv;
+	int chunk;
+	int left = len;
+	uint8_t *p = buf;
+
+	dprintk("%s: buf %p len %d address 0x%x\n", __func__, buf, len,
+		priv->addr);
+
+	/* Word align it */
+	chunk = left & ~3;
+
+	if (chunk > DMA_MIN_LEN) {
+		/* Now do the rest via DMA */
+		stv576_read_dma(priv, p, chunk);
+		p += chunk;
+		left &= 3;
+	}
+
+	/* And the last bit */
+	if (left)
+		stv576_read_direct(priv, p, left);
+
+}
+
+static int stv576_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf, int page)
+{
+	struct stv576_nand_info *priv = chip->priv;
+	int ret;
+
+	dprintk("%s: buf %p\n", __func__, buf);
+
+	init_dma_chain_for_read(priv);
+
+	dma_add_buffer(priv, buf, mtd->writesize);
+	dma_add_buffer(priv, chip->oob_poi, mtd->oobsize);
+
+	ret = complete_dma_read(priv);
+
+	priv->addr += mtd->writesize + mtd->oobsize;
+
+	return 0;
+
+}
+
+static int stv576_verify_buf(struct mtd_info *mtd, const uint8_t * buf, int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct stv576_nand_info *priv = chip->priv;
+
+	stv576_read_dma(priv, priv->verify_buf, len);
+
+	if (memcmp(priv->verify_buf, buf, len) != 0)
+		return -EFAULT;
+
+	return 0;
+}
+
+static void stv576_cmd_ctrl(struct mtd_info *mtd, int dat, unsigned int ctrl)
+{
+	dprintk("%s: dat 0x%x ctrl 0x%x\n", __func__, dat, ctrl);
+
+}
+
+static int stv576_dev_ready(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct stv576_nand_info *priv = chip->priv;
+
+	return readl_be(priv->iobase + NFLASH_STS_REG) & STATUS_READY;
+}
+
+static void stv576_do_cmd(struct stv576_nand_info *info, int cmd, int len)
+{
+	int i;
+	uint32_t *p = (uint32_t *) info->id_buf;
+
+	if (len >= ID_BUF_SIZE)
+		len = ID_BUF_SIZE;
+
+	writel_be(CMD_NFC(cmd) | CMD_INIT_TRANSFER | CMD_READ |
+		  CMD_DATA_COUNT(len), info->iobase + NFLASH_CMD_REG);
+
+	dprintk("Waiting for transfer complete!\n");
+
+	wait_for_transfer_complete(info);
+
+	p[0] = readl(info->iobase + NFLASH_DATA_REG(0));
+	p[1] = readl(info->iobase + NFLASH_DATA_REG(1));
+
+	info->id_len = len;
+	info->id_pos = 0;
+	for (i = 0; i < len; i++)
+		dprintk("id_buf[%d] = 0x%x\n", i, info->id_buf[i]);
+}
+
+static void stv576_do_readid(struct stv576_nand_info *info)
+{
+	stv576_do_cmd(info, NFC_ID_REG, 5);
+}
+
+static void stv576_get_status(struct stv576_nand_info *info)
+{
+	stv576_do_cmd(info, NFC_STATUS_REG, 1);
+}
+
+static void stv576_do_erase(struct stv576_nand_info *priv)
+{
+	/* Set up the address, this is computed in stv576_cmdfunc() */
+	writel_be(priv->addr, priv->iobase + NFLASH_ADDR_REG);
+
+	dprintk("Erasing....... Address 0x%08x\n", priv->addr);
+
+	/* Issue the erase */
+	writel_be(CMD_ERASE, priv->iobase + NFLASH_CMD_REG);
+
+	/* Poll status register for erase to complete */
+	while (!
+	       (readl_be(priv->iobase + NFLASH_INTSTS_REG) &
+		INTSTS_ERASE_COMPLETE)) ;
+
+	dprintk("Complete!!!\n");
+
+	/* Reset status */
+	writel_be(~0, priv->iobase + NFLASH_INTSTS_REG);
+
+	if (readl_be(priv->iobase + NFLASH_CMD_REG) & CMD_ERASE)
+		printk(KERN_ERR "ERASE NOT COMPLETE!!!\n");
+}
+
+static void stv576_do_reset(struct stv576_nand_info *priv)
+{
+	dprintk("Resetting NAND....\n");
+	writel_be(CMD_RESET, priv->iobase + NFLASH_CMD_REG);
+
+	while (!(readl_be(priv->iobase + NFLASH_INTSTS_REG) &
+		 INTSTS_RESET_COMPLETE)) ;
+
+	writel_be(~0, priv->iobase + NFLASH_INTSTS_REG);
+	dprintk("Complete!\n");
+}
+
+static void stv576_cmdfunc(struct mtd_info *mtd, unsigned int command,
+			   int column, int page_addr)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct stv576_nand_info *info = chip->priv;
+	uint32_t addr = 0;
+	int lp = (mtd->writesize != 512);	/* large page or not */
+
+	dprintk("In %s: command is %s (0x%x), column %d, page_addr %d\n",
+		__func__, nand_command_string(command), command, column,
+		page_addr);
+
+	/* Emulate NAND_CMD_READOOB  for lp */
+	if (lp && (command == NAND_CMD_READOOB)) {
+		column += mtd->writesize;
+		command = NAND_CMD_READ0;
+	}
+
+	info->cmd = command;
+
+	/* Now translate the column/page_addr into something the hardware
+	 * can understand.
+	 */
+
+	if (page_addr != -1)
+		addr = (page_addr << (chip->page_shift + lp));
+
+	if (column != -1)
+		addr |= column;
+
+	if (!lp && command == NAND_CMD_READ1)
+		addr |= 1 << 8;
+
+	info->addr = addr;
+
+	switch (command) {
+	case NAND_CMD_READ0:
+	case NAND_CMD_READ1:
+	case NAND_CMD_RNDOUT:
+	case NAND_CMD_PAGEPROG:
+	case NAND_CMD_READOOB:
+		break;
+	case NAND_CMD_ERASE1:
+		stv576_do_erase(info);
+		break;
+	case NAND_CMD_STATUS:
+		stv576_get_status(info);
+		break;
+	case NAND_CMD_STATUS_MULTI:
+	case NAND_CMD_SEQIN:
+	case NAND_CMD_RNDIN:
+		break;
+	case NAND_CMD_READID:
+		stv576_do_readid(info);
+		break;
+	case NAND_CMD_RESET:
+		stv576_do_reset(info);
+		break;
+	case NAND_CMD_ERASE2:
+		break;
+	default:
+		printk(KERN_ERR "stv576_nand: Unknown command 0x%x in %s\n",
+		       command, __func__);
+		break;
+	}
+
+}
+
+static void __init prescan_init(struct stv576_nand_info *info)
+{
+	uint32_t cntl;
+
+	cntl = readl_be(info->iobase + NFLASH_CNTL_REG);
+
+	/* Preserve the page size */
+	cntl &= CNTL_PAGE_SIZE;
+
+	/* We enable swapping. We pump the data into the registers as little
+	 * endian.  The bus then flips this to big. The swap then flips it back
+	 * to little which is what we want:-)
+	 */
+
+	writel_be(cntl | CNTL_EXIT_BOOT_WINDOW |
+		  CNTL_IGNORE_UNINIT_DATA |
+		  CNTL_GLOBAL_INT_MASK, info->iobase + NFLASH_CNTL_REG);
+
+	/* Force primary flash */
+	writel_be(0, info->iobase + NFLASH_DEVICE_SEL_REG);
+}
+
+static void __init postscan_init(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct stv576_nand_info *priv = chip->priv;
+	uint32_t reg;
+
+	reg = readl_be(priv->iobase + NFLASH_CNTL_REG);
+
+	if (mtd->writesize == 512) {
+		/* We have a small page device */
+		writel_be(reg & ~CNTL_PAGE_SIZE,
+			  priv->iobase + NFLASH_CNTL_REG);
+	} else {
+		writel_be(reg | CNTL_PAGE_SIZE, priv->iobase + NFLASH_CNTL_REG);
+	}
+
+	/* Set the array size. Unsure what the sequential bit means */
+	writel_be(PCNFG_REDUNDANT_ARRAY_PAGE_SIZE(mtd->oobsize - 1) |
+			PCNFG_MAIN_ARRAY_PAGE_SIZE(mtd->writesize - 1),
+			priv->iobase + NFLASH_PCNFG_REG);
+
+	/* This is wrong for the moment for small page devices. Fix up when I
+	 * understand how the addressing works better. Same for block address
+	 * start
+	 */
+	writel_be(ACNFG_BLOCK_ADDR_START((mtd->writesize == 512) ? 1 : 2) |
+			ACNFG_NUM_ADDR_CYCLES(4) |
+			ACNFG_BLOCK_MASK(chip->pagemask), priv->iobase +
+			NFLASH_ACNFG_REG);
+
+	/* Timings for Hynix chip. I tried to calculate these. Didn't work.
+	 * Then doubled the numbers. Still didn't work. Somebody who
+	 * understands the hardware will have to figure out what to put in
+	 * here, it should give a significant performance boost as the defaults
+	 * are very conservative.  Should be passed in from the board layer.
+	 */
+#if 0
+	writel_be(MISC_CE_HIGH_TIMING(0xf) | MISC_BUSY_TIMING(0xff) |
+		  MISC_HOLD_TIMING(1) | MISC_SETUP_TIMING(3),
+		  priv->iobase + NFLASH_MISC_REG);
+
+	writel_be(WE_HIGH_TO_RE_LOW(0x8) | WE_HIGH_TIME(2) | WE_LOW_TIME(2),
+		  priv->iobase + NFLASH_WE_REG);
+
+	writel_be(RE_ALE_LOW_TO_RE(2) | RE_READY_TO_RE(3) | RE_RE_HIGH_TIME(2) |
+		  RE_RE_LOW_TIME(2), priv->iobase + NFLASH_RE_REG);
+
+#endif
+
+}
+
+static int stv576_nand_scan(struct mtd_info *mtd)
+{
+	int ret;
+
+	/* Figure out what we have. We cannot have more than
+	 * one chip
+	 */
+	ret = nand_scan_ident(mtd, 1);
+
+	if (ret)
+		return ret;
+
+	/* Now we know what we have connected, set up
+	 * the parameters appropriately. We should really
+	 * set up the timing information here as well
+	 */
+	postscan_init(mtd);
+
+	return nand_scan_tail(mtd);
+}
+
+static void free_nand_info(struct stv576_nand_info *priv)
+{
+	int i;
+
+	if (priv->iobase)
+		iounmap(priv->iobase);
+
+	for (i = 0; i < MAX_DMA_CHAIN_SIZE; i++) {
+		if (priv->dma_chain[i].descriptor) {
+			dma_unmap_single(NULL,
+					 priv->dma_chain[i].descriptor_dma_addr,
+					 sizeof(struct dma_descriptor),
+					 DMA_TO_DEVICE);
+			kfree(priv->dma_chain[i].descriptor);
+		}
+	}
+
+	for (i = 0; i < MAX_BOUNCE_BUFFERS; i++) {
+		if (priv->bounce[i].buffer) {
+			dma_unmap_single(NULL, priv->bounce[i].dma_addr,
+					 DMA_ALIGN_SIZE, DMA_BIDIRECTIONAL);
+			kfree(priv->bounce[i].buffer);
+		}
+	}
+	kfree(priv->verify_buf);
+}
+
+static int __init stv576_nand_probe(struct platform_device *pdev)
+{
+	struct stv576_nand_info *priv;
+	struct mtd_info *mtd;
+	struct nand_chip *nand_chip;
+	int res;
+	int i;
+	struct plat_stv576_nand_data *nand_data = pdev->dev.platform_data;
+
+	priv = kzalloc(sizeof(struct stv576_nand_info), GFP_KERNEL);
+	if (!priv) {
+		printk(KERN_ERR
+		       "stv576_nand: failed to allocate device structure\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < MAX_BOUNCE_BUFFERS; i++) {
+		priv->bounce[i].buffer =
+		    kmalloc(NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE, GFP_KERNEL);
+		if (priv->bounce[i].buffer == NULL) {
+			res = -ENOMEM;
+			goto out;
+		}
+		priv->bounce[i].dma_addr =
+		    dma_map_single(NULL, priv->bounce[i].buffer,
+				   NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE,
+				   DMA_BIDIRECTIONAL);
+	}
+
+	/* Zeroeth element not used, set up in registers */
+	for (i = 1; i < MAX_DMA_CHAIN_SIZE; i++) {
+		priv->dma_chain[i].descriptor =
+		    kmalloc(sizeof(struct dma_descriptor), GFP_KERNEL);
+		if (priv->dma_chain[i].descriptor == NULL) {
+			printk(KERN_ERR "stv576_nand: "
+					"cannot allocate dma chain buffer\n");
+			res = -ENOMEM;
+			goto out;
+		}
+		/* The bounce buffers are used both ways */
+		priv->dma_chain[i].descriptor_dma_addr =
+		    dma_map_single(NULL, priv->dma_chain[i].descriptor,
+				   sizeof(struct dma_descriptor),
+				   DMA_TO_DEVICE);
+	}
+
+	priv->verify_buf =
+	    kmalloc(NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE, GFP_KERNEL);
+
+	if (!priv->verify_buf) {
+		res = -ENOMEM;
+		goto out;
+	}
+
+	priv->iobase = ioremap(pdev->resource[0].start,
+			       pdev->resource[0].end - pdev->resource[0].start +
+			       1);
+
+	if (!priv->iobase) {
+		printk(KERN_ERR "stv576_nand: ioremap failed\n");
+		res = -EBUSY;
+		goto out;
+	}
+
+	platform_set_drvdata(pdev, priv);
+
+	mtd = &priv->mtd;
+	nand_chip = &priv->nand_chip;
+
+	nand_chip->priv = priv;
+	mtd->priv = nand_chip;
+	mtd->owner = THIS_MODULE;
+
+	/* Now fill in the nand_chip structures. We have to override *a lot*
+	 * as the hardware is too smart to plug in easily.
+	 */
+
+	/* The software should NEVER read this directly */
+	nand_chip->IO_ADDR_R = NULL;
+	nand_chip->IO_ADDR_W = NULL;
+
+	nand_chip->read_byte = stv576_read_byte;
+	nand_chip->read_word = stv576_read_word;
+	nand_chip->write_buf = stv576_write_buf;
+	nand_chip->read_buf = stv576_read_buf;
+	nand_chip->verify_buf = stv576_verify_buf;
+	nand_chip->cmd_ctrl = stv576_cmd_ctrl;
+	nand_chip->dev_ready = stv576_dev_ready;
+	nand_chip->cmdfunc = stv576_cmdfunc;
+
+	nand_chip->ecc.write_page_raw = stv576_write_page_raw;
+	nand_chip->ecc.read_page_raw = stv576_read_page_raw;
+
+	/* The hardware error correction is a bit mad */
+	nand_chip->ecc.mode = NAND_ECC_SOFT;
+
+	nand_chip->options = nand_data->options |
+	    NAND_NO_AUTOINCR | NAND_NO_SUBPAGE_READ;
+
+	/* Set the hardware to allow scan to work */
+	prescan_init(priv);
+
+	if (stv576_nand_scan(mtd)) {
+		res = -ENXIO;
+		goto out;
+	}
+
+	/* The controller doesn't support these, so disable them */
+	nand_chip->options &= ~(NAND_CACHEPRG | NAND_COPYBACK);
+
+#ifdef CONFIG_MTD_PARTITIONS
+	if (nand_data->mtd_parts)
+		res = add_mtd_partitions(mtd, nand_data->mtd_parts,
+					 nand_data->nr_parts);
+	else
+		res = add_mtd_device(mtd);
+#else
+	res = add_mtd_device(mtd);
+#endif
+
+	if (!res)
+		return res;
+
+	nand_release(mtd);
+
+out:
+	platform_set_drvdata(pdev, NULL);
+	free_nand_info(priv);
+	kfree(priv);
+	return res;
+}
+
+static int __devexit stv576_nand_remove(struct platform_device *pdev)
+{
+	struct stv576_nand_info *priv = platform_get_drvdata(pdev);
+
+	nand_release(&priv->mtd);
+
+	platform_set_drvdata(pdev, NULL);
+	free_nand_info(priv);
+
+	kfree(priv);
+
+	return 0;
+}
+
+static struct platform_driver stv576_nand_driver = {
+	.probe = stv576_nand_probe,
+	.remove = stv576_nand_remove,
+	.driver = {
+		   .name = "stv576_nand",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init stv576_nand_init(void)
+{
+	return platform_driver_register(&stv576_nand_driver);
+}
+
+static void __exit stv576_nand_exit(void)
+{
+	platform_driver_unregister(&stv576_nand_driver);
+}
+
+module_init(stv576_nand_init);
+module_exit(stv576_nand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David McKay <david.mckay@st.com>");
+MODULE_DESCRIPTION("NAND driver for STMicro STV576");
diff --git a/drivers/mtd/nand/stv576_nand.h b/drivers/mtd/nand/stv576_nand.h
new file mode 100644
index 0000000..445fb1c
--- /dev/null
+++ b/drivers/mtd/nand/stv576_nand.h
@@ -0,0 +1,121 @@
+/* drivers/mtd/nand/sv576_nand.h: Defines for STV576 NAND hardware
+ *
+ * Copyright (c) 2009 David McKay <david.mckay@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 only.
+ * See linux/COPYING for more info
+ */
+
+#ifndef __STV576_NAND_H__
+#define __STV576_NAND_H__
+
+/* NAND Controller registers */
+#define NFLASH_CNTL_REG		0x00
+#define NFLASH_PCNFG_REG	0x04
+#define NFLASH_ACNFG_REG	0x08
+#define NFLASH_DATA_REG(n)	(0x10 + ( (n) * 4))
+#define NFLASH_ADDR_REG		0x50
+#define NFLASH_CMD_REG		0x54
+#define NFLASH_STS_REG		0x58
+#define NFLASH_INTEN_REG	0x5c
+#define NFLASH_INTSTS_REG	0x60
+#define NFLASH_FADDR_REG	0x64
+#define NFLASH_MISC_REG		0x70
+#define NFLASH_DEVICE_SEL_REG	0x74
+#define NFLASH_WE_REG		0x78
+#define NFLASH_RE_REG		0x7c
+#define NFLASH_SADDR_REG	0x100
+#define NFLASH_BYTE_CNT_REG	0x104
+#define NFLASH_DESCR_ADDR_REG	0x108
+#define NFLASH_DMACNTL_REG	0x10c
+
+#define CNTL_EXIT_BOOT_WINDOW	(1 << 16)
+#define CNTL_PAGE_SIZE		(1 << 8)
+#define CNTL_SWAP_DISABLE	(1 << 3)
+#define CNTL_IGNORE_UNINIT_DATA	(1 << 2)
+#define CNTL_GLOBAL_INT_MASK	(1 << 1)
+#define CNTL_ECC_ENABLE		(1 << 0)
+
+#define PCNFG_MAIN_ARRAY_PAGE_SIZE(n) 		(n)
+#define PCNFG_REDUNDANT_ARRAY_PAGE_SIZE(n)	( (n) << 16)
+#define PCNFG_SEQUENTIAL_READ_SUPPORT		(1 << 31)
+
+#define ACNFG_BLOCK_ADDR_START(a) 	(a)
+#define ACNFG_NUM_ADDR_CYCLES(n) 	( (n) << 4)
+#define ACNFG_BLOCK_MASK(n) 		( (n) << 12)
+
+#define CMD_INIT_TRANSFER		( 1 << 22)
+#define CMD_RESET			( 1 << 21)
+#define CMD_ERASE			( 1 << 20)
+#define CMD_NFC(n)			( (n) << 17)
+#define NFC_MAIN_REDUNDANT		0
+#define NFC_REDUNDANT_ONLY		1
+#define NFC_STATUS_REG			2
+#define NFC_ID_REG			3
+
+#define CMD_READ			( 1 << 16)
+#define CMD_WRITE			0
+#define CMD_DATA_COUNT(n)		(n)
+
+#define STATUS_GLOBAL_INT_PENDING	( 1 << 3)
+#define STATUS_BLOCK_STATUS_VAL(x)	(  ((x) & 0x6) >> 1)
+#define STATUS_IDLE			0
+#define STATUS_READ_WRITE		1
+#define STATUS_ERASING			2
+#define STATUS_RESETTING		3
+#define STATUS_READY			(1 << 0)
+
+#define INTEN_BUSY_NOT_ASSERTED		(1 << 9)
+#define INTEN_PROGRAM_FAILURE		(1 << 8)
+#define INTEN_TRANSFER_COMPLETE		(1 << 7)
+#define INTEN_DMA_WRITE_DONE		(1 << 6)
+#define INTEN_DMA_READ_DONE		(1 << 5)
+#define INTEN_ERASE_COMPLETE		(1 << 4)
+#define INTEN_RESET_COMPLETE		(1 << 3)
+#define INTEN_ECC_ERROR			(1 << 2)
+#define INTEN_UNCORRECTABLE_ECC_ERROR	(1 << 1)
+#define INTEN_READY			(1 << 0)
+
+#define INTSTS_BUSY_NOT_ASSERTED	(1 << 9)
+#define INTSTS_PROGRAM_FAILURE		(1 << 8)
+#define INTSTS_TRANSFER_COMPLETE	(1 << 7)
+#define INTSTS_DMA_WRITE_DONE		(1 << 6)
+#define INTSTS_DMA_READ_DONE		(1 << 5)
+#define INTSTS_ERASE_COMPLETE		(1 << 4)
+#define INTSTS_RESET_COMPLETE		(1 << 3)
+#define INTSTS_ECC_ERROR		(1 << 2)
+#define INTSTS_UNCORRECTABLE_ECC_ERROR	(1 << 1)
+#define INTSTS_READY			(1 << 0)
+
+#define MISC_CE_HIGH_TIMING(n)		( (n) << 24)
+#define MISC_BUSY_TIMING(n)		( (n) << 16)
+#define MISC_HOLD_TIMING(n)		( (n) << 8)
+#define MISC_SETUP_TIMING(n)		(n)
+
+#define DEVICE_SEL_DEVICE_SELECT	( 1 << 0)
+
+#define WE_HIGH_TO_RE_LOW(n)		( (n) << 16)
+#define WE_HIGH_TIME(n)			( (n) << 8)
+#define WE_LOW_TIME(n) 			( (n) )
+
+#define RE_ALE_LOW_TO_RE(n)		( (n) << 24)
+#define RE_READY_TO_RE(n)		( (n) << 16)
+#define RE_RE_HIGH_TIME(n)		( (n) << 8)
+#define RE_RE_LOW_TIME(n)		( (n) << 0)
+
+#define DESCR_ADDR_ENABLE_DMA_CHAINING	( 1 << 0)
+
+#define DMACNTL_DONE			(1 << 18)
+#define DMACNTL_FIFO_FLUSHED		(1 << 17)
+#define DMACNTL_SENDER_DONE		(1 << 16)
+#define DMACNTL_TERMINAL_COUNT		(1 << 15)
+#define DMACNTL_ACTIVE			(1 << 14)
+#define DMACNTL_BURST_LENGTH(n)		( (n) << 6)
+#define DMACNTL_SWAP(n)			( (n) << 4)
+#define DMACNTL_REVERSE			(1 << 3)
+#define DMACNTL_DUPLEX			(1 << 2)
+#define DMACNTL_ABORT			(1 << 1)
+#define DMACNTL_ENABLE			(1 << 0)
+
+#endif
diff --git a/drivers/net/tulip/tulip_core.c b/drivers/net/tulip/tulip_core.c
index 6b2330e..1d17f70 100644
--- a/drivers/net/tulip/tulip_core.c
+++ b/drivers/net/tulip/tulip_core.c
@@ -66,7 +66,7 @@ const char * const medianame[32] = {
 /* Set the copy breakpoint for the copy-only-tiny-buffer Rx structure. */
 #if defined(__alpha__) || defined(__arm__) || defined(__hppa__) \
 	|| defined(CONFIG_SPARC) || defined(__ia64__) \
-	|| defined(__sh__) || defined(__mips__)
+	|| defined(__sh__) || defined(__mips__) || defined(__st200__)
 static int rx_copybreak = 1518;
 #else
 static int rx_copybreak = 100;
@@ -95,7 +95,7 @@ static int csr0 = 0x01A00000 | 0x8000;
  * any more than that.
  */
 static int csr0 = 0x01A00000 | 0x9000;
-#elif defined(__arm__) || defined(__sh__)
+#elif defined(__arm__) || defined(__sh__) || defined(__st200__)
 static int csr0 = 0x01A00000 | 0x4800;
 #elif defined(__mips__)
 static int csr0 = 0x00200000 | 0x4000;
diff --git a/drivers/pci/Makefile b/drivers/pci/Makefile
index 4a7f11d..5e8111d 100644
--- a/drivers/pci/Makefile
+++ b/drivers/pci/Makefile
@@ -43,6 +43,7 @@ obj-$(CONFIG_ALPHA) += setup-bus.o setup-irq.o
 obj-$(CONFIG_ARM) += setup-bus.o setup-irq.o
 obj-$(CONFIG_PARISC) += setup-bus.o
 obj-$(CONFIG_SUPERH) += setup-bus.o setup-irq.o
+obj-$(CONFIG_ARCH_ST200) += setup-bus.o setup-irq.o
 obj-$(CONFIG_PPC) += setup-bus.o
 obj-$(CONFIG_MIPS) += setup-bus.o setup-irq.o
 obj-$(CONFIG_X86_VISWS) += setup-irq.o
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index e522572..5b475fb 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -1477,4 +1477,19 @@ config SERIAL_BCM63XX_CONSOLE
 	  If you have enabled the serial port on the bcm63xx CPU
 	  you can make it the console by answering Y to this option.
 
+config SERIAL_STV576
+	bool "STV576 serial port support"
+	depends on SOC_STV576
+	select SERIAL_CORE
+	help
+	  Support for simple serial ports found on the STV576 family
+	  from STMicroelectroncis.
+
+config SERIAL_STV576_CONSOLE
+	bool "Console on STV576 serial port"
+	depends on SERIAL_STV576
+	select SERIAL_CORE_CONSOLE
+	help
+	  Select this if you want a console on an STV576 serial port.
+
 endmenu
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index d21d5dd..25b64fe 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -81,3 +81,4 @@ obj-$(CONFIG_SERIAL_KS8695) += serial_ks8695.o
 obj-$(CONFIG_KGDB_SERIAL_CONSOLE) += kgdboc.o
 obj-$(CONFIG_SERIAL_QE) += ucc_uart.o
 obj-$(CONFIG_SERIAL_TIMBERDALE)	+= timbuart.o
+obj-$(CONFIG_SERIAL_STV576) += serial_stv576.o
diff --git a/drivers/serial/serial_stv576.c b/drivers/serial/serial_stv576.c
new file mode 100644
index 0000000..3399b80
--- /dev/null
+++ b/drivers/serial/serial_stv576.c
@@ -0,0 +1,779 @@
+/*
+ *  drivers/serial/strs.c
+ *
+ *  Driver for ST RS simple serial port
+ *  Found on various ST ASICs
+ *
+ */
+
+#if defined(CONFIG_SERIAL_STV576_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/sysrq.h>
+#include <linux/serial.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/console.h>
+#include <linux/generic_serial.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/serial_core.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+
+#include "serial_stv576.h"
+
+#define DRIVER_NAME "strs"
+
+#ifdef CONFIG_SERIAL_STV576_CONSOLE
+static struct console strs_console;
+#endif
+
+extern struct platform_device *strs_configured_devices[];
+extern int strs_console_device;
+extern int strs_configured_devices_count;
+
+/* Nothing to put in here just yet, but there is
+ * bound to be later!!
+ */
+struct strs_port {
+	struct uart_port port;
+	struct timer_list timer;	/* timer bodge for now */
+};
+
+#define STRS_MAX_PORTS 3
+#define STRS_MAJOR 204
+#define STRS_MINOR_START 40	/* Same minor as ASC ports */
+
+#define FIFO_SIZE RS_FIFO_SIZE
+
+struct strs_port strs_ports[STRS_MAX_PORTS];
+
+/* Inline functions to read and write the uart registers.
+ * They all seem to be 16 bit. I'm guessing that the fifo write
+ * only writes a byte at a time if you do a word write
+ */
+static inline u16 strs_in(struct uart_port *port, int offset)
+{
+	return be16_to_cpu(readw(port->membase + offset));
+}
+
+static inline void strs_out(struct uart_port *port, int offset, u16 val)
+{
+	writew(cpu_to_be16(val), port->membase + offset);
+}
+
+/* Some simple utility functions to enable and disable interrupts.
+ * Note that these need to be called with interrupts disabled.
+ */
+static inline void strs_disable_tx_interrupt(struct uart_port *port)
+{
+	u16 mask = strs_in(port, RS_INTR_MASK);
+
+	mask |= INTR_MASK_FO_EMP_MASK;
+
+	strs_out(port, RS_INTR_MASK, mask);
+}
+
+static inline void strs_enable_tx_interrupt(struct uart_port *port)
+{
+	u16 mask = strs_in(port, RS_INTR_MASK);
+
+	mask &= ~INTR_MASK_FO_EMP_MASK;
+
+	strs_out(port, RS_INTR_MASK, mask);
+}
+
+static inline void strs_disable_rx_interrupt(struct uart_port *port)
+{
+	u16 mask = strs_in(port, RS_INTR_MASK);
+
+	mask |= INTR_MASK_RECV_PENDING_MASK | INTR_MASK_FI_FULL_MASK |
+	    INTR_MASK_FI_PFULL_MASK;
+
+	strs_out(port, RS_INTR_MASK, mask);
+
+}
+
+static inline void strs_enable_rx_interrupt(struct uart_port *port)
+{
+	u16 mask = strs_in(port, RS_INTR_MASK);
+
+	mask &= ~(INTR_MASK_RECV_PENDING_MASK | INTR_MASK_FI_FULL_MASK |
+		  INTR_MASK_FI_PFULL_MASK);
+
+	strs_out(port, RS_INTR_MASK, mask);
+}
+
+static unsigned int strs_tx_empty(struct uart_port *port)
+{
+	u16 status;
+
+	status = strs_in(port, RS_INTR_STAT);
+
+	if (status & INTR_STAT_FIFO_EMPTY_INT)
+		return TIOCSER_TEMT;
+	return 0;
+}
+
+static void strs_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	/* Don't have RTS/CTS etc pins to set, so do nothing */
+}
+
+static unsigned int strs_get_mctrl(struct uart_port *port)
+{
+	/* There are no other signals whatsover on the ST RS
+	 * serial ports, just RX/TX
+	 */
+	return 0;
+}
+
+/*
+ * Transmit stop - interrupts disabled on entry
+ */
+static void strs_stop_tx(struct uart_port *port)
+{
+	strs_disable_tx_interrupt(port);
+}
+
+/*
+ * Receive stop - interrupts still enabled on entry
+ */
+static void strs_stop_rx(struct uart_port *port)
+{
+	strs_disable_rx_interrupt(port);
+}
+
+/*
+ * Force modem status interrupts on - no-op for us
+ */
+static void strs_enable_ms(struct uart_port *port)
+{
+	/* Nothing here yet .. */
+}
+
+/*
+ * Handle breaks - ignored by us
+ */
+static void strs_break_ctl(struct uart_port *port, int break_state)
+{
+	/* Nothing here yet .. */
+}
+
+static int strs_calc_baud(int baud)
+{
+	u16 val;
+	static const int baud_rates[8] =
+	    { 115200, 57600, 38400, 19200, 9600, 4800, 2400, 1200 };
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(baud_rates); i++) {
+		if (baud == baud_rates[i])
+			return i;
+	}
+
+	return -1;
+}
+
+static inline unsigned strs_hw_txroom(struct uart_port *port)
+{
+	u16 status;
+
+	status = strs_in(port, RS_INTR_STAT);
+
+	if (status & INTR_STAT_FIFO_EMPTY_INT)
+		return 5;
+
+	//if(status & INTR_STAT_FO_PEMP_INT) return 1;
+	/* We know there is some space, but not how much
+	 * This may not be accurate, you have to check
+	 */
+	return 0;
+}
+
+static inline void strs_receive_chars(struct uart_port *port)
+{
+	int count;
+	struct tty_struct *tty = port->state->port.tty;
+	int copied = 0;
+	u16 status;
+	u16 c = 0;
+	char flag;
+	int overrun;
+
+	while (1) {
+		status = strs_in(port, RS_INTR_STAT);
+		if (status & INTR_STAT_FI_FULL_INT) {
+			count = FIFO_SIZE;
+		} else if (status & INTR_STAT_FI_PFULL_INT) {
+			count = 1;
+		} else {
+			count = 0;
+		}
+
+		/* Don't copy more bytes than there are room for in the buffer */
+		count = tty_buffer_request_room(tty, count);
+
+		/* If for any reason we can't copy more data, we're done! */
+		if (count == 0)
+			break;
+
+		for (; count != 0; count--) {
+			c = strs_in(port, RS_QUEUE_RD);
+			if (!(c & QUEUE_RD_FI_DAV))
+				break;
+			flag = TTY_NORMAL;
+			port->icount.rx++;
+			tty_insert_flip_char(tty, c & 0xff, flag);
+			copied = 1;
+		}
+	}
+
+	if (copied) {
+		/* Tell the rest of the system the news. New characters! */
+		tty_flip_buffer_push(tty);
+	}
+
+}
+
+static void strs_free_irq(struct uart_port *port)
+{
+	free_irq(port->irq, port);
+}
+
+static irqreturn_t strs_interrupt(int irq, void *ptr)
+{
+	struct uart_port *port = ptr;
+	unsigned long status;
+
+	spin_lock(&port->lock);
+
+	status = strs_in(port, RS_INTR_STAT);
+	if (status & INTR_STAT_FI_PFULL_INT) {
+		/* Receive FIFO not empty */
+		strs_receive_chars(port);
+	}
+#if 0
+	if ((status & ASC_STA_THE) && (strs_in(port, INTEN) & ASC_INTEN_THE)) {
+		/* Transmitter FIFO at least half empty */
+		strs_transmit_chars(port);
+	}
+#endif
+
+	spin_unlock(&port->lock);
+
+	return IRQ_HANDLED;
+}
+
+static int strs_request_irq(struct uart_port *port)
+{
+	struct platform_device *pdev = to_platform_device(port->dev);
+#if 1
+	if (request_irq(port->irq, strs_interrupt, 0, pdev->name, port)) {
+		printk(KERN_ERR "stasc: cannot allocate irq.\n");
+		return -ENODEV;
+	}
+#endif
+	return 0;
+}
+
+/*
+ * Start transmitting chars.
+ * This is called from both interrupt and task level.
+ * Either way interrupts are disabled.
+ */
+static void strs_transmit_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->state->xmit;
+	int txroom;
+	unsigned long intenable;
+	unsigned char c;
+
+#if 1
+	txroom = strs_hw_txroom(port);
+
+	if ((txroom != 0) && port->x_char) {
+		c = port->x_char;
+		port->x_char = 0;
+		strs_out(port, RS_FIFO_WR, c);
+		port->icount.tx++;
+		txroom = strs_hw_txroom(port);
+	}
+
+	/* Real ugly hack to just keep on dumping stuff out while we
+	 * can. Need to be properly interrupt driven, but we don't
+	 * have any interrupts!
+	 */
+	while (!uart_circ_empty(xmit)) {
+		do {
+			txroom = strs_hw_txroom(port);
+		} while (txroom == 0);
+
+		if (uart_tx_stopped(port) || uart_circ_empty(xmit)) {
+			break;
+		}
+
+		c = xmit->buf[xmit->tail];
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		strs_out(port, RS_FIFO_WR, c);
+		port->icount.tx++;
+	}
+
+#else // Skeleton for when we actually have interrupts
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS) {
+		uart_write_wakeup(port);
+	}
+
+	intenable = strs_in(port, INTEN);
+	if (port->x_char || (!uart_circ_empty(xmit))) {
+		intenable |= ASC_INTEN_THE;
+	} else {
+		intenable &= ~ASC_INTEN_THE;
+	}
+	strs_out(port, INTEN, intenable);
+
+#endif
+
+}
+
+/*
+ * There are probably characters waiting to be transmitted.
+ * Start doing so.
+ * The port lock is held and interrupts are disabled.
+ */
+static void strs_start_tx(struct uart_port *port)
+{
+
+	strs_transmit_chars(port);
+}
+
+/* Base timer interval for polling */
+static inline int poll_timeout(int timeout)
+{
+	return timeout > 6 ? (timeout / 2 - 2) : 1;
+}
+
+static void strs_backup_timeout(unsigned long data)
+{
+	struct strs_port *rsport = (struct strs_port *)data;
+
+	strs_interrupt(rsport->port.irq, rsport);
+
+}
+
+/*
+ * Enable port for reception.
+ * port_sem held and interrupts disabled
+ */
+static int strs_startup(struct uart_port *port)
+{
+	struct strs_port *rsport = container_of(port, struct strs_port, port);
+#if 1
+	strs_request_irq(port);
+	strs_transmit_chars(port);
+	strs_enable_rx_interrupt(port);
+#endif
+
+	rsport->timer.function = strs_backup_timeout;
+	rsport->timer.data = (unsigned long)rsport;
+
+	return 0;
+}
+
+static void strs_shutdown(struct uart_port *port)
+{
+#if 1
+	strs_disable_tx_interrupt(port);
+	strs_disable_rx_interrupt(port);
+	strs_free_irq(port);
+#endif
+}
+
+void strs_set_termios_cflag(struct strs_port *rsport, int cflag, int baud)
+{
+	struct uart_port *port = &rsport->port;
+	int baud_bits = strs_calc_baud(baud);
+	unsigned long flags;
+	u16 val;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* Reset input/output ports */
+	strs_out(port, RS_FIFO_CLR, 0);
+
+	/* Set baud rate */
+	if (baud_bits) {
+		val = strs_in(port, RS_CNTRL) & ~CNTRL_BAUD_SEL_MASK;
+		val |= CNTRL_BAUD_SEL(baud_bits);
+		uart_update_timeout(port, cflag, baud);
+	}
+
+	strs_out(port, RS_PARITY, (cflag & PARODD) ? PARITY_ODD : PARITY_NONE);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void strs_set_termios(struct uart_port *port, struct ktermios *termios,
+			     struct ktermios *old)
+{
+	struct strs_port *rsport = container_of(port, struct strs_port, port);
+	unsigned int baud;
+
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);
+
+	strs_set_termios_cflag(rsport, termios->c_cflag, baud);
+}
+
+static const char *strs_type(struct uart_port *port)
+{
+	struct platform_device *pdev = to_platform_device(port->dev);
+	return pdev->name;
+}
+
+static void strs_release_port(struct uart_port *port)
+{
+	struct strs_port *rsport = container_of(port, struct strs_port, port);
+	struct platform_device *pdev = to_platform_device(port->dev);
+	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+	int i;
+
+	release_mem_region(port->mapbase, size);
+
+	if (port->flags & UPF_IOREMAP) {
+		iounmap(port->membase);
+		port->membase = NULL;
+	}
+
+}
+
+static int strs_remap_port(struct strs_port *rsport, int req)
+{
+	struct uart_port *port = &rsport->port;
+	struct platform_device *pdev = to_platform_device(port->dev);
+	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+	int i;
+
+	if (req && !request_mem_region(port->mapbase, size, pdev->name))
+		return -EBUSY;
+
+	/* We have already been remapped for the console */
+	if (port->membase)
+		return 0;
+
+	if (port->flags & UPF_IOREMAP) {
+		port->membase = ioremap(port->mapbase, size);
+		if (port->membase == NULL) {
+			release_mem_region(port->mapbase, size);
+			return -ENOMEM;
+		}
+	}
+
+	return 0;
+}
+
+static int strs_request_port(struct uart_port *port)
+{
+	struct strs_port *rsport = container_of(port, struct strs_port, port);
+
+	return strs_remap_port(rsport, 0);
+}
+
+/* Called when the port is opened, and UPF_BOOT_AUTOCONF flag is set */
+/* Set type field if successful */
+static void strs_config_port(struct uart_port *port, int flags)
+{
+	if ((flags & UART_CONFIG_TYPE) && (strs_request_port(port) == 0))
+		port->type = PORT_STV576;
+}
+
+static int strs_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	/* No user changeable parameters */
+	return -EINVAL;
+}
+
+/*---------------------------------------------------------------------*/
+
+static struct uart_ops strs_uart_ops = {
+	.tx_empty = strs_tx_empty,
+	.set_mctrl = strs_set_mctrl,
+	.get_mctrl = strs_get_mctrl,
+	.start_tx = strs_start_tx,
+	.stop_tx = strs_stop_tx,
+	.stop_rx = strs_stop_rx,
+	.enable_ms = strs_enable_ms,
+	.break_ctl = strs_break_ctl,
+	.startup = strs_startup,
+	.shutdown = strs_shutdown,
+	.set_termios = strs_set_termios,
+	.type = strs_type,
+	.release_port = strs_release_port,
+	.request_port = strs_request_port,
+	.config_port = strs_config_port,
+	.verify_port = strs_verify_port,
+};
+
+static void __devinit strs_init_port(struct strs_port *rsport,
+				     struct platform_device *pdev)
+{
+	struct uart_port *port = &rsport->port;
+	struct ststrs_uart_data *data = pdev->dev.platform_data;
+	struct clk *clk;
+	unsigned long rate;
+	int i;
+
+	init_timer(&rsport->timer);
+
+	port->iotype = UPIO_MEM;
+	port->flags = UPF_BOOT_AUTOCONF;
+	port->ops = &strs_uart_ops;
+	port->fifosize = FIFO_SIZE;
+	port->line = pdev->id;
+	port->dev = &pdev->dev;
+
+	port->mapbase = pdev->resource[0].start;
+	port->irq = pdev->resource[1].start;
+
+	/* Assume that we can always use ioremap */
+	port->flags |= UPF_IOREMAP;
+	//port->membase = NULL;
+
+	port->uartclk = 7384600;	/* Should be filled in from platform data */
+}
+
+static struct uart_driver strs_uart_driver = {
+	.owner = THIS_MODULE,
+	.driver_name = DRIVER_NAME,
+	.dev_name = "ttyRS",
+	.major = STRS_MAJOR,
+	.minor = STRS_MINOR_START,
+	.nr = STRS_MAX_PORTS,
+#ifdef CONFIG_SERIAL_STV576_CONSOLE
+	.cons = &strs_console,
+#endif
+};
+
+#ifdef CONFIG_SERIAL_STV576_CONSOLE
+
+static void __init strs_init_ports(void)
+{
+	int i;
+
+	for (i = 0; i < strs_configured_devices_count; i++)
+		strs_init_port(&strs_ports[i], strs_configured_devices[i]);
+}
+
+/*
+ * Early console initialization.
+ */
+static int __init strs_console_init(void)
+{
+	if (!strs_configured_devices_count)
+		return 0;
+
+	strs_init_ports();
+	register_console(&strs_console);
+	if (strs_console_device != -1)
+		add_preferred_console("ttyRS", strs_console_device, NULL);
+
+	return 0;
+}
+
+console_initcall(strs_console_init);
+
+/*
+ * Late console initialization.
+ */
+static int __init strs_late_console_init(void)
+{
+	if (!(strs_console.flags & CON_ENABLED))
+		register_console(&strs_console);
+
+	return 0;
+}
+
+core_initcall(strs_late_console_init);
+#endif
+
+static int __devinit strs_serial_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct strs_port *rsport = &strs_ports[pdev->id];
+
+	strs_init_port(rsport, pdev);
+
+	ret = uart_add_one_port(&strs_uart_driver, &rsport->port);
+	if (ret == 0) {
+		platform_set_drvdata(pdev, &rsport->port);
+	}
+
+	return ret;
+}
+
+static int __devexit strs_serial_remove(struct platform_device *pdev)
+{
+	struct uart_port *port = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+	return uart_remove_one_port(&strs_uart_driver, port);
+}
+
+static struct platform_driver strs_serial_driver = {
+	.probe = strs_serial_probe,
+	.remove = __devexit_p(strs_serial_remove),
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init strs_init(void)
+{
+	int ret;
+	static char banner[] __initdata =
+	    KERN_INFO "ST RS driver initialized\n";
+
+	printk(banner);
+
+	ret = uart_register_driver(&strs_uart_driver);
+	if (ret)
+		return ret;
+
+	ret = platform_driver_register(&strs_serial_driver);
+	if (ret)
+		uart_unregister_driver(&strs_uart_driver);
+
+	return ret;
+}
+
+static void __exit strs_exit(void)
+{
+	platform_driver_unregister(&strs_serial_driver);
+	uart_unregister_driver(&strs_uart_driver);
+}
+
+module_init(strs_init);
+module_exit(strs_exit);
+
+MODULE_AUTHOR("David McKay <david.mckay@st.com>");
+MODULE_DESCRIPTION("ST RS serial driver");
+MODULE_LICENSE("GPL");
+
+#ifdef CONFIG_SERIAL_STV576_CONSOLE
+static void put_char(struct uart_port *port, char c)
+{
+	unsigned long flags;
+
+try_again:
+	/* Poll with interrupts enabled */
+	while (strs_hw_txroom(port) == 0) ;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* Check again in case we are unlucky */
+	if (strs_hw_txroom(port) == 0) {
+		spin_unlock_irqrestore(&port->lock, flags);
+		goto try_again;
+	}
+
+	strs_out(port, RS_FIFO_WR, c);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+/*
+ * Send the packet in buffer.  The host gets one chance to read it.
+ * This routine does not wait for a positive acknowledge.
+ */
+
+static void put_string(struct uart_port *port, const char *buffer, int count)
+{
+	int i;
+	const unsigned char *p = buffer;
+
+	for (i = 0; i < count; i++) {
+		if (*p == 10)
+			put_char(port, '\r');
+		put_char(port, *p++);
+	}
+}
+
+static int early_strs_remap_port(struct strs_port *rsport, int req)
+{
+
+	struct uart_port *port = &rsport->port;
+	if (port->membase)
+		return 0;
+
+	port->membase = ioremap(port->mapbase, 0x12);
+
+	/* HACK */
+	strs_out(port, RS_CNTRL, 0);
+}
+
+/*
+ *  Setup initial baud/bits/parity. We do two things here:
+ *	- construct a cflag setting for the first rs_open()
+ *	- initialize the serial port
+ *  Return non-zero if we didn't find a serial port.
+ */
+
+static int __init strs_console_setup(struct console *co, char *options)
+{
+	struct strs_port *rsport;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+	int ret;
+
+	if (co->index >= STRS_MAX_PORTS)
+		co->index = 0;
+
+	rsport = &strs_ports[co->index];
+	if ((rsport->port.mapbase == 0))
+		return -ENODEV;
+
+	if ((ret = early_strs_remap_port(rsport, 0)) != 0)
+		return ret;
+
+	if (options) {
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	}
+
+	return uart_set_options(&rsport->port, co, baud, parity, bits, flow);
+}
+
+/*
+ *  Print a string to the serial port trying not to disturb
+ *  any possible real use of the port...
+ */
+
+static void
+strs_console_write(struct console *co, const char *s, unsigned count)
+{
+	struct uart_port *port = &strs_ports[co->index].port;
+
+	put_string(port, s, count);
+}
+
+static struct console strs_console = {
+	.name = "ttyRS",
+	.device = uart_console_device,
+	.write = strs_console_write,
+	.setup = strs_console_setup,
+	.flags = CON_PRINTBUFFER,
+	.index = -1,
+	.data = &strs_uart_driver,
+};
+
+#endif /* CONFIG_SERIAL_STV576_CONSOLE */
diff --git a/drivers/serial/serial_stv576.h b/drivers/serial/serial_stv576.h
new file mode 100644
index 0000000..d92b032
--- /dev/null
+++ b/drivers/serial/serial_stv576.h
@@ -0,0 +1,65 @@
+#ifndef __SERIAL_STV576_H
+#define __SERIAL_STV576_H
+
+#define RS_CNTRL 	0x00
+#define RS_PARITY 	0x02
+#define RS_INTR_MASK 	0x04
+#define RS_FIFO_WR	0x06
+#define RS_FIFO_CLR	0x08
+#define RS_FIFO_RD	0x0a
+#define RS_QUEUE_RD	0x0c
+#define RS_STATUS	0x0e
+#define RS_INTR_STAT	0x10
+
+#define RS_NUM_REGS 	8
+
+#define RS_FIFO_SIZE 5
+
+#define PARITY_ODD 0x1
+#define PARITY_NONE 0
+
+
+#define FIFO_RD_FI_DAV	(1<<8)
+#define QUEUE_RD_FI_DAV	(1<<8)
+
+#define STATUS_FI_PART_FULL (1<<12)
+#define STATUS_FI_FULL (1<<11)
+#define STATUS_FI_EMPTY (1<<10)
+#define STATUS_FO_FULL (1<<9)
+#define STATUS_FO_PART_EMP (1<<8)
+#define STATUS_FO_EMPTY (1<<7)
+#define STATUS_TRANS_IDLE (1<<6)
+#define STATUS_RECV_IDLE (1<<5)
+#define STATUS_TIMEOUT (1<<4)
+#define STATUS_DATA_IN (1<<3)
+#define STATUS_FI_DAV (1<<2)
+#define STATUS_PARITY_MODE (3)
+
+#define INTR_STAT_FI_PFULL_INT		(1 << 8)
+#define INTR_STAT_FI_FULL_INT		(1 << 7)
+#define INTR_STAT_FRAME_INT		(1 << 6)
+#define INTR_STAT_PARITY_INT		(1 << 5)
+#define INTR_STAT_RECV_OVER_INT		(1 << 4)
+#define INTR_STAT_FO_PEMP_INT		(1 << 3)
+#define INTR_STAT_FIFO_EMPTY_INT	(1 << 2)
+#define INTR_STAT_TRANS_OVER_INT	(1 << 1)
+#define INTR_STAT_TIMEOUT_INT		(1 << 0)
+
+#define INTR_MASK_RECV_PENDING_MASK	(1 << 9)
+#define INTR_MASK_TIMEOUT_MASK		(1 << 8)
+#define INTR_MASK_TRANS_OVER_MASK	(1 << 7)
+#define INTR_MASK_FO_EMP_MASK		(1 << 6)
+#define INTR_MASK_FO_PEMP_MASK		(1 << 5)
+#define INTR_MASK_RECV_OVER_MASK	(1 << 4)
+#define INTR_MASK_PARITY_MASK		(1 << 3)
+#define INTR_MASK_FRAME_MASK		(1 << 2)
+#define INTR_MASK_FI_FULL_MASK		(1 << 1)
+#define INTR_MASK_FI_PFULL_MASK		(1 << 0)
+
+
+#define CNTRL_BAUD_SEL(n)		(((n) & 0x7) << 4)
+#define CNTRL_BAUD_SEL_MASK 		CNTRL_BAUD_SEL(0x7)
+
+#endif
+
+
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 2407508..92eae14 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -49,6 +49,8 @@ config USB_ARCH_HAS_OHCI
 	default y if CPU_SUBTYPE_SH7721
 	default y if CPU_SUBTYPE_SH7763
 	default y if CPU_SUBTYPE_SH7786
+	# ST200:
+	default y if SOC_STV576
 	# more:
 	default PCI
 
@@ -60,6 +62,8 @@ config USB_ARCH_HAS_EHCI
 	default y if ARCH_IXP4XX
 	default y if ARCH_W90X900
 	default y if ARCH_AT91SAM9G45
+	# ST200:
+	default y if SOC_STV576
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 9b43b22..bd84dac 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -90,12 +90,12 @@ config USB_EHCI_TT_NEWSCHED
 
 config USB_EHCI_BIG_ENDIAN_MMIO
 	bool
-	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX || ARCH_IXP4XX)
+	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX || ARCH_IXP4XX || SOC_STV576)
 	default y
 
 config USB_EHCI_BIG_ENDIAN_DESC
 	bool
-	depends on USB_EHCI_HCD && (440EPX || ARCH_IXP4XX)
+	depends on USB_EHCI_HCD && (440EPX || ARCH_IXP4XX || SOC_STV576)
 	default y
 
 config USB_EHCI_FSL
@@ -243,20 +243,27 @@ config USB_OHCI_HCD_SSB
 
 	  If unsure, say N.
 
+config USB_STV576_COMMON
+        bool
+        depends on SOC_STV576
+        default y if USB_EHCI_HCD=y || USB_OHCI_HCD=y
+
 config USB_OHCI_BIG_ENDIAN_DESC
 	bool
 	depends on USB_OHCI_HCD
+	default y if SOC_STV576
 	default n
 
 config USB_OHCI_BIG_ENDIAN_MMIO
 	bool
 	depends on USB_OHCI_HCD
+	default y if SOC_STV576
 	default n
 
 config USB_OHCI_LITTLE_ENDIAN
 	bool
 	depends on USB_OHCI_HCD
-	default n if STB03xxx || PPC_MPC52xx
+	default n if STB03xxx || PPC_MPC52xx || SOC_STV576
 	default y
 
 config USB_UHCI_HCD
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index f58b249..f141973 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -32,3 +32,5 @@ obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
 obj-$(CONFIG_USB_R8A66597_HCD)	+= r8a66597-hcd.o
 obj-$(CONFIG_USB_ISP1760_HCD)	+= isp1760.o
 obj-$(CONFIG_USB_HWA_HCD)	+= hwa-hc.o
+obj-$(CONFIG_USB_STV576_COMMON) += stv576-common.o
+
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e18c677..5100c72 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1141,6 +1141,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_atmel_driver
 #endif
 
+#ifdef CONFIG_SOC_STV576
+#include "ehci-stv576.c"
+#define PLATFORM_DRIVER 	ehci_hcd_stv576_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
diff --git a/drivers/usb/host/ehci-stv576.c b/drivers/usb/host/ehci-stv576.c
new file mode 100644
index 0000000..5a5e614
--- /dev/null
+++ b/drivers/usb/host/ehci-stv576.c
@@ -0,0 +1,159 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB
+ *
+ * (C) copyright STMicroelectronics 2008
+ * Author: David McKay <david.mckay@st.com>
+ *
+ * Bus glue for ST's STV576 ASIC
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/platform_device.h>
+
+static int ehci_stv576_reset(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	return ehci_reset(ehci);
+}
+
+#ifdef	CONFIG_PM
+static int ehci_stv576_suspend(struct usb_hcd *hcd, pm_message_t message)
+{
+	return 0;
+}
+
+static int ehci_stv576_resume(struct usb_hcd *hcd)
+{
+	return 0;
+}
+#endif
+
+static const struct hc_driver ehci_stv576_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "ST STV576 EHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+
+	/* generic hardware linkage */
+	.irq = ehci_irq,
+	.flags = HCD_USB2 | HCD_MEMORY,
+
+	/* basic lifecycle operations */
+	.reset = ehci_stv576_reset,
+	.start = ehci_run,
+#ifdef	CONFIG_PM
+	.suspend = ehci_stv576_suspend,
+	.resume = ehci_stv576_resume,
+#endif
+	.stop = ehci_stop,
+
+	/* managing i/o requests and associated device resources */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+
+	/* scheduling support */
+	.get_frame_number = ehci_get_frame,
+
+	/* root hub support */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+#ifdef	CONFIG_USB_SUSPEND
+/* note we don't export these funcs for our ehci*/
+/*	.hub_suspend =		ehci_hub_suspend,*/
+/*	.hub_resume =		ehci_hub_resume,*/
+#endif
+};
+
+static int ehci_hcd_stv576_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = NULL;
+	struct ehci_hcd *ehci;
+	const struct hc_driver *driver = &ehci_stv576_hc_driver;
+	int retval;
+	extern int stv576_start_host_controller(struct platform_device *pdev);
+
+	if (usb_disabled())
+		return -ENODEV;
+#if 1
+	retval = stv576_start_host_controller(pdev);
+	if (retval)
+		return retval;
+#endif
+
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		pr_debug("hcd_create_hcd failed");
+		retval = -ENOMEM;
+		goto err0;
+	}
+
+	hcd->rsrc_start = pdev->resource[0].start;
+	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		pr_debug("ioremap failed");
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+	ehci = hcd_to_ehci(hcd);
+	ehci->big_endian_mmio = 1;
+	ehci->big_endian_desc = 1;
+
+	ehci->caps = hcd->regs;
+	ehci->regs =
+	    hcd->regs + HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	retval = usb_add_hcd(hcd, pdev->resource[1].start, 0);
+	if (retval == 0)
+		return retval;
+
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
+err0:
+	return retval;
+}
+
+static int ehci_hcd_stv576_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+static struct platform_driver ehci_hcd_stv576_driver = {
+	.driver = {
+		   .name = "stv576-ehci",
+		   .bus = &platform_bus_type},
+	.probe = ehci_hcd_stv576_probe,
+	.remove = ehci_hcd_stv576_remove,
+	.shutdown = usb_hcd_platform_shutdown,
+};
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 24eb747..931d1b8 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -1085,6 +1085,12 @@ MODULE_LICENSE ("GPL");
 #define TMIO_OHCI_DRIVER	ohci_hcd_tmio_driver
 #endif
 
+#ifdef CONFIG_SOC_STV576
+#include "ohci-stv576.c"
+#define PLATFORM_DRIVER 	ohci_hcd_stv576_driver
+#endif
+
+
 #if	!defined(PCI_DRIVER) &&		\
 	!defined(PLATFORM_DRIVER) &&	\
 	!defined(OF_PLATFORM_DRIVER) &&	\
diff --git a/drivers/usb/host/ohci-stv576.c b/drivers/usb/host/ohci-stv576.c
new file mode 100644
index 0000000..95c1d31
--- /dev/null
+++ b/drivers/usb/host/ohci-stv576.c
@@ -0,0 +1,160 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB
+ *
+ * (C) copyright STMicroelectronics 2008
+ * Author: David McKay <david.mckay@st.com>
+ *
+ * Bus glue for ST's STV576 ASIC
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/platform_device.h>
+
+static int ohci_stv576_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	int ret = 0;
+
+	ret = ohci_init(ohci);
+	if (ret < 0)
+		return ret;
+
+	ret = ohci_run(ohci);
+	if (ret < 0) {
+		err("can't start %s", hcd->self.bus_name);
+		ohci_stop(hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+#ifdef	CONFIG_PM
+static int ohci_stv576_suspend(struct usb_hcd *hcd, pm_message_t message)
+{
+	return 0;
+}
+
+static int ohci_stv576_resume(struct usb_hcd *hcd)
+{
+	return 0;
+}
+#endif
+
+static const struct hc_driver ohci_stv576_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "ST STV576 OHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ohci_hcd),
+
+	/* generic hardware linkage */
+	.irq = ohci_irq,
+	.flags = HCD_USB11 | HCD_MEMORY,
+
+	/* basic lifecycle operations */
+	.start = ohci_stv576_start,
+#ifdef	CONFIG_PM
+	.suspend = ohci_stv576_suspend,
+	.resume = ohci_stv576_resume,
+#endif
+	.stop = ohci_stop,
+
+	/* managing i/o requests and associated device resources */
+	.urb_enqueue = ohci_urb_enqueue,
+	.urb_dequeue = ohci_urb_dequeue,
+	.endpoint_disable = ohci_endpoint_disable,
+
+	/* scheduling support */
+	.get_frame_number = ohci_get_frame,
+
+	/* root hub support */
+	.hub_status_data = ohci_hub_status_data,
+	.hub_control = ohci_hub_control,
+#ifdef	CONFIG_USB_SUSPEND
+/* note we don't export these funcs for our ohci*/
+/*	.hub_suspend =		ohci_hub_suspend,*/
+/*	.hub_resume =		ohci_hub_resume,*/
+#endif
+	.start_port_reset = ohci_start_port_reset,
+};
+
+static int ohci_hcd_stv576_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = NULL;
+	struct ohci_hcd *ohci;
+	const struct hc_driver *driver = &ohci_stv576_hc_driver;
+	int retval;
+	extern int stv576_start_host_controller(struct platform_device *pdev);
+
+	if (usb_disabled())
+		return -ENODEV;
+
+#if 1
+	retval = stv576_start_host_controller(pdev);
+	if (retval)
+		return retval;
+#endif
+
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		pr_debug("hcd_create_hcd failed");
+		retval = -ENOMEM;
+		goto err0;
+	}
+
+	hcd->rsrc_start = pdev->resource[0].start;
+	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		pr_debug("ioremap failed");
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+	ohci = hcd_to_ohci(hcd);
+
+	ohci->flags |= OHCI_QUIRK_FRAME_NO;
+
+	ohci_hcd_init(ohci);
+
+	retval = usb_add_hcd(hcd, pdev->resource[1].start, 0);
+	if (retval == 0)
+		return retval;
+
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
+err0:
+	return retval;
+}
+
+static int ohci_hcd_stv576_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+static struct platform_driver ohci_hcd_stv576_driver = {
+	.driver = {
+		   .name = "stv576-ohci",
+		   .bus = &platform_bus_type},
+	.probe = ohci_hcd_stv576_probe,
+	.remove = ohci_hcd_stv576_remove,
+	.shutdown = usb_hcd_platform_shutdown,
+};
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 5bf15fe..f5ffe23 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -655,7 +655,7 @@ static inline u32 hc32_to_cpup (const struct ohci_hcd *ohci, const __hc32 *x)
  * some big-endian SOC implementations.  Same thing happens with PSW access.
  */
 
-#ifdef CONFIG_PPC_MPC52xx
+#if defined(CONFIG_PPC_MPC52xx) || defined(CONFIG_SOC_STV576)
 #define big_endian_frame_no_quirk(ohci)	(ohci->flags & OHCI_QUIRK_FRAME_NO)
 #else
 #define big_endian_frame_no_quirk(ohci)	0
diff --git a/drivers/usb/host/stv576-common.c b/drivers/usb/host/stv576-common.c
new file mode 100644
index 0000000..4846520
--- /dev/null
+++ b/drivers/usb/host/stv576-common.c
@@ -0,0 +1,98 @@
+#include <linux/st_soc.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+
+#define USB2_HOST_CONTROL               0x04
+
+#define USB2_HOST_RESET                 0x08
+#define PHY_UTMI_RESET_N                (0x3<<8)
+#define CORE_UTMI_RESET_N               (0x3<<4)
+#define CORE_PHY_RST_N                  (1<<2)
+#define CORE_HRESET_N                   (1<<1)
+#define OHCI_0_CLKCKTRST_N              (1<<0)
+
+#define USB2_HOST_INTERRUPT             0x0c
+
+#define USB2_HOST_INTERRUPT_ENABLE      0x10
+#define OHCI_0_COMMON_INT               (1<<16)
+#define OHCI_0_INTERRUPT_ENABLE         (1<<1)
+#define EHCI_INTERRUPT_ENABLE           (1<<0)
+
+#define USB2_HOST_FRAME_ADJUST          0x14
+#define USB2_HOST_AUTOPPD_ON_OVERCUR_EN 0x18
+#define USB2_HOST_CONTROL_SIM           0x1c
+#define USB2_HOST_DISCON_FILT           0x20
+#define USB_BUS_MONITOR                 0x24
+#define AHB_TO_AXI_CONTROL              0x2c
+#define MUXES_CONTROL                   0x30
+#define FW_CONTROL_PORT_POWER_GPO       0x34
+#define CORE_PORT_POWER                 0x38
+#define FW_CONTROL_OVERCURRENT          0x3c
+#define GPI_FILTERED                    0x40
+#define GPI_INTERRUPT_STATUS            0x44
+#define GPI_INTERRUPT_SELECT            0x48
+
+#define CLK_RUNNING_FLAG                0x00
+#define POWER_ON_RESET                  0x04
+#define POR                                1
+
+/* Various reset controls for USB */
+#define USB_HS_INTERFACE_RESET 	0x3a
+#define USB_FSHOST_RST		0x3b
+#define USB_FSHOSTPLL_RST	0x3c
+#define USB_SWITCH_RST		0x3d
+#define USB2_HOST_RST		0x41
+
+extern int stv576_release_reset(int block);
+
+int stv576_start_host_controller(struct platform_device *pdev)
+{
+	struct plat_stv576_usb_data *stv576 = pdev->dev.platform_data;
+	u32 reset;
+
+	if (stv576->initialised)
+		return 0;
+
+	stv576->usb_ctrl = ioremap(stv576->usb_ctrl_addr, 0x4c);
+	stv576->usb_phy = ioremap(stv576->usb_phy_addr, 0x22);
+
+	/* The delays need to be revisited */
+	stv576_release_reset(USB_FSHOSTPLL_RST);
+	mdelay(1);
+
+	stv576_release_reset(USB_FSHOST_RST);
+	mdelay(1);
+
+	stv576_release_reset(USB2_HOST_RST);
+	mdelay(1);
+
+#if 1
+	writel_be(0, stv576->usb_phy + POWER_ON_RESET);
+	udelay(20);
+	writel_be(POR, stv576->usb_phy + POWER_ON_RESET);
+	udelay(10);
+#endif
+	reset = OHCI_0_CLKCKTRST_N;
+	writel_be(reset, stv576->usb_ctrl + USB2_HOST_RESET);
+	mdelay(1);
+	reset |= PHY_UTMI_RESET_N;
+	writel_be(reset, stv576->usb_ctrl + USB2_HOST_RESET);
+	mdelay(1);
+	reset |= CORE_PHY_RST_N | CORE_UTMI_RESET_N;
+	writel_be(reset, stv576->usb_ctrl + USB2_HOST_RESET);
+
+	mdelay(1);
+
+	reset |= CORE_HRESET_N;
+	writel_be(reset, stv576->usb_ctrl + USB2_HOST_RESET);
+	mdelay(1);
+
+	writel_be(OHCI_0_COMMON_INT | OHCI_0_INTERRUPT_ENABLE |
+		  EHCI_INTERRUPT_ENABLE,
+		  stv576->usb_ctrl + USB2_HOST_INTERRUPT_ENABLE);
+
+	stv576->initialised = 1;
+
+	return 0;
+}
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 188e1ba..aa486a9 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -2032,6 +2032,26 @@ config FB_DA8XX
 	  found on DA8xx/OMAP-L1xx SoCs.
 	  If unsure, say N.
 
+config FB_ST200_SIMULATOR
+	tristate "ST200 simulator frame buffer device"
+	depends on FB && ST200_SIMULATOR
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	---help---
+	  Include support for the ST200 framebuffer device provided
+	  with the sim200 simulator.
+
+config FB_STV576
+	tristate "STV576 CLCD controller support"
+	depends on FB && SOC_STV576
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	---help---
+	  Include support for the CLCD controller found on ST's
+	  STV576 chip.
+
 config FB_VIRTUAL
 	tristate "Virtual Frame Buffer support (ONLY FOR TESTING!)"
 	depends on FB
@@ -2160,6 +2180,19 @@ config FB_BROADSHEET
 	  and could also have been called by other names when coupled with
 	  a bridge adapter.
 
+
+config FB_ST200_SIMFB
+	tristate "ST200 simulator frame buffer device"
+	depends on FB && ST200_SIMULATOR
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	---help---
+	  Include support for the ST200 framebuffer device provided
+	  with the sim200 simulator.
+
+
+
 source "drivers/video/omap/Kconfig"
 
 source "drivers/video/backlight/Kconfig"
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 80232e1..25b67ff 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -139,6 +139,8 @@ obj-$(CONFIG_FB_BF54X_LQ043)	  += bf54x-lq043fb.o
 obj-$(CONFIG_FB_BFIN_T350MCQB)	  += bfin-t350mcqb-fb.o
 obj-$(CONFIG_FB_MX3)		  += mx3fb.o
 obj-$(CONFIG_FB_DA8XX)		  += da8xx-fb.o
+obj-$(CONFIG_FB_ST200_SIMFB)	  += st200simfb.o
+obj-$(CONFIG_FB_STV576)		  += stv576-fb.o
 
 # the test framebuffer is last
 obj-$(CONFIG_FB_VIRTUAL)          += vfb.o
diff --git a/drivers/video/st200simfb.c b/drivers/video/st200simfb.c
new file mode 100644
index 0000000..b83b600
--- /dev/null
+++ b/drivers/video/st200simfb.c
@@ -0,0 +1,294 @@
+/*
+ * linux/drivers/video/st200simfb.c
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/fb.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+
+#define SIMFB_MAGIC	0x000
+#define SIMFB_COMMAND	0x004
+#define SIMFB_WIDTH	0x010
+#define SIMFB_HEIGHT	0x014
+#define SIMFB_DEPTH	0x018
+
+#define SIMFB_COMMAND_SETMODE 1
+
+#define SIMFB_MAGIC_VAL	0xdeface01
+
+struct simfb_par {
+	char* ctrl_base;
+};
+
+static u32 pseudo_palette[16];
+static struct fb_info fb_info;
+static struct simfb_par fb_par;
+
+static struct fb_fix_screeninfo simfb_fix = {
+	.id 		= "ST200 simulator",
+//	.smem_start 	= SIMFB_FB_BASE,
+//	.smem_len 	= SIMFB_FB_SIZE,
+	.type 		= FB_TYPE_PACKED_PIXELS,
+	.visual 	= FB_VISUAL_TRUECOLOR,
+	.xpanstep	= 1,
+	.ypanstep	= 1,
+	.ywrapstep	= 1,
+	.accel 		= FB_ACCEL_NONE,
+};
+
+static int simfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	int fb_mem;
+
+	/* Check color depth */
+	if ((var->bits_per_pixel != 16) && (var->bits_per_pixel != 32))
+		return -EINVAL;
+
+	/* Check we have enough memory */
+	fb_mem =  var->xres_virtual * var->yres_virtual * (var->bits_per_pixel / 8);
+        if (fb_mem > info->fix.smem_len)
+                return -ENOMEM;
+
+	var->xres_virtual = var->xres;
+	var->yres_virtual = var->yres;
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		/* RGB 565 */
+		var->red.offset = 11;
+		var->red.length = 5;
+		var->green.offset = 5;
+		var->green.length = 6;
+		var->blue.offset = 0;
+		var->blue.length = 5;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+                break;
+        case 32:
+		/* RGBA 8888 */
+                var->red.offset = 16;
+                var->red.length = 8;
+                var->green.offset = 8;
+                var->green.length = 8;
+                var->blue.offset = 0;
+                var->blue.length = 8;
+                var->transp.offset = 0;
+                var->transp.length = 0;
+		break;
+	}
+	var->red.msb_right = 0;
+        var->green.msb_right = 0;
+        var->blue.msb_right = 0;
+        var->transp.msb_right = 0;
+	return 0;
+}
+
+static int simfb_set_par(struct fb_info *info)
+{
+	struct simfb_par *par = (struct simfb_par*)info->par;
+
+#if 0
+	printk("simfb_set_par\n");
+	printk(" xres %d\n", info->var.xres);
+	printk(" yres %d\n", info->var.yres);
+	printk(" xres_virtual %d\n", info->var.xres_virtual);
+	printk(" yres_virtual %d\n", info->var.yres_virtual);
+	printk(" xoffset %d\n", info->var.xoffset);
+	printk(" yoffset %d\n", info->var.yoffset);
+	printk(" bits_per_pixel %d\n", info->var.bits_per_pixel);
+	printk(" grayscale %d\n", info->var.grayscale);
+	printk(" red %d %d %d\n", info->var.red.offset, info->var.red.length, info->var.red.msb_right);
+	printk(" green %d %d %d\n", info->var.green.offset, info->var.green.length, info->var.green.msb_right);
+	printk(" blue %d %d %d\n", info->var.blue.offset, info->var.blue.length, info->var.blue.msb_right);
+	printk(" transparent %d %d %d\n", info->var.transp.offset, info->var.transp.length, info->var.transp.msb_right);
+	printk(" nonstd %d\n", info->var.nonstd);
+	printk(" activate %d\n", info->var.activate);
+	printk(" height %d\n", info->var.height);
+	printk(" width %d\n", info->var.width);
+	printk(" accel_flags %d\n", info->var.accel_flags);
+	printk(" pixclock %d\n", info->var.pixclock);
+	printk(" left_margin %d\n", info->var.left_margin);
+	printk(" right_margin %d\n", info->var.right_margin);
+	printk(" upper_margin %d\n", info->var.upper_margin);
+	printk(" lower_margin %d\n", info->var.lower_margin);
+	printk(" hsync_len %d\n", info->var.hsync_len);
+	printk(" vsync_len %d\n", info->var.vsync_len);
+	printk(" sync %d\n", info->var.sync);
+	printk(" vmode %d\n", info->var.vmode);
+	printk(" rotate %d\n", info->var.rotate);
+#endif
+	info->fix.line_length = info->var.xres_virtual * info->var.bits_per_pixel / 8;
+
+	writel(info->var.xres_virtual,   par->ctrl_base + SIMFB_WIDTH);
+	writel(info->var.yres_virtual,   par->ctrl_base + SIMFB_HEIGHT);
+	writel(info->var.bits_per_pixel, par->ctrl_base + SIMFB_DEPTH);
+	writel(SIMFB_COMMAND_SETMODE,    par->ctrl_base + SIMFB_COMMAND);
+
+        return 0;
+}
+
+static int
+simfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			u_int transp, struct fb_info *info)
+{
+	if (regno > 15)
+		return 1;
+
+	pseudo_palette[regno] = (((red   & 0xff00) << 8) |
+                       ((green & 0xff00) >> 0) |
+                       ((blue  & 0xff00) >> 8));
+	return 0;
+}
+
+
+static struct fb_ops simfb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= simfb_check_var,
+	.fb_set_par	= simfb_set_par,
+	.fb_setcolreg	= simfb_setcolreg,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+};
+
+int __init simfb_probe(struct device *dev)
+{
+	struct platform_device *pdev=to_platform_device(dev);
+	struct resource *res;
+	int reslen;
+	int result = 0;
+	int magic;
+	struct fb_var_screeninfo default_var;
+	const struct fb_videomode *default_mode = NULL;
+	const int default_bpp = 32;
+
+
+	res=platform_get_resource(pdev,IORESOURCE_MEM,0);
+	if (!res) {
+		return ENODEV;
+//		goto out;
+	}
+
+	reslen=res->end - res->start + 1;
+
+	if (!request_mem_region(res->start,reslen, "simfb"))
+		return -ENOMEM;
+
+
+	if ( (fb_par.ctrl_base = ioremap_nocache(res->start,reslen))==NULL) {
+		result = -EIO;
+		goto fail;
+	}
+
+	res=platform_get_resource(pdev,IORESOURCE_MEM,1);
+	if (!res) {
+		result = -ENODEV;
+//		goto out;
+	}
+
+	reslen=res->end - res->start + 1;
+
+	if (!request_mem_region(res->start,reslen, "simfb"))
+		return -ENOMEM;
+
+	if ((fb_info.screen_base = ioremap_writecombine(res->start,reslen)) == NULL) {
+		result = -EIO;
+		goto fail;
+	}
+
+	simfb_fix.smem_start=res->start;
+	simfb_fix.smem_len=reslen;
+
+
+
+	fb_info.flags = FBINFO_FLAG_DEFAULT;
+	fb_info.fbops = &simfb_ops;
+	fb_info.fix = simfb_fix;
+	fb_info.pseudo_palette = &pseudo_palette;
+	fb_info.par = &fb_par;
+
+	magic = readl(fb_par.ctrl_base + SIMFB_MAGIC);
+	if (magic != SIMFB_MAGIC_VAL) {
+		printk(KERN_ERR "ST200 simulator fb: incorrect magic %08x\n", magic);
+		result = -EIO;
+		goto fail;
+	}
+
+	memset(&default_var, 0, sizeof(default_var));
+	if (!fb_find_mode(&default_var, &fb_info, NULL, NULL,0,
+			  default_mode, default_bpp))
+		return -EINVAL;
+	default_var.activate |= FB_ACTIVATE_NOW;
+	default_var.width = -1;
+	default_var.height = -1;
+	fb_info.var = default_var;
+	fb_info.fix.line_length = fb_info.var.xres_virtual * fb_info.var.bits_per_pixel / 8;
+
+	fb_alloc_cmap(&fb_info.cmap, 16, 0);
+
+	if (register_framebuffer(&fb_info) < 0) {
+		result = -EINVAL;
+		goto fail;
+	}
+
+        printk(KERN_INFO "fb%d: %s frame buffer device %dx%d %dbpp at %p\n",
+               fb_info.node, fb_info.fix.id,
+	       default_var.xres, default_var.yres,
+	       default_var.bits_per_pixel, fb_info.screen_base);
+
+	return 0;
+
+fail:
+	if (fb_par.ctrl_base)
+		iounmap(fb_par.ctrl_base);
+	if (fb_info.screen_base)
+		iounmap(fb_info.screen_base);
+//	release_mem_region(SIMFB_CTRL_BASE, SIMFB_CTRL_SIZE);
+//	release_mem_region(SIMFB_FB_BASE, SIMFB_FB_SIZE);
+	return result;
+}
+
+
+static int simfb_remove(struct device *dev)
+{
+}
+
+static struct device_driver simfb_driver = {
+	.name		= "STM-" "simfb",
+	.bus		= &platform_bus_type,
+	.probe		= simfb_probe,
+	.remove		= simfb_remove,
+//	.suspend	= simfb_drv_suspend,
+//	.resume		= simfb_drv_resume,
+};
+
+static int __init simfb_init(void)
+{
+	return driver_register(&simfb_driver);
+}
+
+static void __exit simfb_cleanup(void)
+{
+	driver_unregister(&simfb_driver);
+}
+
+module_init(simfb_init);
+module_exit(simfb_cleanup);
+
+
+MODULE_AUTHOR("Stuart Menefy <stuart.menefy@st.com>")
+MODULE_DESCRIPTION("ST200 simulator framebuffer driver");
+MODULE_SUPPORTED_DEVICE("fb");
diff --git a/drivers/video/stv576-fb.c b/drivers/video/stv576-fb.c
new file mode 100644
index 0000000..d4701f2
--- /dev/null
+++ b/drivers/video/stv576-fb.c
@@ -0,0 +1,447 @@
+/*
+ * stv576fb.c
+ *
+ * ST STV576 LCD frame buffer driver
+ *
+ * Author: David McKay <david.mckay@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * Based on xilinxfb.c from MontaVista
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+#define DRIVER_NAME		"stv576-fb"
+#define DRIVER_DESCRIPTION	"STV576 LCD frame buffer driver"
+
+/*
+ * Here are the default fb_fix_screeninfo and fb_var_screeninfo structures
+ */
+static struct fb_fix_screeninfo stv576_fb_fix = {
+	.id = "stv576-fb",
+	.type = FB_TYPE_PACKED_PIXELS,
+	.visual = FB_VISUAL_TRUECOLOR,
+	.accel = FB_ACCEL_NONE
+};
+
+#define BYTES_PER_PIXEL	4
+#define BITS_PER_PIXEL	(BYTES_PER_PIXEL * 8)
+
+/* These are almost certainly wrong to start with */
+#define RED_SHIFT	16
+#define GREEN_SHIFT	8
+#define BLUE_SHIFT	0
+
+static struct fb_var_screeninfo stv576_fb_var = {
+	.bits_per_pixel = BITS_PER_PIXEL,
+
+	.red = {RED_SHIFT, 8, 0},
+	.green = {GREEN_SHIFT, 8, 0},
+	.blue = {BLUE_SHIFT, 8, 0},
+	.transp = {0, 0, 0},
+	.activate = FB_ACTIVATE_NOW
+};
+
+#define PALETTE_ENTRIES_NO	16	/* passed to fb_alloc_cmap() */
+
+struct stv576fb_drvdata {
+	struct fb_info info;	/* FB driver info record */
+	void __iomem *info_block;	/* virt. address of info registers */
+	void __iomem *clcd_regs;	/* clcd regs */
+	void __iomem *clcd_strip;	/* clcd strip gen regs */
+	void __iomem *clcd_sram;	/* clcd sram regs */
+	void __iomem *clcd_dma;	/* clcd dma regs */
+
+	unsigned long regs_phys;
+	void *fb_virt;		/* virt. address of the frame buffer */
+	u32 pseudo_palette[PALETTE_ENTRIES_NO];
+	/* Fake palette of 16 colors */
+	unsigned long align_offset;	/* Add to FB to page align */
+	unsigned long max_yres;	/* Maximum virtual y resolution */
+};
+
+#define to_stv576fb_drvdata(_info) \
+	container_of(_info, struct stv576fb_drvdata, info)
+
+static int stv576fb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			      unsigned blue, unsigned transp,
+			      struct fb_info *fbi)
+{
+	u32 *palette = fbi->pseudo_palette;
+
+	if (regno >= PALETTE_ENTRIES_NO)
+		return -EINVAL;
+
+	if (fbi->var.grayscale) {
+		/* Convert color to grayscale.
+		 * grayscale = 0.30*R + 0.59*G + 0.11*B */
+		red = green = blue =
+		    (red * 77 + green * 151 + blue * 28 + 127) >> 8;
+	}
+
+	/* fbi->fix.visual is always FB_VISUAL_TRUECOLOR */
+
+	/* We only handle 8 bits of each color. */
+	red >>= 8;
+	green >>= 8;
+	blue >>= 8;
+	palette[regno] = (red << RED_SHIFT) | (green << GREEN_SHIFT) |
+	    (blue << BLUE_SHIFT);
+
+	return 0;
+}
+
+#define PV(x) printk(KERN_DEBUG "var->%s = %d\n", #x, var->x)
+
+static int stv576fb_check_var(struct fb_var_screeninfo *var,
+			      struct fb_info *info)
+{
+	struct stv576fb_drvdata *drvdata = dev_get_drvdata(info->dev);
+	int max_yres = drvdata->max_yres;
+
+	printk("stv576fb_check_var, max_yres is %d\n", max_yres);
+
+	PV(xres);
+	PV(yres);
+	PV(bits_per_pixel);
+	PV(xres_virtual);
+	PV(yres_virtual);
+	PV(xoffset);
+	PV(yoffset);
+
+	if (var->xres != 480)
+		return -EINVAL;
+	if (var->yres != 272)
+		return -EINVAL;
+
+	if (var->bits_per_pixel == 24)
+		var->bits_per_pixel = 32;
+	if (var->bits_per_pixel != 32)
+		return -EINVAL;
+
+	if (var->xres_virtual != 480)
+		return -EINVAL;
+
+	if (var->xoffset != 0)
+		return -EINVAL;
+
+	if (var->yres_virtual > max_yres)
+		var->yres_virtual = max_yres;
+
+	if (var->yoffset > (max_yres - 272))
+		var->yoffset = max_yres - 272;
+
+	return 0;
+}
+
+#define STV576_FB_PHYS 		0
+#define STV576_FB_SIZE 		4
+#define STV576_FB_WIDTH 		8
+#define STV576_FB_HEIGHT 	12
+
+#define CLCD_REGS_CLCD_ENABLE		0x12
+#define CLCD_ENABLE_NORMAL_MODE		(1<<3)	/* Clear to enable debug interleaved mode */
+
+#define CLCD_REGS_EVENLINEPIXCOLOR	0x1c
+#define CLCD_REGS_ODDLINEPIXCOLOR	0x1e
+
+#define CLCD_SRAM_R_BOTTOM_LIMIT 	0x00
+#define CLCD_SRAM_G_BOTTOM_LIMIT 	0x02
+#define CLCD_SRAM_B_BOTTOM_LIMIT 	0x04
+
+#define CLCD_SRAM_R_TOP_LIMIT		0x06
+#define CLCD_SRAM_G_TOP_LIMIT		0x08
+#define CLCD_SRAM_B_TOP_LIMIT		0x0a
+
+#define CLCD_DMA_INTERFACE_Y		0x00
+
+static int stv576fb_set_par(struct fb_info *info)
+{
+	struct stv576fb_drvdata *drvdata = dev_get_drvdata(info->dev);
+	int yoff;
+
+	// The only thing we can change is the y offset
+	yoff = (info->var.yoffset * 480 * 4) + drvdata->align_offset;
+
+	return 0;
+}
+
+static int stv576fb_pan_display(struct fb_var_screeninfo *var,
+				struct fb_info *info)
+{
+	struct stv576fb_drvdata *drvdata = dev_get_drvdata(info->dev);
+	int yoff;
+
+	printk("panning to %d\n", var->yoffset);
+
+	if (var->yoffset > drvdata->max_yres - 272)
+		return -EINVAL;
+
+	yoff = (var->yoffset * 480 * 4) + drvdata->align_offset;
+
+	return 0;
+}
+
+static struct fb_ops stv576fb_ops = {
+	.owner = THIS_MODULE,
+#if 0
+	.fb_check_var = stv576fb_check_var,
+	.fb_set_par = stv576fb_set_par,
+	.fb_pan_display = stv576fb_pan_display,
+#endif
+	.fb_setcolreg = stv576fb_setcolreg,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+};
+
+/* Need to look at error handling in more detail here, not quite sure how it
+ * works with the devm infrastructure
+ */
+static int __devinit plat_ioremap_region(struct platform_device *pdev, int
+		region, void **p) { struct resource *res; unsigned long size;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, region);
+	if (res == NULL)
+		return -ENODEV;
+
+	size = res->end - res->start + 1;
+
+	if (!devm_request_mem_region(&pdev->dev, res->start, size, res->name))
+		return -ENODEV;
+
+	*p = devm_ioremap_nocache(&pdev->dev, res->start, size);
+
+	if (*p == NULL) {
+		printk(KERN_ERR
+		       "pci-stm: Failed to map address 0x%08lx for device %s\n",
+		       (unsigned long)res->start, res->name);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void __iomem *devm_ioremap_writecombine(struct device *dev,
+					       unsigned long offset,
+					       unsigned long size)
+{
+	void __iomem **ptr, *addr;
+
+	ptr = devres_alloc(devm_ioremap_release, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return NULL;
+
+	addr = ioremap_writecombine(offset, size);
+	if (addr) {
+		*ptr = addr;
+		devres_add(dev, ptr);
+	} else
+		devres_free(ptr);
+
+	return addr;
+}
+
+static int stv576fb_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+	struct stv576fb_drvdata *drvdata;
+	int rc;
+	unsigned long fb_phys, fb_size;
+	int fb_xres, fb_yres;
+	unsigned long info_phys, info_size;
+	unsigned long fb_offset;
+	int i;
+	u16 clcd_enable;
+
+	drvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);
+	if (!drvdata)
+		return -ENOMEM;
+	dev_set_drvdata(dev, drvdata);
+
+	if (rc = plat_ioremap_region(pdev, 0, &drvdata->info_block))
+		return rc;
+
+	if (rc = plat_ioremap_region(pdev, 1, &drvdata->clcd_regs))
+		return rc;
+
+	if (rc = plat_ioremap_region(pdev, 2, &drvdata->clcd_strip))
+		return rc;
+
+	if (rc = plat_ioremap_region(pdev, 3, &drvdata->clcd_sram))
+		return rc;
+
+	if (rc = plat_ioremap_region(pdev, 4, &drvdata->clcd_dma))
+		return rc;
+
+	/* Mask out any crap address, ask Jim to put in proper physical */
+	fb_phys = readl_be(drvdata->info_block + STV576_FB_PHYS) & 0x3fffffff;
+	fb_size = readl_be(drvdata->info_block + STV576_FB_SIZE) & 0x3fffffff;
+	fb_xres = readl_be(drvdata->info_block + STV576_FB_WIDTH);
+	fb_yres = readl_be(drvdata->info_block + STV576_FB_HEIGHT);
+
+	printk (KERN_INFO "STV576 framebuffer at physical 0x%x, "
+			  "size %d, width %d, height %d\n",
+			  fb_phys, fb_size, fb_xres, fb_yres);
+
+/*
+ * Bodge to work around none page aligned boundary which
+ * appears to break direct_fb for unknown reasons.
+ */
+#if 1
+	fb_offset = PAGE_ALIGN(fb_phys) - fb_phys;
+	fb_size -= fb_offset;
+	fb_size = PAGE_ALIGN(fb_size - PAGE_SIZE - 1);
+
+	drvdata->align_offset = fb_offset;
+
+	fb_phys += fb_offset;
+#endif
+
+	/* How many lines we can have with the available memory */
+	drvdata->max_yres = (fb_size / (fb_xres * 4));
+
+	/* Remap the framebuffer, use write combine for optimum performance */
+	drvdata->fb_virt = devm_ioremap_writecombine(dev, fb_phys, fb_size);
+
+	if (!drvdata->fb_virt) {
+		dev_err(dev, "Could not allocate frame buffer memory\n");
+		return -ENOMEM;
+	}
+
+	/* Set the start of the framebuffer */
+	writel_be(fb_phys | 0x40000000,
+		  drvdata->clcd_dma + CLCD_DMA_INTERFACE_Y);
+
+	/* Enable interleaved debug mode */
+	clcd_enable = readw_be(drvdata->clcd_regs + CLCD_REGS_CLCD_ENABLE);
+
+	writew_be(clcd_enable & ~CLCD_ENABLE_NORMAL_MODE,
+		  drvdata->clcd_regs + CLCD_REGS_CLCD_ENABLE);
+
+	clcd_enable = readw_be(drvdata->clcd_regs + CLCD_REGS_CLCD_ENABLE);
+
+/* The dual ref wires up the RGB data differently on the board, and so needs a
+ * different value here. Doing it this way is utter crap, it needs to be
+ * abstracted at the board layer, this is a temporary bodge until the video
+ * driver is cleaned up
+ */
+#if defined(CONFIG_BOARD_STV576_REF)
+#define PIXCOLOR_VAL 0x6
+#else
+#define PIXCOLOR_VAL 0x24
+#endif
+	/* Change the pixel ordering to be ARGB (from a little endian point of
+	 * view) */
+	writew_be(PIXCOLOR_VAL,
+		  drvdata->clcd_regs + CLCD_REGS_EVENLINEPIXCOLOR);
+
+	writew_be(PIXCOLOR_VAL, drvdata->clcd_regs + CLCD_REGS_ODDLINEPIXCOLOR);
+
+	writew_be(0x00, drvdata->clcd_sram + CLCD_SRAM_R_BOTTOM_LIMIT);
+	writew_be(0x1bd, drvdata->clcd_sram + CLCD_SRAM_R_TOP_LIMIT);
+
+	writew_be(0x1be, drvdata->clcd_sram + CLCD_SRAM_G_BOTTOM_LIMIT);
+	writew_be(0x1ce, drvdata->clcd_sram + CLCD_SRAM_G_TOP_LIMIT);
+
+	writew_be(0x1cf, drvdata->clcd_sram + CLCD_SRAM_B_BOTTOM_LIMIT);
+	writew_be(0x1df, drvdata->clcd_sram + CLCD_SRAM_B_TOP_LIMIT);
+
+	/* Clear (turn to black) the framebuffer */
+	memset_io((void __iomem *)drvdata->fb_virt, 0, fb_size);
+
+	/* Fill struct fb_info */
+	drvdata->info.device = dev;
+	drvdata->info.screen_base = (void __iomem *)drvdata->fb_virt;
+	drvdata->info.fbops = &stv576fb_ops;
+	drvdata->info.fix = stv576_fb_fix;
+	drvdata->info.fix.smem_start = fb_phys;
+	drvdata->info.fix.smem_len = fb_size;
+	drvdata->info.fix.line_length = fb_xres * BYTES_PER_PIXEL;
+
+	drvdata->info.fix.xpanstep = 0;
+	drvdata->info.fix.ypanstep = 1;
+	drvdata->info.fix.ywrapstep = 0;
+
+	drvdata->info.pseudo_palette = drvdata->pseudo_palette;
+	drvdata->info.flags = FBINFO_DEFAULT;
+	drvdata->info.var = stv576_fb_var;
+	drvdata->info.var.height = -1;	// pdata->screen_height_mm;
+	drvdata->info.var.width = -1;	// pdata->screen_width_mm;
+	drvdata->info.var.xres = fb_xres;
+	drvdata->info.var.yres = fb_yres;
+	drvdata->info.var.xres_virtual = fb_xres;
+	drvdata->info.var.yres_virtual = fb_yres;
+
+	/* Allocate a colour map */
+	rc = fb_alloc_cmap(&drvdata->info.cmap, PALETTE_ENTRIES_NO, 0);
+	if (rc) {
+		dev_err(dev, "Fail to allocate colormap (%d entries)\n",
+			PALETTE_ENTRIES_NO);
+		return rc;
+	}
+
+	/* Register new frame buffer */
+	rc = register_framebuffer(&drvdata->info);
+	if (rc) {
+		dev_err(dev, "Could not register frame buffer\n");
+		return rc;
+	}
+
+	return 0;		/* success */
+
+}
+
+static int stv576fb_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct stv576fb_drvdata *drvdata = dev_get_drvdata(dev);
+
+	unregister_framebuffer(&drvdata->info);
+
+	fb_dealloc_cmap(&drvdata->info.cmap);
+
+	return 0;
+}
+
+static struct platform_driver stv576fb_driver = {
+	.probe = stv576fb_probe,
+	.remove = stv576fb_remove,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = DRIVER_NAME,
+		   },
+};
+
+int __devinit stv576fb_init(void)
+{
+	return platform_driver_register(&stv576fb_driver);
+}
+
+void __exit stv576fb_cleanup(void)
+{
+	platform_driver_unregister(&stv576fb_driver);
+}
+
+module_init(stv576fb_init);
+module_exit(stv576fb_cleanup);
+
+MODULE_AUTHOR("David McKay <david.mckay@st.com>");
+MODULE_DESCRIPTION(DRIVER_DESCRIPTION);
+MODULE_LICENSE("GPL");
diff --git a/include/linux/elf-em.h b/include/linux/elf-em.h
index 18bea78..356d9de 100644
--- a/include/linux/elf-em.h
+++ b/include/linux/elf-em.h
@@ -35,6 +35,7 @@
 #define EM_BLACKFIN     106     /* ADI Blackfin Processor */
 #define EM_FRV		0x5441	/* Fujitsu FR-V */
 #define EM_AVR32	0x18ad	/* Atmel AVR32 */
+#define EM_ST200	0x64	/* STMicroelectronics ST200 */
 
 /*
  * This is an interim value that we will use until the committee comes
diff --git a/include/linux/log2.h b/include/linux/log2.h
index 25b8086..ccda848 100644
--- a/include/linux/log2.h
+++ b/include/linux/log2.h
@@ -185,7 +185,7 @@ unsigned long __rounddown_pow_of_two(unsigned long n)
 #define rounddown_pow_of_two(n)			\
 (						\
 	__builtin_constant_p(n) ? (		\
-		(n == 1) ? 0 :			\
+		(n == 1) ? 1 :			\
 		(1UL << ilog2(n))) :		\
 	__rounddown_pow_of_two(n)		\
  )
diff --git a/include/linux/math64.h b/include/linux/math64.h
index c87f152..03eb06e 100644
--- a/include/linux/math64.h
+++ b/include/linux/math64.h
@@ -91,7 +91,7 @@ __iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder)
 	while (dividend >= divisor) {
 		/* The following asm() prevents the compiler from
 		   optimising this loop into a modulo operation.  */
-		asm("" : "+rm"(dividend));
+		/* asm("" : "+rm"(dividend)); */
 
 		dividend -= divisor;
 		ret++;
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 7a232a9..f22f56c 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -167,7 +167,8 @@ typedef enum {
 #define NAND_NO_READRDY		0x00000100
 /* Chip does not allow subpage writes */
 #define NAND_NO_SUBPAGE_WRITE	0x00000200
-
+/* Chip/controller does not allow subpage reads */
+#define NAND_NO_SUBPAGE_READ	0x00000400
 
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \
@@ -180,10 +181,12 @@ typedef enum {
 #define NAND_HAS_COPYBACK(chip) ((chip->options & NAND_COPYBACK))
 /* Large page NAND with SOFT_ECC should support subpage reads */
 #define NAND_SUBPAGE_READ(chip) ((chip->ecc.mode == NAND_ECC_SOFT) \
-					&& (chip->page_shift > 9))
+				&& (chip->page_shift > 9)  \
+				&& !(chip->options & NAND_NO_SUBPAGE_READ))
 
 /* Mask to zero out the chip options, which come from the id table */
-#define NAND_CHIPOPTIONS_MSK	(0x0000ffff & ~NAND_NO_AUTOINCR)
+#define NAND_CHIPOPTIONS_MSK	(0x0000ffff & \
+		~(NAND_NO_AUTOINCR | NAND_NO_SUBPAGE_READ))
 
 /* Non chip related options */
 /* Use a flash based bad block table. This option is passed to the
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index db532ce..cd2fd89 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -179,6 +179,10 @@
 /* BCM63xx family SoCs */
 #define PORT_BCM63XX	89
 
+/* STV576 serial ports */
+#define PORT_STV576	90
+
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>
diff --git a/include/linux/st_soc.h b/include/linux/st_soc.h
new file mode 100644
index 0000000..4aa745c
--- /dev/null
+++ b/include/linux/st_soc.h
@@ -0,0 +1,81 @@
+
+#ifndef __LINUX_ST_SOC_H
+#define __LINUX_ST_SOC_H
+
+#include <linux/types.h>
+
+struct soc_info {
+	/* List of platform devices exported by this SOC. You may choose which devices
+	 * you instantiate in the board support list. The UARTS are *NOT* present in this
+	 * list, they are in a separate one because you nearly always need to diddle with
+	 * the uarts, since the boards vary wildly.
+	 */
+	struct platform_device **devices;
+	int num_devices;
+
+	/* list of serial ports this soc exports */
+	struct platform_device *uarts;
+	int num_uarts;
+};
+
+
+extern struct soc_info soc_data;
+
+/* Do whatever you need to do in order to allow the board_setup routine
+ * to work. Usually this involves mapping the PIOs and sysconfig
+ * registers, perhaps some clock setup etc etc.
+ */
+
+
+int soc_setup(void);
+
+int board_setup(void);
+
+void soc_machine_restart(char *cmd);
+void soc_machine_halt(void);
+void soc_machine_power_off(void);
+
+/* Private usb data for the STV576 */
+struct plat_stv576_usb_data {
+	unsigned long usb_ctrl_addr;
+	unsigned long usb_phy_addr;
+	int initialised;
+	void *usb_ctrl;
+	void *usb_phy;
+};
+
+/* Information for NAND block. Only contains MTD partition info for now,
+ * we should probably extend this to include timing information for the block
+ * as well. Should also use platform_nand_data as well.
+ */
+
+struct plat_stv576_nand_data {
+	void *mtd_parts;        /* MTD partition table          */
+	int nr_parts;           /* Number of partitions         */
+	unsigned boot_device:1; /* True if we booted from NAND  */
+	unsigned options;       /* Flags to pass through to MTD */
+};
+
+/* Audio data */
+struct plat_stv576_audio_data {
+	unsigned long audio_clock; /* Usually 48Mhz */
+	/* Burst sizes for audio dma engine */
+	int dma_min_burst_words;
+	int dma_max_burst_words;
+};
+
+/* Driver information for v320 PCI controller, used in the
+ * MB388 and MB427 FPGA platforms
+ */
+
+struct plat_v320usc_pci_data {
+	u32 mem_window_phys; /* Where the PCI memory window is */
+	u32 mem_window_size; /* How big */
+	u32 io_window_phys; /* Where IO window is, fixed at 16M */
+	/* Get idsel value for this device */
+	int (*idsel)(unsigned char dev);
+};
+
+#endif /* __LINUX_ST_SOC_H */
+
+
diff --git a/kernel/time.c b/kernel/time.c
index 2e2e469..ef95926 100644
--- a/kernel/time.c
+++ b/kernel/time.c
@@ -378,12 +378,12 @@ void set_normalized_timespec(struct timespec *ts, time_t sec, s64 nsec)
 		 * optimising this loop into a modulo operation. See
 		 * also __iter_div_u64_rem() in include/linux/time.h
 		 */
-		asm("" : "+rm"(nsec));
+		/* asm("" : "+rm"(nsec)); */
 		nsec -= NSEC_PER_SEC;
 		++sec;
 	}
 	while (nsec < 0) {
-		asm("" : "+rm"(nsec));
+		/* asm("" : "+rm"(nsec)); */
 		nsec += NSEC_PER_SEC;
 		--sec;
 	}
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index 234ceb1..22a6f51 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -566,7 +566,8 @@ config DEBUG_BUGVERBOSE
 	bool "Verbose BUG() reporting (adds 70K)" if DEBUG_KERNEL && EMBEDDED
 	depends on BUG
 	depends on ARM || AVR32 || M32R || M68K || SPARC32 || SPARC64 || \
-		   FRV || SUPERH || GENERIC_BUG || BLACKFIN || MN10300
+		   FRV || SUPERH || GENERIC_BUG || BLACKFIN || MN10300 || \
+		   ARCH_ST200
 	default !EMBEDDED
 	help
 	  Say Y here to make BUG() panics output the file name and line number
diff --git a/net/ipv4/ipconfig.c b/net/ipv4/ipconfig.c
index f8d04c2..12b476c 100644
--- a/net/ipv4/ipconfig.c
+++ b/net/ipv4/ipconfig.c
@@ -186,6 +186,7 @@ struct ic_device {
 
 static struct ic_device *ic_first_dev __initdata = NULL;/* List of open device */
 static struct net_device *ic_dev __initdata = NULL;	/* Selected device */
+static unsigned int __initdata ipconf_delay = 0;
 
 static int __init ic_open_devs(void)
 {
@@ -193,6 +194,12 @@ static int __init ic_open_devs(void)
 	struct net_device *dev;
 	unsigned short oflags;
 
+	if (ipconf_delay) {
+		printk(KERN_INFO "Waiting %dsec before opening network devices...\n",
+		       ipconf_delay);
+		ssleep(ipconf_delay);
+	}
+
 	last = &ic_first_dev;
 	rtnl_lock();
 
@@ -1574,6 +1581,14 @@ static int __init vendor_class_identifier_setup(char *addrs)
 	return 1;
 }
 
+static int __init ipconfdelay_config_setup(char *str)
+{
+	ipconf_delay = simple_strtoul(str, NULL, 0);
+	return 1;
+}
+
+
 __setup("ip=", ip_auto_config_setup);
 __setup("nfsaddrs=", nfsaddrs_config_setup);
 __setup("dhcpclass=", vendor_class_identifier_setup);
+__setup("ipconfdelay=", ipconfdelay_config_setup);
diff --git a/sound/Kconfig b/sound/Kconfig
index 439e15c..42f751b 100644
--- a/sound/Kconfig
+++ b/sound/Kconfig
@@ -96,6 +96,11 @@ source "sound/mips/Kconfig"
 
 source "sound/sh/Kconfig"
 
+# This driver should use the soc framework really,
+# but for expediency just do a full driver for now until we
+# get it working
+source "sound/stv576/Kconfig"
+
 # the following will depend on the order of config.
 # here assuming USB is defined before ALSA
 source "sound/usb/Kconfig"
diff --git a/sound/Makefile b/sound/Makefile
index ec467de..2c53b8c 100644
--- a/sound/Makefile
+++ b/sound/Makefile
@@ -6,7 +6,7 @@ obj-$(CONFIG_SOUND_PRIME) += sound_firmware.o
 obj-$(CONFIG_SOUND_PRIME) += oss/
 obj-$(CONFIG_DMASOUND) += oss/
 obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ sh/ synth/ usb/ \
-	sparc/ spi/ parisc/ pcmcia/ mips/ soc/ atmel/
+	sparc/ spi/ parisc/ pcmcia/ mips/ soc/ atmel/ stv576/
 obj-$(CONFIG_SND_AOA) += aoa/
 
 # This one must be compilable even if sound is configured out
diff --git a/sound/stv576/Kconfig b/sound/stv576/Kconfig
new file mode 100644
index 0000000..3771eaf
--- /dev/null
+++ b/sound/stv576/Kconfig
@@ -0,0 +1,12 @@
+menu "STV576 ALSA devices"
+	depends on SND!=n && SOC_STV576
+
+config SND_STV576_AUDIO
+	tristate "STV576 Audio driver"
+	depends on SOC_STV576
+	help
+	  Audio for STV576 chips
+
+endmenu
+
+
diff --git a/sound/stv576/Makefile b/sound/stv576/Makefile
new file mode 100644
index 0000000..bb25955
--- /dev/null
+++ b/sound/stv576/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_SND_STV576_AUDIO) += stv576.o
+
diff --git a/sound/stv576/stv576.c b/sound/stv576/stv576.c
new file mode 100644
index 0000000..9477794
--- /dev/null
+++ b/sound/stv576/stv576.c
@@ -0,0 +1,742 @@
+/* sound/stv576/stv576.c : Audio driver for STV576.
+ *
+ * Copyright (c) 2009 David McKay <david.mckay@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 only.
+ * See linux/COPYING for more info
+ *
+ * TODO:
+ * 	Change to ASOC framework
+ * 	Volume control
+ * 	Change to write combine mapping
+ */
+
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/soundcard.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+
+#include <linux/st_soc.h>
+
+#include "stv576_audio.h"
+
+struct stv576_info {
+	spinlock_t lock;
+	struct snd_card *card;
+	struct snd_pcm_substream *substream;
+	void __iomem *iobase;	/* register addresss */
+	dma_addr_t dma_addr;	/* Circular buffer address */
+	unsigned char *dma_area;
+	unsigned period_words;	/* Size of period in words */
+	unsigned buffer_words;	/* Total size of buffer in words */
+	u16 dma_burst;		/* Settings for min/max burst lengths */
+	u16 fifo_size;		/* Number of word in fifo */
+
+	/* Value we start counting down from. Must be a multiple of
+	 * the buffer size (not necessarily the period size). This is
+	 * set to be the largest multiple of the buffer size in  a 20 bit
+	 * counter since the counter counts in words.
+	 */
+	unsigned long dma_length_reset;
+
+	/* Holds things like clock rate etc etc */
+	struct plat_stv576_audio_data *audio_data;
+
+	int volume;
+};
+
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+
+#define AUDIO_BUFFER_SIZE (128*1024)
+
+#define STV576_MIN_PERIOD_SIZE 128
+
+/* Hardware capabilities of the PCM stream */
+static struct snd_pcm_hardware stv576_playback = {
+	.info 	= 	SNDRV_PCM_INFO_MMAP |
+			SNDRV_PCM_INFO_INTERLEAVED |
+			SNDRV_PCM_INFO_MMAP_VALID |
+			SNDRV_PCM_INFO_BLOCK_TRANSFER,
+	/* The hardware says it can support little endian as well. However,
+	 * experiments indicate that this is not true
+	 */
+	.formats = 	SNDRV_PCM_FMTBIT_S16_BE |
+			SNDRV_PCM_FMTBIT_U16_BE |
+			SNDRV_PCM_FMTBIT_S8 |
+			SNDRV_PCM_FMTBIT_U8,
+
+	.rates = 	SNDRV_PCM_RATE_CONTINUOUS,
+	/* DAC Sampling rate range */
+	.rate_min = 8000,	/* Minimum sampling rate */
+	.rate_max = 48000,	/* Maximum sampling rate */
+	/* Mono only unfortunately */
+	.channels_min = 1,
+	.channels_max = 1,
+	.buffer_bytes_max = AUDIO_BUFFER_SIZE,	/* Maximum buffer size */
+
+	.period_bytes_min = STV576_MIN_PERIOD_SIZE,
+	.period_bytes_max = AUDIO_BUFFER_SIZE,
+	.periods_min = 1,
+	.periods_max = AUDIO_BUFFER_SIZE / STV576_MIN_PERIOD_SIZE,
+};
+
+/* #define STV576_AUDIO_DEBUG */
+
+#ifdef STV576_AUDIO_DEBUG
+#define dprintk(format, a...) \
+	printk(KERN_DEBUG "<%s():%d> " format, __func__, __LINE__, ##a)
+#else
+#define dprintk(format, a...)
+#endif
+
+static inline void stv576_writew(struct stv576_info *info, int reg, u16 val)
+{
+	writew_be(val, info->iobase + reg);
+}
+
+static inline void stv576_writel(struct stv576_info *info, int reg, u32 val)
+{
+	writel_be(val, info->iobase + reg);
+}
+
+static inline u16 stv576_readw(struct stv576_info *info, int reg)
+{
+	return readw_be(info->iobase + reg);
+}
+
+static inline u32 stv576_readl(struct stv576_info *info, int reg)
+{
+	return readl_be(info->iobase + reg);
+}
+
+#define OVERSAMPLE_RATIO 64
+#define MAX_SAMPLE_RATE 48000
+
+/* Performs a very simple calculation at the moment and sets the registers up */
+
+static int stv576_set_clock(struct stv576_info *info, unsigned long sample_rate)
+{
+	int boost = 3;
+	u16 denominator;
+	unsigned long os_rate;
+	u16 codec_control;
+	unsigned long audio_clock = info->audio_data->audio_clock;
+
+	while ((sample_rate * (1 << boost)) > MAX_SAMPLE_RATE)
+		boost--;
+
+	os_rate = sample_rate * OVERSAMPLE_RATIO * (1 << boost);
+
+	denominator = (2 * (audio_clock / os_rate) + 1) / 2;
+
+	/* Pass straight through */
+	stv576_writew(info, AUDIO_CLOCK_DIVIDER, 0);
+
+	stv576_writew(info, AUDIO_CLOCK_SCALER,
+		      AUDIO_CLOCK_SCALER_NUMERATOR(1) |
+		      AUDIO_CLOCK_SCALER_DENOMINATOR(denominator));
+
+	codec_control = stv576_readw(info, AUDIO_EMBEDDED_CODEC_CONTROL) &
+	    AUDIO_EMBEDDED_CODEC_CONTROL_SAMPLE_BOOST_MASK;
+
+	codec_control |= AUDIO_EMBEDDED_CODEC_CONTROL_SAMPLE_BOOST(boost);
+	stv576_writew(info, AUDIO_EMBEDDED_CODEC_CONTROL, codec_control);
+
+	return 0;
+}
+
+static void stv576_init(struct stv576_info *info)
+{
+
+	/* Set up burst control. DMA is not enabled at this point */
+	stv576_writew(info, AUDIO_DMA_CONTROL_A, info->dma_burst);
+
+	stv576_writel(info, AUDIO_DMA_TRIP_ADDR, 0);
+
+	/* Enable the hardware. We switch on playback to avoid a big clunk
+	 * every time we switch on and off audio. It just plays silence
+	 */
+	stv576_writew(info, AUDIO_MAIN,
+		      AUDIO_MAIN_INT_NOT_EXT | AUDIO_MAIN_PLAYBACK_EN);
+
+	/* Clear out any state hanging around */
+	stv576_writew(info, AUDIO_INTERRUPT_CONTROL,
+		      AUDIO_INTERRUPT_CONTROL_CLR_SNIPPET_TRIP |
+		      AUDIO_INTERRUPT_CONTROL_CLR_ADDRESS_TRIP);
+
+	stv576_writew(info, AUDIO_INTERRUPT_CONTROL, 0);
+
+	stv576_writew(info, AUDIO_EMBEDDED_CODEC_CONTROL,
+		      AUDIO_EMBEDDED_CODEC_CONTROL_NOISE_GENERATOR_ENABLE |
+		      AUDIO_EMBEDDED_CODEC_CONTROL_EMBEDDED_CODEC_ENABLE |
+		      AUDIO_EMBEDDED_CODEC_CONTROL_UPSAMPLE_NOT_DOWNSAMPLE);
+}
+
+
+int stv576_set_format(struct stv576_info *info, snd_pcm_format_t format)
+{
+	/* The bigend and wordswap fields in the register are completely
+	 * useless as far as I can tell. Later versions of the IP will have
+	 * proper flipping to support little endian samples, but for the moment
+	 * it is big endian only
+	 */
+	struct stv576_format_bits {
+		unsigned char supported:1,	/* We can do this one */
+			      wordnbyte:1,	/* 16 bit samples */
+			      signed_data:1; 	/* Signed samples */
+	};
+	static struct stv576_format_bits
+	    stv576_format_table[SNDRV_PCM_FORMAT_LAST + 1] = {
+		[SNDRV_PCM_FORMAT_U8] = {
+			.supported = 1, .wordnbyte = 0, .signed_data = 0
+		},
+		[SNDRV_PCM_FORMAT_S8] = {
+			.supported = 1, .wordnbyte = 0, .signed_data = 1
+		},
+		[SNDRV_PCM_FORMAT_S16_BE] = {
+			.supported = 1, .wordnbyte = 1, .signed_data = 1
+		},
+		[SNDRV_PCM_FORMAT_U16_BE] = {
+			.supported = 1, .wordnbyte   = 1, .signed_data = 0
+		},
+	};
+	struct stv576_format_bits *f = stv576_format_table + format;
+	u16 ctrl;
+
+	if (!f->supported)
+		return -EINVAL;
+
+	/* Set the main format register */
+	stv576_writew(info, AUDIO_MAIN, AUDIO_MAIN_INT_NOT_EXT |
+		      AUDIO_MAIN_PLAYBACK_EN |
+		      AUDIO_MAIN_BIGEND |
+		      AUDIO_MAIN_WORDNBYTE_FIELD(f->wordnbyte));
+
+	ctrl = stv576_readw(info, AUDIO_EMBEDDED_CODEC_CONTROL) &
+	    ~AUDIO_EMBEDDED_CODEC_CONTROL_SIGNED_DATA_ENABLE;
+
+	/* Set signed data for codec */
+	stv576_writew(info, AUDIO_EMBEDDED_CODEC_CONTROL, ctrl |
+   AUDIO_EMBEDDED_CODEC_CONTROL_SIGNED_DATA_ENABLE_FIELD(f->signed_data));
+
+	return 0;
+}
+
+/* Returns number of words left in current DMA transaction */
+static inline u32 stv576_dma_counter(struct stv576_info *info)
+{
+	u32 dma_status = stv576_readl(info, AUDIO_DMA_STATUS);
+
+	return AUDIO_DMA_STATUS_FIFO_SNIPPET_COUNT(dma_status);
+}
+
+#define DMA_COUNTER_RED_ZONE 8
+
+static void stv576_set_next_period(struct stv576_info *info)
+{
+	u32 counter, next_period;
+	u32 period_words = info->period_words;
+	unsigned long flags;
+
+	spin_lock_irqsave(&info->lock, flags);
+
+	/* Calculate where the next period interrupt should be */
+	counter = stv576_dma_counter(info);
+
+	/* Calculate where last period should have been, remember the counter
+	 * is counting down, not up
+	 * */
+	next_period = ((counter + period_words) / period_words) * period_words;
+	next_period -= period_words; /* Go onto next one */
+
+	/* We need a red zone here, if we try to set a period interrupt that is
+	 * too close to the next period, we have to go onto the next one.  It
+	 * doesn't matter if we miss one, but it does matter if we wrap around
+	 * We should not have to worry about underflowing the counter, as it
+	 * should never be less than the buffer size
+	 */
+	counter = stv576_dma_counter(info);
+	if (next_period > counter ||
+			(counter - next_period) < DMA_COUNTER_RED_ZONE)
+		next_period -= period_words;	/* Got to next one */
+
+	/* DMA_LENGTH is in words */
+	stv576_writel(info, AUDIO_DMA_TRIP_LENGTH, next_period);
+
+	stv576_writew(info, AUDIO_INTERRUPT_CONTROL,
+		      AUDIO_INTERRUPT_CONTROL_CLR_SNIPPET_TRIP);
+
+	/* Reset them and enable interrupts */
+	stv576_writew(info, AUDIO_INTERRUPT_CONTROL,
+		      AUDIO_INTERRUPT_CONTROL_DMA_INT_SNIP_EN);
+
+	spin_unlock_irqrestore(&info->lock, flags);
+}
+
+static inline void stv576_set_dma_address(struct stv576_info *info,
+					  dma_addr_t start_addr,
+					  dma_addr_t end_addr)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&info->lock, flags);
+
+	stv576_writel(info, AUDIO_DMA_START_ADDR, start_addr);
+	stv576_writel(info, AUDIO_DMA_END_ADDR, end_addr);
+
+	/* Set the bits..... */
+	stv576_writew(info, AUDIO_INTERRUPT_CONTROL,
+		      AUDIO_INTERRUPT_CONTROL_INIT_ADDRESS_COUNT |
+		      AUDIO_INTERRUPT_CONTROL_CLR_ADDRESS_TRIP);
+
+	stv576_writew(info, AUDIO_INTERRUPT_CONTROL,
+		      AUDIO_INTERRUPT_CONTROL_DMA_INT_SNIP_EN);
+
+	spin_unlock_irqrestore(&info->lock, flags);
+}
+
+static inline void stv576_set_dma_length(struct stv576_info *info,
+					 u32 word_length)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&info->lock, flags);
+
+	stv576_writel(info, AUDIO_DMA_LENGTH, word_length);
+
+	/* Set the bits..... */
+	stv576_writew(info, AUDIO_INTERRUPT_CONTROL,
+		      AUDIO_INTERRUPT_CONTROL_INIT_SNIPPET_COUNT |
+		      AUDIO_INTERRUPT_CONTROL_CLR_SNIPPET_TRIP);
+
+	stv576_writew(info, AUDIO_INTERRUPT_CONTROL,
+		      AUDIO_INTERRUPT_CONTROL_DMA_INT_SNIP_EN);
+
+	spin_unlock_irqrestore(&info->lock, flags);
+}
+
+static void stv576_dma_setup(struct stv576_info *info)
+{
+	dma_addr_t start_addr, end_addr;
+	int buffer_words = info->buffer_words;
+
+	start_addr = info->dma_addr;
+	end_addr = start_addr + (buffer_words * 4) - 4;
+
+	stv576_set_dma_address(info, start_addr, end_addr);
+
+	/* The -1 is so that when we wrap we can just add on on the current
+	 * counter without worrying about overflowing
+	 */
+
+	info->dma_length_reset =
+	  ((AUDIO_MAX_SNIPPET_COUNT / buffer_words) - 1) * buffer_words;
+
+	stv576_set_dma_length(info, info->dma_length_reset);
+
+	/* Set up the first interrupt */
+	stv576_set_next_period(info);
+}
+
+static void stv576_flush_fifo(struct stv576_info *info)
+{
+	/* flush data */
+	stv576_writew(info, AUDIO_DMA_CONTROL_B,
+		      AUDIO_DMA_CONTROL_B_CLR_FIFO_ERRORS |
+		      AUDIO_DMA_CONTROL_B_FLUSH_FIFO);
+
+	stv576_writew(info, AUDIO_DMA_CONTROL_B, 0);
+}
+
+static inline void stv576_start_dma(struct stv576_info *info)
+{
+	stv576_writew(info, AUDIO_DMA_CONTROL_A,
+		      info->dma_burst | AUDIO_DMA_CONTROL_A_DMA_EN);
+}
+
+static inline void stv576_stop_dma(struct stv576_info *info)
+{
+	stv576_writew(info, AUDIO_DMA_CONTROL_A, info->dma_burst);
+}
+
+
+static void __init stv576_init_one(struct stv576_info *info)
+{
+	struct plat_stv576_audio_data *d = info->audio_data;
+
+	info->fifo_size = stv576_readw(info, AUDIO_FIFO_SIZE);
+
+	stv576_playback.fifo_size = info->fifo_size * 4;
+
+	/* Calculate the dma_burst register. The enable bit is also in this
+	 * register for some reason
+	 */
+
+	info->dma_burst =
+		AUDIO_DMA_CONTROL_A_MIN_BURST_LEN(d->dma_min_burst_words - 1) |
+		AUDIO_DMA_CONTROL_A_MAX_BURST_LEN(d->dma_max_burst_words);
+
+	stv576_init(info);
+}
+
+
+/* Open the device in playback mode */
+static int stv576_pb_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct stv576_info *info = substream->private_data;
+	int ret;
+
+	/* It looks as if the buffer has to be a multiple of the maximum dma
+	 * burst length, otherwise you get an annoying click when the buffer
+	 * wraps around
+	 */
+	ret = snd_pcm_hw_constraint_step(runtime, 0,
+			SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
+			info->audio_data->dma_max_burst_words * 4);
+
+	if (ret)
+		return ret;
+
+	/* Periods should be a multiple of a word, as the hardware counter is in
+	 * words
+	 */
+	ret = snd_pcm_hw_constraint_step(runtime, 0,
+			SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 4);
+
+	if (ret)
+		return ret;
+
+	runtime->hw = stv576_playback;
+
+	info->substream = substream;
+
+	stv576_init(info);
+
+	return 0;
+}
+
+static int stv576_pb_close(struct snd_pcm_substream *substream)
+{
+	struct stv576_info *info = substream->private_data;
+
+	/* Should already be stopped, but just in case ... */
+	stv576_stop_dma(info);
+
+	return 0;
+}
+
+/* Prepare to transfer an audio stream to the codec */
+static int stv576_pb_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct stv576_info *info = snd_pcm_substream_chip(substream);
+	unsigned period_bytes, buffer_bytes;
+
+	stv576_set_clock(info, runtime->rate);
+	stv576_set_format(info, runtime->format);
+
+	period_bytes = frames_to_bytes(runtime, runtime->period_size);
+	buffer_bytes = frames_to_bytes(runtime, runtime->buffer_size);
+
+	info->period_words = period_bytes / 4;
+	info->buffer_words = buffer_bytes / 4;
+
+	dprintk("Rate %d, format %d\n", runtime->rate, runtime->format);
+	dprintk("Period (%d bytes %d words %lu frames)\n",
+		period_bytes, info->period_words, runtime->period_size);
+	dprintk("Buffer (%d bytes %d words %lu frames)\n",
+		buffer_bytes, info->buffer_words, runtime->buffer_size);
+
+	info->dma_addr = runtime->dma_addr;
+	info->dma_area = runtime->dma_area;
+
+	stv576_dma_setup(info);
+
+	return 0;
+}
+
+static int stv576_pb_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct stv576_info *info = snd_pcm_substream_chip(substream);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		stv576_flush_fifo(info);
+		stv576_start_dma(info);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		stv576_stop_dma(info);
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return 0;
+}
+
+static int
+stv576_hw_params(struct snd_pcm_substream *substream,
+		 struct snd_pcm_hw_params *hw_params)
+{
+	/* Use preallocated memory from stv576_audio_probe() to
+	   satisfy this memory request */
+	return snd_pcm_lib_malloc_pages(substream,
+				       params_buffer_bytes(hw_params));
+}
+
+static int stv576_hw_free(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static snd_pcm_uframes_t stv576_pb_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct stv576_info *info = snd_pcm_substream_chip(substream);
+	unsigned counter;
+	int buffer_words = info->buffer_words;
+	int buffer_pos;		/* Position in buffer in bytes */
+
+	counter = stv576_dma_counter(info);
+
+	/* Reset length - counter should give us total number of words
+	 * transferred. Modulo buffer size will give us the current position
+	 * in the buffer
+	 */
+	buffer_pos = ((info->dma_length_reset - counter) % buffer_words) * 4;
+
+	return bytes_to_frames(runtime, buffer_pos);
+}
+
+struct page *stv576_page(struct snd_pcm_substream *substream,
+			 unsigned long offset)
+{
+	void *pageptr = substream->runtime->dma_area + offset;
+	return vmalloc_to_page(pageptr);
+}
+
+static struct snd_pcm_ops stv576_playback_ops = {
+	.open = stv576_pb_open,
+	.close = stv576_pb_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = stv576_hw_params,
+	.hw_free = stv576_hw_free,
+	.prepare = stv576_pb_prepare,
+	.trigger = stv576_pb_trigger,
+	.pointer = stv576_pb_pointer,
+	.page = stv576_page,
+};
+
+static irqreturn_t stv576_audio_irq(int irq, void *ptr)
+{
+	struct stv576_info *info = ptr;
+	u16 status;
+	u32 counter;
+
+	status = stv576_readw(info, AUDIO_INTERRUPT_CONTROL);
+
+	if (!(status & AUDIO_INTERRUPT_CONTROL_TRIP_SNIPPET))
+		return IRQ_NONE;
+
+	/* Tell ALSA how many periods have elapsed */
+	snd_pcm_period_elapsed(info->substream);
+
+	/* Check for wrap. This happens every 43 seconds at 48Khz
+	 *
+	 * We may lose sync here by a few words or so. Not very helpful
+	 * hardware, it would be so much easier if you could just read
+	 * the current DMA position.If we disable the DMA engine
+	 * while we are doing this, and then re-enable it, will the counter
+	 * still possibly change?
+	 */
+	counter = stv576_dma_counter(info);
+	if (counter < info->buffer_words) {
+		stv576_stop_dma(info);
+		counter = stv576_dma_counter(info);
+		stv576_set_dma_length(info, counter + info->dma_length_reset);
+		stv576_start_dma(info);
+	}
+
+	stv576_set_next_period(info);
+
+	return IRQ_HANDLED;
+}
+
+
+static int stv576_pb_vol_info(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_info *uinfo)
+{
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 15;
+	uinfo->value.integer.step = 1;
+
+	return 0;
+}
+
+static int stv576_pb_vol_put(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *uvalue)
+{
+	struct stv576_info *info = kcontrol->private_data;
+	int vol = uvalue->value.integer.value[0];
+
+	info->volume = vol;
+
+	/* write_m41_volume_register(vol) */
+
+	return 0;
+}
+
+
+static int stv576_pb_vol_get(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *uvalue)
+{
+	struct stv576_info *info = kcontrol->private_data;
+
+	/* The M41T00AUD remembers the volume setting over power cycles,
+	 * therefore you have to read it here
+	 */
+
+	/* info->volume = read_m41_volume_register() */
+
+	uvalue->value.integer.value[0] = info->volume;
+
+	return 0;
+}
+
+
+static struct snd_kcontrol_new stv576_playback_vol = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "STV576 volume",
+	.info = stv576_pb_vol_info,
+	.get  = stv576_pb_vol_get,
+	.put  = stv576_pb_vol_put,
+};
+
+static int __init stv576_audio_probe(struct platform_device *pdev)
+{
+	struct snd_card *card;
+	struct snd_pcm *pcm = NULL;
+	struct resource *res;
+	int res_size;
+	struct stv576_info *info;
+	int irq;
+	int err;
+	struct plat_stv576_audio_data *audio_data = pdev->dev.platform_data;
+
+	err = snd_card_create(-1, id[pdev->id], THIS_MODULE,
+			 sizeof(struct stv576_info), &card);
+	if (err < 0)
+		return err;
+
+	info = card->private_data;
+	info->card = card;
+	info->audio_data = audio_data;
+
+	spin_lock_init(&info->lock);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL)
+		goto err_out;
+
+	res_size = res->end - res->start + 1;
+	if (!devm_request_mem_region(&pdev->dev, res->start,
+				      res_size, "stv576 audio"))
+		goto err_out;
+
+	info->iobase = devm_ioremap_nocache(&pdev->dev, res->start, res_size);
+
+	if (!info->iobase) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	/* We init here before we hook the irq to clear any pending ones down */
+	stv576_init_one(info);
+
+	irq = platform_get_irq(pdev, 0);
+
+	err = devm_request_irq(&pdev->dev, irq, stv576_audio_irq,
+				IRQF_DISABLED, "stv576 audio", info);
+
+	if (err) {
+		dev_printk(KERN_ERR, &pdev->dev,
+				"Unable to request irq %d\n", irq);
+		goto err_out;
+	}
+
+	err = snd_pcm_new(card, "stv576 pcm", 0, 1, 0, &pcm);
+	if (err)
+		goto err_out;
+
+	pcm->private_data = info;
+
+	err = snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					snd_dma_continuous_data(GFP_KERNEL),
+					AUDIO_BUFFER_SIZE, AUDIO_BUFFER_SIZE);
+	if (err)
+		goto err_out;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &stv576_playback_ops);
+
+
+	snd_ctl_add(card, snd_ctl_new1(&stv576_playback_vol, info));
+
+
+	strcpy(card->driver, "stv576");
+
+	/* Register the sound card */
+	err = snd_card_register(card);
+
+	if (err)
+		goto err_out;
+
+	/* Store card for access from other methods */
+	platform_set_drvdata(pdev, card);
+
+	return 0;
+
+err_out:
+	snd_card_free(card);
+	return err;
+}
+
+static int stv576_audio_remove(struct platform_device *dev)
+{
+	snd_card_free(platform_get_drvdata(dev));
+	platform_set_drvdata(dev, NULL);
+	return 0;
+}
+
+static struct platform_driver stv576_audio_driver = {
+	.probe = stv576_audio_probe,
+	.remove = stv576_audio_remove,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "stv576_audio",
+	},
+};
+
+static int __init stv576_audio_init(void)
+{
+	/* Register the platform driver and device */
+	return platform_driver_register(&stv576_audio_driver);
+}
+
+static void __exit stv576_audio_exit(void)
+{
+	platform_driver_unregister(&stv576_audio_driver);
+}
+
+module_init(stv576_audio_init);
+module_exit(stv576_audio_exit);
+MODULE_LICENSE("GPL");
diff --git a/sound/stv576/stv576_audio.h b/sound/stv576/stv576_audio.h
new file mode 100644
index 0000000..20d596e
--- /dev/null
+++ b/sound/stv576/stv576_audio.h
@@ -0,0 +1,128 @@
+#ifndef __STV576_AUDIO_H__
+#define __STV576_AUDIO_H__
+
+/* Registers for audio block on STV576 */
+
+#define AUDIO_MAIN			0x00
+#define AUDIO_MAIN_INT_NOT_EXT		(1<<5)
+#define AUDIO_MAIN_WORDSWAP 		(1<<4)
+#define AUDIO_MAIN_WORDNBYTE		(1<<3)
+#define AUDIO_MAIN_BIGEND		(1<<2)
+#define AUDIO_MAIN_RECORD_EN		(1<<1)
+#define AUDIO_MAIN_PLAYBACK_EN		(1<<0)
+#define AUDIO_MAIN_WORDNBYTE_FIELD(x) 	((x) << 3)
+
+#define AUDIO_FIFO_SIZE			0x02
+
+/* Clock registers */
+#define AUDIO_CLOCK_SCALER		0x04
+#define AUDIO_CLOCK_SCALER_NUMERATOR(x)   (((x) & 0x7) << 8)
+#define AUDIO_CLOCK_SCALER_DENOMINATOR(x) (((x) & 0xff))
+#define AUDIO_CLOCK_DIVIDER		0x06
+
+/* Registers to talk to external codec */
+#define AUDIO_CODEC_COMMAND		0x08
+#define AUDIO_CODEC_STATUS		0x0a
+#define AUDIO_CODEC_COMM_STATUS		0x0c
+#define AUDIO_CODEC_COMM_CONTROL_A	0x0e
+#define AUDIO_CODEC_COMM_CONTROL_B	0x10
+#define AUDIO_CODEC_COMM_CONTROL_C	0x12
+#define AUDIO_CODEC_COMM_CONTROL_D	0x14
+#define AUDIO_CODEC_COMM_CONTROL_E	0x16
+#define AUDIO_CODEC_COMM_CONTROL_F	0x18
+#define AUDIO_CODEC_COMM_CONTROL_G	0x1a
+
+/* DMA controller registers */
+#define AUDIO_DMA_CONTROL_A			0x1c
+#define AUDIO_DMA_CONTROL_A_DMA_EN		(1<<15)
+#define AUDIO_DMA_CONTROL_A_MIN_BURST_LEN(x) 	(((x) & 0x3f) << 8)
+#define AUDIO_DMA_CONTROL_A_MAX_BURST_LEN(x) 	(((x) & 0x3f))
+
+#define AUDIO_DMA_CONTROL_B			0x1e
+#define AUDIO_DMA_CONTROL_B_CLR_FIFO_ERRORS	(1<<1)
+#define AUDIO_DMA_CONTROL_B_FLUSH_FIFO		(1<<0)
+
+#define AUDIO_DMA_STATUS_A				0x20
+#define AUDIO_DMA_STATUS_A_FIFO_LEVEL(x) 		(((x) >> 8) & 0xff)
+#define AUDIO_DMA_STATUS_A_FIFO_FULL			(1<<7)
+#define AUDIO_DMA_STATUS_A_FIFO_EMPTY 			(1<<6)
+#define AUDIO_DMA_STATUS_A_FIFO_OVERFLOW 		(1<<5)
+#define AUDIO_DMA_STATUS_A_FIFO_UNDERFLOW 		(1<<4)
+#define AUDIO_DMA_STATUS_A_FIFO_SNIPPET_COUNT_HIGH(x) 	(((x) >> 0) & 0xf)
+
+#define AUDIO_DMA_STATUS_B				0x22
+#define AUDIO_DMA_STATUS_B_FIFO_SNIPPET_COUNT_LOW(x) 	(((x) >> 0) & 0xffff)
+
+/* Read as a 32 bit register */
+#define AUDIO_DMA_STATUS				0x20
+#define AUDIO_DMA_STATUS_FIFO_LEVEL(x) 			(((x) >> 24) & 0xff)
+#define AUDIO_DMA_STATUS_FIFO_FULL(x) 			(((x) >> 23) & 0x1)
+#define AUDIO_DMA_STATUS_FIFO_EMPTY(x) 			(((x) >> 22) & 0x1)
+#define AUDIO_DMA_STATUS_FIFO_OVERFLOW(x) 		(((x) >> 21) & 0x1)
+#define AUDIO_DMA_STATUS_FIFO_UNDERFLOW(x) 		(((x) >> 20) & 0x1)
+#define AUDIO_DMA_STATUS_FIFO_SNIPPET_COUNT(x) 		(((x) >> 0) & 0xfffff)
+
+#define AUDIO_MAX_SNIPPET_COUNT				0xfffff
+
+#define AUDIO_DMA_START_ADDR_HIGH			0x24
+#define AUDIO_DMA_START_ADDR_LOW			0x26
+#define AUDIO_DMA_START_ADDR				0x24
+
+#define AUDIO_DMA_END_ADDR_HIGH				0x28
+#define AUDIO_DMA_END_ADDR_LOW				0x2a
+#define AUDIO_DMA_END_ADDR				0x28
+
+#define AUDIO_DMA_TRIP_ADDR_HIGH			0x2c
+#define AUDIO_DMA_TRIP_ADDR_LOW				0x2e
+#define AUDIO_DMA_TRIP_ADDR				0x2c
+
+#define AUDIO_DMA_TRIP_LENGTH_HIGH			0x30
+#define AUDIO_DMA_TRIP_LENGTH_LOW			0x32
+#define AUDIO_DMA_TRIP_LENGTH				0x30
+
+#define AUDIO_DMA_LENGTH_HIGH				0x34
+#define AUDIO_DMA_LENGTH_LOW				0x36
+#define AUDIO_DMA_LENGTH				0x34
+
+#define AUDIO_INTERRUPT_CONTROL				0x38
+#define AUDIO_INTERRUPT_CONTROL_TRIP_SNIPPET		(1<<7)
+#define AUDIO_INTERRUPT_CONTROL_TRIP_ADDRESS		(1<<6)
+#define AUDIO_INTERRUPT_CONTROL_INIT_SNIPPET_COUNT	(1<<5)
+#define AUDIO_INTERRUPT_CONTROL_CLR_SNIPPET_TRIP	(1<<4)
+#define AUDIO_INTERRUPT_CONTROL_INIT_ADDRESS_COUNT	(1<<3)
+#define AUDIO_INTERRUPT_CONTROL_CLR_ADDRESS_TRIP	(1<<2)
+#define AUDIO_INTERRUPT_CONTROL_DMA_INT_SNIP_EN		(1<<1)
+#define AUDIO_INTERRUPT_CONTROL_DMA_INT_ADDR_EN		(1<<0)
+
+#define AUDIO_DMA_FIFO_READ_HIGH			0x3a
+#define AUDIO_DMA_FIFO_READ_LOW				0x3c
+#define AUDIO_DMA_FIFO_READ				0x3a
+
+#define AUDIO_DMA_FIFO_WRITE_HIGH			0x3e
+#define AUDIO_DMA_FIFO_WRITE_LOW			0x40
+#define AUDIO_DMA_FIFO_WRITE				0x40
+
+#define AUDIO_EMBEDDED_CODEC_CONTROL				0x42
+#define AUDIO_EMBEDDED_CODEC_CONTROL_EXT_MUTE			(1<<14)
+#define AUDIO_EMBEDDED_CODEC_CONTROL_AOUT_MINUS_DISABLE		(1<<13)
+#define AUDIO_EMBEDDED_CODEC_CONTROL_AOUT_PLUS_DISABLE		(1<<12)
+#define AUDIO_EMBEDDED_CODEC_CONTROL_DCLK_RECORD_STATE(x)	(((x)&0x3)<<10)
+#define AUDIO_EMBEDDED_CODEC_CONTROL_RECORD_BIT_OFFSET(x)	(((x)&0x3)<<8)
+#define AUDIO_EMBEDDED_CODEC_CONTROL_SAMPLE_BOOST(x)		(((x)&0x3)<<5)
+#define AUDIO_EMBEDDED_CODEC_CONTROL_SAMPLE_BOOST_MASK		(~((0x3) << 5))
+#define AUDIO_EMBEDDED_CODEC_CONTROL_UPSAMPLE_NOT_DOWNSAMPLE	(1<<4)
+#define AUDIO_EMBEDDED_CODEC_CONTROL_SIGNED_DATA_ENABLE		(1<<3)
+#define AUDIO_EMBEDDED_CODEC_CONTROL_SIGNED_DATA_ENABLE_FIELD(x) ((x) << 3)
+#define AUDIO_EMBEDDED_CODEC_CONTROL_NOISE_GENERATOR_ENABLE	(1<<2)
+#define AUDIO_EMBEDDED_CODEC_CONTROL_TINY_CODEC_ENABLE		(1<<1)
+#define AUDIO_EMBEDDED_CODEC_CONTROL_EMBEDDED_CODEC_ENABLE	(1<<0)
+#define AUDIO_EMBEDDED_CODEC_SDM_CLIPPPING_STATUS		0x44
+
+#define AUDIO_EMBEDDED_TINY_CODEC_CONTROL			0x46
+#define AUDIO_EMBEDDED_TINY_CODEC_DAC_RATE			0x48
+
+#define AUDIO_PLAYBACK_VOLUME_CONTROL_HIGH			0x4a
+#define AUDIO_PLAYBACK_VOLUME_CONTROL_LOW			0x4c
+#define AUDIO_PLAYBACK_VOLUME_CONTROL				0x4a
+
+#endif /* __STV576_AUDIO_H__ */
